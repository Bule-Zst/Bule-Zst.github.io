<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Bule-Zst个人博客">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>LeetCode 410. 分割数组的最大值 | Bule-Zst</title>
<link rel="shortcut icon" href="/favicon.ico?v=1644136782545">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      displayMath: [['$$', '$$'], ["\\[", "\\]"]]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a', 'annotation', 'annotation-xml'],
      ignoreHtmlClass: 'tex2jax_ignore|crayon-.*', // 'crayon-' 开头的类，属于Wordpress代码高亮库，这部分不需要处理，否则会导致显示不正确,这部分是正则式，多条之间用'|'分割
      processHtmlClass: 'tex2jax_process'
    },
    //禁用右键菜单	
    renderActions: {
      addMenu: [0, '', '']
    }
  };
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?52033379f884b28a50e8ebc12b7743f9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="LeetCode 410. 分割数组的最大值" />
  <meta name="keywords" content="算法,题解" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Bule-Zst</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Bule-Zst</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">50</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">34</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">34</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="http://Bule-Zst.gitee.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/Bule-Zst">
              <i class="fa fa-github" title="Github"></i>
            </a>
          
            <a href="/media/images/QQ.png">
              <i class="fa fa-qq" title="QQ"></i>
            </a>
          
            <a href="/media/images/WeChat.png">
              <i class="fa fa-weixin" title="WeChat"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E9%A2%98%E6%84%8F">题意</a></li>
<li><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</a>
<ul>
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2">暴力搜索</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/">
      LeetCode 410. 分割数组的最大值
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-12-30 16:10:48">2020-12-30</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="http://Bule-Zst.gitee.io/算法/">
        <span>算法</span>
      </a>、
      
      
      
      <a href="http://Bule-Zst.gitee.io/题解/">
        <span>题解</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>837<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/2020-12-30-LeetCode 410. 分割数组的最大值/" data-flag-title="LeetCode 410. 分割数组的最大值" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="题意">题意</h1>
<p>给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。</p>
<h1 id="解题思路">解题思路</h1>
<h2 id="暴力搜索">暴力搜索</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><msubsup><mi>n</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>{</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mtext> </mtext><mi>M</mi><mo>[</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mtext> </mtext><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub><mo>}</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">M[n,k] = min^n_{j=1}\{max\{ \ M[j,k-1], \ \sum^{n-1}_{i=j}A_i\}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.133108em;vertical-align:-0.383108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">}</span></span></span></span></span></p>
<p>其中，n表示数组长度，k表示数组分成几段。<br>
初始化条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><msub><mi>A</mi><mn>0</mn></msub><mspace linebreak="newline"></mspace><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M[1,k] = A_0 \\ M[n,1] = \sum^{n-1}_{i=0}A_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="动态规划">动态规划</h2>
<p>递归算法拥有指数时间的复杂度，并且会重复计算一些M值。这类的算法一般可以使用动态规划进行优化。使用数组保存一些已经计算得到的值，采用自底向上进行计算</p>
<h2 id="二分查找">二分查找</h2>
<p>此题可以想象成把数据按顺序装入桶中，m即是给定的桶数，问桶的容量至少应该为多少才能恰好把这些数装入k个桶中（按顺序装的）。</p>
<p>首先我们可以知道，桶的容量最少不会小于数组中的最大值，即桶容量的最小值（小于的话，这个数没法装进任何桶中），假设只需要一个桶，那么其容量应该是数组所有元素的和，即桶容量的最大值；其次，桶数量越多，需要的桶的容量就可以越少，即随着桶容量的增加，需要的桶的数量非递增的（二分查找就是利用这点）；我们要求的就是在给定的桶数量m的时候，找最小的桶容量就可以把所有的数依次装入k个桶中。在二分查找的过程中，对于当前的桶容量，我们可以计算出需要的最少桶数requiredPainters，如果需要的桶数量大于给定的桶数量k，说明桶容量太小了，只需在后面找对应的最小容量使需要的桶数恰好等于k；如果计算需要的桶数量小于等于k，说明桶容量可能大了（也可能正好是要找的最小桶容量），不管怎样，该桶容量之后的桶容量肯定不用考虑了（肯定大于最小桶容量），这样再次缩小查找的范围，继续循环直到终止，终止时，当前的桶容量既是最小的桶容量。</p>
<p>对于数组 1 2 3 4 5 6 7，假设k=3，最小桶容量为7（要5个桶），最大桶容量为28（一个桶）</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/1609316379450.png" alt="" loading="lazy"></figure>
<p>第一行表示桶容量，第二行表示需要的桶数，即要求桶数量恰为k的最小桶容量。</p>
<h1 id="代码">代码</h1>
<pre><code class="language-c++">class Solution {
public:
    bool judge( vector&lt;int&gt;&amp; nums, int capacity, int num ) {
        int curCapacity = capacity;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            if( curCapacity &lt; nums[i] ) {
                num--;
                if( num == 0 ) {
                    return false;
                }
                curCapacity = capacity;
                i--;
            } else {
                curCapacity -= nums[i];
            }
        }
        return true;
    }
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        int max, min;
        int sum = 0;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            sum += nums[i];
        }
        max = sum; // 成功的情况
        min = 0; // 失败的情况
        while( min&lt;max-1 ) { // 当两者相邻，就退出
            int mid = ( min+max ) / 2;
            if( judge(nums,mid,m) ) {
                max = mid;
            } else {
                min = mid;
            }
        }
        return max;
    }
};
</code></pre>
<hr>
<p>from <a href="https://www.cnblogs.com/ygh1229/p/10637504.html">https://www.cnblogs.com/ygh1229/p/10637504.html</a></p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Bule-Zst
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/" title="LeetCode 410. 分割数组的最大值">http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="http://Bule-Zst.gitee.io/算法/"># 算法</a>
    
      <a href="http://Bule-Zst.gitee.io/题解/"># 题解</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Jetbrains系列产品重置试用方法" href="http://Bule-Zst.gitee.io/2021-01-06-Jetbrains系列产品重置试用方法/">Jetbrains系列产品重置试用方法</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Jetbrains系列产品重置试用方法" href="http://Bule-Zst.gitee.io/2021-01-06-Jetbrains系列产品重置试用方法/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Ubuntu下配置telnet环境" href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/">Ubuntu下配置telnet环境</a>
        <a class="nav-mobile-next" title="Ubuntu下配置telnet环境" href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'icyVx6by4LtMh3OUkAxAV9Td-gzGzoHsz',
    appKey: 'BjJojXprANUbtBlAXlKTqVD6',
    avatar: 'mp',
    placeholder: '填上邮箱可以收到我的回复哦 (*^ω^*)~~\n请尽量7点-23点给我评论哦~',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'false',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: -10px;bottom: -23px;"
    data-key="65029773e7e94d1986196a5c0a08cb91">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2022-02-01-JavaHan/"" data-c="
          &lt;p&gt;本人的面试八股文（面试小抄），供大家参考。&lt;/p&gt;
&lt;p&gt;JavaHan，致敬 JavaGuide，Han指的是憨，并且感觉读起来比较顺口。&lt;/p&gt;
&lt;p&gt;为了方便检索，我把所有内容都放在一个文档中的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;h3 id=&#34;java-基础&#34;&gt;Java 基础&lt;/h3&gt;
&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基本类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包装类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缓存池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;new Integer(123) 与 Integer.valueOf(123) 的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new Integer(123) 每次都会新建一个对象；&lt;/li&gt;
&lt;li&gt;Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Java 8 中，Integer 缓存池的大小默认为 -128~127。&lt;/p&gt;
&lt;p&gt;编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本类型对应的缓冲池如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boolean values true and false&lt;/li&gt;
&lt;li&gt;all byte values&lt;/li&gt;
&lt;li&gt;short values between -128 and 127&lt;/li&gt;
&lt;li&gt;int values between -128 and 127&lt;/li&gt;
&lt;li&gt;char in the range \u0000 to \u007F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。&lt;/p&gt;
&lt;p&gt;在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。&lt;/p&gt;
&lt;h4 id=&#34;string&#34;&gt;String&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）&lt;/p&gt;
&lt;p&gt;在 Java 8 中，String 内部使用 char 数组存储数据。&lt;/p&gt;
&lt;p&gt;在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 &lt;code&gt;coder&lt;/code&gt; 来标识使用了哪种编码。&lt;/p&gt;
&lt;p&gt;value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变的好处&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。&lt;/li&gt;
&lt;li&gt;String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。&lt;/li&gt;
&lt;li&gt;安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。&lt;/li&gt;
&lt;li&gt;线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String StringBuffer StringBuilder 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 可变性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 不可变&lt;/li&gt;
&lt;li&gt;StringBuffer 和 StringBuilder 可变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 线程安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 不可变，因此是线程安全的&lt;/li&gt;
&lt;li&gt;StringBuilder 不是线程安全的&lt;/li&gt;
&lt;li&gt;StringBuffer 是线程安全的，内部使用 synchronized 进行同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String Pool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。&lt;/p&gt;
&lt;p&gt;当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。&lt;/p&gt;
&lt;p&gt;下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 &amp;quot;aaa&amp;quot; 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s1 = new String(&amp;quot;aaa&amp;quot;);
String s2 = new String(&amp;quot;aaa&amp;quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);           // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是采用 &amp;quot;bbb&amp;quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s5 = &amp;quot;bbb&amp;quot;;
String s6 = &amp;quot;bbb&amp;quot;;
System.out.println(s5 == s6);  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中，跟随 GC 被回收。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;new String(&amp;quot;abc&amp;quot;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &amp;quot;abc&amp;quot; 字符串对象）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;abc&amp;quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &amp;quot;abc&amp;quot; 字符串字面量；&lt;/li&gt;
&lt;li&gt;而使用 new 的方式会在堆中创建一个字符串对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a = &amp;quot;a&amp;quot;;
String b = new String( a );

Class c = String.class;
Field field = c.getDeclaredField(&amp;quot;value&amp;quot;);
field.setAccessible( true );

System.out.println( a==b );                              // false

System.out.println( field.get( a ) == field.get( b ) );  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;运算&#34;&gt;运算&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;参数传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 的参数是以 值传递 的形式传入方法中，而不是引用传递（传递变量的地址）。&lt;/p&gt;
&lt;p&gt;例如 Dog dog 中的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。&lt;/p&gt;
&lt;p&gt;在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。&lt;/p&gt;
&lt;p&gt;但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;float 与 double&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 不能隐式执行向下转型，因为这会使得精度降低。&lt;/p&gt;
&lt;p&gt;1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// float f = 1.1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.1f 字面量才是 float 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;float f = 1.1f;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;隐式类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;short s1 = 1;
// s1 = s1 + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是使用 += 或者 ++ 运算符会执行隐式类型转换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;s1 += 1;
s1++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;s1 = (short) (s1 + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;switch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s = &amp;quot;a&amp;quot;;
switch (s) {
    case &amp;quot;a&amp;quot;:
        System.out.println(&amp;quot;aaa&amp;quot;);
        break;
    case &amp;quot;b&amp;quot;:
        System.out.println(&amp;quot;bbb&amp;quot;);
        break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。&lt;/p&gt;
&lt;h4 id=&#34;关键字&#34;&gt;关键字&lt;/h4&gt;
&lt;h5 id=&#34;final&#34;&gt;final&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型，final 使数值不变；&lt;/li&gt;
&lt;li&gt;对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明方法不能被子类重写。&lt;/p&gt;
&lt;p&gt;private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明类不允许被继承。&lt;/p&gt;
&lt;h5 id=&#34;static&#34;&gt;static&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 静态变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。&lt;/li&gt;
&lt;li&gt;实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。&lt;/p&gt;
&lt;p&gt;静态方法只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 静态语句块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态语句块，在且仅在 类加载时运行一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 静态内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态内部类不能访问外部类的非静态的变量和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 静态导包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;使用静态变量和方法时&lt;/strong&gt;不用再指明 ClassName，从而简化代码，但可读性大大降低。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static com.xxx.ClassName.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6. 初始化顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static String staticField = &amp;quot;静态变量&amp;quot;;

static {
    System.out.println(&amp;quot;静态语句块&amp;quot;);
}

public String field = &amp;quot;实例变量&amp;quot;;

{
    System.out.println(&amp;quot;普通语句块&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后才是构造函数的初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public InitialOrderTest() {
    System.out.println(&amp;quot;构造函数&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在继承的情况下，初始化顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父类（静态变量、静态语句块）&lt;/li&gt;
&lt;li&gt;子类（静态变量、静态语句块）&lt;/li&gt;
&lt;li&gt;父类（实例变量、普通语句块）&lt;/li&gt;
&lt;li&gt;父类（构造函数）&lt;/li&gt;
&lt;li&gt;子类（实例变量、普通语句块）&lt;/li&gt;
&lt;li&gt;子类（构造函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;object-通用方法&#34;&gt;Object 通用方法&lt;/h4&gt;
&lt;h5 id=&#34;equals&#34;&gt;equals()&lt;/h5&gt;
&lt;p&gt;用来判断两个对象是否&lt;strong&gt;等价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个对象具有等价关系，需要满足以下五个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自反性：x.equals(x); // true&lt;/li&gt;
&lt;li&gt;对称性：x.equals(y) == y.equals(x); // true&lt;/li&gt;
&lt;li&gt;传递性：if (x.equals(y) &amp;amp;&amp;amp; y.equals(z))  x.equals(z); // true;&lt;/li&gt;
&lt;li&gt;一致性：多次调用 equals() 方法结果不变&lt;/li&gt;
&lt;li&gt;与 null 的比较：对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价（&lt;code&gt;equals()&lt;/code&gt;）与相等（&lt;code&gt;==&lt;/code&gt;）的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。&lt;/li&gt;
&lt;li&gt;对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查是否为同一个对象的引用，如果是直接返回 true；&lt;/li&gt;
&lt;li&gt;检查是否是同一个类型，如果不是，直接返回 false；&lt;/li&gt;
&lt;li&gt;将 Object 对象进行转型；&lt;/li&gt;
&lt;li&gt;判断每个关键域是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    EqualExample that = (EqualExample) o;

    if (x != that.x) return false;
    if (y != that.y) return false;
    return z == that.z;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;hashcode&#34;&gt;hashCode()&lt;/h5&gt;
&lt;p&gt;hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。&lt;/p&gt;
&lt;p&gt;在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。&lt;/p&gt;
&lt;p&gt;HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。&lt;/p&gt;
&lt;p&gt;下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&amp;lt;EqualExample&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;tostring&#34;&gt;toString()&lt;/h5&gt;
&lt;p&gt;默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为哈希值的无符号十六进制表示。&lt;/p&gt;
&lt;h5 id=&#34;clone&#34;&gt;clone()&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. cloneable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法（父类的 protected 方法，对于子类来说，是 private 方法）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample {
    private int a;
    private int b;
}
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重写 clone() 得到以下实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
java.lang.CloneNotSupportedException: CloneExample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。&lt;/p&gt;
&lt;p&gt;应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 浅拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拷贝对象和原始对象引用同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 深拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拷贝对象和原始对象引用不同对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. clone() 的替代方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &amp;lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;继承&#34;&gt;继承&lt;/h4&gt;
&lt;h5 id=&#34;访问权限&#34;&gt;访问权限&lt;/h5&gt;
&lt;p&gt;Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。&lt;/p&gt;
&lt;p&gt;可以对类或类中的成员（字段和方法）加上访问修饰符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类可见：表示其它类可以用这个类创建实例对象。&lt;/li&gt;
&lt;li&gt;成员可见：表示其它类可以用这个类的实例对象访问到该成员；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。&lt;/p&gt;
&lt;p&gt;设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。&lt;/p&gt;
&lt;p&gt;如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。&lt;/p&gt;
&lt;p&gt;字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。&lt;/p&gt;
&lt;p&gt;可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。&lt;/p&gt;
&lt;h5 id=&#34;抽象类与接口&#34;&gt;抽象类与接口&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 抽象类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。&lt;/p&gt;
&lt;p&gt;抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。&lt;/p&gt;
&lt;p&gt;从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。&lt;/p&gt;
&lt;p&gt;接口的成员（字段 + 方法）默认都是 public 的，并且&lt;strong&gt;不允许&lt;/strong&gt;定义为 private 或者 protected。从 Java 9 开始，允许将&lt;strong&gt;方法&lt;/strong&gt;定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。&lt;/p&gt;
&lt;p&gt;接口的字段默认都是 static 和 final 的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。&lt;/li&gt;
&lt;li&gt;从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。&lt;/li&gt;
&lt;li&gt;接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。&lt;/li&gt;
&lt;li&gt;接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 使用选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；&lt;/li&gt;
&lt;li&gt;需要使用多重继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用抽象类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要在几个相关的类中共享代码。&lt;/li&gt;
&lt;li&gt;需要能控制继承来的成员的访问权限，而不是都为 public。&lt;/li&gt;
&lt;li&gt;需要继承非静态和非常量字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。&lt;/p&gt;
&lt;h5 id=&#34;super&#34;&gt;super&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。使用 super() 调用父类构造函数，必须放在第一条语句。&lt;/li&gt;
&lt;li&gt;访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;重写与重载&#34;&gt;重写与重载&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 重写（Override）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。&lt;/p&gt;
&lt;p&gt;为了满足里式替换原则，重写有以下三个限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类方法的访问权限必须大于等于父类方法；&lt;/li&gt;
&lt;li&gt;子类方法的返回类型必须是父类方法返回类型或为其子类型。&lt;/li&gt;
&lt;li&gt;子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。&lt;/p&gt;
&lt;p&gt;下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类方法访问权限为 public，大于父类的 protected。&lt;/li&gt;
&lt;li&gt;子类的返回类型为 ArrayList&amp;lt;Integer&amp;gt;，是父类返回类型 List&amp;lt;Integer&amp;gt; 的子类。&lt;/li&gt;
&lt;li&gt;子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。&lt;/li&gt;
&lt;li&gt;子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this.func(this)&lt;/li&gt;
&lt;li&gt;super.func(this)&lt;/li&gt;
&lt;li&gt;this.func(super)&lt;/li&gt;
&lt;li&gt;super.func(super)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println(&amp;quot;A.show(A)&amp;quot;);
    }

    public void show(C obj) {
        System.out.println(&amp;quot;A.show(C)&amp;quot;);
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println(&amp;quot;B.show(A)&amp;quot;);
    }
}

class C extends B {
}

class D extends C {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 重载（Overload）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。&lt;/p&gt;
&lt;p&gt;应该注意的是，返回值不同，其它都相同不算是重载。&lt;/p&gt;
&lt;h4 id=&#34;反射&#34;&gt;反射&lt;/h4&gt;
&lt;p&gt;每个类都有一个 &lt;strong&gt;Class&lt;/strong&gt; 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。&lt;/p&gt;
&lt;p&gt;类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 &lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code&gt; 这种方式来控制类的加载，该方法会返回一个 Class 对象。&lt;/p&gt;
&lt;p&gt;反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。&lt;/p&gt;
&lt;p&gt;Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；&lt;/li&gt;
&lt;li&gt;Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；&lt;/li&gt;
&lt;li&gt;Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。&lt;/li&gt;
&lt;li&gt;类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。&lt;/li&gt;
&lt;li&gt;调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。&lt;/p&gt;
&lt;p&gt;反射的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。&lt;/li&gt;
&lt;li&gt;安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。&lt;/li&gt;
&lt;li&gt;内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;其他&#34;&gt;其他&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： &lt;strong&gt;Error&lt;/strong&gt; 和 &lt;strong&gt;Exception&lt;/strong&gt;。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;受检异常&lt;/strong&gt; ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非受检异常&lt;/strong&gt; ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/PPjwP.png&#34; alt=&#34;img&#34; style=&#34;zoom:13%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;泛型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    // T stands for &amp;quot;Type&amp;quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1033693&#34;&gt;10 道 Java 泛型面试题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java vs C++&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。&lt;/li&gt;
&lt;li&gt;Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。&lt;/li&gt;
&lt;li&gt;Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。&lt;/li&gt;
&lt;li&gt;Java 支持自动垃圾回收，而 C++ 需要手动回收。&lt;/li&gt;
&lt;li&gt;Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。&lt;/li&gt;
&lt;li&gt;Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。&lt;/li&gt;
&lt;li&gt;Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;JRE vs JDK&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。&lt;/li&gt;
&lt;li&gt;JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;vs-python&#34;&gt;vs python&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机：java 和 python 的运行，都是基于虚拟机&lt;/li&gt;
&lt;li&gt;核心：java 的核心是虚拟机，python 的核心是类库&lt;/li&gt;
&lt;li&gt;动静态：python 是全动态的，可以在运行时修改代码，变量也是动态的；java 的变量是静态的，必须事先声明&lt;/li&gt;
&lt;li&gt;起源：python 是对标 c 语言的，类是后加的；java 是对标 c++ 的，主要为了解决 c++ 指针问题&lt;/li&gt;
&lt;li&gt;开发模式：
&lt;ul&gt;
&lt;li&gt;python 适合敏捷开发；java 适合多人合作开发&lt;/li&gt;
&lt;li&gt;python 更“自由”；java 更“规范”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能：源于强大的虚拟机，java 性能要优于 python，且对于 java 虚拟机是可以进行调优的&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;python 是脚本语言，比较轻便，可以很方便地调用 c 语言函数或 c++ 库，因此广泛用于数据分析、图像算法等领域&lt;/li&gt;
&lt;li&gt;java 虚拟机巨大，一般用在服务端，对数据库支持良好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java 和 Python 有哪些区别？ - find goo的回答 - 知乎 https://www.zhihu.com/question/20491745/answer/100741761&lt;/p&gt;
&lt;h4 id=&#34;从编写到运行的过程&#34;&gt;从编写到运行的过程&lt;/h4&gt;
&lt;p&gt;编译器 -&amp;gt; .class&lt;/p&gt;
&lt;p&gt;类加载器 加载到 虚拟机&lt;/p&gt;
&lt;p&gt;虚拟机内部的解释器进行运行&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/57c3e650eaf14983061e74cf29fa964a.png&#34; alt=&#34;在这里插入图片描述&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;https://www.pianshen.com/article/91151664011/&lt;/p&gt;
&lt;h3 id=&#34;java-容器&#34;&gt;Java 容器&lt;/h3&gt;
&lt;h4 id=&#34;概述&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191208220948084.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;1. Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。&lt;/li&gt;
&lt;li&gt;HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。&lt;/li&gt;
&lt;li&gt;LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。&lt;/li&gt;
&lt;li&gt;LinkedHashSet &lt;strong&gt;vs&lt;/strong&gt; HashSet
&lt;ul&gt;
&lt;li&gt;LinkedHashSet 基于 LinkedHashMap&lt;/li&gt;
&lt;li&gt;HashSet 基于 HashMap&lt;/li&gt;
&lt;li&gt;LinkedHashSet 继承于 HashSet，HashSet 中有一个特定供 LinkedHashSet 使用的构造函数&lt;/li&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220120140335907.png&#34; alt=&#34;image-20220120140335907&#34; style=&#34;zoom:30%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList：基于动态数组实现，支持随机访问。&lt;/li&gt;
&lt;li&gt;Vector：和 ArrayList 类似，但它是线程安全的。&lt;/li&gt;
&lt;li&gt;LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. Queue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinkedList：可以用它来实现双向队列。&lt;/li&gt;
&lt;li&gt;PriorityQueue：基于堆结构实现，可以用它来实现优先队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20201101234335837.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;TreeMap：基于红黑树实现。&lt;/li&gt;
&lt;li&gt;HashMap：基于哈希表实现。&lt;/li&gt;
&lt;li&gt;HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。&lt;/li&gt;
&lt;li&gt;LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;容器中的设计模式&#34;&gt;容器中的设计模式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。&lt;/p&gt;
&lt;p&gt;从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&amp;quot;a&amp;quot;);
list.add(&amp;quot;b&amp;quot;);
for (String item : list) {
    System.out.println(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java.util.Arrays#asList() 可以把数组类型转换为 List 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SafeVarargs
public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用以下方式调用 asList()：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List list = Arrays.asList(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;通过 asList() 方法，把数组对象包装成 List 对象。在 asList() 方法的内部实现中，把数组直接赋值给了内部类 ArrayList 的数组字段，且为 final。&lt;/p&gt;
&lt;p&gt;使用 asList() 获得的 List，不支持 add() 操作，仅能对已有数据进行 get 和 set。&lt;/p&gt;
&lt;h4 id=&#34;源码分析&#34;&gt;源码分析&lt;/h4&gt;
&lt;p&gt;如果没有特别说明，以下源码分析基于 JDK 1.8。&lt;/p&gt;
&lt;p&gt;在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。&lt;/p&gt;
&lt;h5 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的默认大小为 10。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final int DEFAULT_CAPACITY = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 add() 方法添加元素，在 add() 方法内部，会自动进行必要的扩容。&lt;/p&gt;
&lt;p&gt;添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 &lt;code&gt;oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)&lt;/code&gt;，即 oldCapacity+oldCapacity/2。其中 oldCapacity &amp;gt;&amp;gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）&lt;/p&gt;
&lt;p&gt;扩容操作需要调用 &lt;code&gt;Arrays.copyOf()&lt;/code&gt; 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 删除元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。&lt;/p&gt;
&lt;p&gt;保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient Object[] elementData; // non-private to simplify nested class access
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &amp;gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&amp;lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&amp;lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Fail-Fast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。&lt;/p&gt;
&lt;p&gt;在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。&lt;/p&gt;
&lt;p&gt;检测 modCount 是否改变，主要是为了确保在序列化的过程中，没有别的线程对 ArrayList 进行修改&lt;/p&gt;
&lt;h5 id=&#34;vector&#34;&gt;Vector&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index &amp;gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。&lt;/p&gt;
&lt;p&gt;调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 与 ArrayList 的比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；&lt;/li&gt;
&lt;li&gt;Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 替代方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SynchronizedList&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;Collections.synchronizedList();&lt;/code&gt; 得到一个线程安全的 ArrayList。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
List&amp;lt;String&amp;gt; synList = Collections.synchronizedList(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SynchronizedList 类是 Collections 类的静态内部类&lt;/p&gt;
&lt;p&gt;SynchronizedList &lt;strong&gt;vs&lt;/strong&gt; Vector：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SynchronizedList 使用同步代码块，而 Vector 使用同步方法&lt;/li&gt;
&lt;li&gt;扩容机制不同，ArrayList 默认是 1.5 倍，Vector 是 2 倍&lt;/li&gt;
&lt;li&gt;SynchronizedList 可以让任何 List 都变成线程安全的，例如，获取线程安全的 LinkedList 对象&lt;/li&gt;
&lt;li&gt;SynchronizedList 可以指定锁定的对象，在构造函数中可为 mutex 初始化，mutex 为同步代码块的锁定对象&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/lujiahua/p/11408789.html&#34;&gt;SynchronizedList和Vector的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;copyonwritearraylist&#34;&gt;CopyOnWriteArrayList&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 读写分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。&lt;/p&gt;
&lt;p&gt;写操作需要加锁，防止并发写入时导致写入数据丢失。&lt;/p&gt;
&lt;p&gt;写操作结束之后需要把原始数组指向新的复制数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。&lt;/p&gt;
&lt;p&gt;但是 CopyOnWriteArrayList 有其缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；&lt;/li&gt;
&lt;li&gt;数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。&lt;/p&gt;
&lt;h5 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于双向链表实现，使用 Node 存储链表节点信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class Node&amp;lt;E&amp;gt; {
    E item;
    Node&amp;lt;E&amp;gt; next;
    Node&amp;lt;E&amp;gt; prev;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个链表存储了 first 和 last 指针：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;transient Node&amp;lt;E&amp;gt; first;
transient Node&amp;lt;E&amp;gt; last;
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191208233940066.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;2. 与 ArrayList 的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组支持随机访问，但插入删除的代价很高，需要移动大量元素；&lt;/li&gt;
&lt;li&gt;链表不支持随机访问，但插入删除只需要改变指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;hashmap&#34;&gt;HashMap&lt;/h5&gt;
&lt;p&gt;为了便于理解，以下源码分析以 JDK 1.7 为主。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组+单向链表（红黑树）&lt;/p&gt;
&lt;p&gt;内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;2. 拉链法的工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(&amp;quot;K1&amp;quot;, &amp;quot;V1&amp;quot;);
map.put(&amp;quot;K2&amp;quot;, &amp;quot;V2&amp;quot;);
map.put(&amp;quot;K3&amp;quot;, &amp;quot;V3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;新建一个 HashMap，默认大小为 16；&lt;/li&gt;
&lt;li&gt;插入 &amp;lt;K1,V1&amp;gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。&lt;/li&gt;
&lt;li&gt;插入 &amp;lt;K2,V2&amp;gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。&lt;/li&gt;
&lt;li&gt;插入 &amp;lt;K3,V3&amp;gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &amp;lt;K2,V2&amp;gt; 前面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应该注意到链表的插入是以&lt;strong&gt;头插法&lt;/strong&gt;方式进行的，例如上面的 &amp;lt;K3,V3&amp;gt; 不是插在 &amp;lt;K2,V2&amp;gt; 后面，而是插入在链表头部。&lt;/p&gt;
&lt;p&gt;查找需要分成两步进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算键值对所在的桶；&lt;/li&gt;
&lt;li&gt;在链表上顺序查找，时间复杂度显然和链表的长度成正比。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191208235258643.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;3. put 操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 jdk1.7&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。&lt;/p&gt;
&lt;p&gt;使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 jdk1.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流程梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据key计算hash值&lt;/li&gt;
&lt;li&gt;根据hash值，从table中取出node
&lt;ul&gt;
&lt;li&gt;如果node为空，则根据key-value构造node，放到table相应位置中&lt;/li&gt;
&lt;li&gt;如果node不为空
&lt;ul&gt;
&lt;li&gt;如果node为红黑树，则会调用putTreeVal，向树中添加元素&lt;/li&gt;
&lt;li&gt;如果node为单链表，则会遍历单链表
&lt;ul&gt;
&lt;li&gt;如果找到与key-value相等的元素，则直接返回。&lt;/li&gt;
&lt;li&gt;如果没找到，则在尾部新建节点。新建后，如果发现链表长度大于TREEIFY_THRESHOLD（默认为8），则会将单链表转为红黑树。
&lt;ul&gt;
&lt;li&gt;分支逻辑：在转换过程中，如果发现当前table数组的大小小于MIN_TREEIFY_CAPACITY（默认为64），则不会进行转换，而是进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后，将size++，如果size超过阈值（容量*比例因子），则会进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 确定桶下标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多操作都需要先确定一个键值对所在的桶下标。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 计算 hash 值
int hash = hash(key);
// 根据 hash 值计算桶下标
int i = indexFor(hash, table.length);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.1 取模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 x = 1&amp;lt;&amp;lt;4，即 x 为 2 的 4 次方，它具有以下性质：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;x   : 00010000
x-1 : 00001111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;y       : 10110010
x-1     : 00001111
y&amp;amp;(x-1) : 00000010
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个性质和 y 对 x 取模效果是一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;y   : 10110010
x   : 00010000
y%x : 00000010
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。&lt;/p&gt;
&lt;p&gt;确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static int indexFor(int h, int length) {
    return h &amp;amp; (length-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1 基本原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。&lt;/p&gt;
&lt;p&gt;为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。&lt;/p&gt;
&lt;p&gt;和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;capacity&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;size&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;键值对数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;threshold&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;size 的临界值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;loadFactor&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩容时机&lt;/strong&gt;：添加元素前先检查 size，如果 size 大于等于 threshold，就进行扩容操作，令 capacity 为原来的两倍&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    size++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.2 重新计算桶下标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。&lt;/p&gt;
&lt;p&gt;假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;capacity     : 00010000
new capacity : 00100000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一个 Key，它的哈希值 hash 在第 5 位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；&lt;/li&gt;
&lt;li&gt;为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6. 计算数组容量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。&lt;/p&gt;
&lt;p&gt;先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;mask |= mask &amp;gt;&amp;gt; 1    11011000
mask |= mask &amp;gt;&amp;gt; 2    11111110
mask |= mask &amp;gt;&amp;gt; 4    11111111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mask+1 是大于原始数字的最小的 2 的 n 次方。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;num      10010000
mask+1  100000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下是 HashMap 中计算数组容量的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7. 链表转红黑树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。&lt;/p&gt;
&lt;p&gt;在转换过程中，如果发现当前 table 长度小于 MIN_TREEIFY_CAPACITY，则会停止转换，而进行扩容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
    int n, index; Node&amp;lt;K,V&amp;gt; e;
    if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
        TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
        do {
            TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8. 与 Hashtable 的比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hashtable 使用 synchronized 来进行同步。&lt;/li&gt;
&lt;li&gt;HashMap 可以插入键为 null 的 Entry。&lt;/li&gt;
&lt;li&gt;HashMap 的迭代器是 fail-fast 迭代器。
&lt;ul&gt;
&lt;li&gt;fail-fast（快速失败）：遍历过程中，源 modCount 被修改，则直接抛异常&lt;/li&gt;
&lt;li&gt;fail-safe（安全失败）：遍历过程中，源数据可被修改&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/biglxl/article/details/77462266&#34;&gt;fail-fast和fail-safe详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;concurrenthashmap&#34;&gt;ConcurrentHashMap&lt;/h5&gt;
&lt;p&gt;jdk 1.7&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191209001038024.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。&lt;/p&gt;
&lt;p&gt;Segment 继承自 ReentrantLock。&lt;/p&gt;
&lt;p&gt;默认的并发级别为 16，也就是说默认创建 16 个 Segment。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int DEFAULT_CONCURRENCY_LEVEL = 16;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. size 操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。&lt;/p&gt;
&lt;p&gt;尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。&lt;/p&gt;
&lt;p&gt;如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&amp;lt;K,V&amp;gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn&#39;t retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &amp;lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &amp;lt; segments.length; ++j) {
                Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &amp;lt; 0 || (size += c) &amp;lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &amp;gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &amp;lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. JDK 1.8 的改动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。&lt;/p&gt;
&lt;p&gt;JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。&lt;/p&gt;
&lt;p&gt;并且 JDK 1.8 的实现也在链表过长时将其转换为红黑树。&lt;/p&gt;
&lt;h5 id=&#34;linkedhashmap&#34;&gt;LinkedHashMap&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LinkedHashMap&amp;lt;K,V&amp;gt; extends HashMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;accessOrder 决定了顺序，默认为 false&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;false：插入顺序&lt;/li&gt;
&lt;li&gt;true：LRU&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final boolean accessOrder;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void afterNodeAccess(Node&amp;lt;K,V&amp;gt; p) { }
void afterNodeInsertion(boolean evict) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;afterNodeAccess()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个节点被访问时，如果 accessOrder 为 true（LRU），则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { // move node to last
    LinkedHashMap.Entry&amp;lt;K,V&amp;gt; last;
    if (accessOrder &amp;amp;&amp;amp; (last = tail) != e) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
            (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;afterNodeInsertion()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 put 等操作之后执行&lt;/p&gt;
&lt;p&gt;当 removeEldestEntry() 方法返回 true 时，会移除最晚的节点，也就是链表首部节点 first。&lt;/p&gt;
&lt;p&gt;evict 只有在构建 Map 的时候才为 false，在这里为 true。&lt;/p&gt;
&lt;p&gt;当 evict 为 false 时，就不会自动删除元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&amp;lt;K,V&amp;gt; first;
    if (evict &amp;amp;&amp;amp; (first = head) != null &amp;amp;&amp;amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected boolean removeEldestEntry(Map.Entry&amp;lt;K,V&amp;gt; eldest) {
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;维护链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap 继承于 HashMap&lt;/p&gt;
&lt;p&gt;重载 newNode() 方法，当新建节点时，添加到链表中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node&amp;lt;K,V&amp;gt; newNode(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; e) {
    LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
        new LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重载 afterNodeRemoval() 方法，当删除节点时，从链表中同步删除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void afterNodeRemoval(Node&amp;lt;K,V&amp;gt; e) { // unlink
    LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
        (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;)e, b = p.before, a = p.after;
    p.before = p.after = null;
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LRU 缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是使用 LinkedHashMap 实现的一个 LRU 缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设定最大缓存空间 MAX_ENTRIES 为 3；&lt;/li&gt;
&lt;li&gt;使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；&lt;/li&gt;
&lt;li&gt;覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class LRUCache&amp;lt;K, V&amp;gt; extends LinkedHashMap&amp;lt;K, V&amp;gt; {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &amp;gt; MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}

public static void main(String[] args) {
    LRUCache&amp;lt;Integer, String&amp;gt; cache = new LRUCache&amp;lt;&amp;gt;();
    cache.put(1, &amp;quot;a&amp;quot;);
    cache.put(2, &amp;quot;b&amp;quot;);
    cache.put(3, &amp;quot;c&amp;quot;);
    cache.get(1);
    cache.put(4, &amp;quot;d&amp;quot;);
    System.out.println(cache.keySet());
}

[3, 1, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;weakhashmap&#34;&gt;WeakHashMap&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。&lt;/p&gt;
&lt;p&gt;WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ConcurrentCache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。&lt;/p&gt;
&lt;p&gt;ConcurrentCache 采取的是分代缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；&lt;/li&gt;
&lt;li&gt;不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。&lt;/li&gt;
&lt;li&gt;当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。&lt;/li&gt;
&lt;li&gt;当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ConcurrentCache&amp;lt;K, V&amp;gt; {

    private final int size;

    private final Map&amp;lt;K, V&amp;gt; eden;

    private final Map&amp;lt;K, V&amp;gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&amp;lt;&amp;gt;(size);
        this.longterm = new WeakHashMap&amp;lt;&amp;gt;(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &amp;gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java-并发&#34;&gt;Java 并发&lt;/h3&gt;
&lt;h4 id=&#34;使用线程&#34;&gt;使用线程&lt;/h4&gt;
&lt;p&gt;有三种使用线程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现 Runnable 接口；&lt;/li&gt;
&lt;li&gt;实现 Callable 接口；&lt;/li&gt;
&lt;li&gt;继承 Thread 类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现 Runnable 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要实现接口中的 run() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现 Callable 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyCallable implements Callable&amp;lt;Integer&amp;gt; {
    public Integer call() {
        return 123;
    }
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask&amp;lt;Integer&amp;gt; ft = new FutureTask&amp;lt;&amp;gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;继承 Thread 类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。&lt;/p&gt;
&lt;p&gt;当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyThread extends Thread {
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现接口 VS 继承 Thread&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现接口会更好一些，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；&lt;/li&gt;
&lt;li&gt;类可能只要求可执行就行，继承整个 Thread 类开销过大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基础线程机制&#34;&gt;基础线程机制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Executor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p&gt;
&lt;p&gt;主要有三种 Executor：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CachedThreadPool：一个任务创建一个线程；&lt;/li&gt;
&lt;li&gt;FixedThreadPool：所有任务只能使用固定大小的线程；&lt;/li&gt;
&lt;li&gt;SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &amp;lt; 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Daemon&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。&lt;/p&gt;
&lt;p&gt;当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。&lt;/p&gt;
&lt;p&gt;main() 属于非守护线程。&lt;/p&gt;
&lt;p&gt;在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;sleep()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。&lt;/p&gt;
&lt;p&gt;sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yield()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void run() {
    Thread.yield();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;中断&#34;&gt;中断&lt;/h4&gt;
&lt;p&gt;一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InterruptedException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。&lt;/p&gt;
&lt;p&gt;对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InterruptExample {

    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println(&amp;quot;Thread run&amp;quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println(&amp;quot;Main run&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;interrupted()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。&lt;/p&gt;
&lt;p&gt;但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InterruptExample {

    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
            }
            System.out.println(&amp;quot;Thread end&amp;quot;);
        }
    }
}
public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Executor 的中断操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。&lt;/p&gt;
&lt;p&gt;以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; {
        try {
            Thread.sleep(2000);
            System.out.println(&amp;quot;Thread run&amp;quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println(&amp;quot;Main run&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&amp;lt;?&amp;gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Future&amp;lt;?&amp;gt; future = executorService.submit(() -&amp;gt; {
    // ..
});
future.cancel(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Future.cancel( boolean )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传入true会中断线程停止任务&lt;/li&gt;
&lt;li&gt;传入false则会让线程正常执行至完成&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;线程处于&lt;strong&gt;等待&lt;/strong&gt;状态：此时调用 &lt;code&gt;cancel()&lt;/code&gt; 方法不管传入true还是false都会标记为取消，任务依然保存在任务队列中，但当轮到此任务运行时会直接跳过。&lt;/li&gt;
&lt;li&gt;线程处于&lt;strong&gt;运行中&lt;/strong&gt;：此时传入true会中断正在执行的任务，传入false则不会中断。&lt;/li&gt;
&lt;li&gt;线程处于&lt;strong&gt;完成&lt;/strong&gt;状态：此时 &lt;code&gt;cancel()&lt;/code&gt; 不会起任何作用，因为任务已经完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/StefanTimber/article/details/73823689&#34;&gt;关于Future.cancel(false)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;互斥同步&#34;&gt;互斥同步&lt;/h4&gt;
&lt;p&gt;Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。&lt;/p&gt;
&lt;h5 id=&#34;synchronized&#34;&gt;synchronized&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象的监视器：monitor&lt;/p&gt;
&lt;p&gt;monitorenter：尝试获取 monitor&lt;/p&gt;
&lt;p&gt;monitorexit：释放 monitor&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 同步一个代码块&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void func() {
    synchronized (this) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。&lt;/p&gt;
&lt;p&gt;对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &amp;quot; &amp;quot;);
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; e1.func1());
    executorService.execute(() -&amp;gt; e1.func1());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; e1.func1());
    executorService.execute(() -&amp;gt; e2.func1());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 同步一个方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized void func () {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它和同步代码块一样，作用于同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 同步一个类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &amp;quot; &amp;quot;);
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; e1.func2());
    executorService.execute(() -&amp;gt; e2.func2());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 同步一个静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized static void fun() {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用于整个类。&lt;/p&gt;
&lt;h5 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h5&gt;
&lt;p&gt;ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &amp;quot; &amp;quot;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}

public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; lockExample.func());
    executorService.execute(() -&amp;gt; lockExample.func());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;比较&#34;&gt;比较&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 锁的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 等待可中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p&gt;
&lt;p&gt;ReentrantLock 可中断，而 synchronized 不行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 公平锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。&lt;/p&gt;
&lt;p&gt;synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 锁绑定多个条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 ReentrantLock 可以同时绑定多个 Condition 对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/p&gt;
&lt;h4 id=&#34;线程间的协作&#34;&gt;线程间的协作&lt;/h4&gt;
&lt;p&gt;当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;join()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。&lt;/p&gt;
&lt;p&gt;对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println(&amp;quot;A&amp;quot;);
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;B&amp;quot;);
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;A
B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;wait() notify() notifyAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。&lt;/p&gt;
&lt;p&gt;它们都属于 Object 的一部分，而不属于 Thread。&lt;/p&gt;
&lt;p&gt;wait() 方法会释放当前线程持有的对象锁，并进入等待队列（等待队列中的线程会被挂起，等待唤醒，不会竞争锁）&lt;/p&gt;
&lt;p&gt;notify() 方法会将任意一个在等待队列中的线程移动到同步队列（在同步队列中的线程会竞争锁）&lt;/p&gt;
&lt;p&gt;两个方法都只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 wait() 方法，因为要释放锁，所以等先获取锁&lt;/li&gt;
&lt;li&gt;对于 notify() 方法，必须在同步方法或同步块中使用，是 java 的规范，因为 wait() 的初衷就是释放锁，让别的线程获取锁，当进行一些操作后，再唤醒自身。所以，必须在同步块中才有意义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wxw7blog/p/7396906.html&#34;&gt;为什么wait()，notify()和notifyAll()必须在同步块或同步方法中调用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println(&amp;quot;before&amp;quot;);
        notifyAll();
    }

    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&amp;quot;after&amp;quot;);
    }
}

public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -&amp;gt; example.after());
    executorService.execute(() -&amp;gt; example.before());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;before
after
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于加锁解锁操作，主要是对 对象头 进行修改&lt;/li&gt;
&lt;li&gt;对于同步队列、等待队列，主要基于队列实现，当锁被释放后，由 JVM 对同步队列中的线程进行唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;wait() 和 sleep() 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；&lt;/li&gt;
&lt;li&gt;wait() 会释放锁，sleep() 不会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;await() signal() signalAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。&lt;/p&gt;
&lt;p&gt;相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。&lt;/p&gt;
&lt;p&gt;使用 Lock 来获取一个 Condition 对象。&lt;/p&gt;
&lt;p&gt;与 wait() notify() 相同，await() signal() 也必须放在同步块中（lock.lock() lock.unlock()）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println(&amp;quot;before&amp;quot;);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println(&amp;quot;after&amp;quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -&amp;gt; example.after());
    executorService.execute(() -&amp;gt; example.before());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;before
after
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;线程状态&#34;&gt;线程状态&lt;/h4&gt;
&lt;p&gt;一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新建（NEW）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建后尚未启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可运行（RUNABLE）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞（BLOCKED）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无限期等待（WAITING）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等待其它线程显式地唤醒。&lt;/p&gt;
&lt;p&gt;阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;进入方法&lt;/th&gt;
&lt;th&gt;退出方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;没有设置 Timeout 参数的 Object.wait() 方法&lt;/td&gt;
&lt;td&gt;Object.notify() / Object.notifyAll()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;没有设置 Timeout 参数的 Thread.join() 方法&lt;/td&gt;
&lt;td&gt;被调用的线程执行完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LockSupport.park() 方法&lt;/td&gt;
&lt;td&gt;LockSupport.unpark(Thread)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;限期等待（TIMED_WAITING）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;进入方法&lt;/th&gt;
&lt;th&gt;退出方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Thread.sleep() 方法&lt;/td&gt;
&lt;td&gt;时间结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置了 Timeout 参数的 Object.wait() 方法&lt;/td&gt;
&lt;td&gt;时间结束 / Object.notify() / Object.notifyAll()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置了 Timeout 参数的 Thread.join() 方法&lt;/td&gt;
&lt;td&gt;时间结束 / 被调用的线程执行完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LockSupport.parkNanos() 方法&lt;/td&gt;
&lt;td&gt;LockSupport.unpark(Thread)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LockSupport.parkUntil() 方法&lt;/td&gt;
&lt;td&gt;LockSupport.unpark(Thread)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;调用 Thread.sleep() 方法使线程进入限期&lt;strong&gt;等待&lt;/strong&gt;状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期&lt;strong&gt;等待&lt;/strong&gt;时，常常用“挂起一个线程”进行描述。&lt;/p&gt;
&lt;p&gt;睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死亡（TERMINATED）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以是线程结束任务之后自己结束，或者产生了异常而结束。&lt;/p&gt;
&lt;h4 id=&#34;juc-aqs&#34;&gt;J.U.C - AQS&lt;/h4&gt;
&lt;p&gt;java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。&lt;/p&gt;
&lt;h5 id=&#34;countdownlatch&#34;&gt;&lt;strong&gt;CountDownLatch&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;用来控制一个或者多个线程等待多个线程。&lt;/p&gt;
&lt;p&gt;维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ba078291-791e-4378-b6d1-ece76c2f0b14.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; totalThread; i++) {
            executorService.execute(() -&amp;gt; {
                System.out.print(&amp;quot;run..&amp;quot;);
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println(&amp;quot;end&amp;quot;);
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;run..run..run..run..run..run..run..run..run..run..end
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;cyclicbarrier&#34;&gt;&lt;strong&gt;CyclicBarrier&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。&lt;/p&gt;
&lt;p&gt;和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。&lt;/p&gt;
&lt;p&gt;CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。&lt;/p&gt;
&lt;p&gt;CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &amp;lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; totalThread; i++) {
            executorService.execute(() -&amp;gt; {
                System.out.print(&amp;quot;before..&amp;quot;);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print(&amp;quot;after..&amp;quot;);
            });
        }
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;semaphore&#34;&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。&lt;/p&gt;
&lt;p&gt;以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; totalRequestCount; i++) {
            executorService.execute(()-&amp;gt;{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + &amp;quot; &amp;quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2 1 2 2 2 2 2 1 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;juc-其它组件&#34;&gt;J.U.C - 其它组件&lt;/h4&gt;
&lt;h5 id=&#34;futuretask&#34;&gt;&lt;strong&gt;FutureTask&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&amp;lt;V&amp;gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&amp;lt;V&amp;gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt;
public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;Integer&amp;gt;(new Callable&amp;lt;Integer&amp;gt;() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i &amp;lt; 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;other task is running...&amp;quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;other task is running...
4950
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;blockingqueue&#34;&gt;&lt;strong&gt;BlockingQueue&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FIFO 队列&lt;/strong&gt; ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级队列&lt;/strong&gt; ：PriorityBlockingQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。&lt;/p&gt;
&lt;p&gt;示例：使用 BlockingQueue 实现生产者消费者问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProducerConsumer {

    private static BlockingQueue&amp;lt;String&amp;gt; queue = new ArrayBlockingQueue&amp;lt;&amp;gt;(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put(&amp;quot;product&amp;quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&amp;quot;produce..&amp;quot;);
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&amp;quot;consume..&amp;quot;);
        }
    }
}
public static void main(String[] args) {
    for (int i = 0; i &amp;lt; 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i &amp;lt; 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i &amp;lt; 3; i++) {
        Producer producer = new Producer();
        producer.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;forkjoin&#34;&gt;&lt;strong&gt;ForkJoin&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ForkJoinExample extends RecursiveTask&amp;lt;Integer&amp;gt; {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first &amp;lt;= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i &amp;lt;= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ForkJoinPool extends AbstractExecutorService
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。&lt;/p&gt;
&lt;p&gt;例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h4 id=&#34;线程不安全示例&#34;&gt;线程不安全示例&lt;/h4&gt;
&lt;p&gt;如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。&lt;/p&gt;
&lt;p&gt;以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &amp;lt; threadSize; i++) {
        executorService.execute(() -&amp;gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;997
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;java-内存模型&#34;&gt;Java 内存模型&lt;/h4&gt;
&lt;p&gt;Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;
&lt;h5 id=&#34;主内存与工作内存&#34;&gt;&lt;strong&gt;主内存与工作内存&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;处理器上的寄存器的读写速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。&lt;/p&gt;
&lt;p&gt;加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。&lt;/p&gt;
&lt;p&gt;线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h5 id=&#34;内存间交互操作&#34;&gt;&lt;strong&gt;内存间交互操作&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;read：把一个变量的值从主内存传输到工作内存中&lt;/li&gt;
&lt;li&gt;load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中&lt;/li&gt;
&lt;li&gt;use：把工作内存中一个变量的值传递给执行引擎&lt;/li&gt;
&lt;li&gt;assign：把一个从执行引擎接收到的值赋给工作内存的变量&lt;/li&gt;
&lt;li&gt;store：把工作内存的一个变量的值传送到主内存中&lt;/li&gt;
&lt;li&gt;write：在 store 之后执行，把 store 得到的值放入主内存的变量中&lt;/li&gt;
&lt;li&gt;lock：作用于主内存的变量&lt;/li&gt;
&lt;li&gt;unlock&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;内存模型三大特性&#34;&gt;内存模型三大特性&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。&lt;/p&gt;
&lt;p&gt;有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。&lt;/p&gt;
&lt;p&gt;为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。&lt;/p&gt;
&lt;p&gt;下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;AtomicInteger 能保证多个线程修改的原子性。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &amp;lt; threadSize; i++) {
        executorService.execute(() -&amp;gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AtomicSynchronizedExample {
    private int cnt = 0;

    public synchronized void add() {
        cnt++;
    }

    public synchronized int get() {
        return cnt;
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &amp;lt; threadSize; i++) {
        executorService.execute(() -&amp;gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。&lt;/p&gt;
&lt;p&gt;主要有三种实现可见性的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;volatile&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现原理：
&lt;ul&gt;
&lt;li&gt;JVM：在操作前后添加内存屏障指令&lt;/li&gt;
&lt;li&gt;CPU：使用 lock 指令，对总线加锁，实现内存屏障，并保证可见性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 有序性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;/p&gt;
&lt;p&gt;volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。&lt;/p&gt;
&lt;p&gt;可以通过 synchronized 来保证多线程的有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。&lt;/p&gt;
&lt;h5 id=&#34;先行发生原则&#34;&gt;先行发生原则&lt;/h5&gt;
&lt;p&gt;上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。&lt;/p&gt;
&lt;p&gt;先行发生原则，指的是，在满足某些条件时，若操作 A 在时间上先于操作 B，那么，&lt;strong&gt;从逻辑上看&lt;/strong&gt;，操作 A 一定先于操作 B。&lt;/p&gt;
&lt;p&gt;解释两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么时间上已经有先后顺序了，还需要先行发生原则？因为多线程之间的无序性。&lt;/li&gt;
&lt;li&gt;为什么我说的是“从逻辑上”？因为事实就是如此，在先行发生原则下，可能操作 A 晚于操作 B 发生，但是先行发生原则能保证，逻辑上，一定是先 A 后 B。详见：&lt;a href=&#34;https://blog.csdn.net/wangdong5678999/article/details/80960118&#34;&gt;先行发生原则(happens-before)介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. 单一线程原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Single Thread rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一个线程内，在程序前面的操作先行发生于后面的操作。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;2. 管程锁定规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Monitor Lock Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;3. volatile 变量规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Volatile Variable Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/942f33c9-8ad9-4987-836f-007de4c21de0.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;4. 线程启动规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thread Start Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;5. 线程加入规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thread Join Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thread 对象的结束先行发生于 join() 方法返回。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/233f8d89-31d7-413f-9c02-042f19c46ba1.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;6. 线程中断规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thread Interruption Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 对象终结规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Finalizer Rule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 传递性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Transitivity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。&lt;/p&gt;
&lt;h4 id=&#34;实现线程安全的方法&#34;&gt;实现线程安全的方法&lt;/h4&gt;
&lt;p&gt;定义：多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。&lt;/p&gt;
&lt;p&gt;线程安全有以下几种实现方式：&lt;/p&gt;
&lt;h5 id=&#34;不可变&#34;&gt;&lt;strong&gt;不可变&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。&lt;/p&gt;
&lt;p&gt;不可变的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;final 关键字修饰的基本数据类型&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;枚举类型&lt;/li&gt;
&lt;li&gt;Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ImmutableExample {
    public static void main(String[] args) {
        Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        Map&amp;lt;String, Integer&amp;gt; unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put(&amp;quot;a&amp;quot;, 1);
    }
}
Exception in thread &amp;quot;main&amp;quot; java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;线程同步&#34;&gt;线程同步&lt;/h5&gt;
&lt;h6 id=&#34;互斥同步阻塞同步&#34;&gt;&lt;strong&gt;互斥同步（阻塞同步）&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;synchronized 和 ReentrantLock。&lt;/p&gt;
&lt;h6 id=&#34;非阻塞同步&#34;&gt;&lt;strong&gt;非阻塞同步&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。&lt;/p&gt;
&lt;p&gt;互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。&lt;/p&gt;
&lt;p&gt;随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. CAS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. AtomicInteger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。&lt;/p&gt;
&lt;p&gt;以下代码使用了 AtomicInteger 执行了自增的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。&lt;/p&gt;
&lt;p&gt;可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. ABA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。&lt;/p&gt;
&lt;p&gt;J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。&lt;/p&gt;
&lt;h5 id=&#34;无同步方案&#34;&gt;&lt;strong&gt;无同步方案&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 栈封闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i &amp;lt; 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}

public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; example.add100());
    executorService.execute(() -&amp;gt; example.add100());
    executorService.shutdown();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100
100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 线程本地存储（Thread Local Storage）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/p&gt;
&lt;p&gt;符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。&lt;/p&gt;
&lt;p&gt;可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。&lt;/p&gt;
&lt;p&gt;对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -&amp;gt; {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -&amp;gt; {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了理解 ThreadLocal，先看以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -&amp;gt; {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -&amp;gt; {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它所对应的底层结构图为：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6782674c-1bfe-4879-af39-e9d722a95d39.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&amp;gt;value 键值对插入到该 Map 中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get() 方法类似。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。&lt;/p&gt;
&lt;p&gt;在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 可重入代码（Reentrant Code）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。&lt;/p&gt;
&lt;p&gt;可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。&lt;/p&gt;
&lt;h4 id=&#34;jdk16-synchronized-锁优化&#34;&gt;jdk1.6 synchronized 锁优化&lt;/h4&gt;
&lt;h5 id=&#34;锁消除&#34;&gt;&lt;strong&gt;锁消除&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。&lt;/p&gt;
&lt;p&gt;锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。&lt;/p&gt;
&lt;p&gt;对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。&lt;/p&gt;
&lt;h5 id=&#34;锁粗化&#34;&gt;锁粗化&lt;/h5&gt;
&lt;p&gt;如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。&lt;/p&gt;
&lt;p&gt;上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。&lt;/p&gt;
&lt;h5 id=&#34;锁升级&#34;&gt;锁升级&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;主要流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程对对象进行加锁，当获取到锁后，首先会对对象加偏向锁，加完偏向锁，如果有别的线程也想对该对象加锁，则该对象的偏向锁会转换成轻量级锁。在轻量级锁的情况下，如果 CAS 超过一定次数，则会转成重量级锁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/92808298&#34;&gt;synchronized锁升级优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自旋锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。&lt;/p&gt;
&lt;p&gt;自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。&lt;/p&gt;
&lt;p&gt;在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。&lt;/p&gt;
&lt;p&gt;以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 锁标记位 对应了五个状态，这些状态在左侧的 锁状态 中给出。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/v2-e47232518a4e042f31a9e0eb6a48f88c_1440w.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。&lt;/p&gt;
&lt;p&gt;当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/baaa681f-7c52-4198-a5ae-303b9386cf47.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p&gt;
&lt;p&gt;当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。&lt;/p&gt;
&lt;p&gt;当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。&lt;/p&gt;
&lt;h4 id=&#34;多线程开发良好的实践&#34;&gt;多线程开发良好的实践&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;给线程起个有意义的名字，这样可以方便找 Bug。&lt;/li&gt;
&lt;li&gt;缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。&lt;/li&gt;
&lt;li&gt;多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。&lt;/li&gt;
&lt;li&gt;使用 BlockingQueue 实现生产者消费者问题。&lt;/li&gt;
&lt;li&gt;多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。&lt;/li&gt;
&lt;li&gt;使用本地变量和不可变类来保证线程安全。&lt;/li&gt;
&lt;li&gt;使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java-虚拟机&#34;&gt;Java 虚拟机&lt;/h3&gt;
&lt;p&gt;本文大部分内容参考 &lt;strong&gt;周志明《深入理解 Java 虚拟机》&lt;/strong&gt; ，想要深入学习的话请看原书。&lt;/p&gt;
&lt;h4 id=&#34;运行时数据区域&#34;&gt;运行时数据区域&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png&#34; alt=&#34;image-20210727153842086&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）&lt;/p&gt;
&lt;p&gt;记录每个线程当前运行的代码在方法区中的位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。&lt;/p&gt;
&lt;p&gt;对栈帧的创建、入栈、出栈，由虚拟机进行控制&lt;/p&gt;
&lt;p&gt;局部变量表 存放基本数据类型变量或者对象的引用&lt;/p&gt;
&lt;p&gt;栈 -&amp;gt; 线程 -&amp;gt; 方法：从栈中划分一块区域给线程，再从这块区域中划分一块给方法&lt;/p&gt;
&lt;p&gt;可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java -Xss2M HackTheJava
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该区域可能抛出以下异常（栈溢出）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（单个线程栈 溢出）如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java 虚拟机将抛出一个StackOverFlowError异常&lt;/li&gt;
&lt;li&gt;（整个虚拟机栈 溢出）如果 java 虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是依旧无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那 java 虚拟机将会抛出一个OutOfMemoryError异常&lt;/li&gt;
&lt;li&gt;java栈内存溢出怎么产生？ - skywa的回答 - 知乎 https://www.zhihu.com/question/28637033/answer/41568606&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈溢出的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归调用&lt;/li&gt;
&lt;li&gt;启动线程过多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。&lt;/p&gt;
&lt;p&gt;本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;quot;GC 堆&amp;quot;）。&lt;/p&gt;
&lt;p&gt;现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代（Young Generation）&lt;/li&gt;
&lt;li&gt;老年代（Old Generation）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。&lt;/p&gt;
&lt;p&gt;可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java -Xms1M -Xmx2M HackTheJava
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。&lt;/p&gt;
&lt;p&gt;对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。&lt;/p&gt;
&lt;p&gt;HotSpot 虚拟机把它当成&lt;strong&gt;永久代&lt;/strong&gt;来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至&lt;strong&gt;元空间&lt;/strong&gt;，它位于本地内存中，而不是虚拟机内存中。&lt;/p&gt;
&lt;p&gt;方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行时常量池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行时常量池是方法区的一部分。&lt;/p&gt;
&lt;p&gt;Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。&lt;/p&gt;
&lt;p&gt;除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。&lt;/p&gt;
&lt;h4 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h4&gt;
&lt;p&gt;垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。&lt;/p&gt;
&lt;h5 id=&#34;判断一个对象是否可被回收&#34;&gt;判断一个对象是否可被回收&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 引用计数算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。&lt;/p&gt;
&lt;p&gt;在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 可达性分析算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。&lt;/p&gt;
&lt;p&gt;Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量表中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI 中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/83d909d2-3858-4fe1-8ff4-16471db0b180.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;3. 方法区的回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。&lt;/p&gt;
&lt;p&gt;主要是对常量池的回收和对类的卸载。&lt;/p&gt;
&lt;p&gt;为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。&lt;/p&gt;
&lt;p&gt;类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。&lt;/li&gt;
&lt;li&gt;加载该类的 ClassLoader 已经被回收。&lt;/li&gt;
&lt;li&gt;该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. finalize()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 C++ 的析构函数，用于关闭外部资源，但 try-finally 等方式可以做得更好。并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。&lt;/p&gt;
&lt;p&gt;当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。&lt;/p&gt;
&lt;h5 id=&#34;引用类型&#34;&gt;引用类型&lt;/h5&gt;
&lt;p&gt;无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。&lt;/p&gt;
&lt;p&gt;Java 提供了四种强度不同的引用类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 强引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被强引用关联的对象不会被回收。&lt;/p&gt;
&lt;p&gt;使用 new 一个新对象的方式来创建强引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 软引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被软引用关联的对象只有在内存不够的情况下才会被回收。&lt;/p&gt;
&lt;p&gt;使用 SoftReference 类来创建软引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
SoftReference&amp;lt;Object&amp;gt; sf = new SoftReference&amp;lt;Object&amp;gt;(obj);
obj = null;  // 使对象只被软引用关联
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 弱引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。&lt;/p&gt;
&lt;p&gt;使用 WeakReference 类来创建弱引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
WeakReference&amp;lt;Object&amp;gt; wf = new WeakReference&amp;lt;Object&amp;gt;(obj);
obj = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 虚引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。&lt;/p&gt;
&lt;p&gt;为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。&lt;/p&gt;
&lt;p&gt;使用 PhantomReference 来创建虚引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object obj = new Object();
PhantomReference&amp;lt;Object&amp;gt; pf = new PhantomReference&amp;lt;Object&amp;gt;(obj, null);
obj = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;垃圾收集算法&#34;&gt;垃圾收集算法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 标记 - 清除&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/005b481b-502b-4e3f-985d-d043c2b330aa.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。&lt;/p&gt;
&lt;p&gt;在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。&lt;/p&gt;
&lt;p&gt;在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。&lt;/p&gt;
&lt;p&gt;不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记和清除过程效率都不高；&lt;/li&gt;
&lt;li&gt;会产生大量不连续的内存碎片，导致无法给大对象分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 标记 - 整理&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ccd773a5-ad38-4022-895c-7ac318f31437.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不会产生内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不足:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要移动大量对象，处理效率比较低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 标记-复制&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。&lt;/p&gt;
&lt;p&gt;主要不足是只使用了内存的一半。&lt;/p&gt;
&lt;p&gt;现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。&lt;/p&gt;
&lt;p&gt;HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有&lt;strong&gt;多于 10%&lt;/strong&gt; 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行&lt;strong&gt;空间分配担保&lt;/strong&gt;，也就是借用老年代的空间存储放不下的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 分代收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。&lt;/p&gt;
&lt;p&gt;一般将堆分为新生代和老年代。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代使用：复制算法&lt;/li&gt;
&lt;li&gt;老年代使用：标记 - 清除 或者 标记 - 整理 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;垃圾收集器&#34;&gt;垃圾收集器&lt;/h5&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png&#34; alt=&#34;image-20210923142511010&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;以上是 HotSpot 虚拟机中的 7+3 个垃圾收集器，连线表示垃圾收集器可以配合使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；&lt;/li&gt;
&lt;li&gt;串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;概述-2&#34;&gt;概述&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新生代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial：标记-复制算法+单线程&lt;/li&gt;
&lt;li&gt;ParNew：标记-复制算法+多线程+STW尽量短&lt;/li&gt;
&lt;li&gt;Parallel Scavenge：标记-复制算法+多线程+吞吐量可控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial Old：标记-整理算法+单线程&lt;/li&gt;
&lt;li&gt;Parallel Old：标记-整理算法+吞吐量&lt;/li&gt;
&lt;li&gt;CMS：标记-清除算法+STW尽量短
&lt;ul&gt;
&lt;li&gt;初始标记、并发标记、重新标记、并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jdk9 默认的收集器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区+分代&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/aef0f4765098&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZGC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STW极短&lt;/li&gt;
&lt;li&gt;分区思想&lt;/li&gt;
&lt;li&gt;染色指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;1-serial-收集器&#34;&gt;1. Serial 收集器&lt;/h6&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;Serial 翻译为串行，也就是说它以串行的方式执行。&lt;/p&gt;
&lt;p&gt;它是单线程的收集器，只会使用一个线程进行垃圾收集工作。&lt;/p&gt;
&lt;p&gt;它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。&lt;/p&gt;
&lt;p&gt;它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。&lt;/p&gt;
&lt;h6 id=&#34;2-parnew-收集器&#34;&gt;2. ParNew 收集器&lt;/h6&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;它是 Serial 收集器的多线程版本。&lt;/p&gt;
&lt;p&gt;它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。&lt;/p&gt;
&lt;h6 id=&#34;3-parallel-scavenge-收集器&#34;&gt;3. Parallel Scavenge 收集器&lt;/h6&gt;
&lt;p&gt;与 ParNew 一样是多线程收集器。&lt;/p&gt;
&lt;p&gt;其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“&lt;strong&gt;吞吐量&lt;/strong&gt;优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。&lt;/p&gt;
&lt;p&gt;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。&lt;/p&gt;
&lt;p&gt;缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。&lt;/p&gt;
&lt;p&gt;可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。&lt;/p&gt;
&lt;h6 id=&#34;4-serial-old-收集器&#34;&gt;4. Serial Old 收集器&lt;/h6&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。&lt;/li&gt;
&lt;li&gt;作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;5-parallel-old-收集器&#34;&gt;5. Parallel Old 收集器&lt;/h6&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;是 Parallel Scavenge 收集器的老年代版本。&lt;/p&gt;
&lt;p&gt;在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。&lt;/p&gt;
&lt;h6 id=&#34;6-cms-收集器&#34;&gt;6. CMS 收集器&lt;/h6&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。&lt;/p&gt;
&lt;p&gt;分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。&lt;/li&gt;
&lt;li&gt;并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。&lt;/li&gt;
&lt;li&gt;重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。&lt;/li&gt;
&lt;li&gt;并发清除：不需要停顿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。&lt;/p&gt;
&lt;p&gt;具有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。&lt;/li&gt;
&lt;li&gt;标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;7-g1-收集器&#34;&gt;7. G1 收集器&lt;/h6&gt;
&lt;p&gt;G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。&lt;/p&gt;
&lt;p&gt;堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/4cf711a8-7ab2-4152-b85c-d5c226733807.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。&lt;/p&gt;
&lt;p&gt;每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RS被用来记录从其他Region指向一个Region的指针情况。因此，一个Region就会有一个RS。这种记录可以带来一个极大的好处：在回收一个Region的时候不需要执行全堆扫描，只需要检查它的RS就可以找到外部引用&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/aef0f4765098&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。&lt;/li&gt;
&lt;li&gt;筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;回收原理与 CMS 类似，只是在最终回收时，利用分区的思想，全局采用标记整理算法，局部采用复制算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具备如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li&gt;
&lt;li&gt;可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011546953/article/details/78994882&#34;&gt;CMS收集器与G1收集器&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;8-zgc&#34;&gt;8. ZGC&lt;/h6&gt;
&lt;p&gt;将堆划分成3部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小页面（2M）：对象小于256KB&lt;/li&gt;
&lt;li&gt;中页面（32M）：对象在256KM~4MB&lt;/li&gt;
&lt;li&gt;大页面（&amp;gt;32M）：对象大于4M&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指针着色：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png&#34; alt=&#34;image-20210923143727759&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。&lt;/li&gt;
&lt;li&gt;并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）&lt;/li&gt;
&lt;li&gt;再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。&lt;/li&gt;
&lt;li&gt;并发转移准备：筛选需要转移的分区&lt;/li&gt;
&lt;li&gt;初始转移：转移与GC Roots直接关联的对象&lt;/li&gt;
&lt;li&gt;并发转移：转发表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么初始标记阶段，不标记所有对象？&lt;/p&gt;
&lt;p&gt;因为耗时少！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么不直接进行并发标记？即，初始标记的意义是什么？&lt;/p&gt;
&lt;p&gt;初始标记的意义：找根对象&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png&#34; alt=&#34;image-20210924093232733&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Z的含义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可能大伙还惦记这标题吧？&lt;strong&gt;ZGC 的 Z 是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实没啥意思，就是个名字而已。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/yessimida/article/details/109763732&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;h4 id=&#34;内存分配与回收策略&#34;&gt;内存分配与回收策略&lt;/h4&gt;
&lt;h5 id=&#34;minor-gc-和-full-gc&#34;&gt;Minor GC 和 Full GC&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。虽然使用的是复制算法，但非垃圾对象较少，因此拷贝时间较短。
&lt;ul&gt;
&lt;li&gt;用空间换时间，需要两个内存空间，直接Copy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。
&lt;ul&gt;
&lt;li&gt;用时间换空间，需要Mark+Compact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Major GC (Old GC)：回收老年代。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。&lt;/p&gt;
&lt;p&gt;对于大多数老年代的垃圾收集器，回收过程都是新生代和老年代一起收集的，因此是 Full GC，对于 CMS，回收过程只针对老年代，因此是 Major GC。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/41922036&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;内存分配策略&#34;&gt;内存分配策略&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 对象优先在 Eden 分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 大对象直接进入老年代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p&gt;
&lt;p&gt;经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p&gt;
&lt;p&gt;-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 长期存活的对象进入老年代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p&gt;
&lt;p&gt;-XX:MaxTenuringThreshold 用来定义年龄的阈值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 动态对象年龄判定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 空间分配担保&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p&gt;
&lt;p&gt;如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p&gt;
&lt;h5 id=&#34;full-gc-的触发条件&#34;&gt;Full GC 的触发条件&lt;/h5&gt;
&lt;p&gt;对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 调用 System.gc()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 老年代空间不足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p&gt;
&lt;p&gt;为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 空间分配担保失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. JDK 1.7 及以前的永久代空间不足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p&gt;
&lt;p&gt;当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. Concurrent Mode Failure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p&gt;
&lt;h5 id=&#34;性能调优-减少-stw&#34;&gt;性能调优-减少 STW&lt;/h5&gt;
&lt;p&gt;性能调优的目的：减少 STW 的时间&lt;/p&gt;
&lt;p&gt;STW：Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。&lt;/p&gt;
&lt;p&gt;Full GC 的 SWT 时间远大于 Minor GC，因此需要尽量减少 Full GC 的次数&lt;/p&gt;
&lt;p&gt;调优方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。&lt;/li&gt;
&lt;li&gt;对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。&lt;/li&gt;
&lt;li&gt;使用不同的垃圾收集器，不同收集器，适用于不同的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png&#34; alt=&#34;image-20210727162355407&#34; style=&#34;zoom:55%;&#34; /&gt;
&lt;h4 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h4&gt;
&lt;p&gt;类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;包括以下 7 个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载（Loading）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证（Verification）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;准备（Preparation）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解析（Resolution）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化（Initialization）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用（Using）&lt;/li&gt;
&lt;li&gt;卸载（Unloading）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类加载过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含了加载、验证、准备、解析和初始化这 5 个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载是类加载的一个阶段，注意不要混淆。&lt;/p&gt;
&lt;p&gt;加载过程完成以下三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过类的完全限定名称获取定义该类的二进制字节流。&lt;/li&gt;
&lt;li&gt;将该字节流表示的静态存储结构转换为方法区的运行时存储结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中二进制字节流可以从以下方式中获取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。&lt;/li&gt;
&lt;li&gt;从网络中获取，最典型的应用是 Applet。&lt;/li&gt;
&lt;li&gt;运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。&lt;/li&gt;
&lt;li&gt;由其他文件生成，例如由 JSP 文件生成对应的 Class 类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。&lt;/p&gt;
&lt;p&gt;实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。&lt;/p&gt;
&lt;p&gt;初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int value = 123;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final int value = 123;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将常量池的符号引用替换为直接引用的过程。&lt;/p&gt;
&lt;p&gt;其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &amp;lt;clinit&amp;gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。&lt;/p&gt;
&lt;p&gt;&amp;lt;clinit&amp;gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于父类的 &amp;lt;clinit&amp;gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &amp;lt;clinit&amp;gt;() 方法。但接口与类不同的是，执行接口的 &amp;lt;clinit&amp;gt;() 方法不需要先执行父接口的 &amp;lt;clinit&amp;gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &amp;lt;clinit&amp;gt;() 方法。&lt;/p&gt;
&lt;p&gt;虚拟机会保证一个类的 &amp;lt;clinit&amp;gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &amp;lt;clinit&amp;gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &amp;lt;clinit&amp;gt;() 方法完毕。如果在一个类的 &amp;lt;clinit&amp;gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类初始化时机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 主动引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。&lt;/li&gt;
&lt;li&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；&lt;/li&gt;
&lt;li&gt;当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 被动引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过子类引用父类的静态字段，不会导致子类初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SuperClass[] sca = new SuperClass[10];
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(ConstClass.HELLOWORLD);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类与类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。&lt;/p&gt;
&lt;p&gt;这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类加载器分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；&lt;/li&gt;
&lt;li&gt;所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 Java 开发人员的角度看，类加载器可以划分得更细致一些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &amp;lt;JRE_HOME&amp;gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。&lt;/li&gt;
&lt;li&gt;扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &amp;lt;JAVA_HOME&amp;gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。&lt;/li&gt;
&lt;li&gt;应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双亲委派模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。&lt;/p&gt;
&lt;p&gt;下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;1. 工作过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。&lt;/p&gt;
&lt;p&gt;例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义类加载器实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。&lt;/p&gt;
&lt;p&gt;java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace(&#39;.&#39;, File.separatorChar) + &amp;quot;.class&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FileSystemClassLoader loader = new FileSystemClassLoader(&amp;quot;rootDir&amp;quot;);
Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&amp;quot;类名&amp;quot;);
Object o = clazz.newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java-io&#34;&gt;Java IO&lt;/h3&gt;
&lt;h4 id=&#34;磁盘操作file&#34;&gt;磁盘操作：File&lt;/h4&gt;
&lt;p&gt;File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。&lt;/p&gt;
&lt;p&gt;递归地列出一个目录下所有文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 Java7 开始，可以使用 Paths 和 Files 代替 File。&lt;/p&gt;
&lt;h4 id=&#34;字节操作inputstream-和-outputstream&#34;&gt;字节操作：InputStream 和 OutputStream&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实现文件复制&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java I/O 使用了装饰者模式来实现。以 InputStream 为例，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InputStream 是抽象组件；&lt;/li&gt;
&lt;li&gt;FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；&lt;/li&gt;
&lt;li&gt;FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9709694b-db05-4cce-8d2f-1c8b09f4d921.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。&lt;/p&gt;
&lt;h4 id=&#34;字符操作reader-和-writer&#34;&gt;字符操作：Reader 和 Writer&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;编码与解码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编码就是把字符转换为字节，而解码是把字节重新组合成字符。&lt;/p&gt;
&lt;p&gt;如果编码和解码过程使用不同的编码方式那么就出现了乱码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；&lt;/li&gt;
&lt;li&gt;UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；&lt;/li&gt;
&lt;li&gt;UTF-16 编码中，中文字符和英文字符都占 2 个字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java 的内存编码使用双字节编码 UTF-16，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String 的编码方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 可以看成一个&lt;strong&gt;字符&lt;/strong&gt;序列，可以指定一个编码方式将它编码为&lt;strong&gt;字节&lt;/strong&gt;序列，也可以指定一个编码方式将一个字节序列解码为 String。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String str1 = &amp;quot;中文&amp;quot;;
byte[] bytes = str1.getBytes(&amp;quot;UTF-8&amp;quot;);
String str2 = new String(bytes, &amp;quot;UTF-8&amp;quot;);
System.out.println(str2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。&lt;/p&gt;
&lt;p&gt;双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] bytes = str1.getBytes();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Reader 与 Writer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InputStreamReader 实现从字节流解码成字符流；&lt;/li&gt;
&lt;li&gt;OutputStreamWriter 实现字符流编码成为字节流。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对象操作serializable&#34;&gt;对象操作：Serializable&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列化就是将一个对象转换成字节序列，方便存储和传输。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列化：ObjectOutputStream.writeObject()&lt;/li&gt;
&lt;li&gt;反序列化：ObjectInputStream.readObject()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Serializable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transient&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;transient 关键字可以使一些属性不会被序列化。&lt;/p&gt;
&lt;p&gt;ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private transient Object[] elementData;

/**
 * Save the state of the &amp;lt;tt&amp;gt;ArrayList&amp;lt;/tt&amp;gt; instance to a stream (that
 * is, serialize it).
 *
 * @serialData The length of the array backing the &amp;lt;tt&amp;gt;ArrayList&amp;lt;/tt&amp;gt;
 *             instance is emitted (int), followed by all of its elements
 *             (each an &amp;lt;tt&amp;gt;Object&amp;lt;/tt&amp;gt;) in the proper order.
 */
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();
 
    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);
 
    // Write out all elements in the proper order.
    for (int i=0; i&amp;lt;size; i++) {
        s.writeObject(elementData[i]);
    }
 
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;网络操作socket&#34;&gt;网络操作：Socket&lt;/h4&gt;
&lt;p&gt;Java 中的网络支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InetAddress：用于表示网络上的硬件资源，即 IP 地址；&lt;/li&gt;
&lt;li&gt;URL：统一资源定位符；&lt;/li&gt;
&lt;li&gt;Sockets：使用 TCP 协议实现网络通信；&lt;/li&gt;
&lt;li&gt;Datagram：使用 UDP 协议实现网络通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InetAddress&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有公有的构造函数，只能通过静态方法来创建实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;URL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以直接从 URL 中读取字节流数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws IOException {

    URL url = new URL(&amp;quot;http://www.baidu.com&amp;quot;);

    /* 字节流 */
    InputStream is = url.openStream();

    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, &amp;quot;utf-8&amp;quot;);

    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Sockets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ServerSocket：服务器端类&lt;/li&gt;
&lt;li&gt;Socket：客户端类&lt;/li&gt;
&lt;li&gt;服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;Datagram&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DatagramSocket：通信类&lt;/li&gt;
&lt;li&gt;DatagramPacket：数据包类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nio&#34;&gt;NIO&lt;/h4&gt;
&lt;p&gt;NIO 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向&lt;strong&gt;块&lt;/strong&gt;的 I/O。&lt;/p&gt;
&lt;h5 id=&#34;流与块&#34;&gt;流与块&lt;/h5&gt;
&lt;p&gt;I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。&lt;/p&gt;
&lt;p&gt;面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。&lt;/p&gt;
&lt;p&gt;面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。&lt;/p&gt;
&lt;p&gt;I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。&lt;/p&gt;
&lt;h5 id=&#34;通道与缓冲区&#34;&gt;通道与缓冲区&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1. 通道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。&lt;/p&gt;
&lt;p&gt;通道是对 NIO 的具体实现。&lt;/p&gt;
&lt;p&gt;通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。&lt;/p&gt;
&lt;p&gt;通道包括以下类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileChannel：从文件中读写数据；&lt;/li&gt;
&lt;li&gt;DatagramChannel：通过 UDP 读写网络中数据；&lt;/li&gt;
&lt;li&gt;SocketChannel：通过 TCP 读写网络中数据；&lt;/li&gt;
&lt;li&gt;ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。&lt;/p&gt;
&lt;p&gt;缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。&lt;/p&gt;
&lt;h5 id=&#34;缓冲区状态变量&#34;&gt;缓冲区状态变量&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;capacity：最大容量；&lt;/li&gt;
&lt;li&gt;position：当前已经读写的字节数；&lt;/li&gt;
&lt;li&gt;limit：还可以读写的字节数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态变量的改变过程举例：&lt;/p&gt;
&lt;p&gt;① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。&lt;/p&gt;
&lt;img src=&#34;https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/952e06bd-5a65-4cab-82e4-dd1536462f38.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/67bf5487-c45d-49b6-b9c0-a058d8c68902.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h5 id=&#34;文件-nio-实例&#34;&gt;文件 NIO 实例&lt;/h5&gt;
&lt;p&gt;以下展示了使用 NIO 快速复制文件的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的文件通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);

        /* 清空缓冲区 */
        buffer.clear();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;选择器&#34;&gt;选择器&lt;/h5&gt;
&lt;p&gt;NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。&lt;/p&gt;
&lt;p&gt;NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。&lt;/p&gt;
&lt;p&gt;通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。&lt;/p&gt;
&lt;p&gt;因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。&lt;/p&gt;
&lt;p&gt;应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 创建选择器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Selector selector = Selector.open();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 将通道注册到选择器上&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。&lt;/p&gt;
&lt;p&gt;在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SelectionKey.OP_CONNECT&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_ACCEPT&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_READ&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_WRITE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们在 SelectionKey 的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final int OP_READ = 1 &amp;lt;&amp;lt; 0;
public static final int OP_WRITE = 1 &amp;lt;&amp;lt; 2;
public static final int OP_CONNECT = 1 &amp;lt;&amp;lt; 3;
public static final int OP_ACCEPT = 1 &amp;lt;&amp;lt; 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 监听事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int num = selector.select();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 获取到达的事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys();
Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while (true) {
    int num = selector.select();
    Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys();
    Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;内存映射文件&#34;&gt;内存映射文件&lt;/h5&gt;
&lt;p&gt;内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。&lt;/p&gt;
&lt;p&gt;向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。&lt;/p&gt;
&lt;p&gt;下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;nio-vs-普通-io&#34;&gt;NIO vs 普通 I/O&lt;/h5&gt;
&lt;p&gt;NIO 与普通 I/O 的区别主要有以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NIO 是非阻塞的；&lt;/li&gt;
&lt;li&gt;NIO 面向块，I/O 面向流。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;
&lt;h3 id=&#34;概述-3&#34;&gt;概述&lt;/h3&gt;
&lt;h4 id=&#34;isp&#34;&gt;ISP&lt;/h4&gt;
&lt;p&gt;互联网服务提供商&lt;/p&gt;
&lt;p&gt;ISP 可以从 互联网管理机构 获得许多 IP 地址，个人或机构向 ISP 缴纳一定的费用就可以接入互联网&lt;/p&gt;
&lt;h4 id=&#34;osi模型-五层模型与-tcpip-模型&#34;&gt;OSI模型、五层模型与 TCP/IP 模型&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211217120543019.png&#34; alt=&#34;image-20211217120543019&#34; style=&#34;zoom:45%;&#34; /&gt;
&lt;p&gt;五层模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：负责在&lt;strong&gt;具体媒体&lt;/strong&gt;上传输数据&lt;strong&gt;比特流&lt;/strong&gt;，为 数据链路层 屏蔽具体的媒体特性。&lt;/li&gt;
&lt;li&gt;数据链路层：负责在&lt;strong&gt;具体链路&lt;/strong&gt;上传输&lt;strong&gt;数据帧&lt;/strong&gt;，为 网络层 屏蔽具体链路信息（网络层中，主机间的传输，需要经过多条链路）。&lt;/li&gt;
&lt;li&gt;网络层：负责在&lt;strong&gt;主机间&lt;/strong&gt;传输&lt;strong&gt;数据分组&lt;/strong&gt;，为 传输层 屏蔽主机信息。&lt;/li&gt;
&lt;li&gt;传输层：负责在&lt;strong&gt;进程间&lt;/strong&gt;传输数据，为 应用层 屏蔽进程信息。
&lt;ul&gt;
&lt;li&gt;TCP：传输控制协议，面向连接、可靠的数据传输服务，数据单位为&lt;strong&gt;报文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UDP：用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是&lt;strong&gt;用户数据报&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层：负责在&lt;strong&gt;应用间&lt;/strong&gt;传输&lt;strong&gt;报文&lt;/strong&gt;，例如HTTP、DNS协议。&lt;/li&gt;
&lt;li&gt;越底层，数据量越大，逐层封装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSI模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层：负责数据处理，比如，压缩、加密等，使 &lt;strong&gt;应用层&lt;/strong&gt; 无需关心数据内部格式方面的问题。&lt;/li&gt;
&lt;li&gt;会话层：负责会话的连接、维护、断开等。当应用间需要传输数据时，首先需要建立会话；当数据传输完时，会话层会有选择地进行会话的维护；最终，会话层会断开会话。&lt;/li&gt;
&lt;li&gt;五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP 模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将五层模型中的数据链路层和物理层合并为网络接口层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;物理层&#34;&gt;物理层&lt;/h3&gt;
&lt;h3 id=&#34;链路层&#34;&gt;链路层&lt;/h3&gt;
&lt;h4 id=&#34;信道复用技术41种&#34;&gt;信道复用技术（4+1种）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频分复用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时分复用（TDM）：为每个用户分配固定位置的时隙&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/67582ade-d44a-46a6-8757-3c1296cc1ef9.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计时分复用（异步时分复用，STDM）：不固定每个用户在时分复用帧中的位置，只要有数据，就为其分配时隙，用户拿到时隙后，就可以发送数据（注意区分两张图中字母的顺序）&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6283be2a-814a-4a10-84bf-9592533fe6bc.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;码分复用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ppp-协议&#34;&gt;PPP 协议&lt;/h4&gt;
&lt;p&gt;互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。&lt;/p&gt;
&lt;h4 id=&#34;arp-地址解析协议&#34;&gt;ARP 地址解析协议&lt;/h4&gt;
&lt;p&gt;ARP 协议负责根据 IP 地址获取 MAC 地址。&lt;/p&gt;
&lt;p&gt;实现原理：每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果某 IP 地址不存在，则通过广播的形式获取。MAC 地址&lt;/p&gt;
&lt;p&gt;MAC 地址是链路层地址，长度为 6 字节（6*8=48 位），用于唯一标识网络适配器（网卡）。&lt;/p&gt;
&lt;p&gt;一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。&lt;/p&gt;
&lt;h4 id=&#34;网络设备&#34;&gt;网络设备&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;集线器：
&lt;ul&gt;
&lt;li&gt;物理层设备，作用于 比特&lt;/li&gt;
&lt;li&gt;当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口&lt;/li&gt;
&lt;li&gt;如果集线器同时收到两个不同接口的帧，那么就发生了碰撞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换机：
&lt;ul&gt;
&lt;li&gt;链路层设备，作用于 帧&lt;/li&gt;
&lt;li&gt;不会发生碰撞&lt;/li&gt;
&lt;li&gt;能根据 MAC 地址进行存储转发&lt;/li&gt;
&lt;li&gt;具有自学习能力，能自动生成 交换表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层&lt;/h3&gt;
&lt;h4 id=&#34;概述-4&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;网络层的作用：使用 IP 协议，将异构的物理网络连接起来，使得其看起来好像是一个统一的网络&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地址解析协议 ARP（Address Resolution Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网际控制报文协议 ICMP（Internet Control Message Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网际组管理协议 IGMP（Internet Group Management Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ip-协议&#34;&gt;IP 协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:65%;&#34; /&gt;
&lt;p&gt;IP 地址能够在网络世界唯一标识一台电脑，IP 地址一共有32位，即8个字节。&lt;/p&gt;
&lt;p&gt;IP 地址的编址方式的三个历史阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类编址：
&lt;ul&gt;
&lt;li&gt;不同分类具有不同的网络号长度，并且是固定的&lt;/li&gt;
&lt;li&gt;网络号+主机号&lt;/li&gt;
&lt;li&gt;网络地址：指的是，网络号不变，主机位二进制全为0的 ip 地址，类似于电话号码的区号&lt;/li&gt;
&lt;li&gt;要达到 Internet 上的某个主机，先利用 IP 地址的高位部分（网络地址）找到该主机所在的网络，再利用 IP 地址的低位部分（主机地址）找到该网络中的主机。&lt;/li&gt;
&lt;li&gt;子网掩码，又叫网络掩码、地址掩码。它的作用是，用来指明某个 IP 地址哪些标识位是网络地址，哪些标识位是主机地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子网划分编址：
&lt;ul&gt;
&lt;li&gt;网络号+子网号+主机号&lt;/li&gt;
&lt;li&gt;举例：B 类地址的默认子网掩码为 255.255.0.0（11111111 11111111 00000000 00000000），如果子网占两个比特，那么子网掩码为 255.255.192.0（11111111 11111111 11000000 00000000）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无分类编址（CIDR）：
&lt;ul&gt;
&lt;li&gt;网络前缀号+主机号&lt;/li&gt;
&lt;li&gt;在 IP 地址后面加上网络前缀长度，例如，128.14.35.7/20&lt;/li&gt;
&lt;li&gt;路由聚合与最长前缀匹配：
&lt;ul&gt;
&lt;li&gt;路由聚合：将 200.23.a.b/23 与 200.23.c.d/23 进行聚合，得到200.23.x.x/20，减少路由表项的数量&lt;/li&gt;
&lt;li&gt;最长前缀皮配：如果路由表中存在 A: 200.23.18.0/23 和 B: 200.23.x.x/20，则对于 200.23.18.0/23，选择A与之进行匹配（虽然 B 也能进行匹配，但是不是最长的）&lt;/li&gt;
&lt;li&gt;参考：https://blog.csdn.net/iostream1001001/article/details/78126150&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;icmp-网际控制报文协议&#34;&gt;ICMP 网际控制报文协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e3124763-f75e-46c3-ba82-341e6c98d862.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:43%;&#34; /&gt;
&lt;p&gt;放在 IP 数据报的数据部分，用于实现一些特定的功能，目的是为了更有效地转发 IP 数据报和提高交付成功的机会。&lt;/p&gt;
&lt;p&gt;ICMP 的应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ping：用于测试两台主机之间的连通性。&lt;/li&gt;
&lt;li&gt;Traceroute：用来跟踪一个数据分组从源点到终点的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;vpn-虚拟专用网&#34;&gt;VPN 虚拟专用网&lt;/h4&gt;
&lt;p&gt;如何理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，什么是专用网？主机需要分配 IP 地址才能上网，但往往，一个机构能申请到的 IP 地址是有限的，因此，只能为主机分配本机构内部有效的专用地址。主机间使用专用地址进行通信，构成专用网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是虚拟专用网？指的是，该专用网其实是依托于互联网形成的，所以不是实实在在的专用网，而是虚拟专用网。主机 A 向主机 B 发送数据，数据报的源地址和目的地址都是专用地址，在路由器中，会对数据报进行加密、封装，新的数据报源地址和目的地址都是全球地址。在目的路由接收后，再对数据报进行解密，然后根据专用地址进行转发。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1556770b-8c01-4681-af10-46f1df69202c.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nat-网络地址转换&#34;&gt;NAT 网络地址转换&lt;/h4&gt;
&lt;p&gt;功能：将专业地址转换成全球地址，或将全球地址转换成专用地址，使得机构内部主机可以上网。&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将本地 IP 和全球 IP 一一对应&lt;/li&gt;
&lt;li&gt;缺点：拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网&lt;/li&gt;
&lt;li&gt;解决方案：NAPT 网络地址与端口转换（将传输层的端口号也用上）&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2719067e-b299-4639-9065-bed6729dbf0b.png&#34; alt=&#34;img&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;h4 id=&#34;路由器&#34;&gt;路由器&lt;/h4&gt;
&lt;p&gt;位于网络层，只负责主机间的数据传输&lt;/p&gt;
&lt;p&gt;功能：路由选择与分组转发&lt;/p&gt;
&lt;h4 id=&#34;路由选择协议&#34;&gt;路由选择协议&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内部网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RIP 路由信息协议：基于距离，依靠路由器间交换路由表，获取整个网络的距离信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OSPF 开放式最短路径优先协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Dijkstra 提出的最短路径算法 SPF&lt;/li&gt;
&lt;li&gt;向内部网络中的所有路由器发送信息，且只有当链路状态发生变化时，路由器才会发送信息，因此信息更新过程收敛得更快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BGP 边界网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AS 之间的路由选择很困难，因此，BGP 只能寻找一条比较好的路由，而不是最佳路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png&#34; alt=&#34;img&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;
&lt;h4 id=&#34;udp-vs-tcp&#34;&gt;UDP vs TCP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TCP：
&lt;ul&gt;
&lt;li&gt;传输控制协议，面向连接、可靠（超时重传）的数据传输服务，数据单位为&lt;strong&gt;报文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每一条 TCP 连接，只能一对一&lt;/li&gt;
&lt;li&gt;有流量控制、拥塞控制&lt;/li&gt;
&lt;li&gt;面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP：
&lt;ul&gt;
&lt;li&gt;用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是&lt;strong&gt;用户数据报&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;n对n，n &amp;gt;= 1&lt;/li&gt;
&lt;li&gt;无流量控制、拥塞控制&lt;/li&gt;
&lt;li&gt;面向报文（对应用层传下来的报文不合并也不拆分，只是添加 UDP 首部）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的三次握手&#34;&gt;TCP 的三次握手&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e92d0ebc-7d46-413b-aec1-34a39602f787.png&#34; alt=&#34;img&#34; style=&#34;zoom:43%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的&lt;strong&gt;序号 x&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，&lt;strong&gt;确认号为 x+1&lt;/strong&gt;，同时也选择一个初始的&lt;strong&gt;序号 y&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A 收到 B 的连接确认报文后，还要向 B 发出确认，&lt;strong&gt;确认号为 y+1&lt;/strong&gt;，序号为 &lt;strong&gt;x+1&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B 收到 A 的确认后，连接建立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认 ACK&lt;/strong&gt; ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步 SYN&lt;/strong&gt; ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三次握手的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。&lt;/li&gt;
&lt;li&gt;客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;syn-攻击&#34;&gt;SYN 攻击&lt;/h4&gt;
&lt;p&gt;客户端第一次握手后，故意不进行第三次握手，导致服务端保存大量半连接，占用系统资源。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制同时打开的半连接数目&lt;/li&gt;
&lt;li&gt;缩短超时时间：在超时时间内，服务器会不停重发请求，直到达到超时时间，然后放弃掉该半连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的四次挥手&#34;&gt;TCP 的四次挥手&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;A 发送连接释放报文，FIN=1。&lt;/li&gt;
&lt;li&gt;B 收到之后发出确认报文，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。&lt;/li&gt;
&lt;li&gt;当 B 不再需要连接时，发送连接释放报文，FIN=1。&lt;/li&gt;
&lt;li&gt;A 收到后发出确认报文，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。&lt;/li&gt;
&lt;li&gt;B 收到 A 的确认后释放连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;四次挥手的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进入 TIME_WAIT 状态的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。&lt;/li&gt;
&lt;li&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的滑动窗口&#34;&gt;TCP 的滑动窗口&lt;/h4&gt;
&lt;p&gt;发送方和接收方，都有滑动窗口，接收方通过报文告知发送方自己窗口（接收窗口）的大小，发送方根据接收窗口大小以及其它信息（见拥塞控制那一节）设置自己窗口（发送窗口）的大小&lt;/p&gt;
&lt;p&gt;当发送窗口左侧字节收到确认，右移发送窗口，直到左部第一个字节不是已确认的状态&lt;/p&gt;
&lt;p&gt;接收窗口只会按需进行确认，确认后，右移接收窗口。因此，对于发送窗口来说，收到某个字节的确认，就说明，此字节之前的字节，接收方都已接收。&lt;/p&gt;
&lt;h4 id=&#34;tcp-的流量控制&#34;&gt;TCP 的流量控制&lt;/h4&gt;
&lt;p&gt;接收方通过确认报文中的窗口字段 &lt;strong&gt;影响&lt;/strong&gt; 发送窗口的大小，从而 &lt;strong&gt;影响&lt;/strong&gt; 发送速率（注意，我这里用的是 &lt;strong&gt;影响&lt;/strong&gt;，而不是 &lt;strong&gt;控制&lt;/strong&gt;，见 拥塞控制 那一节，思考原因）&lt;/p&gt;
&lt;p&gt;将窗口字段设置为0，则发送方不能发送数据&lt;/p&gt;
&lt;h4 id=&#34;tcp-的拥塞控制&#34;&gt;TCP 的拥塞控制&lt;/h4&gt;
&lt;p&gt;如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。&lt;/p&gt;
&lt;p&gt;发送窗口大小 = min{ 接收方允许的窗口大小（由确认报文指定），拥塞窗口变量（cwnd） }&lt;/p&gt;
&lt;p&gt;拥塞控制算法（慢开始、拥塞避免、快重传、快恢复）流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将 cwnd 设置为1（&lt;strong&gt;慢开始&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次当收到确认报文后，将 cwnd 加倍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 cwnd &amp;gt;= &lt;strong&gt;慢开始门限&lt;/strong&gt; ssthrsh 后， cwnd 每次只加一（&lt;strong&gt;拥塞避免&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果出现超时，令 ssthresh = cwnd / 2，然后重新执行慢开始（回到第一步）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果连续收到 3 次重复确认，则说明报文段丢失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即重传丢失报文（&lt;strong&gt;快重传&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;并令 ssthresh = cwnd / 2，cwnd = ssthresh （&lt;strong&gt;快恢复&lt;/strong&gt;：无需重新执行慢开始）&lt;/li&gt;
&lt;/ul&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-如何保证可靠性&#34;&gt;TCP 如何保证可靠性&lt;/h4&gt;
&lt;p&gt;6点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;校验和
&lt;ul&gt;
&lt;li&gt;计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;序列号与确认应答&lt;/li&gt;
&lt;li&gt;超时重传&lt;/li&gt;
&lt;li&gt;连接管理&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/42dbcd39c3e7&#34;&gt;TCP 如何保证可靠性&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp-的序号&#34;&gt;TCP 的序号&lt;/h4&gt;
&lt;p&gt;序号指的是，报文段在整个报文中的位置&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设主机A的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流，主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500 000字节的文件组成，其MSS（最大报文段长度）为1000字节，数据流的首字节编号是0，如下图所示：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20190507215823752.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;https://blog.csdn.net/wangquan1992/article/details/89930585&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;初始序号是随机产生的&lt;/p&gt;
&lt;h3 id=&#34;应用层&#34;&gt;应用层&lt;/h3&gt;
&lt;h4 id=&#34;ftp-文件传送协议&#34;&gt;FTP 文件传送协议&lt;/h4&gt;
&lt;p&gt;使用 TCP 进行连接，需要两个连接来传送一个文件：控制连接+数据连接&lt;/p&gt;
&lt;h4 id=&#34;dhcp-动态主机配置协议&#34;&gt;DHCP 动态主机配置协议&lt;/h4&gt;
&lt;p&gt;由 DHCP 服务器提供配置信息，无需用户手动进行配置。&lt;/p&gt;
&lt;p&gt;配置信息包括：IP 地址、子网掩码、网关 IP 地址&lt;/p&gt;
&lt;p&gt;DHCP 工作过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。&lt;/li&gt;
&lt;li&gt;如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。&lt;/li&gt;
&lt;li&gt;DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;dns-协议&#34;&gt;DNS 协议&lt;/h4&gt;
&lt;p&gt;域名 -&amp;gt; ip 地址&lt;/p&gt;
&lt;h4 id=&#34;电子邮件协议&#34;&gt;电子邮件协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7b3efa99-d306-4982-8cfb-e7153c33aab4.png&#34; alt=&#34;img&#34; style=&#34;zoom:53%;&#34; /&gt;
&lt;p&gt;电子邮件协议包括：SMTP、POP3、IMAP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送协议：用于将电子邮件从发送服务器发送到接收服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMTP 简单邮件传送协议：，但只支持 ASCII 码的邮件主体。为了解决这个问题，增加了 MIME 多用途互联网邮件扩展类型，MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取协议：用于将电子邮件从接收服务器读取到客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POP3 邮件读取协议：单向通信，从服务器到客户端。旧版中，用户从服务器读取邮件后，就会把邮件删除，新版中可以不删除邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IMAP 网际报文存取协议：双向通信，客户端和服务器上的邮件保持同步，可以同步文件夹、分类等信息。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/v2-dd366f60ce8a2908e36bcc53a57fc615_720w.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-超文本传输协议&#34;&gt;HTTP 超文本传输协议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;H&lt;/strong&gt;yper &lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol&lt;/p&gt;
&lt;p&gt;根据名字我们可以了解到，HTTP 主要用于传输超文本，最常见的就是 html 页面。&lt;/p&gt;
&lt;h5 id=&#34;url&#34;&gt;URL&lt;/h5&gt;
&lt;p&gt;全称：统一资源定位符（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;L&lt;/strong&gt;ocator），用于定位资源&lt;/p&gt;
&lt;p&gt;URL 是 URI（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;I&lt;/strong&gt;dentifier，统一资源标识符）的子集，在 URI 的基础上增加了定位能力&lt;/p&gt;
&lt;p&gt;URI 除了包含 URL，还包含 URN（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;N&lt;/strong&gt;ame，统一资源名称），用来定义一个资源的名称，但不具备定位该资源的能力。例如，urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h5 id=&#34;http-状态码&#34;&gt;HTTP 状态码&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1XX 信息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;100 Continue&lt;/strong&gt; ：表明到目前为止一切正常，客户端可以发送后续请求或者忽略这个响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2XX 成功&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;200 OK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;204 No Content&lt;/strong&gt; ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;206 Partial Content&lt;/strong&gt; ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容，即，不返回全部实体，只返回部分实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3XX 重定向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt; ：永久性重定向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;302 Found&lt;/strong&gt; ：临时性重定向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;303 See Other&lt;/strong&gt; ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。&lt;/li&gt;
&lt;li&gt;注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。也就是说，对于 303，重定向时一定使用 GET 方法，对于 301 和 302，理论上不应该改变请求方法，但是一般浏览器都会把请求方法改成 GET。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt; ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;307 Temporary Redirect&lt;/strong&gt; ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4XX 客户端错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt; ：请求报文中存在语法错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;401 Unauthorized&lt;/strong&gt; ：该状态码表示发送的请求需要有认证信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;403 Forbidden&lt;/strong&gt; ：请求被拒绝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;416 Requested Range Not Satisfiable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5XX 服务器错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt; ：服务器执行请求时发生错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt; ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类别&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Informational（信息性状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Success（成功状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Redirection（重定向状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Client Error（客户端错误状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Server Error（服务器错误状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;连接管理&#34;&gt;连接管理&lt;/h5&gt;
&lt;p&gt;短连接与长连接：当浏览器访问一个包含多张图片的 HTML 页面时，需要请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。如果要断开连接，需要由客户端或者服务器端提出断开，使用 &lt;code&gt;Connection : close&lt;/code&gt;。从 HTTP/1.1 开始默认是长连接的，之前默认是短连接，如果需要使用长连接，则使用 &lt;code&gt;Connection : Keep-Alive&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。&lt;/p&gt;
&lt;h5 id=&#34;cookie&#34;&gt;Cookie&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;概述：HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 数据保存在客户端本地。Cookie 曾一度用于客户端数据的存储，但现在，Cookie 渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。&lt;/li&gt;
&lt;li&gt;用途：
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建过程：服务器发送的响应报文包含 &lt;strong&gt;Set-Cookie 首部字段&lt;/strong&gt;，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 &lt;strong&gt;Cookie 请求首部字段&lt;/strong&gt;发送给服务器。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。&lt;/li&gt;
&lt;li&gt;持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。在 Set-Cookie 字段中指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域：
&lt;ul&gt;
&lt;li&gt;Domain 标识：指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名（如 developer.mozilla.org）中。&lt;/li&gt;
&lt;li&gt;Path 标识：指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&amp;quot;/&amp;quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：/docs、/docs/Web/。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JavaScript：
&lt;ul&gt;
&lt;li&gt;浏览器通过 &lt;code&gt;document.cookie&lt;/code&gt; 属性可创建新的 Cookie，也可通过该属性访问&lt;strong&gt;非 HttpOnly 标记&lt;/strong&gt;的 Cookie。&lt;/li&gt;
&lt;li&gt;标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 &lt;code&gt;document.cookie&lt;/code&gt; API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Secure 标识：
&lt;ul&gt;
&lt;li&gt;标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。&lt;/li&gt;
&lt;li&gt;但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Session：
&lt;ul&gt;
&lt;li&gt;Session 数据存储在服务端&lt;/li&gt;
&lt;li&gt;使用过程：将数据存储在服务端，生成唯一 Session ID，将 Session ID 作为 Cookie 传给客户端，客户端之后的每个请求都会带有该 Session ID。&lt;/li&gt;
&lt;li&gt;Session ID 安全性问题：应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，避免产生容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。&lt;/li&gt;
&lt;li&gt;若浏览器禁用 Cookie，则需要使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。&lt;/li&gt;
&lt;li&gt;Cookie VS Session：
&lt;ul&gt;
&lt;li&gt;Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；&lt;/li&gt;
&lt;li&gt;Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；&lt;/li&gt;
&lt;li&gt;对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;虚拟主机&#34;&gt;虚拟主机&lt;/h5&gt;
&lt;p&gt;HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。&lt;/p&gt;
&lt;h5 id=&#34;代理&#34;&gt;代理&lt;/h5&gt;
&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;网络访问控制&lt;/li&gt;
&lt;li&gt;访问日志记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正向代理：用户察觉得到&lt;/li&gt;
&lt;li&gt;反向代理：一般位于内部网络中，用户察觉不到&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;https&#34;&gt;HTTPS&lt;/h5&gt;
&lt;p&gt;HTTP 有以下安全性问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被窃听：使用明文进行通信，内容可能会被窃听；&lt;/li&gt;
&lt;li&gt;被伪装：不验证通信方的身份，通信方的身份有可能遭遇伪装；&lt;/li&gt;
&lt;li&gt;被篡改：无法证明报文的完整性，报文有可能遭篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。&lt;/p&gt;
&lt;p&gt;实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer 安全套接字协议）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。&lt;/li&gt;
&lt;li&gt;SSL 是一种为网络通信提供安全及数据完整性的一种安全协议，在传输层与应用层之间对网络连接进行加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ssl-offloading.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h6 id=&#34;加密&#34;&gt;加密&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称密钥加密：加密和解密使用同一密钥，运算速度快，无法安全地将密钥传输给通信方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称密钥加密：加密和解密使用不同的密钥，运算速度慢，可以更安全地将公开密钥传输给通信发送方，除了用来加密，还可以用来进行签名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220125153836682.png&#34; alt=&#34;image-20220125153836682&#34; style=&#34;zoom:30%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 采用的加密方式：混合加密机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用非对称密钥加密方式，传输对称密钥加密方式所需要的密钥，从而保证安全性&lt;/li&gt;
&lt;li&gt;获取到密钥后，再使用对称密钥加密方式进行通信，从而保证效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;认证&#34;&gt;认证&lt;/h6&gt;
&lt;p&gt;通过使用 &lt;strong&gt;证书&lt;/strong&gt; 来对通信方进行认证。&lt;/p&gt;
&lt;p&gt;数字签名：用私钥加密过的原文摘要&lt;/p&gt;
&lt;p&gt;数字签名：用 CA 私钥加密过的公钥&lt;/p&gt;
&lt;p&gt;数字签名生成及验证过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方：通过摘要算法生成原文的摘要，利用自身私钥对摘要进行加密，然后把加密后的摘要以及原文发送给接收方&lt;/li&gt;
&lt;li&gt;接收方：通过发送方的公钥对加密后的摘要进行解密，然后计算原文的摘要，与解密后的摘要进行比对，如果一致，则认证通过&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&#34;&gt;数字签名是什么？阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yangdiao127/article/details/70478498&#34;&gt;证书与签名（二）：数字签名流程与签名认证流程&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;完整性保护&#34;&gt;完整性保护&lt;/h6&gt;
&lt;p&gt;SSL 提供报文摘要功能来进行完整性保护。&lt;/p&gt;
&lt;p&gt;HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。&lt;/p&gt;
&lt;p&gt;HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。&lt;/p&gt;
&lt;h6 id=&#34;缺点&#34;&gt;缺点&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;因为需要进行加密解密等过程，因此速度会更慢；&lt;/li&gt;
&lt;li&gt;需要支付证书授权的高额费用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;综合应用-web-页面请求过程&#34;&gt;综合应用-Web 页面请求过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找网关（DHCP）&lt;/li&gt;
&lt;li&gt;根据网关，找目标服务器（DNS）&lt;/li&gt;
&lt;li&gt;发送&lt;/li&gt;
&lt;li&gt;网关是什么：&lt;a href=&#34;https://www.zhihu.com/question/21787311/answer/19316065&#34;&gt;网关和路由器的区别是什么？ - 吕小星的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dhcp-配置主机信息&#34;&gt;DHCP 配置主机信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 协议来获取。&lt;/li&gt;
&lt;li&gt;主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。&lt;/li&gt;
&lt;li&gt;该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。&lt;/li&gt;
&lt;li&gt;该数据报则被放置在 MAC 帧中，并将广播到与交换机连接的所有设备。&lt;/li&gt;
&lt;li&gt;连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arp-解析-mac-地址&#34;&gt;ARP 解析 MAC 地址&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。&lt;/li&gt;
&lt;li&gt;主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。&lt;/li&gt;
&lt;li&gt;该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。&lt;/li&gt;
&lt;li&gt;该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。&lt;/li&gt;
&lt;li&gt;DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。&lt;/li&gt;
&lt;li&gt;网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dns-解析域名&#34;&gt;DNS 解析域名&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。&lt;/li&gt;
&lt;li&gt;网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。&lt;/li&gt;
&lt;li&gt;因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。&lt;/li&gt;
&lt;li&gt;到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。&lt;/li&gt;
&lt;li&gt;找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-请求页面&#34;&gt;HTTP 请求页面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。（其实和上面所提到的 ARP 协议一样，知道了 IP 地址后，依旧需要获取 MAC 地址，但是为了避免冗余，这里就不写了）&lt;/li&gt;
&lt;li&gt;在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。&lt;/li&gt;
&lt;li&gt;HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。&lt;/li&gt;
&lt;li&gt;连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。&lt;/li&gt;
&lt;li&gt;HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。&lt;/li&gt;
&lt;li&gt;浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;socket-套接字&#34;&gt;Socket 套接字&lt;/h3&gt;
&lt;h4 id=&#34;概述-5&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;什么是套接字？答：Socket。&lt;/p&gt;
&lt;p&gt;那么，什么是Socket？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它本质上是一组接口，或者说一种抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谁的接口？谁的抽象？传输层协议的接口或抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有什么用？应用层协议，通过 Socket 可以与传输层协议进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有 Socket 行不行？不行，如果没有 Socket，那么传输层的协议就只是一种概念，无法具体使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样。&lt;br&gt;
&lt;strong&gt;TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;by https://blog.csdn.net/github_34606293/article/details/78230456&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;io-模型&#34;&gt;I/O 模型&lt;/h4&gt;
&lt;p&gt;一个 输入操作 通常包括两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待数据准备好&lt;/li&gt;
&lt;li&gt;从内核向进程复制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个套接字上的输入操作，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。&lt;/li&gt;
&lt;li&gt;第二步就是把数据从内核缓冲区复制到应用进程缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;阻塞式-io&#34;&gt;阻塞式 I/O&lt;/h5&gt;
&lt;p&gt;应用进程被阻塞，直到数据从 内核缓冲区 复制到 应用进程缓冲区 中才返回。&lt;/p&gt;
&lt;p&gt;应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，&lt;strong&gt;这种模型的 CPU 利用率会比较高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意看图，可以加深理解&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492928416812_4.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;非阻塞式-io&#34;&gt;非阻塞式 I/O&lt;/h5&gt;
&lt;p&gt;应用进程执行 recvfrom 之后，如果数据未准备好，则内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知数据是否准备好，这种方式称为轮询（polling）。&lt;/p&gt;
&lt;p&gt;由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929000361_5.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;io-复用selectpollepoll&#34;&gt;I/O 复用（select/poll/epoll）&lt;/h5&gt;
&lt;p&gt;使用 select, poll 或 epoll 等待数据，可以同时等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。&lt;/p&gt;
&lt;p&gt;I/O 复用使得单个进程可以同时处理多个 I/O 事件。又被称为 Event Driven I/O，即事件驱动 I/O。&lt;/p&gt;
&lt;p&gt;如果一个 Web 服务器没有 I/O 复用，那么对于每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929444818_6.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;信号驱动式-iosigio&#34;&gt;信号驱动式 I/O（SIGIO）&lt;/h5&gt;
&lt;p&gt;应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。&lt;/p&gt;
&lt;p&gt;相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929553651_7.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;异步-ioaio&#34;&gt;异步 I/O（AIO）&lt;/h5&gt;
&lt;p&gt;应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。&lt;/p&gt;
&lt;p&gt;异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。（看图更清晰）&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492930243286_8.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;5-种-io-的比较&#34;&gt;5 种 I/O 的比较&lt;/h5&gt;
&lt;p&gt;这一节主要讨论同步/异步、阻塞/非阻塞的问题，参考：https://www.zhihu.com/question/19732473&lt;/p&gt;
&lt;p&gt;首先讲概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步与异步：主要看调用结果是如何返回的。如果调用结果是由调用者主动等待得到的，那么就算是&lt;strong&gt;同步&lt;/strong&gt;；如果调用结果最终是由被调用者主动通知调用者的（比如通过回调函数），那就就算&lt;strong&gt;异步&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;阻塞与非阻塞：主要看等待结果过程中，调用者的状态。如果等待过程中，调用者啥事都不做，那就是&lt;strong&gt;阻塞&lt;/strong&gt;；如果等待过程中，调用者做了别的事，那就是&lt;strong&gt;非阻塞&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式 I/O：同步 阻塞&lt;/li&gt;
&lt;li&gt;非阻塞式 I/O：同步 第一阶段非阻塞 第二阶段阻塞&lt;/li&gt;
&lt;li&gt;I/O 复用：同步 阻塞&lt;/li&gt;
&lt;li&gt;信号驱动式 I/O：第一阶段异步非阻塞 第二阶段同步阻塞&lt;/li&gt;
&lt;li&gt;异步 I/O：异步 非阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492928105791_3.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;io-复用&#34;&gt;I/O 复用&lt;/h4&gt;
&lt;p&gt;select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。&lt;/p&gt;
&lt;h5 id=&#34;select-vs-poll&#34;&gt;select vs poll&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;select 和 poll 都可以允许应用程序监听一组文件描述符的状态变化&lt;/li&gt;
&lt;li&gt;select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；&lt;/li&gt;
&lt;li&gt;如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
&lt;ul&gt;
&lt;li&gt;有可能函数调用会立即返回&lt;/li&gt;
&lt;li&gt;也有可能，会持续监听，超时返回&lt;/li&gt;
&lt;li&gt;也有可能，会返回成功，但是读取时报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;select 和 poll 速度都比较慢，每次调用都需要将全部描述符从 应用进程缓冲区 复制到 内核缓冲区（因为 select 和 poll 是系统调用，所以需要将数据拷贝到内核）（&lt;a href=&#34;https://bbs.csdn.net/topics/390696333&#34;&gt;参考资料&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;几乎所有系统都支持 select，部分系统不支持 poll。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;epoll&#34;&gt;epoll&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;epoll_create()&lt;/code&gt; 用于创建 epoll 对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_ctl()&lt;/code&gt; 用于向内核注册新的描述符或者是改变某个文件描述符的监听事件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_wait()&lt;/code&gt; 用于得到事件完成的描述符&lt;/p&gt;
&lt;p&gt;已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数，内核会将 I/O 准备好的描述符加入到一个链表中进行管理，等待 &lt;code&gt;epoll_wait()&lt;/code&gt; 的调用&lt;/p&gt;
&lt;p&gt;从上面的描述可以看出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll 只需要将描述符从 进程缓冲区 向 内核缓冲区 拷贝一次（select 和 poll 需要再拷贝出来，然后通过遍历获取事件完成的描述符，而 epoll 只需要通过 &lt;code&gt;epoll_wait()&lt;/code&gt; 直接获取事件完成的描述符）&lt;/li&gt;
&lt;li&gt;并且进程不需要通过轮询来获得事件完成的描述符（&lt;code&gt;epoll_wait()&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;epoll 仅适用于 Linux OS&lt;/p&gt;
&lt;p&gt;epoll 和 poll 一样，没有描述符数量限制&lt;/p&gt;
&lt;p&gt;epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况（当文件描述符关闭，就会从监听列表中删除）&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_27529917/article/details/82945450&#34;&gt;Select和Epoll底层实现的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xiaowenmu1/article/details/90108663&#34;&gt;epoll在多线程下的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;selectpollepoll-的应用场景&#34;&gt;select/poll/epoll 的应用场景&lt;/h5&gt;
&lt;p&gt;很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select：
&lt;ul&gt;
&lt;li&gt;select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。&lt;/li&gt;
&lt;li&gt;select 可移植性更好，几乎被所有主流平台所支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;poll：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。&lt;/li&gt;
&lt;li&gt;epoll：
&lt;ul&gt;
&lt;li&gt;运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接（因为对于 epoll，描述符是存储在内核中的，所以如果是长连接，就可以一直让内核进行监听）&lt;/li&gt;
&lt;li&gt;需要监听的描述符对应的监听事件变化多，而且都非常短暂，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的监听事件改变都需要通过 &lt;code&gt;epoll_ctl()&lt;/code&gt; 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;
&lt;h3 id=&#34;概述-6&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;4 个基本特征：并发、共享、虚拟、异步&lt;/p&gt;
&lt;p&gt;并发 与 并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。&lt;/li&gt;
&lt;li&gt;并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。&lt;/li&gt;
&lt;li&gt;操作系统通过引入进程和线程，使得程序能够并发运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户态与内核态：如果一个进程在用户态需要使用内核态的功能，就需要进行系统调用从而陷入内核，由操作系统代为完成相应功能。&lt;/p&gt;
&lt;h3 id=&#34;进程管理&#34;&gt;进程管理&lt;/h3&gt;
&lt;h4 id=&#34;进程-vs-线程&#34;&gt;进程 VS 线程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进程：资源分配的基本单位&lt;/li&gt;
&lt;li&gt;线程：独立调度的基本单位&lt;/li&gt;
&lt;li&gt;区别与联系
&lt;ul&gt;
&lt;li&gt;一个 进程 中可以有多个 线程，它们共享 进程 资源&lt;/li&gt;
&lt;li&gt;线程 不拥有资源，但可以访问 隶属进程 的资源&lt;/li&gt;
&lt;li&gt;进程 和 线程 都可被调度，隶属不同进程的线程的切换会引起进程切换&lt;/li&gt;
&lt;li&gt;开销不同：
&lt;ul&gt;
&lt;li&gt;进程：
&lt;ul&gt;
&lt;li&gt;创建或撤销：分配或回收资源，如内存空间、I/O 设备等&lt;/li&gt;
&lt;li&gt;切换：当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程：
&lt;ul&gt;
&lt;li&gt;切换：只需保存和设置少量寄存器内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助特定的方法（进程间通信，IPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程状态&#34;&gt;进程状态&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态（ready）：等待被调度&lt;/li&gt;
&lt;li&gt;运行状态（running）&lt;/li&gt;
&lt;li&gt;阻塞状态（waiting）：等待除 CPU 时间以外的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程调度算法&#34;&gt;进程调度算法&lt;/h4&gt;
&lt;p&gt;不同系统的调度算法目标不同，因此需要针对不同系统来讨论调度算法&lt;/p&gt;
&lt;h5 id=&#34;批处理系统&#34;&gt;批处理系统&lt;/h5&gt;
&lt;p&gt;批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 先来先服务 first-come first-serverd（FCFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非抢占式的调度算法，按照请求的顺序进行调度。&lt;/p&gt;
&lt;p&gt;有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 最短作业优先 shortest job first（SJF）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非抢占式的调度算法，按估计运行时间最短的顺序进行调度。&lt;/p&gt;
&lt;p&gt;长作业有可能会饿死（处于一直等待短作业执行完毕的状态）：因为如果一直有短作业到来，那么长作业永远得不到调度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 最短剩余时间优先 shortest remaining time next（SRTN）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最短作业优先的&lt;strong&gt;抢占式&lt;/strong&gt;版本，按剩余运行时间的顺序进行调度。&lt;/p&gt;
&lt;p&gt;当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。&lt;/p&gt;
&lt;h5 id=&#34;交互式系统&#34;&gt;交互式系统&lt;/h5&gt;
&lt;p&gt;交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 时间片轮转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。&lt;/p&gt;
&lt;p&gt;时间片轮转算法的效率和时间片的大小有很大关系。&lt;/p&gt;
&lt;p&gt;因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 优先级调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个进程分配一个优先级，按优先级进行调度。&lt;/p&gt;
&lt;p&gt;为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 多级反馈队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。&lt;/p&gt;
&lt;p&gt;多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。&lt;/p&gt;
&lt;p&gt;每个队列优先权也不同，最上面的优先权最高。因此只有上层队列没有进程在排队，才能调度下层队列上的进程。&lt;/p&gt;
&lt;p&gt;可以将这种调度算法看成是 时间片轮转调度算法和优先级调度算法的结合。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/042cf928-3c8e-4815-ae9c-f2780202c68f.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;实时系统&#34;&gt;实时系统&lt;/h5&gt;
&lt;p&gt;实时系统要求一个请求在一个确定时间内得到响应。&lt;/p&gt;
&lt;p&gt;分为硬实时和软实时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬实时：必须满足绝对的截止时间&lt;/li&gt;
&lt;li&gt;软实时：可以容忍一定的超时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程同步&#34;&gt;进程同步&lt;/h4&gt;
&lt;h5 id=&#34;临界资源与临界区&#34;&gt;临界资源与临界区&lt;/h5&gt;
&lt;p&gt;临界资源：一次只能供一个进程使用的资源&lt;/p&gt;
&lt;p&gt;对临界资源进行访问的那段代码称为临界区&lt;/p&gt;
&lt;h5 id=&#34;互斥-同步与通信&#34;&gt;互斥、同步与通信&lt;/h5&gt;
&lt;p&gt;进程通信的详细内容看后续章节，这里只是先简单描述一下它们之间在概念上的异同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥：解决进程间竞争关系（间接制约关系）的手段
&lt;ul&gt;
&lt;li&gt;互斥比较好理解，就是解决进程间的竞争，最典型的例子就是对资源的进程，如临界资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步：解决进程间协作关系（直接制约关系）的手段
&lt;ul&gt;
&lt;li&gt;进程间有时需要合作完成某项任务，当某个进程提前完成后，需要等待其他进程完成才能继续，此时就需要进程同步来解决这个问题。也就是说，进程同步解决的是，进程间执行顺序的问题。&lt;/li&gt;
&lt;li&gt;互斥也可以看做是一种进程同步，通过资源的竞争，使得两个进程间产生了先后关系，即进程 A 必须等待进程 B 执行完才能继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信：进程间互相发送数据
&lt;ul&gt;
&lt;li&gt;进程同步也可以看做是一种进程通信，但是进程同步往往是在进程间发送信号，而不是实际的数据&lt;/li&gt;
&lt;li&gt;进程通信是一种手段，而进程同步是一种目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：https://blog.csdn.net/weixin_41413441/article/details/80548683&lt;/p&gt;
&lt;h5 id=&#34;信号量&#34;&gt;信号量&lt;/h5&gt;
&lt;p&gt;信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;down&lt;/strong&gt; : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;up&lt;/strong&gt; ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。&lt;/p&gt;
&lt;p&gt;如果信号量的取值只能为 0 或者 1，那么就成为了 &lt;strong&gt;互斥量（Mutex）&lt;/strong&gt; ，0 表示临界区已经加锁，1 表示临界区解锁。&lt;/p&gt;
&lt;h5 id=&#34;管程&#34;&gt;管程&lt;/h5&gt;
&lt;p&gt;也是一种解决进程同步的技术&lt;/p&gt;
&lt;p&gt;使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。&lt;/p&gt;
&lt;p&gt;它的思想是，将共享变量以及对其的操作封装起来，并且保证同一时刻只有一个进程可以进入管程&lt;/p&gt;
&lt;p&gt;进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。&lt;/p&gt;
&lt;p&gt;管程引入了 &lt;strong&gt;条件变量&lt;/strong&gt; 以及相关的操作：&lt;strong&gt;wait()&lt;/strong&gt; 和 &lt;strong&gt;signal()&lt;/strong&gt; 来实现同步操作。对&lt;strong&gt;条件变量&lt;/strong&gt;执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。对&lt;strong&gt;条件变量&lt;/strong&gt;执行 signal() 操作会唤醒被阻塞的进程。&lt;/p&gt;
&lt;p&gt;参考：https://www.cnblogs.com/xidongyu/p/10891303.html&lt;/p&gt;
&lt;p&gt;可以看“生产者-消费者问题”中管程的实现加深对管程的理解&lt;/p&gt;
&lt;h5 id=&#34;经典进程同步问题&#34;&gt;经典进程同步问题&lt;/h5&gt;
&lt;h6 id=&#34;生产者-消费者问题&#34;&gt;生产者-消费者问题&lt;/h6&gt;
&lt;p&gt;问题描述：使用一个缓冲区来保存物品，缓冲区容量为 N，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 信号量 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下 3 段话用于帮助理解代码，基础好的同学也可直接看代码进行理解。&lt;/p&gt;
&lt;p&gt;因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。&lt;/p&gt;
&lt;p&gt;为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。&lt;/p&gt;
&lt;p&gt;注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 &lt;code&gt;down(mutex)&lt;/code&gt; 再执行 &lt;code&gt;down(empty)&lt;/code&gt;。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 &lt;code&gt;down(empty)&lt;/code&gt; 操作，发现 &lt;code&gt;empty = 0&lt;/code&gt;，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 &lt;code&gt;up(empty)&lt;/code&gt; 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        // produce_item
        down(empty);
        // 临界区开始
        down(mutex);
        // insert item to 缓冲区（临界资源）
        up(mutex);
        // 临界区结束
        up(full);
    }
}

void consumer() {
    while(TRUE) {
        down(full);
        // 临界区开始
        down(mutex);
        // get item from 缓冲区（临界资源）
        // consume_item
        up(mutex);
        // 临界区结束
        up(empty);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用 管程 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-pascal&#34;&gt;// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        // produce_item
        ProducerConsumer.insert();
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        ProducerConsumer.remove();
        // consume_item
    end
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;哲学家进餐问题&#34;&gt;哲学家进餐问题&lt;/h6&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误解法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;信号量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了防止死锁的发生，可以设置两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须同时拿起左右两根筷子；&lt;/li&gt;
&lt;li&gt;只有在两个邻居都没有进餐的情况下才允许进餐。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码的讲解，建议搭配代码一起看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过 mutex 保证临界资源 state 数组同一时刻只有一个进程可以访问&lt;/li&gt;
&lt;li&gt;在这个前提下，就可以根据 state 数组的状态来进行后续的操作&lt;/li&gt;
&lt;li&gt;对于每个哲学家，在 eat() 之前都需要 down()，而在 down() 之前会判断左右两边的 state 数组
&lt;ul&gt;
&lt;li&gt;如果左右两边的哲学家都不是 EATING 的状态，则会 up() 并将自身状态设置成 EATING&lt;/li&gt;
&lt;li&gt;如果左右两边的哲学家存在 EATING 的状态，则不会进行任何操作，在 down() 时等待身边的哲学家吃完&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 5
typedef int semaphore;

int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界资源是 state 数组，对其修改需要互斥

semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        // think
        take_two(i);
        // eat
        put_two(i);
    }
}

void take_two(int i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = HUNGRY;
    check(i);
    up(mutex);
    // state 的临界区 结束
    down(s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = THINKING;
    // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(LEFT);
    check(RIGHT);
    up(mutex);
    // state 的临界区 结束
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(s[i])，使得 down(s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;amp;&amp;amp; state[LEFT] != EATING &amp;amp;&amp;amp; state[RIGHT] != EATING) {
        state[i] = EATING;
        up(s[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;读者-写者问题&#34;&gt;读者-写者问题&lt;/h6&gt;
&lt;p&gt;问题描述：允许多个进程同时对数据进行读操作，但是不允许 读和写 以及 写和写 操作同时发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用信号量实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef int semaphore;
semaphore count_mutex = 1;
int count = 0;

semaphore data_mutex = 1;

void reader() {
    while(TRUE) {
        down(count_mutex);
        count++;
        if(count == 1) down(data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(count_mutex);
        // read
        down(count_mutex);
        count--;
        if(count == 0) up(data_mutex);
        up(count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(data_mutex);
        // write
        up(data_mutex);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;进程通信-ipc&#34;&gt;进程通信 IPC&lt;/h4&gt;
&lt;p&gt;进程通信 与 进程同步 之间的关系，可以见上文“互斥、同步与通信”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管道是通过调用 pipe 函数创建的，filedes[0] 用于读，filedes[1] 用于写。&lt;/p&gt;
&lt;p&gt;由 pipe 函数为 filedes 数组进行赋值，之后，可以通过 read write 函数进行读写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;unistd.h&amp;gt;

int filedes[2];
pipe( filedes );

read( filedes[0], buf, sizeof(buf) );
write( filedes[1], s, sizeof(s) );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只支持半双工通信（单向交替传输）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只能在父子进程或者兄弟进程中使用&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;FIFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也称为命名管道，去除了管道只能在父子进程中使用的限制。&lt;/p&gt;
&lt;p&gt;之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。&lt;/p&gt;
&lt;p&gt;FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png&#34; alt=&#34;img&#34; style=&#34;zoom:65%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比于 FIFO，消息队列具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；&lt;/li&gt;
&lt;li&gt;避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；&lt;/li&gt;
&lt;li&gt;读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是一个计数器，用于为多个进程提供对共享数据对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。&lt;/p&gt;
&lt;p&gt;需要使用信号量用来同步对共享存储的访问。&lt;/p&gt;
&lt;p&gt;多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。&lt;/p&gt;
&lt;p&gt;共享内存使用的不是文件，而是内存的匿名段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;套接字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其它通信机制不同的是，它可用于不同机器间的进程通信&lt;/p&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;h4 id=&#34;必要条件&#34;&gt;必要条件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;互斥：每个资源要么已经分配给了一个进程，要么就是可用的。&lt;/li&gt;
&lt;li&gt;占有和等待：已经得到了某个资源的进程可以再请求新的资源。&lt;/li&gt;
&lt;li&gt;不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。&lt;/li&gt;
&lt;li&gt;环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;处理方法&#34;&gt;处理方法&lt;/h4&gt;
&lt;h5 id=&#34;鸵鸟策略&#34;&gt;鸵鸟策略&lt;/h5&gt;
&lt;p&gt;方法：把头埋在沙子里，假装根本没发生问题。&lt;/p&gt;
&lt;p&gt;原理：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。&lt;/p&gt;
&lt;p&gt;适用场景：当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。&lt;/p&gt;
&lt;p&gt;大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。&lt;/p&gt;
&lt;h5 id=&#34;死锁检测与死锁恢复&#34;&gt;死锁检测与死锁恢复&lt;/h5&gt;
&lt;p&gt;不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每种类型的资源只有一个的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即，对于每种类型的资源，被使用了，别的进程就不能再使用了&lt;/p&gt;
&lt;p&gt;有向图判环：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b1fa0453-a4b0-4eae-a352-48acca8fff74.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。&lt;/p&gt;
&lt;p&gt;图 a 可以抽取出环，如图 b 所示，它满足了环路等待条件，因此会发生死锁。&lt;/p&gt;
&lt;p&gt;该死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每种类型的资源有多个的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即，对于每种类型的资源，存在多个，被进程 A 使用了 1 个后，还有其他实例可以供其他进程使用&lt;/p&gt;
&lt;p&gt;银行家算法：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;上图中，有 3 个进程 4 个资源，每个数据代表的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E 向量：资源总量&lt;/li&gt;
&lt;li&gt;A 向量：资源剩余量&lt;/li&gt;
&lt;li&gt;C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量&lt;/li&gt;
&lt;li&gt;R 矩阵：每个进程请求的资源数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。&lt;/p&gt;
&lt;p&gt;算法总结如下：&lt;/p&gt;
&lt;p&gt;每个进程最开始时都不被标记，算法执行过程对进程进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。&lt;/li&gt;
&lt;li&gt;如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。&lt;/li&gt;
&lt;li&gt;如果没有这样一个进程，算法终止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;死锁恢复&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用抢占恢复&lt;/li&gt;
&lt;li&gt;利用回滚恢复
&lt;ul&gt;
&lt;li&gt;假设进程 A 等待资源，进程 B 占用该资源，则对进程 B 进行回滚并将资源分配给进程 A，从而实现死锁恢复。参考：https://blog.csdn.net/zhangxiaojiakele/article/details/106034016&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过杀死进程恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;死锁预防&#34;&gt;死锁预防&lt;/h5&gt;
&lt;p&gt;在程序运行之前预防发生死锁&lt;/p&gt;
&lt;p&gt;破坏 死锁 发生的必要条件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏互斥条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，“假脱机打印机技术”允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏占有和等待条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种实现方式是，规定所有进程在开始执行前请求所需要的全部资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏不可抢占条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏环路等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给资源统一编号，进程只能按编号顺序来请求资源&lt;/p&gt;
&lt;h5 id=&#34;死锁避免&#34;&gt;死锁避免&lt;/h5&gt;
&lt;p&gt;在程序运行时避免发生死锁&lt;/p&gt;
&lt;p&gt;在为进程分配资源前进行检查，如果发现此次资源分配将导致死锁，则拒绝给该进程分配资源&lt;/p&gt;
&lt;p&gt;安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ed523051-608f-4c3f-b343-383e2d194470.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。&lt;/p&gt;
&lt;p&gt;死锁避免，就是避免进入不安全状态。&lt;/p&gt;
&lt;p&gt;使用 银行家算法 判断某状态是否为 安全状态&lt;/p&gt;
&lt;h5 id=&#34;检测-vs-预防-vs-避免&#34;&gt;检测 VS 预防 VS 避免&lt;/h5&gt;
&lt;p&gt;检测，是判断当前状态是否发生了死锁&lt;/p&gt;
&lt;p&gt;预防，是不给死锁发生的机会&lt;/p&gt;
&lt;p&gt;避免，是死锁可能发生，但是避免其发生，例如，避免进入不安全状态。&lt;/p&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理&lt;/h3&gt;
&lt;h4 id=&#34;分页机制&#34;&gt;分页机制&lt;/h4&gt;
&lt;p&gt;通过 分页机制 可以实现 虚拟内存&lt;/p&gt;
&lt;p&gt;虚拟内存的目的是为了将物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存&lt;/p&gt;
&lt;p&gt;为了更好的管理内存，操作系统将内存抽象成若干地址空间。同时，地址空间又被分割成多个块，每一块称为一页，因此每页中都包含若干地址空间。&lt;/p&gt;
&lt;p&gt;这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的操作，将缺失的部分装入物理内存并重新执行失败的指令。&lt;/p&gt;
&lt;p&gt;从上面的描述中可以看出，虚拟内存允许操作系统不用将地址空间中的每一页都映射到物理内存，也就是说一个程序所使用的所有页不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7b281b1e-0595-402b-ae35-8c91084c33c1.png&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;例如，有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，因此，通过 虚拟内存技术 便可以在该计算机运行一个 64K 大小的程序。&lt;/p&gt;
&lt;p&gt;分页内存管理机制，对于程序来说是透明的，对于程序来说，它只知道地址空间是 0~64K，但其实物理内存空间只有 32KB，在运行过程中，是通过操作系统进行控制的，使得程序感觉上就像在 64KB 的物理内存上运行。&lt;/p&gt;
&lt;h5 id=&#34;分页系统的地址映射&#34;&gt;分页系统的地址映射&lt;/h5&gt;
&lt;p&gt;内存管理单元（MMU）管理着地址空间和物理内存的转换，其中，页表存储着页（地址空间）和页框（物理内存）的映射表。&lt;/p&gt;
&lt;p&gt;一个虚拟地址空间分成两个部分，一部分存储页面号，一部分存储偏移量。&lt;/p&gt;
&lt;p&gt;根据页面号，可以定位到页表中的特定行，然后从该行中获取物理内存地址前缀，与偏移量合并，得到物理内存地址。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;上图的页表存放着 16 个页（16行），这 16 个页需要用 4 个比特位来进行索引定位（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^4=16&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;例如，对于虚拟地址（0010 000000000100）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据前 4 位（0010）得知页面号为2，从页表第 2 行读取内容：110 1，其中，前 3 位为物理内存地址前缀，第 4 位表示是否存在于内存中，1 表示存在。&lt;/li&gt;
&lt;li&gt;后 12 位存储偏移量，结合刚才的物理内存地址前缀（110），这个页对应的页框的地址为 （110 000000000100）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h5&gt;
&lt;p&gt;在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。&lt;/p&gt;
&lt;p&gt;页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。&lt;/p&gt;
&lt;p&gt;页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳 OPT Optimal replacement algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择最长时间不再被访问的页面，将其置换。因为是最长时间不被访问的页面，所以可以保证获得最低的缺页率&lt;/p&gt;
&lt;p&gt;这是一种理论算法，无法实现，因为无法获知哪个页面在未来最长时间不被访问&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;系统为某进程分配了三个物理块，并有如下页面引用序列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为站在上帝视角，我们知道页面 7 再次被访问的时间最长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近最久未使用 LRU Least Recently Used&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然无法知道未来页面的使用情况，但是可以知道过去页面的使用情况。&lt;/p&gt;
&lt;p&gt;LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的。&lt;/p&gt;
&lt;p&gt;因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近未使用 NRU Not Recently Used&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。&lt;/p&gt;
&lt;p&gt;其中 R 位会定时被清零。&lt;/p&gt;
&lt;p&gt;将页面分成以下四&lt;strong&gt;类&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：R=0，M=0&lt;/li&gt;
&lt;li&gt;1：R=0，M=1&lt;/li&gt;
&lt;li&gt;2：R=1，M=0&lt;/li&gt;
&lt;li&gt;3：R=1，M=1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发生缺页中断时，NRU 算法随机地从&lt;strong&gt;类&lt;/strong&gt;编号最小的非空类中挑选一个页面将它换出。&lt;/p&gt;
&lt;p&gt;NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先进先出 FIFO First In First Out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择换出的页面是最先进入的页面。&lt;/p&gt;
&lt;p&gt;该算法会将那些经常被访问的页面换出，导致缺页率升高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次机会算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改。&lt;/p&gt;
&lt;p&gt;当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时钟 Clock&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;分段机制&#34;&gt;分段机制&lt;/h4&gt;
&lt;p&gt;现在，请先忘掉分页机制，分段机制是一种独立的机制，和分页机制无关。&lt;/p&gt;
&lt;p&gt;分段机制的设计思想是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护&lt;/p&gt;
&lt;p&gt;一般情况下，程序在运行时都会在内存中存储程序代码和数据，存储程序代码是为了能让程序执行下去（总要把下一行要执行的代码放到内存中吧，不然系统哪知道应该做什么）&lt;/p&gt;
&lt;p&gt;基于这个现象，操作系统内存管理分段机制允许程序拥有多个段，在不同段中存储不同类型的数据，且段的大小是可变的。程序无需知道段在物理内存中的位置，只需要使用段偏移量进行访问即可，在程序运行时，操作系统会把段映射到实际的内存空间中。例如，段偏移量是 0000~0100，那么程序实际运行时，会把段映射到 xxxx0000~xxxx0100&lt;/p&gt;
&lt;p&gt;因此，分段机制中是不涉及虚拟内存的&lt;/p&gt;
&lt;h4 id=&#34;分页-vs-分段&#34;&gt;分页 VS 分段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;空间大小是否可变：分页机制不可变；分段机制可变
&lt;ul&gt;
&lt;li&gt;分页存在覆盖问题：假设页的长度是100，那么程序在访问到 xxx101 时就会出错（xxx为页面号；为了方便，用的是十进制），因为根据地址映射，会把页面号进行替换，得到物理内存地址，但是因为页的长度是 100，所以其实本质上已经访问到下一页了，就会出现覆盖问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透明性：分页对程序是透明的，分段是不透明的&lt;/li&gt;
&lt;li&gt;目的：
&lt;ul&gt;
&lt;li&gt;分页主要用于实现虚拟内存，从而获得更大的地址空间&lt;/li&gt;
&lt;li&gt;分段主要为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;段页式&#34;&gt;段页式&lt;/h4&gt;
&lt;p&gt;程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2019040522291138.png&#34; alt=&#34;img&#34; style=&#34;zoom:100%;&#34; /&gt;
&lt;p&gt;根据段号和段表，获取页表，根据页号和页表，获取物理内存空间前缀，最后根据页内偏移计算出物理地址。&lt;/p&gt;
&lt;p&gt;一个程序拥有多个段，每个段包含多个页，每个页会被映射到物理内存&lt;/p&gt;
&lt;h3 id=&#34;用户态与内核态&#34;&gt;用户态与内核态&lt;/h3&gt;
&lt;p&gt;首先明确概念，用户态和内核态指的是什么？指的是，cpu 所处的状态。若 cpu 处于用户态，那么程序只能访问其自身所拥有的内存空间，不允许访问外围设备，不能强占 cpu 资源，而如果 cpu 处于内核态，则程序可以访问内存的所有数据，可以访问外围设备，可以控制 cpu 切换进程。&lt;/p&gt;
&lt;p&gt;可以发现，若 cpu 处于内核态，程序的权限将变得无限高，因此，只有在发生 系统调用 时，cpu 才会从用户态切换到内核态，并且切换到内核态后，cpu 只会执行系统函数，并在执行结束后把结果返回给程序。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/maxigang/p/9041080.html&lt;/p&gt;
&lt;h3 id=&#34;磁盘&#34;&gt;磁盘&lt;/h3&gt;
&lt;h4 id=&#34;磁盘结构&#34;&gt;磁盘结构&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/014fbc4d-d873-4a12-b160-867ddaed9807.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;盘面（Platter）：一个磁盘有多个盘面；&lt;/li&gt;
&lt;li&gt;磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；&lt;/li&gt;
&lt;li&gt;扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；&lt;/li&gt;
&lt;li&gt;磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；&lt;/li&gt;
&lt;li&gt;制动手臂（Actuator arm）：用于在磁道之间移动磁头；&lt;/li&gt;
&lt;li&gt;主轴（Spindle）：使整个盘面转动。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;磁盘调度算法&#34;&gt;磁盘调度算法&lt;/h4&gt;
&lt;p&gt;读写一个磁盘块的时间的影响因素有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旋转时间：主轴转动盘面，使得磁头移动到适当的扇区上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寻道时间&lt;/strong&gt;：制动手臂移动，使得磁头移动到适当的磁道上&lt;/li&gt;
&lt;li&gt;实际的数据传输时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，&lt;strong&gt;寻道时间&lt;/strong&gt;最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先来先服务 FCFS First Come First Served&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照磁盘请求的顺序进行调度。&lt;/p&gt;
&lt;p&gt;优点是公平和简单。&lt;/p&gt;
&lt;p&gt;缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短寻道时间优先 SSTF Shortest Seek Time First&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优先调度与当前磁头所在磁道距离最近的磁道。&lt;/p&gt;
&lt;p&gt;虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/4e2485e4-34bd-4967-9f02-0c093b797aaa.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;电梯算法 SCAN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。&lt;/p&gt;
&lt;p&gt;电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。&lt;/p&gt;
&lt;p&gt;因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/271ce08f-c124-475f-b490-be44fedc6d2e.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;
&lt;h4 id=&#34;链接系统&#34;&gt;链接系统&lt;/h4&gt;
&lt;p&gt;以下是一个 hello.c 程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    printf(&amp;quot;hello, world\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Unix 系统上，由编译器把源文件转换为目标文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -o hello hello.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个过程大致如下：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：处理以 # 开头的预处理命令；&lt;/li&gt;
&lt;li&gt;编译阶段：翻译成汇编文件；&lt;/li&gt;
&lt;li&gt;汇编阶段：将汇编文件翻译成可重定位目标文件；&lt;/li&gt;
&lt;li&gt;链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行目标文件：可以直接在内存中执行；&lt;/li&gt;
&lt;li&gt;可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；&lt;/li&gt;
&lt;li&gt;共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态链接&#34;&gt;静态链接&lt;/h4&gt;
&lt;p&gt;静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。&lt;/li&gt;
&lt;li&gt;重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;动态链接&#34;&gt;动态链接&lt;/h4&gt;
&lt;p&gt;静态库有以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当静态库更新时那么整个程序都要重新进行链接；&lt;/li&gt;
&lt;li&gt;对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；&lt;/li&gt;
&lt;li&gt;在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;面试重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令：cat（文件）、grep（查找指令）、cut（管道指令）
&lt;ul&gt;
&lt;li&gt;括号中标出来这些指令所在的章节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件：实体链接与符号链接&lt;/li&gt;
&lt;li&gt;进程管理：SIGCHLD、僵尸进程与孤儿进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用指令&#34;&gt;常用指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;快捷键&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tab：命令和文件名补全；&lt;/li&gt;
&lt;li&gt;Ctrl+C：中断正在运行的程序；&lt;/li&gt;
&lt;li&gt;Ctrl+D：结束键盘输入（End Of File，EOF）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询指令用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/usr/share/doc 目录中存放着大部分软件的一整套说明文件&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145459251.png&#34; alt=&#34;image-20220104145459251&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;code&gt;--help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指令的基本用法与选项介绍&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;man 是 manual 的缩写，将指令的具体信息显示出来&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145001620.png&#34; alt=&#34;image-20220104145001620&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型&lt;/p&gt;
&lt;p&gt;常用的数字及其类型如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代号&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;用户在 shell 环境中可以操作的指令或者可执行文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td&gt;配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td&gt;系统管理员可以使用的管理指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;info&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;who&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在关机前需要先使用 who 命令查看有没有其它用户在线&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;环境变量 PATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在环境变量 PATH 中声明可执行文件的路径&lt;/p&gt;
&lt;p&gt;路径之间用 &lt;code&gt;:&lt;/code&gt; 分隔&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sudo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo 允许一般用户使用 root 可执行的命令&lt;/p&gt;
&lt;p&gt;不过只有在 &lt;code&gt;/etc/sudoers&lt;/code&gt; 配置文件中添加的用户才能使用该指令&lt;/p&gt;
&lt;h3 id=&#34;vim-的三个模式&#34;&gt;Vim 的三个模式&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191209002818626.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;一般指令模式：VIM 的默认模式，可以用于移动游标查看内容；&lt;/li&gt;
&lt;li&gt;编辑模式：按下 &amp;quot;i&amp;quot; 等按键之后进入，可以对文本进行编辑；&lt;/li&gt;
&lt;li&gt;指令列模式：按下 &amp;quot;:&amp;quot; 按键之后进入，用于保存退出等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 指令列模式 下，有以下命令用于离开或者保存文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写入磁盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:w!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:q&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;离开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:q!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;强制离开不保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:wq&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写入磁盘后离开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:wq!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;强制写入磁盘后离开&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;文件系统理论部分&#34;&gt;文件系统（理论部分）&lt;/h3&gt;
&lt;h4 id=&#34;组成&#34;&gt;组成&lt;/h4&gt;
&lt;p&gt;最主要的几个组成部分如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；&lt;/li&gt;
&lt;li&gt;block：记录文件的内容，文件太大时，会占用多个 block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外还包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;block bitmap：记录 block 是否被使用的位图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件读取&#34;&gt;文件读取&lt;/h4&gt;
&lt;p&gt;对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h4 id=&#34;磁盘碎片&#34;&gt;磁盘碎片&lt;/h4&gt;
&lt;p&gt;指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。&lt;/p&gt;
&lt;h4 id=&#34;block&#34;&gt;block&lt;/h4&gt;
&lt;p&gt;在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1KB&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2KB&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4KB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最大单一文件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16GB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;256GB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2TB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最大文件系统&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16TB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。&lt;/p&gt;
&lt;h4 id=&#34;inode&#34;&gt;inode&lt;/h4&gt;
&lt;p&gt;inode 具体包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权限 (read/write/excute)；&lt;/li&gt;
&lt;li&gt;拥有者与群组 (owner/group)；&lt;/li&gt;
&lt;li&gt;容量；&lt;/li&gt;
&lt;li&gt;建立或状态改变的时间 (ctime)；&lt;/li&gt;
&lt;li&gt;最近读取时间 (atime)；&lt;/li&gt;
&lt;li&gt;最近修改时间 (mtime)；&lt;/li&gt;
&lt;li&gt;定义文件特性的旗标 (flag)，如 SetUID...；&lt;/li&gt;
&lt;li&gt;该文件真正内容的指向 (pointer)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inode 具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 inode 大小均固定为 128 bytes&lt;/li&gt;
&lt;li&gt;每个文件都仅会占用一个 inode。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。&lt;/p&gt;
&lt;h4 id=&#34;目录&#34;&gt;目录&lt;/h4&gt;
&lt;p&gt;目录，也可以理解成文件夹&lt;/p&gt;
&lt;p&gt;建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。&lt;/p&gt;
&lt;p&gt;可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。&lt;/p&gt;
&lt;p&gt;为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/ (root)：根目录&lt;/li&gt;
&lt;li&gt;/usr (unix software resource)：所有系统默认软件都会安装到这个目录&lt;/li&gt;
&lt;li&gt;/var (variable)：存放系统或程序运行过程中的数据文件&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/linux-filesystem.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h3 id=&#34;文件实践部分&#34;&gt;文件（实践部分）&lt;/h3&gt;
&lt;h4 id=&#34;文件属性&#34;&gt;文件属性&lt;/h4&gt;
&lt;p&gt;用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。&lt;/p&gt;
&lt;p&gt;使用 ls 查看一个文件时，会显示一个文件的信息，例如 &lt;code&gt;drwxr-xr-x 3 root root 17 May 6 00:14 .config&lt;/code&gt;，对这个信息的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段&lt;/li&gt;
&lt;li&gt;3：链接数&lt;/li&gt;
&lt;li&gt;root：文件拥有者&lt;/li&gt;
&lt;li&gt;root：所属群组&lt;/li&gt;
&lt;li&gt;17：文件大小&lt;/li&gt;
&lt;li&gt;May 6 00:14：文件最后被修改的时间&lt;/li&gt;
&lt;li&gt;.config：文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的文件类型及其含义有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d：目录&lt;/li&gt;
&lt;li&gt;-：文件&lt;/li&gt;
&lt;li&gt;l：链接文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。&lt;/p&gt;
&lt;p&gt;文件时间可使用 stat 指令查看&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104155901036.png&#34; alt=&#34;image-20220104155901036&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;三种文件时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modification time (mtime)：文件的内容更新就会更新；&lt;/li&gt;
&lt;li&gt;status time (ctime)：文件的状态（权限、属性）更新就会更新；&lt;/li&gt;
&lt;li&gt;access time (atime)：读取文件时就会更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件与目录的基本操作指令&#34;&gt;文件与目录的基本操作指令&lt;/h4&gt;
&lt;p&gt;本节主要列出了 8 个基本操作指令，已经掌握的同学可直接跳过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. ls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出文件或者目录的信息，目录的信息就是其中包含的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. cd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更换当前目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;cd [相对路径或绝对路径]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. mkdir&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. rmdir&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除目录，目录必须为空。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;rmdir [-p] 目录名称
-p ：递归删除目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. touch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新文件时间或者建立新文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&amp;quot;日期或时间&amp;quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6. cp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7. rm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## rm [-fir] 文件或目录
-r ：递归删除
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8. mv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;移动文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;权限&#34;&gt;权限&lt;/h4&gt;
&lt;h5 id=&#34;修改权限&#34;&gt;修改权限&lt;/h5&gt;
&lt;p&gt;可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod [-R] xyz dirname/filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod 754 .bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用符号来设定权限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：为 .bashrc 文件的所有用户添加写权限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod a+w .bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;默认权限&#34;&gt;默认权限&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。&lt;/li&gt;
&lt;li&gt;目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。&lt;/p&gt;
&lt;h5 id=&#34;目录的权限&#34;&gt;目录的权限&lt;/h5&gt;
&lt;p&gt;文件名不是存储在一个文件的内容中，而是存储在该文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。&lt;/p&gt;
&lt;p&gt;目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。&lt;/p&gt;
&lt;h4 id=&#34;实体链接-vs-符号链接&#34;&gt;实体链接 VS 符号链接&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实体链接，也叫，硬链接&lt;/p&gt;
&lt;p&gt;符号链接，也叫，软连接&lt;/p&gt;
&lt;p&gt;两者关系如图：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;如果不理解，可继续看下面的解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。&lt;/p&gt;
&lt;p&gt;删除任意一个条目，文件还是存在，只要引用数量不为 0。&lt;/p&gt;
&lt;p&gt;有以下限制：不能跨越文件系统、不能对目录进行链接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为什么不能对目录创建实体链接&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;因为，目录是支持 &lt;code&gt;cd ../&lt;/code&gt; 操作的，因此，如果像文件那样，只是在目录中添加 inode 编号，那么带来的问题就是，在实体链接目录 /d1/d2 中执行 &lt;code&gt;cd ../&lt;/code&gt; 可能会跳转到 /d3 中，也就是说，会发现目录错位的现象。为了解决这个问题，那就需要真正创建一个目录，并在目录中为每个文件创建实体链接，但是这样的成本太高了，因此 操作系统禁止用户这么做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例来说，如果你要将 /etc 使用硬链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下的所有文件名同时都与 /etc 下面的文件名要创建硬链接的，而不是仅仅连接到 /etc 和 /etc_hd 而已。并且，将来如果需要在 /etc_hd 目录下创建新文件时，连带的，/etc 下面的数据又得要创建一次硬链接。因此造成环境相当大的复杂度，所以是不支持链接目录的。&lt;/p&gt;
&lt;p&gt;by 鸟哥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实，Linux 中是存在目录的实体链接的，比如，&lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt;，但是 Linux 不允许用户创建实体链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;符号链接保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。&lt;/p&gt;
&lt;p&gt;当源文件被删除了，链接文件就打不开了。&lt;/p&gt;
&lt;p&gt;因为记录的是路径，所以可以为目录建立符号链接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&amp;gt; /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-个获取文件内容指令&#34;&gt;7 个获取文件内容指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. cat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取得文件内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. tac&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 cat 的反向操作，从最后一行开始打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. more&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. less&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和 more 类似，但是多了一个向前翻页的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. head&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取得文件前几行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## head [-n number] filename
-n ：后面接数字，代表显示几行的意思
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6. tail&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 head 的反向操作，只是取得是后几行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. od&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以字符或者十六进制的形式显示二进制文件。&lt;/p&gt;
&lt;h4 id=&#34;4-个搜索指令&#34;&gt;4 个搜索指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. which&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指令搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## which [-a] command
-a ：将所有指令列出，而不是只列第一个
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. whereis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。速度比较快，因为它只搜索几个特定的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## whereis [-bmsu] dirname/filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. locate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。可以用关键字或者正则表达式进行搜索。&lt;/p&gt;
&lt;p&gt;locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## locate [-ir] keyword
-r：正则表达式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. find&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。可以使用文件的属性和权限进行搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## find [basedir] [option]
example: find . -name &amp;quot;shadow*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;① 与时间有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;+4、4 和 -4 的指示的时间范围如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/658fc5e7-79c0-4247-9445-d69bf194c539.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;② 与文件拥有者和所属群组有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;③ 与文件权限和名称有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;压缩与打包&#34;&gt;压缩与打包&lt;/h3&gt;
&lt;h4 id=&#34;压缩文件名&#34;&gt;压缩文件名&lt;/h4&gt;
&lt;p&gt;Linux 底下有很多压缩文件名，常见的如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;扩展名&lt;/th&gt;
&lt;th&gt;压缩程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*.Z&lt;/td&gt;
&lt;td&gt;compress&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.zip&lt;/td&gt;
&lt;td&gt;zip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.gz&lt;/td&gt;
&lt;td&gt;gzip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.bz2&lt;/td&gt;
&lt;td&gt;bzip2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.xz&lt;/td&gt;
&lt;td&gt;xz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar&lt;/td&gt;
&lt;td&gt;tar 程序打包的数据，没有经过压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.gz&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 gzip 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.bz2&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 bzip2 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.xz&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 xz 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;3-个压缩指令&#34;&gt;3 个压缩指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. gzip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。&lt;/p&gt;
&lt;p&gt;经过 gzip 压缩过，源文件就不存在了。&lt;/p&gt;
&lt;p&gt;有 9 个不同的压缩等级可以使用。&lt;/p&gt;
&lt;p&gt;可以使用 zcat、zmore、zless 来读取压缩文件的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. bzip2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供比 gzip 更高的压缩比。&lt;/p&gt;
&lt;p&gt;查看命令：bzcat、bzmore、bzless、bzgrep。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ bzip2 [-cdkzv#] filename
-k ：保留源文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. xz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供比 bzip2 更佳的压缩比。&lt;/p&gt;
&lt;p&gt;可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。&lt;/p&gt;
&lt;p&gt;查看命令：xzcat、xzmore、xzless、xzgrep。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ xz [-dtlkc#] filename
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;打包指令&#34;&gt;打包指令&lt;/h4&gt;
&lt;p&gt;压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;使用方式&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打包压缩&lt;/td&gt;
&lt;td&gt;tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查 看&lt;/td&gt;
&lt;td&gt;tar -jtv -f filename.tar.bz2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;解压缩&lt;/td&gt;
&lt;td&gt;tar -jxv -f filename.tar.bz2 -C 要解压缩的目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;bash&#34;&gt;Bash&lt;/h3&gt;
&lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;p&gt;Bash 是 Shell 的一种&lt;/p&gt;
&lt;p&gt;Shell 指的是一类程序，通过 Shell 程序，可以把我们的命令传递给内核，从而调用计算机硬件执行相关的操作，之后再把执行结果翻译成自然语言，呈现在我们面前。&lt;/p&gt;
&lt;p&gt;Bash 是当前大多数 Linux 发行版的默认Shell&lt;/p&gt;
&lt;h4 id=&#34;特性&#34;&gt;特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;命令历史：记录使用过的命令&lt;/li&gt;
&lt;li&gt;命令与文件补全：快捷键：tab&lt;/li&gt;
&lt;li&gt;命名别名：例如 ll 是 ls -al 的别名&lt;/li&gt;
&lt;li&gt;shell scripts&lt;/li&gt;
&lt;li&gt;通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;变量操作&#34;&gt;变量操作&lt;/h4&gt;
&lt;p&gt;对一个变量赋值直接使用 =。&lt;/p&gt;
&lt;p&gt;对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；&lt;/p&gt;
&lt;p&gt;输出变量使用 echo 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ x=abc
$ echo $x
$ echo ${x}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量内容如果有空格，必须使用双引号或者单引号。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号内的特殊字符可以保留原本特性，例如 x=&amp;quot;lang is $LANG&amp;quot;，则 x 的值为 lang is zh_TW.UTF-8；&lt;/li&gt;
&lt;li&gt;单引号内的特殊字符就是特殊字符本身，例如 x=&#39;lang is $LANG&#39;，则 x 的值为 lang is $LANG。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。&lt;/p&gt;
&lt;p&gt;可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。&lt;/p&gt;
&lt;p&gt;Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 [ ] 来对数组进行索引操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;指令搜索顺序&#34;&gt;指令搜索顺序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；&lt;/li&gt;
&lt;li&gt;由别名找到该指令来执行；&lt;/li&gt;
&lt;li&gt;由 Bash 内置的指令来执行；&lt;/li&gt;
&lt;li&gt;按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据流重定向&#34;&gt;数据流重定向&lt;/h4&gt;
&lt;p&gt;重定向指的是使用文件代替标准输入、标准输出和标准错误输出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准输入 (stdin)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt; 或 &amp;lt;&amp;lt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准输出 (stdout)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;gt; 或 &amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准错误输出 (stderr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&amp;gt; 或 2&amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，有一个箭头的表示以覆盖的方式重定向，而 有两个箭头的表示以追加的方式重定向。&lt;/p&gt;
&lt;p&gt;可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。&lt;/p&gt;
&lt;p&gt;如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&amp;gt;&amp;amp;1 表示将标准错误输出转换为标准输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ find /home -name .bashrc &amp;gt; list 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;管道指令&#34;&gt;管道指令&lt;/h3&gt;
&lt;p&gt;管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。&lt;/p&gt;
&lt;p&gt;在命令之间使用 | 分隔各个管道命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -al /etc | less
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提取指令 cut&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cut 对数据进行切分，取出想要的部分。&lt;/p&gt;
&lt;p&gt;切分过程一行一行地进行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 1：last 显示登入者的信息，取出用户名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d &#39; &#39; -f 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ export
declare -x HISTCONTROL=&amp;quot;ignoredups&amp;quot;
declare -x HISTSIZE=&amp;quot;1000&amp;quot;
declare -x HOME=&amp;quot;/home/dmtsai&amp;quot;
declare -x HOSTNAME=&amp;quot;study.centos.vbird&amp;quot;
.....(其他省略).....

$ export | cut -c 12-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;排序指令 sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort 用于排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ cat /etc/passwd | sort -t &#39;:&#39; -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;去重指令 uniq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uniq 可以将重复的数据只取一个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：取得每个人的登录总次数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last | cut -d &#39; &#39; -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;双向输出重定向指令 tee&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出重定向会将输出内容重定向到文件中，而 &lt;strong&gt;tee&lt;/strong&gt; 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tee [-a] file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5 个字符转换指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tr&lt;/code&gt; 用来删除一行中的字符，或者对字符进行替换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例，将 last 输出的信息所有小写转换为大写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last | tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;col&lt;/code&gt; 将 tab 字符转为空格字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;expand&lt;/code&gt; 将 tab 转换一定数量的空格，默认是 8 个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ expand [-t] file
-t ：tab 转为空格的数量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt; 将有相同数据的那一行合并在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;paste&lt;/code&gt; 直接将两行粘贴在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分区指令 split&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;split 将一个文件划分成多个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找指令-grep&#34;&gt;查找指令 grep&lt;/h3&gt;
&lt;p&gt;g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep -n &#39;the&#39; regular_express.txt
8:I can&#39;t finish the test.
12:the symbol &#39;*&#39; is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &amp;quot;glad&amp;quot;.
18:google is the best tools for search keyword
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep -n &#39;a\{2,5\}&#39; regular_express.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-个格式化输出指令&#34;&gt;2 个格式化输出指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;printf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ printf &#39;%10s %5i %5i %5i %8.2f \n&#39; $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。&lt;/p&gt;
&lt;p&gt;awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。&lt;/p&gt;
&lt;p&gt;示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
$ last -n 5 | awk &#39;{print $1 &amp;quot;\t&amp;quot; $3}&#39;
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ awk &#39;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cat /etc/passwd | awk &#39;BEGIN {FS=&amp;quot;:&amp;quot;} $3 &amp;lt; 10 {print $1 &amp;quot;\t &amp;quot; $3}&#39;
root 0
bin 1
daemon 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk 变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;变量名称&lt;/th&gt;
&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NF&lt;/td&gt;
&lt;td&gt;每一行拥有的字段总数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NR&lt;/td&gt;
&lt;td&gt;目前所处理的是第几行数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FS&lt;/td&gt;
&lt;td&gt;目前的分隔字符，默认是空格键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;示例：显示正在处理的行号以及每一行有多少字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last -n 5 | awk &#39;{print $1 &amp;quot;\t lines: &amp;quot; NR &amp;quot;\t columns: &amp;quot; NF}&#39;
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;进程管理-2&#34;&gt;进程管理&lt;/h3&gt;
&lt;h4 id=&#34;4-个查看进程指令&#34;&gt;4 个查看进程指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. ps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看某个时间点的进程信息。&lt;/p&gt;
&lt;p&gt;示例：查看自己的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：查看系统所有进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps aux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：查看特定的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps aux | grep threadx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. pstree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看进程树。&lt;/p&gt;
&lt;p&gt;示例：查看所有进程树&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## pstree -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. top&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实时显示进程信息。&lt;/p&gt;
&lt;p&gt;示例：两秒钟刷新一次&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## top -d 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. netstat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看占用端口的进程&lt;/p&gt;
&lt;p&gt;示例：查看特定端口的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## netstat -anp | grep port
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;进程状态-2&#34;&gt;进程状态&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;R&lt;/td&gt;
&lt;td&gt;running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D&lt;/td&gt;
&lt;td&gt;uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;S&lt;/td&gt;
&lt;td&gt;interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Z&lt;/td&gt;
&lt;td&gt;zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;T&lt;/td&gt;
&lt;td&gt;stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2bab4127-3e7d-48cc-914e-436be859fb05.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;h4 id=&#34;子进程的-sigchld-信号&#34;&gt;子进程的 SIGCHLD 信号&lt;/h4&gt;
&lt;p&gt;当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;得到 SIGCHLD 信号；&lt;/li&gt;
&lt;li&gt;waitpid() 或者 wait() 调用会返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。&lt;/p&gt;
&lt;p&gt;在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pid_t wait(int *status)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。&lt;/p&gt;
&lt;p&gt;如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。&lt;/p&gt;
&lt;p&gt;参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;waitpid()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pid_t waitpid(pid_t pid, int *status, int options)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。&lt;/p&gt;
&lt;p&gt;pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。&lt;/p&gt;
&lt;p&gt;options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。&lt;/p&gt;
&lt;h4 id=&#34;孤儿进程&#34;&gt;孤儿进程&lt;/h4&gt;
&lt;p&gt;一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。&lt;/p&gt;
&lt;p&gt;孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。&lt;/p&gt;
&lt;p&gt;由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。&lt;/p&gt;
&lt;h4 id=&#34;僵尸进程&#34;&gt;僵尸进程&lt;/h4&gt;
&lt;p&gt;一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。&lt;/p&gt;
&lt;p&gt;僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。&lt;/p&gt;
&lt;p&gt;系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。&lt;/p&gt;
&lt;p&gt;要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。&lt;/p&gt;
&lt;h2 id=&#34;关系型数据库&#34;&gt;关系型数据库&lt;/h2&gt;
&lt;p&gt;SQL 相关语法可以参考 &lt;a href=&#34;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E8%AF%AD%E6%B3%95.html&#34;&gt;cyc 大佬的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQL 相关练习可以参考 &lt;a href=&#34;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E7%BB%83%E4%B9%A0.html#description-15&#34;&gt;cyc 大佬的博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;sql-语法&#34;&gt;SQL 语法&lt;/h3&gt;
&lt;h4 id=&#34;内连接-自然连接-外连接&#34;&gt;内连接、自然连接、外连接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;内连接（INNER JOIN）：只显示符合 on 条件的行
&lt;ul&gt;
&lt;li&gt;自连接：自身与自身的内连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自然连接（NATURAL JOIN）：自动对同名列进行比对，不能使用 on 语句&lt;/li&gt;
&lt;li&gt;外连接（OUTER JOIN）：对于不符合 on 条件的行，对应列用 NULL 展示。分为左外连接、右外连接、全外连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符集与编码&#34;&gt;字符集与编码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符集（CHARACTER SET）：用于定义编号指代的字符，如，unicode、ascII、gb2312&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码：全称为编码格式，指的是具体字符集在传输和存储过程中的格式，如，utf-8、utf-16 是 unicode 的编码格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;UTF-16是一种编码格式。啥是编码格式？就是怎么存储，也就是存储的方式。 存储啥？存二进制数字。为啥要存二进制数字？ 因为Unicode字符集里面把二进制数字和字符一一对应了，存二进制数字就相当于存了二进制数字对应的字符了。为啥不直接存字符？因为计算机只能处理二进制数字。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/baxianhua/p/10608480.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;unicode则是为了让全球能用上统一的字符集而发明的，有6万多个字符，每个字符占2个字节，比如英文a，ascII是97、unicode则是0097（示意的说法）。中文只收录最常用的6000多个汉字。unicode虽然是大一统的标准，但是在表示英文时浪费空间，并且许多古老的程序只支持ascII，unicode从标准设计上来说是不兼容ascII。正因如此，在实际使用中unicode会以utf-8，utf-16等编码方式存储是传输。utf-8保持和ascII一致，英文使用1个字节，其他字符使用2-6个字节，比如中文多数是3个字节。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/liuliqiang/p/8258716.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;utf-8：3+1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;utf-16：2+2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;utf-32：4+4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么那么多网站钟情 UTF-8？ - 灵剑的回答 - 知乎 https://www.zhihu.com/question/19817672/answer/141807828&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校对字符（COLLATE）：即排序规则，用于指定字符间如何进行比较，主要用于排序和分组。例如，utf8_unicode_ci，ci 表示 Case Insensitive，即大小写无关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;什么是事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务是属于数据库中的一个概念，本质上指的是一系列的操作，但是这些操作会满足一些性质，ACID。&lt;/p&gt;
&lt;p&gt;事务可以通过 Commit 提交，也可以使用 Rollback 进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性 Atomicity：所有操作，要么全部提交，要么全部回滚。
&lt;ul&gt;
&lt;li&gt;回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; Consistency：强调数据库在逻辑上的一致性状态，依赖于原子性。比如，转账操作，要求多账户余额总和保持一致；扣款操作，要求账户余额变化与扣款金额一致。&lt;/li&gt;
&lt;li&gt;隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。&lt;/li&gt;
&lt;li&gt;持久性 Durability：当事务提交后，该事务中的一系列操作需要能被持久化到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
&lt;ul&gt;
&lt;li&gt;系统发生崩溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实，在 ACID 中，最重要的就是一致性，通过一致性，可以保证数据库时刻保持一致性的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;何为一致性状态？它指的是数据处于一种有意义的状态，这种状态是语义上的，而不是语法上的。最常见的例子就是转账，从账户 A 转一笔钱到账户 B，如果账户 A 上的钱减少了，但账户 B 上的钱没有增加，那么就认为此时数据处于不一致的状态。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/stone94/p/10409669.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在无并发的情况下，原子性 可以保证一致性&lt;/li&gt;
&lt;li&gt;在有并发的情况下，原子性+隔离性 可以保证一致性&lt;/li&gt;
&lt;li&gt;在系统发生崩溃时，持久性 可以保证一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207210437023.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;保留点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务处理中设置的临时占位符，如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;autocommit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 默认采用自动提交模式。也就是说，如果不显式使用 &lt;code&gt;START TRANSACTION&lt;/code&gt; 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。&lt;/p&gt;
&lt;p&gt;设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。&lt;/p&gt;
&lt;h4 id=&#34;并发中存在的一致性问题&#34;&gt;并发中存在的一致性问题&lt;/h4&gt;
&lt;p&gt;在并发环境下，如果事务的隔离性没有得到保证，则会出现很多一致性问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改丢失&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221744244.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;修改丢失，指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读脏数据&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221920368.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222102010.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222134306.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发控制可以通过&lt;strong&gt;封锁&lt;/strong&gt;来实现，但是封锁操作需要用户自己控制，相当复杂。&lt;/li&gt;
&lt;li&gt;数据库管理系统提供了事务的&lt;strong&gt;隔离级别&lt;/strong&gt;，让用户以一种更轻松的方式处理并发一致性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;锁&#34;&gt;锁&lt;/h4&gt;
&lt;h5 id=&#34;锁粒度&#34;&gt;&lt;strong&gt;锁粒度&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;MySQL 中提供了两种锁粒度：行级锁 以及 表级锁。&lt;/p&gt;
&lt;p&gt;应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的&lt;strong&gt;并发程度&lt;/strong&gt;就越高。&lt;/p&gt;
&lt;p&gt;但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统&lt;strong&gt;开销&lt;/strong&gt;就越大。&lt;/p&gt;
&lt;p&gt;在选择锁粒度时，需要在 锁开销 和 并发程度 之间做一个权衡。&lt;/p&gt;
&lt;h5 id=&#34;锁类型&#34;&gt;&lt;strong&gt;锁类型&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;读写锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁（E&lt;strong&gt;x&lt;/strong&gt;clusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（&lt;strong&gt;S&lt;/strong&gt;hared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有以下两个规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207213523777.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;意向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度锁。&lt;/p&gt;
&lt;p&gt;在存在 行级锁 和 表级锁 的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。&lt;/p&gt;
&lt;p&gt;意向锁在原来的 X/S 锁之上添加了 IX/IS，IX/IS 都是&lt;strong&gt;表锁&lt;/strong&gt;，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207214442687.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；&lt;/li&gt;
&lt;li&gt;这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;封锁协议&#34;&gt;封锁协议&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;三级封锁协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220440451.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。&lt;/p&gt;
&lt;p&gt;可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220831843.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。&lt;/p&gt;
&lt;p&gt;可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;三级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221313819.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。&lt;/p&gt;
&lt;p&gt;可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段锁协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加锁和解锁分为两个阶段进行。先进行加锁阶段，然后进行解锁阶段。事务进行过程中的所有加锁行为都需要在加锁阶段内完成，解锁同理。&lt;/p&gt;
&lt;p&gt;事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。&lt;/p&gt;
&lt;p&gt;可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。&lt;/p&gt;
&lt;p&gt;充分条件：例如，以下操作满足两段锁协议，因此它是可串行化调度的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非必要条件：例如，以下操作不满足两段锁协议，但它还是可串行化调度的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;innodb-的隐式-显式加锁&#34;&gt;InnoDB 的隐式、显式加锁&lt;/h5&gt;
&lt;p&gt;MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候&lt;strong&gt;自动&lt;/strong&gt;加锁，并且所有的锁都是在同一时刻被释放，这被称为&lt;strong&gt;隐式&lt;/strong&gt;加锁。&lt;/p&gt;
&lt;p&gt;InnoDB 也可以使用特定的语句进行&lt;strong&gt;显式&lt;/strong&gt;加锁，即&lt;strong&gt;手动&lt;/strong&gt;加锁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;格式：
SELECT ... LOCK In SHARE MODE; -- 加 X 锁
SELECT ... FOR UPDATE; -- 加 S 锁
例子：
SELECT * FROM table1 WHERE name=&#39;张三&#39; LOCK In SHARE MODE;
SELECT * F table1 WHERE name=&#39;张三&#39; FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED (未提交读，也叫脏读）：
&lt;ul&gt;
&lt;li&gt;事务未提交时，依旧可以读取到其所做的修改&lt;/li&gt;
&lt;li&gt;该隔离级别在性能上并不会比其他的好太多，但却缺乏其他隔离级别所拥有的好处，因此在实际应用中，一般不使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;READ COMMITTED (提交读，也叫不可重复读）
&lt;ul&gt;
&lt;li&gt;大部分数据库系统默认的隔离级别，但 MySQL 不是&lt;/li&gt;
&lt;li&gt;一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。&lt;/li&gt;
&lt;li&gt;又被称为“不可重复读”，因为同样的查询，在事务提交前和提交后，读取到的数据可能不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;REPEATABLE READ (可重复读）
&lt;ul&gt;
&lt;li&gt;MySQL 默认的隔离级别&lt;/li&gt;
&lt;li&gt;保证了在一个事务中的多次查询结果一致&lt;/li&gt;
&lt;li&gt;该隔离级别可通过 MVCC 实现，但是会存在幻读，即，在事务执行过程中，另一事务修改了数据，从而产生“幻行”，两次查询读取到的数据总行数不一样。&lt;/li&gt;
&lt;li&gt;InnoDB 和 XtraDB 存储引擎通过 MVCC + Next-Key Locks 解决了幻读的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SERIALIZABLE (可串行化）
&lt;ul&gt;
&lt;li&gt;最高级别的隔离级别&lt;/li&gt;
&lt;li&gt;强制事务串行执行，不存在并发，这样多个事务互不干扰，不会出现并发一致性问题&lt;/li&gt;
&lt;li&gt;具体实现：为读取的每一行数据加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207223400787.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;mvcc-多版本并发控制&#34;&gt;MVCC 多版本并发控制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;M&lt;/strong&gt;ulti-&lt;strong&gt;V&lt;/strong&gt;ersion &lt;strong&gt;C&lt;/strong&gt;oncurrency &lt;strong&gt;C&lt;/strong&gt;ontrol&lt;/p&gt;
&lt;p&gt;MVCC 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了 读写锁 来避免不必要的加锁操作，例如，读和读没有互斥关系。但，读和写操作仍然是互斥的。&lt;/p&gt;
&lt;p&gt;而 MVCC 利用了多版本的思想，&lt;strong&gt;写&lt;/strong&gt;操作更新&lt;strong&gt;最新版本&lt;/strong&gt;的快照，而&lt;strong&gt;读&lt;/strong&gt;操作去读&lt;strong&gt;旧版本&lt;/strong&gt;的快照，没有互斥关系，这一点和 CopyOnWrite 类似。&lt;/p&gt;
&lt;p&gt;在 MVCC 中，事务的每次修改操作（DELETE、INSERT、UPDATE）都会为&lt;strong&gt;数据行&lt;/strong&gt;新增一个版本快照。&lt;/p&gt;
&lt;p&gt;脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。&lt;/p&gt;
&lt;p&gt;多版本并发控制，每个 数据行快照版本 对应一个事务 id，当事务执行修改操作时，会生成对应的版本，多个 数据行快照版本 之间构成链表，从最新的版本开始寻找，直到找到满足要求的版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。&lt;/li&gt;
&lt;li&gt;事务版本号 TRX_ID ：事务开始时的系统版本号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Undo 日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。&lt;/p&gt;
&lt;p&gt;例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO t(id, x) VALUES(1, &amp;quot;a&amp;quot;);
UPDATE t SET x=&amp;quot;b&amp;quot; WHERE id=1;
UPDATE t SET x=&amp;quot;c&amp;quot; WHERE id=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为没有使用 &lt;code&gt;START TRANSACTION&lt;/code&gt; 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191208164808217.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReadView&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有个多版本后，MVCC 该如何使用它呢？&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220106103143882.png&#34; alt=&#34;image-20220106103143882&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;MVCC 维护了一个 ReadView 结构，主要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;m_ids：当前系统未提交的事务列表 {TRX_ID_1, TRX_ID_2, ...}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;min_trx_id：m_ids 中的最小值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;max_trx_id：当前系统的版本号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，但是，max_trx_id 的值是 4。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/jmliao/p/13204946.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;creator_trx_id：当前事务的 ID&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进行 SELECT 操作时，根据&lt;strong&gt;数据行&lt;/strong&gt;快照的 TRX_ID 与 min_trx_id 和 max_trx_id 之间的关系，从而判断数据行快照是否可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TRX_ID &amp;lt; min_trx_id，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。&lt;/li&gt;
&lt;li&gt;TRX_ID &amp;gt;= max_trx_id，表示该数据行快照是在事务启动之后被更改的，因此不可使用。&lt;/li&gt;
&lt;li&gt;TRX_ID_MIN &amp;lt;= TRX_ID &amp;lt; TRX_ID_MAX，需要根据隔离级别再进行判断：
&lt;ul&gt;
&lt;li&gt;提交读：如果 TRX_ID 在 m_ids 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。&lt;/li&gt;
&lt;li&gt;可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。&lt;/p&gt;
&lt;p&gt;对于提交读，ReadView 会在每次执行查询语句时生成一次，对于可重复读，只在第一次查询时生成，之后每次查询，复用第一次生成的 ReadView。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照读与当前读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVCC 只会在执行 SELECT 语句时发挥作用，在执行修改操作（INSERT、UPDATE、DELETE）时，依旧会对最新数据进行加锁，这是为了避免发生“修改丢失”。&lt;/p&gt;
&lt;p&gt;对于 SELECT 操作，会去多版本快照中读取数据，称为 快照读，快照读不会进行加锁操作&lt;/p&gt;
&lt;p&gt;对于其他修改操作，会对需要修改的数据进行加锁，确保修改的是最新的数据，这被称为 当前读。以下操作都是当前读：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT;
UPDATE;
DELETE;
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;幻读问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVCC 可以解决 快照读 的幻读问题，因为通过版本控制，只会读到旧版本中的数据，不会发生幻读问题&lt;/li&gt;
&lt;li&gt;但是无法解决 当前读 的幻读问题，因为当前读获取的是最新的数据
&lt;ul&gt;
&lt;li&gt;举个例子：&lt;/li&gt;
&lt;li&gt;事务1 select *&lt;/li&gt;
&lt;li&gt;事务2 insert&lt;/li&gt;
&lt;li&gt;事务1 select *，此时没问题，因为是快照读，不会读到事务2的insert&lt;/li&gt;
&lt;li&gt;事务1 update，因为 update 是当前读，会读到事务 2 的 insert，所以会把这条数据的版本号改成事务1，此时事务 1 再 select，就会出现幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;next-key-locks&#34;&gt;Next-Key Locks&lt;/h4&gt;
&lt;p&gt;Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。&lt;/p&gt;
&lt;p&gt;MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Record Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁定一个记录上的索引，而不是记录本身。&lt;/p&gt;
&lt;p&gt;如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gap Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Next-Key Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定的范围都是前开后闭的区间。&lt;/p&gt;
&lt;p&gt;例如，一个索引包含以下值：10, 11, 13, and 20，那么可能被锁住的区间有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体加锁规则为：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/50ff45e7d6f7826867bdc9c4197cf4c6.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;看了这结论，应该可以解答一大部分问题，不过有一句非常非常重点的话需要关注：&lt;/p&gt;
&lt;p&gt;MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列&amp;lt;=5.7.24，8.0 系列 &amp;lt;=8.0.13&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_36535538/article/details/117623068&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mysql&#34;&gt;MySQL&lt;/h3&gt;
&lt;h4 id=&#34;索引&#34;&gt;索引&lt;/h4&gt;
&lt;p&gt;索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。&lt;/p&gt;
&lt;h5 id=&#34;索引类型&#34;&gt;索引类型&lt;/h5&gt;
&lt;h6 id=&#34;b-tree-索引&#34;&gt;B+ Tree 索引&lt;/h6&gt;
&lt;p&gt;大多数 MySQL 存储引擎的默认索引类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。&lt;/p&gt;
&lt;p&gt;B+ Tree 是 B Tree 的升级版，在 B Tree 的基础上做了改良：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了叶子结点顺序访问指针&lt;/li&gt;
&lt;li&gt;将数据全部保存在叶子结点上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相较于 B Tree，B+ Tree 具有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保留了 B Tree 的平衡性&lt;/li&gt;
&lt;li&gt;可通过顺序访问指针提高区间查询的性能（B Tree中，需要使用中序遍历）&lt;/li&gt;
&lt;li&gt;将数据保存在叶子结点上，使得非叶子结点可以存储更多 key，进一步降低树高&lt;/li&gt;
&lt;li&gt;每次都会查到叶子结点才结束，因此查询时间较稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i+1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，且不为 null，则该指针指向节点的所有 key 大于等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 且小于等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i+1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/33576849-9275-47bb-ada7-8ded5f5e7c73.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;当需要进行查找操作时&lt;/p&gt;
&lt;p&gt;首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。&lt;/p&gt;
&lt;p&gt;插入、删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VS 红黑树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。&lt;/p&gt;
&lt;p&gt;（一）B+ 树有更低的&lt;strong&gt;树高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。&lt;/p&gt;
&lt;p&gt;（二）磁盘访问原理&lt;/p&gt;
&lt;p&gt;操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。&lt;/p&gt;
&lt;p&gt;如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与&lt;strong&gt;树高&lt;/strong&gt;成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。&lt;/p&gt;
&lt;p&gt;（三）磁盘预读特性&lt;/p&gt;
&lt;p&gt;为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（不用红黑树的根本原因还是因为树高！）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。&lt;/li&gt;
&lt;li&gt;因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。&lt;/li&gt;
&lt;li&gt;可以指定多个列作为索引列，多个索引列共同组成键。&lt;/li&gt;
&lt;li&gt;适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InnoDB 中的 B+ Tree 索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个&lt;strong&gt;聚簇索引&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/45016e98-6879-4709-8569-262b2d6d60b9.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7c349b91-050b-4d72-a7f8-ec86320307ea.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h6 id=&#34;其他索引&#34;&gt;其他索引&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希索引能以 O(1) 时间进行查找，但是失去了有序性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法用于排序与分组；&lt;/li&gt;
&lt;li&gt;只支持精确查找，无法用于部分查找和范围查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，这样就让 B+ Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM 存储引擎支持全文索引，&lt;strong&gt;用于查找文本中的关键词&lt;/strong&gt;，而不是直接比较是否相等。&lt;/p&gt;
&lt;p&gt;查找条件使用 MATCH AGAINST，而不是普通的 WHERE。&lt;/p&gt;
&lt;p&gt;全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间数据索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。&lt;/p&gt;
&lt;p&gt;必须使用 GIS 相关的函数来维护数据。&lt;/p&gt;
&lt;h5 id=&#34;如何高效使用索引&#34;&gt;如何高效使用索引&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;独立的列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。&lt;/p&gt;
&lt;p&gt;例如下面的查询不能使用 actor_id 列的索引：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多列索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引列的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让选择性最强的索引列放在前面。&lt;/p&gt;
&lt;p&gt;索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。&lt;/p&gt;
&lt;p&gt;例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;前缀索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。&lt;/p&gt;
&lt;p&gt;前缀长度的选取需要根据索引选择性来确定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;覆盖索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引包含所有需要查询的字段的值。&lt;/p&gt;
&lt;p&gt;具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。&lt;/li&gt;
&lt;li&gt;一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。&lt;/li&gt;
&lt;li&gt;对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;索引的优点与使用条件&#34;&gt;索引的优点与使用条件&lt;/h5&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大大减少了服务器需要扫描的数据行数。&lt;/li&gt;
&lt;li&gt;帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。&lt;/li&gt;
&lt;li&gt;将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；&lt;/li&gt;
&lt;li&gt;对于中到大型的表，索引就非常有效；&lt;/li&gt;
&lt;li&gt;但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。&lt;/p&gt;
&lt;p&gt;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。&lt;/p&gt;
&lt;p&gt;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。&lt;/p&gt;
&lt;p&gt;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。&lt;/p&gt;
&lt;p&gt;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。&lt;/p&gt;
&lt;p&gt;提供了大量的特性，包括压缩表、空间数据索引等。&lt;/p&gt;
&lt;p&gt;不支持事务。&lt;/p&gt;
&lt;p&gt;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。&lt;/p&gt;
&lt;p&gt;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。&lt;/p&gt;
&lt;p&gt;如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。&lt;/li&gt;
&lt;li&gt;并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。&lt;/li&gt;
&lt;li&gt;外键：InnoDB 支持外键。&lt;/li&gt;
&lt;li&gt;备份：InnoDB 支持在线热备份。&lt;/li&gt;
&lt;li&gt;崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。&lt;/li&gt;
&lt;li&gt;其它特性：MyISAM 支持压缩表和空间数据索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据类型-2&#34;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;整型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。&lt;/p&gt;
&lt;p&gt;INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。&lt;/p&gt;
&lt;p&gt;FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。&lt;/p&gt;
&lt;p&gt;VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。&lt;/p&gt;
&lt;p&gt;在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间和日期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DATETIME&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。&lt;/p&gt;
&lt;p&gt;它与时区无关。&lt;/p&gt;
&lt;p&gt;默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TIMESTAMP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。&lt;/p&gt;
&lt;p&gt;它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。&lt;/p&gt;
&lt;p&gt;MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。&lt;/p&gt;
&lt;p&gt;默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;以下-3-点均为性能优化&#34;&gt;以下 3 点均为性能优化：&lt;/h3&gt;
&lt;h3 id=&#34;查询性能优化&#34;&gt;查询性能优化&lt;/h3&gt;
&lt;h4 id=&#34;使用-explain-进行分析&#34;&gt;使用 Explain 进行分析&lt;/h4&gt;
&lt;p&gt;Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。&lt;/p&gt;
&lt;p&gt;各字段含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样&lt;/li&gt;
&lt;li&gt;select_type : 查询类型，有简单查询、联合查询、子查询等&lt;/li&gt;
&lt;li&gt;type：针对单表的查询方式
&lt;ul&gt;
&lt;li&gt;all、index、range、ref、eq_ref、const，从左到右效率依次提升&lt;/li&gt;
&lt;li&gt;all：全表扫描&lt;/li&gt;
&lt;li&gt;index：根据索引的顺序全表扫描&lt;/li&gt;
&lt;li&gt;range：索引范围查询，between、&amp;gt;、&amp;lt;、in&lt;/li&gt;
&lt;li&gt;ref：查询条件使用索引，但不是唯一索引&lt;/li&gt;
&lt;li&gt;eq_ref：查询条件使用唯一索引&lt;/li&gt;
&lt;li&gt;const：查询条件使用主键，优化器会把查询优化为一个常量&lt;/li&gt;
&lt;li&gt;by https://blog.csdn.net/dennis211/article/details/78170079&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys：可能用到的索引&lt;/li&gt;
&lt;li&gt;key : 实际用到的索引&lt;/li&gt;
&lt;li&gt;rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）&lt;/li&gt;
&lt;li&gt;Extra：
&lt;ul&gt;
&lt;li&gt;Impossible where：查询条件为false&lt;/li&gt;
&lt;li&gt;Using where：顺序扫描，where 条件查询&lt;/li&gt;
&lt;li&gt;Using index：覆盖索引&lt;/li&gt;
&lt;li&gt;Using index condition：索引下推
&lt;ul&gt;
&lt;li&gt;根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表&lt;/li&gt;
&lt;li&gt;在表上建立联合索引（name, age）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table1 where name like &amp;quot;张%&amp;quot; and age = 23;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表&lt;/li&gt;
&lt;li&gt;by https://zhuanlan.zhihu.com/p/121084592&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化数据访问&#34;&gt;优化数据访问&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;减少请求的数据量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只返回必要的列：最好不要使用 SELECT * 语句。&lt;/li&gt;
&lt;li&gt;只返回必要的行：使用 LIMIT 语句来限制返回的数据。&lt;/li&gt;
&lt;li&gt;缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;减少服务器端扫描的行数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最有效的方式是使用覆盖索引进行查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重构查询方式&#34;&gt;重构查询方式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 切分大查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/p&gt;
&lt;p&gt;大查询：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM messages WHERE create &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;rows_affected = 0
do {
    rows_affected = do_query(
    &amp;quot;DELETE FROM messages WHERE create  &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&amp;quot;)
} while rows_affected &amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 分解大连接查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;让缓存更高效：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。&lt;/li&gt;
&lt;li&gt;分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少锁竞争；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag=&#39;mysql&#39;;

SELECT * FROM tag WHERE tag=&#39;mysql&#39;;
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切分分库分表&#34;&gt;切分（分库分表）&lt;/h3&gt;
&lt;h4 id=&#34;水平切分-sharding&#34;&gt;水平切分 Sharding&lt;/h4&gt;
&lt;p&gt;水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。&lt;/p&gt;
&lt;p&gt;当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希取模：hash(key) % N；&lt;/li&gt;
&lt;li&gt;范围：可以是 ID 范围也可以是时间范围；&lt;/li&gt;
&lt;li&gt;映射表：使用单独的一个数据库来存储映射关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ID 唯一性：
&lt;ul&gt;
&lt;li&gt;使用全局唯一 ID（GUID）&lt;/li&gt;
&lt;li&gt;为每个分片指定一个 ID 范围&lt;/li&gt;
&lt;li&gt;分布式 ID 生成器 (如 Twitter 的 Snowflake 雪花算法)
&lt;ul&gt;
&lt;li&gt;0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000&lt;/li&gt;
&lt;li&gt;1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;/li&gt;
&lt;li&gt;41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &amp;lt;&amp;lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;/li&gt;
&lt;li&gt;10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;/li&gt;
&lt;li&gt;12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;/li&gt;
&lt;li&gt;加起来刚好64位，为一个Long型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;垂直切分&#34;&gt;垂直切分&lt;/h4&gt;
&lt;p&gt;垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。&lt;/p&gt;
&lt;p&gt;在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入删除要同时进行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共同存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务问题：使用分布式事务来解决，比如 XA 接口。&lt;/li&gt;
&lt;li&gt;连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式&#34;&gt;分布式&lt;/h3&gt;
&lt;h4 id=&#34;主从复制&#34;&gt;主从复制&lt;/h4&gt;
&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;binlog 线程&lt;/strong&gt; ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O 线程&lt;/strong&gt; ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 线程&lt;/strong&gt; ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;读写分离&#34;&gt;读写分离&lt;/h4&gt;
&lt;p&gt;主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。&lt;/p&gt;
&lt;p&gt;读写分离能提高性能的原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从服务器负责各自的读和写，极大程度缓解了锁的争用；&lt;/li&gt;
&lt;li&gt;从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；&lt;/li&gt;
&lt;li&gt;增加冗余，提高可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。&lt;/p&gt;
&lt;h3 id=&#34;关系型数据库-设计理论&#34;&gt;关系型数据库 设计理论&lt;/h3&gt;
&lt;p&gt;函数依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是函数依赖&lt;/li&gt;
&lt;li&gt;什么是键码、完全函数依赖、传递函数依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冗余数据&lt;/li&gt;
&lt;li&gt;修改异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式 1NF&lt;/li&gt;
&lt;li&gt;第二范式 2NF&lt;/li&gt;
&lt;li&gt;第三范式 3NF&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;er-图&#34;&gt;ER 图&lt;/h3&gt;
&lt;p&gt;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%85%AB%E3%80%81er-%E5%9B%BE&lt;/p&gt;
&lt;h2 id=&#34;非关系型数据库-redis&#34;&gt;非关系型数据库 Redis&lt;/h2&gt;
&lt;h3 id=&#34;概述-7&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。&lt;/p&gt;
&lt;p&gt;键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。&lt;/p&gt;
&lt;p&gt;Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。&lt;/p&gt;
&lt;h3 id=&#34;数据类型-3&#34;&gt;数据类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;可以存储的值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;STRING&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符串、整数或者浮点数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt;对整数和浮点数执行自增或者自减操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LIST&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从两端压入或者弹出元素 &lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无序集合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HASH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;包含键值对的无序散列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ZSET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有序集合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;使用方法&#34;&gt;使用方法&lt;/h4&gt;
&lt;p&gt;STRING&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; set hello world
OK
&amp;gt; get hello
&amp;quot;world&amp;quot;
&amp;gt; del hello
(integer) 1
&amp;gt; get hello
(nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LIST&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; rpush list-key item
(integer) 1
&amp;gt; rpush list-key item2
(integer) 2
&amp;gt; rpush list-key item
(integer) 3

&amp;gt; lrange list-key 0 -1
1) &amp;quot;item&amp;quot;
2) &amp;quot;item2&amp;quot;
3) &amp;quot;item&amp;quot;

&amp;gt; lindex list-key 1
&amp;quot;item2&amp;quot;

&amp;gt; lpop list-key
&amp;quot;item&amp;quot;

&amp;gt; lrange list-key 0 -1
1) &amp;quot;item2&amp;quot;
2) &amp;quot;item&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SET&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sadd set-key item
(integer) 1
&amp;gt; sadd set-key item2
(integer) 1
&amp;gt; sadd set-key item3
(integer) 1
&amp;gt; sadd set-key item
(integer) 0

&amp;gt; smembers set-key
1) &amp;quot;item&amp;quot;
2) &amp;quot;item2&amp;quot;
3) &amp;quot;item3&amp;quot;

&amp;gt; sismember set-key item4
(integer) 0
&amp;gt; sismember set-key item
(integer) 1

&amp;gt; srem set-key item2
(integer) 1
&amp;gt; srem set-key item2
(integer) 0

&amp;gt; smembers set-key
1) &amp;quot;item&amp;quot;
2) &amp;quot;item3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HASH&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; hset hash-key sub-key1 value1
(integer) 1
&amp;gt; hset hash-key sub-key2 value2
(integer) 1
&amp;gt; hset hash-key sub-key1 value1
(integer) 0

&amp;gt; hgetall hash-key
1) &amp;quot;sub-key1&amp;quot;
2) &amp;quot;value1&amp;quot;
3) &amp;quot;sub-key2&amp;quot;
4) &amp;quot;value2&amp;quot;

&amp;gt; hdel hash-key sub-key2
(integer) 1
&amp;gt; hdel hash-key sub-key2
(integer) 0

&amp;gt; hget hash-key sub-key1
&amp;quot;value1&amp;quot;

&amp;gt; hgetall hash-key
1) &amp;quot;sub-key1&amp;quot;
2) &amp;quot;value1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ZSET&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; zadd zset-key 728 member1
(integer) 1
&amp;gt; zadd zset-key 982 member0
(integer) 1
&amp;gt; zadd zset-key 982 member0
(integer) 0

&amp;gt; zrange zset-key 0 -1 withscores
1) &amp;quot;member1&amp;quot;
2) &amp;quot;728&amp;quot;
3) &amp;quot;member0&amp;quot;
4) &amp;quot;982&amp;quot;

&amp;gt; zrangebyscore zset-key 0 800 withscores
1) &amp;quot;member1&amp;quot;
2) &amp;quot;728&amp;quot;

&amp;gt; zrem zset-key member1
(integer) 1
&amp;gt; zrem zset-key member1
(integer) 0

&amp;gt; zrange zset-key 0 -1 withscores
1) &amp;quot;member0&amp;quot;
2) &amp;quot;982&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;存储结构&#34;&gt;存储结构&lt;/h4&gt;
&lt;p&gt;在 redis 中有 对象 和 存储结构 的概念，redis 对象利用不同的存储结构进行存储。例如，String 对象可以用 int 结构进行存储，也可以用 SDS 结构进行存储。&lt;/p&gt;
&lt;p&gt;对不同类型的对象，内部存储结构不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int 存储结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDS 存储结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;embstr：小于等于 44 字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png&#34; alt=&#34;image-20210528141323986&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw：大于 44 字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png&#34; alt=&#34;image-20210528141338577&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;embstr与raw的区别是，embstr只会申请一次内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hash 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png&#34; alt=&#34;image-20210525101358367&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表：空间占用大，查找快&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：数据数量较少或所占空间较少时，使用压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链表：空间占用更多，但添加、删除元素时，效率高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速列表：Redis 3.2 之后，用 快速列表 代替 压缩列表和链表&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png&#34; alt=&#34;image-20210528150649602&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数集合&lt;/li&gt;
&lt;li&gt;字典
&lt;ul&gt;
&lt;li&gt;字典中包含两个哈希表，哈希表使用 拉链法 解决哈希冲突&lt;/li&gt;
&lt;li&gt;之所以包含两个哈希表，是为了方便进行 rehash 操作。在扩容时，将其中一个 哈希表 上的键值对 rehash 到另一个 哈希表 上，完成之后释放空间并交换两个 哈希表 的角色。&lt;/li&gt;
&lt;li&gt;rehash 操作：
&lt;ul&gt;
&lt;li&gt;rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。&lt;/li&gt;
&lt;li&gt;渐进式 rehash 通过记录 字典 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 哈希表0 rehash 到 哈希表1，这一次会把 哈希表0 上 table[rehashidx] 的键值对 rehash 到 哈希表1 上，哈希表0 的 table[rehashidx] 指向 null，并令 rehashidx++。&lt;/li&gt;
&lt;li&gt;在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。&lt;/li&gt;
&lt;li&gt;采用渐进式 rehash 会导致字典中的数据分散在两个 哈希表 上，因此对字典的查找操作也需要到对应的 哈希表 上去执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet 对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳表：查找快，但更占空间且更新性能低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相较于 红黑树 的优势：&lt;/li&gt;
&lt;li&gt;插入速度非常快速，因为不需要进行旋转等操作来维护平衡性&lt;/li&gt;
&lt;li&gt;更容易实现&lt;/li&gt;
&lt;li&gt;支持无锁操作&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png&#34; alt=&#34;image-20210524163213876&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当元素个数超过 &lt;code&gt;zset-max-ziplist-entries&lt;/code&gt;，切换成跳表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用场景-7点&#34;&gt;使用场景 7点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计数器、全局序列号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以对 String 进行自增自减运算，从而实现计数器功能，&lt;code&gt;INCR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息&lt;/p&gt;
&lt;p&gt;不过最好使用 Kafka、RabbitMQ 等消息中间件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 查找表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如 DNS 记录就很适合使用 Redis 进行存储。&lt;/p&gt;
&lt;p&gt;查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 会话缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 Redis 来统一存储多台应用服务器的会话信息。&lt;/p&gt;
&lt;p&gt;当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式锁实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。&lt;/p&gt;
&lt;p&gt;可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其它&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Set 可以实现交集、并集等操作，从而实现共同好友等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet 可以实现有序性操作，从而实现排行榜等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单值缓存&lt;/li&gt;
&lt;li&gt;对象缓存：JSON字符串&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;计数器&lt;/li&gt;
&lt;li&gt;分布式系统全局序列号
&lt;ul&gt;
&lt;li&gt;分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象缓存
&lt;ul&gt;
&lt;li&gt;与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现栈、队列、拥塞队列&lt;/li&gt;
&lt;li&gt;消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽奖功能：因为set有srandmember、spop方法&lt;/li&gt;
&lt;li&gt;点赞功能：频繁添加、删除、比较元素，用set效率比list好&lt;/li&gt;
&lt;li&gt;关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZSet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;性能高的原因&#34;&gt;性能高的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象在不同情况下使用不同的存储结构&lt;/li&gt;
&lt;li&gt;基于内存&lt;/li&gt;
&lt;li&gt;多路复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vs-memcached&#34;&gt;VS Memcached&lt;/h3&gt;
&lt;p&gt;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html#%E4%BA%94%E3%80%81redis-%E4%B8%8E-memcached&lt;/p&gt;
&lt;h3 id=&#34;键的过期时间&#34;&gt;键的过期时间&lt;/h3&gt;
&lt;p&gt;Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。&lt;/p&gt;
&lt;p&gt;对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。&lt;/p&gt;
&lt;h3 id=&#34;数据淘汰策略&#34;&gt;数据淘汰策略&lt;/h3&gt;
&lt;p&gt;可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。&lt;/p&gt;
&lt;p&gt;Redis 具体有 6 种淘汰策略：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;策略&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-lru&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中挑选最近最少使用的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-ttl&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中挑选将要过期的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-random&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中任意选择数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allkeys-lru&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从所有数据集中挑选最近最少使用的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allkeys-random&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从所有数据集中任意选择数据进行淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;noeviction&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;禁止驱逐数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。&lt;/p&gt;
&lt;p&gt;使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。&lt;/p&gt;
&lt;h3 id=&#34;持久化&#34;&gt;持久化&lt;/h3&gt;
&lt;p&gt;Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB 持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将某个时间点的所有数据都存放到硬盘上。&lt;/p&gt;
&lt;p&gt;可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。&lt;/p&gt;
&lt;p&gt;如果系统发生故障，将会丢失最后一次创建快照之后的数据。&lt;/p&gt;
&lt;p&gt;如果数据量很大，保存快照的时间会很长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF 持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将写命令添加到 AOF 文件（Append Only File）的末尾。&lt;/p&gt;
&lt;p&gt;使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;同步频率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;always&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每个写命令都同步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;everysec&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每秒同步一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;no&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;让操作系统来决定何时同步&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;always 选项会严重减低服务器的性能；&lt;/li&gt;
&lt;li&gt;everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；&lt;/li&gt;
&lt;li&gt;no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。&lt;/p&gt;
&lt;h3 id=&#34;事务-2&#34;&gt;事务&lt;/h3&gt;
&lt;p&gt;一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。&lt;/p&gt;
&lt;p&gt;事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。&lt;/p&gt;
&lt;p&gt;Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。&lt;/p&gt;
&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;
&lt;p&gt;Redis 服务器是一个事件驱动程序。&lt;/p&gt;
&lt;h4 id=&#34;文件事件&#34;&gt;文件事件&lt;/h4&gt;
&lt;p&gt;服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。&lt;/p&gt;
&lt;p&gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;h4 id=&#34;时间事件&#34;&gt;时间事件&lt;/h4&gt;
&lt;p&gt;服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。&lt;/p&gt;
&lt;p&gt;时间事件又分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时事件：是让一段程序在指定的时间之内执行一次；&lt;/li&gt;
&lt;li&gt;周期性事件：是让一段程序每隔指定时间就执行一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。&lt;/p&gt;
&lt;h4 id=&#34;事件的调度与执行&#34;&gt;事件的调度与执行&lt;/h4&gt;
&lt;p&gt;服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。&lt;/p&gt;
&lt;p&gt;事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &amp;lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从事件处理的角度来看，服务器运行流程如下：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;主从复制-2&#34;&gt;主从复制&lt;/h3&gt;
&lt;p&gt;通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。&lt;/p&gt;
&lt;p&gt;一个从服务器只能有一个主服务器，并且不支持主主复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；&lt;/li&gt;
&lt;li&gt;从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；&lt;/li&gt;
&lt;li&gt;主服务器每执行一次写命令，就向从服务器发送相同的写命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;主从链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h3 id=&#34;sentinel-哨兵&#34;&gt;Sentinel 哨兵&lt;/h3&gt;
&lt;p&gt;Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。&lt;/p&gt;
&lt;h3 id=&#34;分片&#34;&gt;分片&lt;/h3&gt;
&lt;p&gt;分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。&lt;/p&gt;
&lt;p&gt;假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。&lt;/li&gt;
&lt;li&gt;还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据执行分片的位置，可以分为三种分片方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。&lt;/li&gt;
&lt;li&gt;代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。&lt;/li&gt;
&lt;li&gt;服务器分片：Redis Cluster。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;论坛系统实践&#34;&gt;论坛系统实践&lt;/h3&gt;
&lt;p&gt;该论坛系统功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以发布文章；&lt;/li&gt;
&lt;li&gt;可以对文章进行点赞；&lt;/li&gt;
&lt;li&gt;在首页可以按文章的发布时间或者文章的点赞数进行排序显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。&lt;/p&gt;
&lt;p&gt;Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7c54de21-e2ff-402e-bc42-4037de1c1592.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;点赞功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。&lt;/p&gt;
&lt;p&gt;为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/485fdf34-ccf8-4185-97c6-17374ee719a0.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;对文章进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合或一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间或点赞数，而是根据时间或点赞数间接计算出来的）&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;关系型数据库-与-非关系型数据库&#34;&gt;关系型数据库 与 非关系型数据库&lt;/h2&gt;
&lt;p&gt;本质区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系型数据库存储数据之间的关系，比如，可以根据学生学号查询他的姓名。非关系型数据库，只存储数据本身，数据之间是完全独立的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表现形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系型：数据表&lt;/li&gt;
&lt;li&gt;非关系型：键值对、文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各自优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系型：
&lt;ul&gt;
&lt;li&gt;可以利用数据之间的关系进行复杂的查询&lt;/li&gt;
&lt;li&gt;不存在冗余（利用范式优化存储）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非关系型：
&lt;ul&gt;
&lt;li&gt;方便扩展&lt;/li&gt;
&lt;li&gt;无需经过sql层的解析，读写性能很高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;四种常规实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒汉式-线程不安全&lt;/li&gt;
&lt;li&gt;饿汉式-线程安全&lt;/li&gt;
&lt;li&gt;懒汉式-线程安全&lt;/li&gt;
&lt;li&gt;双重校验锁-线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双重校验锁中，为什么需要用 volatile？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uniqueInstance 采用 volatile 关键字修饰也是很有必要的， &lt;code&gt;uniqueInstance = new Singleton();&lt;/code&gt; 这段代码其实是分为三步执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 uniqueInstance 分配内存空间&lt;/li&gt;
&lt;li&gt;初始化 uniqueInstance&lt;/li&gt;
&lt;li&gt;将 uniqueInstance 指向分配的内存地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&amp;gt;3&amp;gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。&lt;/p&gt;
&lt;p&gt;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种非常规实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内部类实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 &lt;code&gt;getUniqueInstance()&lt;/code&gt; 方法从而触发 &lt;code&gt;SingletonHolder.INSTANCE&lt;/code&gt; 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。&lt;/p&gt;
&lt;p&gt;这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JVM 如何保证 INSTANCE 只实例化一次？&lt;/p&gt;
&lt;p&gt;首先，对于类，无论静态类还是非静态类，只有被使用时，类才会被加载&lt;/p&gt;
&lt;p&gt;其次，对于成员变量：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用了static修饰的成员变量，会在类初始化的过程中被收集进类构造器，即&amp;lt; clinit&amp;gt;方法中，在多线程场景下，JVM会保证只有一个线程能执行该类的&amp;lt; clinit&amp;gt;方法，其他线程将会被阻塞等待，等到唯一的一次&amp;lt; cliint&amp;gt;方法执行完成，其他线程将不会再执行&amp;lt; clinit&amp;gt;方法，转而执行自己的代码。也就是说，static修饰的成员变量，在多线程的情况下能保证只实例化一次。&lt;/p&gt;
&lt;p&gt;ps:&lt;br&gt;
&amp;lt; init&amp;gt;:是instance实例构造器，对非静态变量进行初始化。&lt;br&gt;
&amp;lt; clinit&amp;gt;:是class类构造器，对静态变量、静态代码块进行初始化。&lt;br&gt;
————————————————&lt;br&gt;
原文链接：https://blog.csdn.net/weixin_43871678/article/details/107634599&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;枚举实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName(&amp;quot;firstName&amp;quot;);
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName(&amp;quot;secondName&amp;quot;);
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;firstName
secondName
secondName
secondName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。&lt;/li&gt;
&lt;li&gt;该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工厂相关的-3-个模式&#34;&gt;工厂相关的 3 个模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简单工厂模式：由工厂类的 create() 方法负责实例化对象
&lt;ul&gt;
&lt;li&gt;小米工厂负责生产手机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工厂方法模式：工厂类包含抽象方法，工厂子类继承工厂类并实现抽象方法
&lt;ul&gt;
&lt;li&gt;小米子工厂 A 负责生产手机 A，子工厂 B 负责生产手机 B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抽象工厂：在工厂方法模式的基础上，增加抽象方法的个数，从而实现对象家族的创建
&lt;ul&gt;
&lt;li&gt;小米子工厂 A 负责生产手机 A 和 投影仪 A，子工厂 B 负责生产手机 B 和投影仪 B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成器建造者&#34;&gt;生成器（建造者）&lt;/h3&gt;
&lt;p&gt;具体包含两个类：Director、Builder&lt;/p&gt;
&lt;p&gt;由 Director 负责控制流程，由 Builder 负责每一步具体的实现&lt;/p&gt;
&lt;p&gt;Director 依靠 Builder，并最终构造出对象&lt;/p&gt;
&lt;h3 id=&#34;观察者&#34;&gt;观察者&lt;/h3&gt;
&lt;p&gt;定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。&lt;/p&gt;
&lt;p&gt;主题（Subject）是被观察的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加、移除观察者&lt;/li&gt;
&lt;li&gt;通知观察者：notify()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而其所有依赖者（Observer）称为观察者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到通知后的操作：update()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他-2&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许一个对象再创建另外一个可定制的对象，调用者无需知道任何创建的细节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;责任链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于请求，当前类无法处理，则抛给上一层&lt;/p&gt;
&lt;p&gt;通过组合构成责任链&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Handler {

    protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }

    protected abstract void handleRequest(Request request);
}

public class ConcreteHandler1 extends Handler {

    public ConcreteHandler1(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + &amp;quot; is handle by ConcreteHandler1&amp;quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command：命令（开灯操作、关灯操作）&lt;/li&gt;
&lt;li&gt;Receiver：命令接收者，也就是命令真正的执行者（灯）&lt;/li&gt;
&lt;li&gt;Invoker：通过它来调用命令（遥控器）&lt;/li&gt;
&lt;li&gt;Client：可以设置命令与命令的接收者（人）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没懂，暂时不管了，面经遇到再说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A 与 B 要通信，A 告诉中介者，由中介者通知 B&lt;/p&gt;
&lt;p&gt;优势：对象之间的通信可集中管理，让 A 与 B 解耦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备忘录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Originator：原始对象&lt;/li&gt;
&lt;li&gt;Caretaker：负责保存好备忘录&lt;/li&gt;
&lt;li&gt;Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/50678f34-694f-45a4-91c6-34d985c83fee.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类&lt;/p&gt;
&lt;p&gt;实现：将状态抽象成类，并将相应的行为放在该类中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一系列算法，封装每个算法，并使它们可以互换。&lt;/p&gt;
&lt;p&gt;策略模式可以让算法独立于使用它的客户端。&lt;/p&gt;
&lt;p&gt;与 状态模式 的比较：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。&lt;/li&gt;
&lt;li&gt;状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模板方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义算法框架，并将一些步骤的实现延迟到子类。&lt;/p&gt;
&lt;p&gt;通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不懂，暂时跳过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 什么都不做 的空对象来代替 NULL。&lt;/p&gt;
&lt;p&gt;一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一个类接口转换成另一个用户需要的接口&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Duck {
    void quack();
}
public interface Turkey {
    void gobble();
}

public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&amp;quot;gobble!&amp;quot;);
    }
}
public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}

public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将抽象与实现分离开来，使它们可以独立变化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstraction：定义抽象类的接口&lt;/li&gt;
&lt;li&gt;Implementor：定义实现类接口&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;具体应用：https://blog.csdn.net/MY9526/article/details/108738263&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。&lt;/p&gt;
&lt;p&gt;组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为对象动态添加功能&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png&#34; alt=&#34;img&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;外观&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。&lt;/p&gt;
&lt;p&gt;观看电影需要操作很多电器，使用外观模式实现一键看电影功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;享元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象&lt;/p&gt;
&lt;p&gt;主要用于减少创建对象的数量，以减少内存占用和提高性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制对其它对象的访问&lt;/p&gt;
&lt;p&gt;代理有以下四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。&lt;/li&gt;
&lt;li&gt;虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。&lt;/li&gt;
&lt;li&gt;保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。&lt;/li&gt;
&lt;li&gt;智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计原则&#34;&gt;设计原则&lt;/h3&gt;
&lt;h4 id=&#34;solid&#34;&gt;S.O.L.I.D&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;简写&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;全拼&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;中文翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SRP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Single Responsibility Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单一责任原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Open Closed Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;开放封闭原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LSP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Liskov Substitution Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;里氏替换原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ISP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Interface Segregation Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接口分离原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DIP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Dependency Inversion Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;依赖倒置原则&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;1. 单一责任原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改一个类的原因应该只有一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。&lt;/p&gt;
&lt;p&gt;如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 开放封闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。&lt;/p&gt;
&lt;p&gt;符合开闭原则最典型的设计模式是&lt;strong&gt;装饰者模式&lt;/strong&gt;，它可以动态地将责任附加到对象上，而不用去修改类的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 里氏替换原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子类对象必须能够替换掉所有父类对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。&lt;/p&gt;
&lt;p&gt;如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 接口分离原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不应该强迫客户依赖于它们不用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此使用多个专门的接口比使用单一的总接口要好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 依赖倒置原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高层模块不应该依赖于低层模块，二者都应该依赖于抽象；&lt;br&gt;
抽象不应该依赖于细节，细节应该依赖于抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。&lt;/p&gt;
&lt;p&gt;依赖于抽象意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何变量都不应该持有一个指向具体类的指针或者引用；&lt;/li&gt;
&lt;li&gt;任何类都不应该从具体类派生；&lt;/li&gt;
&lt;li&gt;任何方法都不应该覆写它的任何基类中的已经实现的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;其他原则&#34;&gt;其他原则&lt;/h4&gt;
&lt;p&gt;除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;简写&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;全拼&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;中文翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LOD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Law of Demeter&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;迪米特法则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CRP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Composite Reuse Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;合成复用原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Common Closure Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;共同封闭原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SAP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Stable Abstractions Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;稳定抽象原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;The Stable Dependencies Principle&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;稳定依赖原则&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;1. 迪米特法则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。&lt;/p&gt;
&lt;p&gt;外观模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 合成复用原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽量使用对象组合，而不是通过继承来达到复用的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 共同封闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 稳定抽象原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 稳定依赖原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。&lt;/p&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;h3 id=&#34;红黑树&#34;&gt;红黑树&lt;/h3&gt;
&lt;p&gt;近似平衡二叉树&lt;/p&gt;
&lt;p&gt;性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点要么红色要么黑色&lt;/li&gt;
&lt;li&gt;根节点是黑色&lt;/li&gt;
&lt;li&gt;红节点的子节点是黑色&lt;/li&gt;
&lt;li&gt;空叶子结点是黑色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优势（vs AVL）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然查询效率略低于 AVL，但插入效率要远胜于 AVL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统设计&#34;&gt;系统设计&lt;/h2&gt;
&lt;h3 id=&#34;系统设计基础&#34;&gt;系统设计基础&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html&#34;&gt;http://www.cyc2018.xyz/其它/系统设计/系统设计基础.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;性能指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间&lt;/li&gt;
&lt;li&gt;吞吐量&lt;/li&gt;
&lt;li&gt;并发用户数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伸缩性&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;可用性
&lt;ul&gt;
&lt;li&gt;服务降级：系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式-2&#34;&gt;分布式&lt;/h3&gt;
&lt;h4 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h4&gt;
&lt;p&gt;在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。&lt;/p&gt;
&lt;p&gt;阻塞锁通常使用互斥量来实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；&lt;/li&gt;
&lt;li&gt;互斥量为 1 表示未锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 数据库的唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。&lt;/p&gt;
&lt;p&gt;存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁没有失效时间，解锁失败的话其它进程无法再获得该锁；&lt;/li&gt;
&lt;li&gt;只能是非阻塞锁，插入失败直接就报错了，无法重试；&lt;/li&gt;
&lt;li&gt;不可重入，已经获得锁的进程也必须重新获取锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. Redis 的 SETNX 指令（单个实例实现分布式锁）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。&lt;/p&gt;
&lt;p&gt;SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。&lt;/p&gt;
&lt;p&gt;EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis 的 RedLock 算法（多个实例实现分布式锁）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试从 N 个互相独立 Redis 实例获取锁；&lt;/li&gt;
&lt;li&gt;计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；&lt;/li&gt;
&lt;li&gt;如果获取锁失败，就到每个实例上释放锁（因为在获取锁的过程中，已经对部分 redis 实例进行加锁了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. Zookeeper 的有序节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. Zookeeper 抽象模型&lt;/p&gt;
&lt;p&gt;Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/aefa8042-15fa-4e8b-9f50-20b282a2c624.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;2. 节点类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永久节点：不会因为会话结束或者超时而消失；&lt;/li&gt;
&lt;li&gt;临时节点：如果会话结束或者超时就会消失；&lt;/li&gt;
&lt;li&gt;有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 监听器&lt;/p&gt;
&lt;p&gt;为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。&lt;/p&gt;
&lt;p&gt;4. 分布式锁实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个锁目录 /lock；&lt;/li&gt;
&lt;li&gt;当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；&lt;/li&gt;
&lt;li&gt;客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则，监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；&lt;/li&gt;
&lt;li&gt;执行业务代码，完成后，删除对应的子节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5. 会话超时&lt;/p&gt;
&lt;p&gt;如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。&lt;/p&gt;
&lt;p&gt;6. 羊群效应&lt;/p&gt;
&lt;p&gt;一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。&lt;/p&gt;
&lt;h4 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h4&gt;
&lt;p&gt;指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。&lt;/p&gt;
&lt;p&gt;例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。&lt;/p&gt;
&lt;p&gt;分布式锁和分布式事务区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。&lt;/li&gt;
&lt;li&gt;而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两阶段提交 2PC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。&lt;/p&gt;
&lt;p&gt;运行过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;准备阶段：协调者询问参与者事务&lt;strong&gt;是否执行成功&lt;/strong&gt;，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/44d33643-1004-43a3-b99a-4d688a08d0a1.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。&lt;/li&gt;
&lt;li&gt;单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。&lt;/li&gt;
&lt;li&gt;数据不一致：在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。&lt;/li&gt;
&lt;li&gt;太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;三阶段提交 3PC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;待看：https://zhuanlan.zhihu.com/p/163864897&lt;/p&gt;
&lt;p&gt;三阶段提交：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：各节点检查资源，判断业务是否可执行（但在此阶段不&lt;strong&gt;执行&lt;/strong&gt;事务）&lt;/li&gt;
&lt;li&gt;第二阶段（缓冲阶段，precommit）：执行业务，但不提交&lt;/li&gt;
&lt;li&gt;第三阶段：和两阶段提交的第二阶段相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三阶段提交的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引入超时机制，减少阻塞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果超时，默认abort，但如果是第三阶段，超时则自动提交，两阶段提交无法这么做，因为不存在缓冲阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）&lt;br&gt;
————————————————&lt;br&gt;
原文链接：https://blog.csdn.net/u010191243/article/details/52081891&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务管理器集群：幂等操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;补偿事务 TCC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/112540330&lt;/li&gt;
&lt;li&gt;https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;amp;mid=2653195220&amp;amp;idx=2&amp;amp;sn=60552e190233a5b98c4c24fff4ac7238&amp;amp;chksm=8c99f90ebbee70187e9feb6f2f3660df3d06071427bd1a4b3f3467c428d8c1de84c768183e5c&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1001twHtyhaOm0sZl089iHAP#rd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try 阶段：预留资源&lt;/li&gt;
&lt;li&gt;Confirm 阶段：执行业务&lt;/li&gt;
&lt;li&gt;Cancel 阶段：若部分节点 Confirm 失败，则执行 Cancel 进行 &lt;strong&gt;补偿&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地消息表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。&lt;/li&gt;
&lt;li&gt;之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。&lt;/li&gt;
&lt;li&gt;在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;cap&#34;&gt;CAP&lt;/h4&gt;
&lt;p&gt;分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。&lt;/p&gt;
&lt;p&gt;对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。&lt;/li&gt;
&lt;li&gt;最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。&lt;/li&gt;
&lt;li&gt;弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。&lt;/p&gt;
&lt;p&gt;在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分区容忍性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。&lt;/p&gt;
&lt;p&gt;在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。&lt;/p&gt;
&lt;p&gt;可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；&lt;/li&gt;
&lt;li&gt;为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;base&#34;&gt;BASE&lt;/h4&gt;
&lt;p&gt;BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。&lt;/p&gt;
&lt;p&gt;BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。&lt;/p&gt;
&lt;p&gt;例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。&lt;/p&gt;
&lt;p&gt;ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。&lt;/p&gt;
&lt;p&gt;在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。&lt;/p&gt;
&lt;h4 id=&#34;paxos-协议&#34;&gt;Paxos 协议&lt;/h4&gt;
&lt;p&gt;用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。&lt;/p&gt;
&lt;p&gt;主要有三类节点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提议者（Proposer）：提议一个值；&lt;/li&gt;
&lt;li&gt;接受者（Acceptor）：对每个提议进行投票；&lt;/li&gt;
&lt;li&gt;告知者（Learner）：被告知投票的结果，不参与投票过程。往往只有一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b988877c-0f0a-4593-916d-de2081320628.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;执行过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。&lt;/p&gt;
&lt;p&gt;1. Prepare 阶段&lt;/p&gt;
&lt;p&gt;下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。&lt;/p&gt;
&lt;p&gt;如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &amp;gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。&lt;/p&gt;
&lt;p&gt;如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &amp;gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &amp;lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;2. Accept 阶段&lt;/p&gt;
&lt;p&gt;当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。&lt;/p&gt;
&lt;p&gt;Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。&lt;/p&gt;
&lt;p&gt;Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;3. Learn 阶段&lt;/p&gt;
&lt;p&gt;Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;约束条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 正确性&lt;/p&gt;
&lt;p&gt;指只有一个提议值会生效。&lt;/p&gt;
&lt;p&gt;因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。&lt;/p&gt;
&lt;p&gt;2. 可终止性&lt;/p&gt;
&lt;p&gt;指最后总会有一个提议生效。&lt;/p&gt;
&lt;p&gt;Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。&lt;/p&gt;
&lt;h4 id=&#34;raft-协议-竞选-leader&#34;&gt;Raft 协议-竞选 Leader&lt;/h4&gt;
&lt;p&gt;Raft 也是分布式一致性协议，主要是用来竞选主节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个 Candidate 的竞选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有三种节点：Follower、Candidate 和 Leader。&lt;/p&gt;
&lt;p&gt;Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最初阶段，只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。&lt;/li&gt;
&lt;li&gt;此时 Node A 发送投票请求给其它所有节点。&lt;/li&gt;
&lt;li&gt;其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。&lt;/li&gt;
&lt;li&gt;之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;多个 Candidate 的竞选&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如，Node B 和 Node D 都获得两票，需要重新开始投票。&lt;/li&gt;
&lt;li&gt;由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数据同步&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。&lt;/li&gt;
&lt;li&gt;Leader 会把修改复制到所有 Follower。&lt;/li&gt;
&lt;li&gt;Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。&lt;/li&gt;
&lt;li&gt;此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集群&#34;&gt;集群&lt;/h3&gt;
&lt;h4 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h4&gt;
&lt;p&gt;集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。&lt;/p&gt;
&lt;p&gt;负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。&lt;/p&gt;
&lt;p&gt;负载均衡器可以用来实现高可用以及伸缩性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；&lt;/li&gt;
&lt;li&gt;伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负载均衡器运行过程包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据负载均衡算法得到转发的节点；&lt;/li&gt;
&lt;li&gt;进行转发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;负载均衡算法&#34;&gt;负载均衡算法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;轮询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;轮询算法把每个请求轮流发送到每个服务器上。&lt;/p&gt;
&lt;p&gt;下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。&lt;/p&gt;
&lt;p&gt;该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加权轮询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。&lt;/p&gt;
&lt;p&gt;例如，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最少连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。&lt;/p&gt;
&lt;p&gt;例如，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。&lt;/p&gt;
&lt;p&gt;最少连接算法就是将请求发送给当前最少连接数的服务器上。&lt;/p&gt;
&lt;p&gt;例如，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加权最少连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把请求随机发送到服务器上。&lt;/p&gt;
&lt;p&gt;和轮询算法类似，该算法比较适合服务器性能差不多的场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源地址哈希法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。&lt;/p&gt;
&lt;p&gt;可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）&lt;/p&gt;
&lt;h5 id=&#34;转发实现&#34;&gt;转发实现&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;HTTP 重定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要两次请求，因此访问延迟比较高；&lt;/li&gt;
&lt;li&gt;HTTP 负载均衡器处理能力有限，会限制集群的规模。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该负载均衡转发的缺点比较明显，实际场景中很少使用它。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;DNS 域名解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;反向代理服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。&lt;/p&gt;
&lt;p&gt;在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与其它功能集成在一起，部署简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修改网络层数据包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。&lt;/p&gt;
&lt;p&gt;源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内核进程中进行处理，性能比较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修改链路层数据包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。&lt;/p&gt;
&lt;p&gt;通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。&lt;/p&gt;
&lt;p&gt;这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。&lt;/p&gt;
&lt;p&gt;这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。&lt;/p&gt;
&lt;h4 id=&#34;集群下的-session-管理&#34;&gt;集群下的 Session 管理&lt;/h4&gt;
&lt;p&gt;一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sticky Session&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当服务器宕机时，将丢失该服务器上的所有 Session。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1623f524-b011-40c8-b83f-eab38d538f76.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;Session Replication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;占用过多内存；&lt;/li&gt;
&lt;li&gt;同步过程占用网络带宽以及服务器处理器时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/40c6570d-c1d7-4c38-843e-ba991b2328c2.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;Session Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要去实现存取 Session 的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/fdc45a09-f838-4348-8959-d2c793727788.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;
&lt;h4 id=&#34;缓存特性&#34;&gt;缓存特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。&lt;/li&gt;
&lt;li&gt;最大空间：缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。&lt;/li&gt;
&lt;li&gt;淘汰策略：
&lt;ul&gt;
&lt;li&gt;FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。&lt;/li&gt;
&lt;li&gt;LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。&lt;/li&gt;
&lt;li&gt;LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缓存应用&#34;&gt;缓存应用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;浏览器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。&lt;/p&gt;
&lt;p&gt;相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt; 内部的缓存&lt;/p&gt;
&lt;p&gt;Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt; 多级缓存&lt;/p&gt;
&lt;p&gt;CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CDN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。&lt;/p&gt;
&lt;p&gt;CDN 主要有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快地将数据分发给用户；&lt;/li&gt;
&lt;li&gt;通过部署多台服务器，从而提高系统整体的带宽性能；&lt;/li&gt;
&lt;li&gt;多台服务器可以看成是一种冗余机制，从而具有高可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缓存问题&#34;&gt;缓存问题&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对这些不存在的数据缓存一个空数据；&lt;/li&gt;
&lt;li&gt;对这类请求进行过滤。&lt;/li&gt;
&lt;li&gt;布隆过滤器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区分击穿与穿透&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220118101525086.png&#34; alt=&#34;image-20220118101525086&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.jianshu.com/p/b144c11e742e&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。&lt;/p&gt;
&lt;p&gt;在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；&lt;/li&gt;
&lt;li&gt;为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。&lt;/li&gt;
&lt;li&gt;也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缓存一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存一致性要求数据更新的同时缓存数据也能够实时更新。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在数据更新的同时立即去更新缓存；&lt;/li&gt;
&lt;li&gt;在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存 “无底洞” 现象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。&lt;/p&gt;
&lt;p&gt;产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化批量数据操作命令；&lt;/li&gt;
&lt;li&gt;减少网络通信次数；&lt;/li&gt;
&lt;li&gt;降低接入成本，使用长连接 / 连接池，NIO 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缓存存储&#34;&gt;缓存存储&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;传统哈希存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。&lt;/p&gt;
&lt;p&gt;传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。&lt;/p&gt;
&lt;p&gt;顺序分布相比于哈希分布的主要优点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能保持数据原有的顺序；&lt;/li&gt;
&lt;li&gt;并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性哈希存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。&lt;/p&gt;
&lt;p&gt;基本原理&lt;/p&gt;
&lt;p&gt;将哈希空间 [0, &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.664392em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/66402828-fb2b-418f-83f6-82153491bcfe.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;虚拟节点&lt;/p&gt;
&lt;p&gt;上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。&lt;/p&gt;
&lt;p&gt;数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。&lt;/p&gt;
&lt;p&gt;解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。&lt;/p&gt;
&lt;h4 id=&#34;lru-淘汰算法详解&#34;&gt;LRU 淘汰算法详解&lt;/h4&gt;
&lt;p&gt;以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。&lt;/li&gt;
&lt;li&gt;为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息队列&#34;&gt;消息队列&lt;/h3&gt;
&lt;h4 id=&#34;消息模型&#34;&gt;消息模型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;点对点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191212011250613.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;发布/订阅&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191212011410374.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;发布与订阅模式和观察者模式有以下不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。&lt;/li&gt;
&lt;li&gt;观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用场景&#34;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;异步处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。&lt;/p&gt;
&lt;p&gt;例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。&lt;/p&gt;
&lt;p&gt;只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流量削峰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。&lt;/p&gt;
&lt;p&gt;可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用解耦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。&lt;/p&gt;
&lt;p&gt;通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。&lt;/p&gt;
&lt;h4 id=&#34;可靠性&#34;&gt;可靠性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;发送端的可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送端完成操作后一定能将消息成功发送到消息队列中。&lt;/p&gt;
&lt;p&gt;实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收端的可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端能够从消息队列成功消费一次消息。&lt;/p&gt;
&lt;p&gt;两种实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。&lt;/li&gt;
&lt;li&gt;保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;攻击技术&#34;&gt;攻击技术&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://wwww.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html&#34;&gt;http://wwww.cyc2018.xyz/其它/系统设计/攻击技术.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;编码实践&#34;&gt;编码实践&lt;/h2&gt;
&lt;h3 id=&#34;面向对象思想&#34;&gt;面向对象思想&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少耦合：可以独立地开发、测试、优化、使用、理解和修改&lt;/li&gt;
&lt;li&gt;减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块&lt;/li&gt;
&lt;li&gt;有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能&lt;/li&gt;
&lt;li&gt;提高软件的可重用性&lt;/li&gt;
&lt;li&gt;降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。&lt;/p&gt;
&lt;p&gt;注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? &amp;quot;man&amp;quot; : &amp;quot;woman&amp;quot;;
    }

    public void work() {
        if (18 &amp;lt;= age &amp;amp;&amp;amp; age &amp;lt;= 50) {
            System.out.println(name + &amp;quot; is working very hard!&amp;quot;);
        } else {
            System.out.println(name + &amp;quot; can&#39;t work any more!&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承实现了 &lt;strong&gt;IS-A&lt;/strong&gt; 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。&lt;/p&gt;
&lt;p&gt;继承应该遵循 &lt;strong&gt;里氏替换原则&lt;/strong&gt;，子类对象必须能够替换掉所有父类对象。&lt;/p&gt;
&lt;p&gt;Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 &lt;strong&gt;向上转型&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Animal animal = new Cat();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多态分为编译时多态和运行时多态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译时多态主要指方法的重载&lt;/li&gt;
&lt;li&gt;运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行时多态有三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;覆盖（重写）&lt;/li&gt;
&lt;li&gt;向上转型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Instrument {

    public void play() {
        System.out.println(&amp;quot;Instument is playing...&amp;quot;);
    }
}

public class Wind extends Instrument {

    public void play() {
        System.out.println(&amp;quot;Wind is playing...&amp;quot;);
    }
}

public class Percussion extends Instrument {

    public void play() {
        System.out.println(&amp;quot;Percussion is playing...&amp;quot;);
    }
}

public class Music {

    public static void main(String[] args) {
        List&amp;lt;Instrument&amp;gt; instruments = new ArrayList&amp;lt;&amp;gt;();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Wind is playing...
Percussion is playing...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h3&gt;
&lt;p&gt;链接：&lt;a href=&#34;http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html&#34;&gt;http://www.cyc2018.xyz/其它/编码实践/正则表达式.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下为本人摘取的部分内容。&lt;/p&gt;
&lt;h4 id=&#34;大小写转换&#34;&gt;大小写转换&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;元字符&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;\l&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把下个字符转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;\u&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把下个字符转换为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;\L&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把\L 和\E 之间的字符全部转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;\U&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把\U 和\E 之间的字符全部转换为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;\E&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结束\L 或者\U&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把文本的第二个和第三个字符转换为大写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;abcd&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;(\w)(\w{2})(\w)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;替换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$1\U$2\E$3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;aBCd&lt;/p&gt;
&lt;h4 id=&#34;嵌入条件&#34;&gt;嵌入条件&lt;/h4&gt;
&lt;h5 id=&#34;回溯引用条件&#34;&gt;回溯引用条件&lt;/h5&gt;
&lt;p&gt;条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;(\()?abc(?(1)\))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;(abc)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;abc&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(abc&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;前后查找条件&#34;&gt;前后查找条件&lt;/h5&gt;
&lt;p&gt;条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;\d{5}(?(?=-)-\d{4})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;11111&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;22222-&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;33333-4444&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;h4 id=&#34;解决的问题&#34;&gt;解决的问题&lt;/h4&gt;
&lt;p&gt;由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。&lt;/p&gt;
&lt;p&gt;Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。&lt;/p&gt;
&lt;h4 id=&#34;与虚拟机比较&#34;&gt;与虚拟机比较&lt;/h4&gt;
&lt;p&gt;虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/be608a77-7b7f-4f8e-87cc-f2237270bf69.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;启动速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；&lt;/p&gt;
&lt;p&gt;而启动 Docker 相当于启动宿主操作系统上的一个进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;占用资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。&lt;/p&gt;
&lt;p&gt;而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。&lt;/p&gt;
&lt;h4 id=&#34;优势&#34;&gt;优势&lt;/h4&gt;
&lt;p&gt;除了启动速度快以及占用资源少之外，Docker 具有以下优势：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更容易迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更容易维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更容易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。&lt;/p&gt;
&lt;h4 id=&#34;使用场景-2&#34;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;持续集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。&lt;/p&gt;
&lt;p&gt;Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供可伸缩的云服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据应用的负载情况，可以很容易地增加或者减少 Docker。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搭建微服务架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。&lt;/p&gt;
&lt;h4 id=&#34;镜像与容器&#34;&gt;镜像与容器&lt;/h4&gt;
&lt;p&gt;镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。&lt;/p&gt;
&lt;p&gt;镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。&lt;/p&gt;
&lt;p&gt;构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。&lt;/p&gt;
&lt;h3 id=&#34;git&#34;&gt;Git&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html&#34;&gt;http://www.cyc2018.xyz/其它/编码实践/Git.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;构建工具&#34;&gt;构建工具&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html&#34;&gt;http://www.cyc2018.xyz/其它/编码实践/构建工具.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码可读性&#34;&gt;代码可读性&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html&#34;&gt;http://www.cyc2018.xyz/其它/编码实践/代码可读性.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cyc2018.xyz/&#34;&gt;CyC2018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;过往内容&#34;&gt;过往内容&lt;/h2&gt;
&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;h4 id=&#34;3种集群模式主从-哨兵-集群&#34;&gt;3种集群模式：主从、哨兵、集群&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主从模式：
&lt;ul&gt;
&lt;li&gt;1个主节点，N个从节点&lt;/li&gt;
&lt;li&gt;主节点负责写操作，从节点负责读操作&lt;/li&gt;
&lt;li&gt;数据同步&lt;/li&gt;
&lt;li&gt;一旦主节点挂了，集群就丧失写功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哨兵模式
&lt;ul&gt;
&lt;li&gt;主从模式的升级版，添加哨兵&lt;/li&gt;
&lt;li&gt;哨兵本质上是一个进程，sentinel进程，负责监控节点状态，如果主节点挂了，会从从节点总竞选得到新的主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集群模式
&lt;ul&gt;
&lt;li&gt;主从模式+分区&lt;/li&gt;
&lt;li&gt;每个主从集群负责一部分哈希槽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发&#34;&gt;并发&lt;/h2&gt;
&lt;h3 id=&#34;synchronized-和-reentrantlock-的实现及区别&#34;&gt;synchronized 和 Reentrantlock 的实现及区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sychronized 是一个关键字，ReentrantLock 是一个类&lt;/li&gt;
&lt;li&gt;sychronized 会自动的加锁与释放锁，ReentrantLock 需要程序员手动加锁与释放锁，因此更灵活，可以根据业务场景进行相应操作&lt;/li&gt;
&lt;li&gt;sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁&lt;/li&gt;
&lt;li&gt;sychronized底层有一个锁升级的过程
&lt;ul&gt;
&lt;li&gt;偏向锁：偏向第一次持有锁的线程，该线程无需进行同步操作&lt;/li&gt;
&lt;li&gt;轻量级锁：自旋，CAS&lt;/li&gt;
&lt;li&gt;重量级锁：线程阻塞时，需要将用户态转到内核态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;synchronized：锁的是对象，锁信息保存在对象头中，可以是实例对象也可以是类对象&lt;br&gt;
6. 对象：使用汇编指令monitorenter和monitorexit&lt;br&gt;
6. 方法：使用ACC_SYNCHRONIZED标识符，本质上也是monitor的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;ReentrantLock：通过代码中的state标识来标识锁的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cas的缺点&#34;&gt;CAS的缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ABA问题、CPU空转问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程池实现机制-配置参数-使用注意点&#34;&gt;线程池实现机制、配置参数、使用注意点&lt;/h3&gt;
&lt;p&gt;线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建&lt;br&gt;
新的线程来处理被添加的任务。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入&lt;br&gt;
缓冲队列。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等&lt;br&gt;
于maximumPoolSize，那么通过handler所指定的策略来处理此任务。&lt;/li&gt;
&lt;li&gt;当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：目的是更有效地利用CPU资源
&lt;ul&gt;
&lt;li&gt;CPU密集型：CPU核数+1，之所以+1，是为了更优的利用率&lt;/li&gt;
&lt;li&gt;IO密集型：CPU 核心数 * (1 + IO 耗时/ CPU 耗时)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MaximumPoolSize、workQueueSize、handler拒绝策略、keepAliveTime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程池预热方法：prestartAllCoreThreads()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何防止超卖现象&#34;&gt;如何防止超卖现象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;redis缓存和mysql同步更新&lt;/li&gt;
&lt;li&gt;减库存排队，使用窗口进行合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm&#34;&gt;JVM&lt;/h2&gt;
&lt;h3 id=&#34;gc&#34;&gt;GC&lt;/h3&gt;
&lt;h4 id=&#34;cms-g1的优缺点&#34;&gt;CMS、G1的优缺点&lt;/h4&gt;
&lt;p&gt;CMS是老年代的垃圾回收器，用的是标记清除算法，所以会产生内存碎片，但是因为它的回收原理是并发回收，因此STW时间较短。&lt;/p&gt;
&lt;p&gt;G1是面向整个堆的垃圾回收器，同时将分区的思想与分代相结合，每次回收时，都会去挑选需要回收的分区，使用的算法是标记整理算法，是jdk9默认的收集器，同时G1可以控制STW的时间，如果到达指定的STW时间，对于剩下的分区，就不进行回收，从而可以控制STW的时间。&lt;/p&gt;
&lt;h3 id=&#34;如何处理线上的oom&#34;&gt;如何处理线上的OOM&lt;/h3&gt;
&lt;p&gt;-Xms表示初始堆内存大小，memory startup&lt;/p&gt;
&lt;p&gt;-XmX表示最大堆内存大小，memory maximum&lt;/p&gt;
&lt;p&gt;-Xmn表示新生代内存大小，包括初始值和最大值，memory nursery/new&lt;/p&gt;
&lt;p&gt;示例：-Xms16m -Xmx32m&lt;/p&gt;
&lt;p&gt;通过参数配置，让java进程在OOM时自动产生dump文件，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp&lt;/p&gt;
&lt;p&gt;通过命令行导出dump文件，jmap -dump:live, file=jmap.hprof [PID]&lt;/p&gt;
&lt;p&gt;通过jvisualvm分析dump文件，分析哪些对象比较占内存&lt;/p&gt;
&lt;p&gt;两种可能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象确实太大了&lt;/li&gt;
&lt;li&gt;内存泄漏：各种连接，如果不手动关闭，则会被GC认为是不可回收的对象，导致内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络编程&#34;&gt;网络编程&lt;/h2&gt;
&lt;h3 id=&#34;netty&#34;&gt;Netty&lt;/h3&gt;
&lt;h4 id=&#34;了解reactor模型吗&#34;&gt;了解Reactor模型吗？&lt;/h4&gt;
&lt;p&gt;问题拆解：与Netty是什么关系，有几种类型，各自的优势是什么&lt;/p&gt;
&lt;p&gt;Netty 是一个广泛使用的 Java 网络编程框架&lt;/p&gt;
&lt;p&gt;Reactor是1995年由道格拉斯提出的一种高性能网络编程模式，一共有3种形式，单线程Reactor、多线程Reactor和主从多线程Reactor。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单线程Reactor：由一个线程处理连接请求、读写操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程Reactor：由一个线程处理连接请求，由线程池处理读写操作。但一个线程依旧可以处理多个读写操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6463324-1f7a2d77cfa17720.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从Reactor：由一个线程池处理连接请求，并将连接好的请求发送给读写线程池进行处理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6463324-a94066924053c037.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优势：不同形式适应不同的场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bytebuf实现原理&#34;&gt;ByteBuf实现原理&lt;/h4&gt;
&lt;p&gt;在java nio中提供了ByteBuffer作为字节容器，包括4个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark：调用mark()方法时，将position的值赋值给mark；调用reset()方法时，将mark的值赋值给position&lt;/li&gt;
&lt;li&gt;position：下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新&lt;/li&gt;
&lt;li&gt;limit：缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量&lt;/li&gt;
&lt;li&gt;capacity：缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变&lt;/li&gt;
&lt;li&gt;读写模式切换：flip()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;netty提供了ByteBuf作为字节容器，包括3个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;readIndex、writerIndex、capacity：字面意思&lt;/li&gt;
&lt;li&gt;discardReadBytes()：清空已读部分，利用System.arraycopy()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rpc&#34;&gt;RPC&lt;/h2&gt;
&lt;h3 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h3&gt;
&lt;h4 id=&#34;spi机制了解吗&#34;&gt;SPI机制了解吗&lt;/h4&gt;
&lt;p&gt;Java SPI：全称 Service Provider Interface，为接口指定实现类，放在 META-INF/services/ 目录里&lt;/p&gt;
&lt;p&gt;Java SPI的缺点：无法按需加载实现类，只能逐个进行加载，可能存在某个实现类，很耗资源，但又用不上&lt;/p&gt;
&lt;p&gt;Dubbo SPI的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以根据名称，按需加载。原理：在配置文件中由用户提供 名称-类全限定名 的键值对&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;负载均衡算法-2&#34;&gt;负载均衡算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;权重随机算法：获取随机数，然后依次减去每个invorker的权重，直到小于0；如果权重相同，则直接随机&lt;/li&gt;
&lt;li&gt;权重轮询算法：每次增加当前权重，选出大于当前权重的invorkers，然后从中按顺序选择&lt;/li&gt;
&lt;li&gt;最少活跃调用数算法：每次选出最小活跃的invorker，活跃数为invorker正在处理的请求数，如果不止一个，则对于这些invorkers，使用权重随机算法。&lt;/li&gt;
&lt;li&gt;一致性Hash算法：环形Hash空间，虚拟节点，对象迁移，寻找最近节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计思想&#34;&gt;设计思想&lt;/h2&gt;
&lt;h3 id=&#34;api的设计原则&#34;&gt;API的设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单一原则&lt;/li&gt;
&lt;li&gt;升级兼容性&lt;/li&gt;
&lt;li&gt;幂等设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;领域建模&#34;&gt;领域建模&lt;/h3&gt;
&lt;p&gt;DDD 领域驱动设计&lt;/p&gt;
&lt;p&gt;建模：对业务的抽象&lt;/p&gt;
&lt;p&gt;领域建模：将建模过程划分成4层：UI 层、应用层、领域层、基建层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI层：负责展示&lt;/li&gt;
&lt;li&gt;基建层：负责存储&lt;/li&gt;
&lt;li&gt;领域层：负责存储过程中的业务逻辑，只关心是否合法，不管是否合理，例如下订单的操作，设计创建订单和减库存，应该在领域层，而不是应用层&lt;/li&gt;
&lt;li&gt;应用层：负责核心业务逻辑，例如，黑名单的业务，应该在应用层，而不应该在领域层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：https://www.zhihu.com/question/25089273&lt;/p&gt;
&lt;h2 id=&#34;实战&#34;&gt;实战&lt;/h2&gt;
&lt;h3 id=&#34;做的项目遇到什么问题如何解决&#34;&gt;做的项目，遇到什么问题，如何解决&lt;/h3&gt;
&lt;h2 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaomi-info.github.io/2020/01/02/distributed-transaction/&#34;&gt;分布式事务，这一篇就够了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/paddix/p/5367116.html&#34;&gt;Java并发编程：Synchronized及其实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/kusedexingfu/article/details/103744202&#34;&gt;JVM的GC 参数为什么要这么命名：xms、xss、xmn和xmn?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1578846&#34;&gt;未关闭的文件流会引起内存泄露么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/duanxz/p/3696849.html&#34;&gt;Netty中的三种Reactor（反应堆）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/3930150bf7f0&#34;&gt;Netty系列-一分钟了解ByteBuffer和ByteBuf结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35190492/article/details/108256452&#34;&gt;阿里面试真题：Dubbo的SPI机制 敖丙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60c10eabdfaf&#34;&gt;Dubbo负载均衡算法实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/twoheads/p/10135896.html&#34;&gt;一致性哈希算法(consistent hashing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Lq4y1S7Rc?p=1&amp;amp;share_medium=android&amp;amp;share_plat=android&amp;amp;share_source=COPY&amp;amp;share_tag=s_i&amp;amp;timestamp=1632973331&amp;amp;unique_k=BEotpJ&#34;&gt;朋友投稿！与面试官死磕中间件与库存设计！顺利斩获大厂Offer！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">JavaHan</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录与春招相关的一些内容，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明年3月份春招（暑期实习）的备战计划&lt;/li&gt;
&lt;li&gt;春招过程中需要注意的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;备战阶段&#34;&gt;备战阶段&lt;/h2&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java技术栈+计算机基础+算法+项目+加分项（竞赛/开源项目/博客）&lt;/p&gt;
&lt;p&gt;大公司更看重基础知识（八股文），小公司更看中现有能力&lt;/p&gt;
&lt;p&gt;边面试边准备，不要等完全准备好再去面试&lt;/p&gt;
&lt;h3 id=&#34;笔试算法&#34;&gt;笔试（算法）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/cat/&#34;&gt;lintcode CAT模式 天梯上分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codetop.cc/home&#34;&gt;CodeTop 汇总互联网大厂面试的高频考题 帮助面试者更有针对性地准备面试&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;可直接定位特定公司、部门的面试题&lt;/li&gt;
&lt;li&gt;学长学姐都比较推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/study/live/489/1/1&#34;&gt;左神算法笔面试真题精讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/exam-bytedance&#34;&gt;牛客网 名企编程真题&lt;/a&gt;（企业真题可以多刷刷头条 网易 拼多多）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/coding-interviews&#34;&gt;牛客网 剑指offer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/leetcode&#34;&gt;牛客网 经典必刷编程题库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/job-code-high&#34;&gt;牛客网 名企高频面试题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problem-list/2cktkvj/&#34;&gt;LeetCode 热题 HOT 100 官方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problem-list/2ckc81c/&#34;&gt;LeetCode 精选 TOP 面试题 官方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/158977583&#34;&gt;leetcode 精选 by sergio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yuque.com/office/yuque/0/2020/pdf/619289/1605766958275-87ed48a3-0a68-4433-9d3c-b4ea9c829ccb.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fshenjingwa-o51xg%2Fyh6opc%2Fsqqfew%2Fedit&#34;&gt;leetcode 精选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/24964987/answer/182447205&#34;&gt;lintcode 精选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.changgy.com/leetcode-101&#34;&gt;LeetCode 101：和你一起你轻松刷题（C++）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cyc2018.xyz/#%E7%AE%97%E6%B3%95&#34;&gt;Cyc2018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面试题java技术栈计算机基础&#34;&gt;面试题（Java技术栈+计算机基础）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;刷面经！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;备战阶段，就不要去看书或者视频了，书和视频都是用来系统学习知识的，备战阶段要的就是突击！应试！直接刷 &lt;strong&gt;面试题&lt;/strong&gt; 就好~&lt;/p&gt;
&lt;h4 id=&#34;面经&#34;&gt;面经&lt;/h4&gt;
&lt;p&gt;面试题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;自己的春招面经 待补充&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/455889?channel=-2&amp;amp;source_id=discuss_terminal_discuss_sim&#34;&gt;牛客网 字节提前批 客户端 三轮面经&lt;/a&gt;&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/630359?type=2&amp;amp;order=0&amp;amp;pos=13&amp;amp;page=1&amp;amp;source_id=discuss_tag_nctrack&amp;amp;channel=-1&amp;amp;ncTraceId=b147450b14934df290b4f5d60279fc4e.211.16436068164962340&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1643606814017&#34;&gt;** 牛客网 阿里云 开放平台 java后端 2021暑期实习 一二面hr面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/experience?tagId=639&#34;&gt;牛客网 Java工程师精选面经合集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/subject/index/e75efed65dc34f88ad80304f282320f0&#34;&gt;牛客网 话题 #实习经验分享#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/subject/index/dd10269469cc48fa97fc5b0e183d2878&#34;&gt;牛客网 话题 #阿里巴巴暑期实习#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/438229187&#34;&gt;字节&lt;/a&gt; （后面的广告，直接忽略即可）（没看，不是牛客网上的，对质量存疑）&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/293661?from=zhnkw&#34;&gt;合集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/i29juUTnfOKZQIeY08l4RA&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/762719?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;合集 南大 22届 硕 Java后端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/629687?source_id=profile_create_nctrack&amp;amp;channel=-1&#34;&gt;微软+蚂蚁 南大 22届 硕 Java后端 实习面经&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/802981?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=2&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;合集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cxy师兄-面经.docx&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1yCCeNMb0FNCJKDIE6EASYA#list/path=%2F&#34;&gt;大厂面经合集：美团、腾讯、字节、虾皮 各方向都有&lt;/a&gt; 提取码【lrp3】 解压码【jk7z】&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/172152&#34;&gt;合集 C++ 基础架构方向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;心路历程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/56655579&#34;&gt;cyc2018大佬的面经&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/762719?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;南大 22届 硕 Java后端&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;八股文&#34;&gt;八股文&lt;/h4&gt;
&lt;p&gt;第一遍刷，抓大放小&lt;/p&gt;
&lt;p&gt;要形成自己的八股文文档，方便后期复习&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://bule-zst.gitee.io/2021-09-30-JavaHan/&#34;&gt;JavaHan&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cyc2018.github.io/CS-Notes/#/&#34;&gt;JavaCyc&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整理了&lt;a href=&#34;http://www.cyc2018.xyz/&#34;&gt;cyc2018&lt;/a&gt;各部分内容pdf版的页数，方便做计划&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211221102750329.png&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://passjava.cn/#/88.Interview/01.Redis/Redis1&#34;&gt;PassJava-面试必备&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cosen1024/Java-Interview&#34;&gt;「Java面试小抄」一份通向理想互联网公司的面试指南，包括 Java基础、集合、Java并发、JVM、MySQL、Redis、Spring、MyBatis、Kafka、操作系统、计算机网络、系统设计、分布式、Java 项目实战等 by 库森&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/column/c_1339954942191271936&#34;&gt;大厂面试 by 程序员库森&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/820419?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;对线面试官系列之Java集合--面试官看了都说好&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面内容主要整理了需要掌握的知识点，但是没有答案，可以先看上面的内容，下面的查缺补漏时用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/61438?from=zhnkw&#34;&gt;JAVA后端秋招/春招准备方向&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/359264954&#34;&gt;2021春招Java后端开发面试总结【25个技术专题】超详细！&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;项目&#34;&gt;项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;从需求开始，把整个项目的流程讲明白、讲透彻&lt;/p&gt;
&lt;p&gt;介绍项目时，可以埋彩蛋，引导面试官提问&lt;/p&gt;
&lt;p&gt;正反说：&lt;/p&gt;
&lt;p&gt;​		数据库查询比较快，因为用了索引&lt;/p&gt;
&lt;p&gt;​		系统比较慢，通过分析发现是数据库查询比较慢，然后用索引进行了优化&lt;/p&gt;
&lt;p&gt;微软宣讲会 Kaifeng&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;问项目，问得很细，每一步是怎么实现的，过程，如果不是自己亲手一步一步做绝对会露馅&lt;/p&gt;
&lt;p&gt;做项目时遇到了什么困难&lt;/p&gt;
&lt;p&gt;https://www.nowcoder.com/discuss/455889?channel=-2&amp;amp;source_id=discuss_terminal_discuss_sim&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;对实习项目的描述还不够好，没有把实习内容的闪光点描述出来，也没有讲清楚为什么做这个项目，自己通过什么方法去做，以及最后的结果&lt;/p&gt;
&lt;p&gt;cyc2018面经 https://zhuanlan.zhihu.com/p/56655579&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何描述自己的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://www.cnblogs.com/JavaArchitect/p/7586949.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;要素&lt;/th&gt;
&lt;th&gt;样式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。&lt;/td&gt;
&lt;td&gt;我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到 JS 等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。&lt;/td&gt;
&lt;td&gt;我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;描述你在项目里的角色&lt;/td&gt;
&lt;td&gt;我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。&lt;/td&gt;
&lt;td&gt;用到了Java里面的集合，JDBC等技术，用到了Spring MVC等框架，用技术连接数据库。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;（这部分的风险自己承担）如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。&lt;/td&gt;
&lt;td&gt;这个系统是部署在 Linux 上的，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;要避免的情况&lt;/th&gt;
&lt;th&gt;正确的做法&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;回答很简单。问什么答什么，往往就用一句话回答&lt;/td&gt;
&lt;td&gt;把你知道的都说出来，重点突出你知道的思想，框架&lt;/td&gt;
&lt;td&gt;问：你SSH用过吗？答：用过。问：在什么项目里用到？答：一个保险项目问：你做了哪方面的事情？答：开发。面试官直接不问了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;说得太流利&lt;/td&gt;
&lt;td&gt;适当停顿，边思考边说&lt;/td&gt;
&lt;td&gt;让面试官感觉你在背准备的东西，这样后面问题就很难&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目介绍时什么都说&lt;/td&gt;
&lt;td&gt;就说些刚才让准备的一些，而且要有逻辑地说&lt;/td&gt;
&lt;td&gt;会让面试官感觉你思路太乱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过多介绍技术细节&lt;/td&gt;
&lt;td&gt;相关技术点到为止，就说你熟悉的技术，等面试官来问&lt;/td&gt;
&lt;td&gt;你说到的所有技术要点，都可能会被深问。面试官一般会有自己的面试节奏，如果你在介绍时就太多说技术细节，很有可能被打断，从而没法说出你准备好的亮点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里只列出了部分，具体内容可以看链接，感觉写的挺好的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/121136858&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何介绍自己的项目：STAR法则（背景+目标+行动+结果）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景+目标：要做什么&lt;/li&gt;
&lt;li&gt;项目整体功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行动：干了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简短&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责的模块&lt;/li&gt;
&lt;li&gt;担任的角色与职责&lt;/li&gt;
&lt;li&gt;所用的技术点
&lt;ul&gt;
&lt;li&gt;用了什么技术，同类型的技术有哪些，有什么区别，为什么选择这个&lt;/li&gt;
&lt;li&gt;介绍时，只需要提用了什么技术，但是后面 3 个问题需要提前准备，防止面试官问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难点是什么（不知道如何实现 或者 实现后出现了bug）&lt;/li&gt;
&lt;li&gt;亮点是什么&lt;/li&gt;
&lt;li&gt;技术点：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目性能、项目成果&lt;/li&gt;
&lt;li&gt;对项目的&lt;strong&gt;思考&lt;/strong&gt;（优化点和不足）以及&lt;strong&gt;收获&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智力题&#34;&gt;智力题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;智力题（或者叫，逻辑思维题、脑筋急转弯），需要提前准备一下&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简历&#34;&gt;简历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;专业技能，注明熟练度：熟悉、熟练掌握、精通&lt;/li&gt;
&lt;li&gt;不要罗列技术，而是突出，自己通过 XX 技术实现了什么&lt;/li&gt;
&lt;li&gt;简历命名：姓名+学校+岗位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/zvideo/1289637611880026112?utm_source=qq&amp;amp;utm_medium=social&amp;amp;utm_oi=747689983887814656&#34;&gt;建议收藏！小白简历这样改，一秒成为优秀简历！秋招必备，让你offer拿到手软！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU2OTY4Nzk1Mw==&amp;amp;mid=2247485451&amp;amp;idx=1&amp;amp;sn=6a722f682d1df07404cc79b5aaf41a87&amp;amp;chksm=fcfba2f5cb8c2be30908bc0bf2146c8203d4f055780d6b64d9b2e5570d96b5b0bfae9d872432&amp;amp;scene=21#wechat_redirect&#34;&gt;通过 BAT 面试的程序员简历长什么样? 附简历模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cyc2018.github.io/page.html&#34;&gt;cyc2018 大佬的网页简历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;春招开始&#34;&gt;春招开始&lt;/h2&gt;
&lt;h3 id=&#34;投递&#34;&gt;投递&lt;/h3&gt;
&lt;h4 id=&#34;心得&#34;&gt;心得&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;海投！一定要海投！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;疯狂面试，可以积累经验&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;但有一点需要注意&lt;/strong&gt;，就是如果最终拿到实习资格，然后拒掉，会不会影响后期秋招？这个到时候要再确认一下。&lt;/li&gt;
&lt;li&gt;对于一些自己不想去的公司或者部门，也可以试着投递，增加经验（如果是部门，提前了解清楚投递会不会影响到自己想去的部门）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;早投递机会更大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎了解一下boss直聘，到时候找实习，可以把简历放到boss直聘上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;首先就是策略，一开始最好不要立刻投大厂，因为一上来就面大厂的话容易崩，刚开始面的人少所以难度也会相对高一些，有的还凑合的会被大厂当备胎，很难受的。其次就是能内推就不要走官网，能免笔试免笔试，不是说笔试难度大还是咋地，这玩意其实是玄学，因为你说你一个人做呢没问题，大神嘛无所谓但是你保不齐别人是一个实验室或者一个班级的人在做，如果遇到点坑的题目，你交代了，别人合作做出来了那你被挂能怪谁呢。还有就是如果大家也是合作做题的话，oj的查重或者作弊系统的判别现在越来越严，如果保不齐你被抓到了，可能就被企业拉黑，然后你还不知道，后面怎么投都没面试机会这是最惨的。还有就是大家都是一起做的，然后分数也差不多，但是别人接到了面试而你没有，我就遇到了这样的情况，就很玄学我都怀疑是随机选的人面试。反正就是笔试有风险，大家还是抱紧学长学姐的大腿，能走内推就内推。但是内推之前还是需要能够了解一下这个部门，大概是做什么的，hc的数量以及技术氛围，这点其实很重要，因为一旦进了流程，你反悔就来不及了，如果过了之后还想换部门那只能重新面试，再走一遍别说多恶心了。其实哪个部门最好或者哪个部门最有前景啥的这些问题，真的很难了解的非常清楚，我就纠结过很久很久，这种事情找不到最优解的，不过还好对我而言现在只是实习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先拿到保底offer，这样心态会好很多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;部门信息整理&#34;&gt;部门信息整理&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://duibiao.info/&#34;&gt;职级对标 互联网相关信息查询（作息、薪资、评价）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事业群 &amp;gt; 部门 &amp;gt; 中心 &amp;gt; 小组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微众：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贷款科技部：&lt;strong&gt;很核心&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阿里集团（简称集团）
&lt;ul&gt;
&lt;li&gt;阿里云：很香&lt;/li&gt;
&lt;li&gt;天猫精灵团队：&lt;/li&gt;
&lt;li&gt;钉钉：&lt;/li&gt;
&lt;li&gt;一面、二面、总监面、交叉部门主管面、HR面；每一面都有一票否决权（包括HR面）&lt;/li&gt;
&lt;li&gt;转正是否成功，很大程度上取决于HR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蚂蚁
&lt;ul&gt;
&lt;li&gt;CTO线-数据与平台技术事业群-蚂蚁智能引擎与数据中台技术事业部-大数据部
&lt;ul&gt;
&lt;li&gt;一面、二面、笔试、三面、四面、HR面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;听同学群里讨论，集团没有蚂蚁好，至少薪资福利这块，没有蚂蚁好&lt;/li&gt;
&lt;li&gt;重视项目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;百度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程效率部门：做内部工具的，对个人成长并不好&lt;/li&gt;
&lt;li&gt;企业智能平台：主要是内部系统，虽然会接触到机器学习和大数据，不太好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础架构&lt;/li&gt;
&lt;li&gt;今日头条：薪资很诱人
&lt;ul&gt;
&lt;li&gt;头条加面有两种情况，一是三轮评级都是 4 可以评 SSP，二是面试官评价差别很大，再面一轮决定是否录用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data：核心部门&lt;/li&gt;
&lt;li&gt;一面、二面、三面，就可以offer了&lt;/li&gt;
&lt;li&gt;重视算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;荣耀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品线部门：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vivo：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;华为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cloud Bu：不错&lt;/li&gt;
&lt;li&gt;车BU智能座舱产品部&lt;/li&gt;
&lt;li&gt;南研所消费者 BG&lt;/li&gt;
&lt;li&gt;cyc2018 拿到了十四级最高的薪资&lt;/li&gt;
&lt;li&gt;不怎么问技术，重视学历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;华泰证券&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息技术部：base南京&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;杭研院&lt;/li&gt;
&lt;li&gt;网易互联网&lt;/li&gt;
&lt;li&gt;网易雷火&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TP-Link&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;腾讯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微信事业群：gc学长说 挺好的&lt;/li&gt;
&lt;li&gt;上海CSIG：很差&lt;/li&gt;
&lt;li&gt;重视算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深兰科技&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创新奇智&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便利蜂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;携程旅行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旷视&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小米&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bilibili&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;商汤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;度小满&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美团&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金服：&lt;/li&gt;
&lt;li&gt;到店：&lt;/li&gt;
&lt;li&gt;重视项目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拼多多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;贝壳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快手&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;360&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外企&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微软&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STCA-M365
&lt;ul&gt;
&lt;li&gt;笔试、一面、Leader面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3轮技术面+1轮AA面，AA面最终决定是否通过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;亚马逊&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谷歌&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虾皮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重视算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;待投&#34;&gt;待投&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU1MTU2NjcxMQ==&amp;amp;mid=2247504396&amp;amp;idx=1&amp;amp;sn=200877c58bd016dbd5d66aefbee154a3&amp;amp;chksm=fb8dfe14ccfa770246c8c5ffd15eb455fea3c1e307ecb0f16ef8365c61463f6bde033c40850d&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1216AelYAleMD4XYJuv0n2FJ&amp;amp;sharer_sharetime=1639639282713&amp;amp;sharer_shareid=02cdcbb08350c969c2db9d032c863a6d#rd&#34;&gt;微软 提前批 22.1.1&lt;/a&gt; 放弃 觉得自己没有准备好&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;宝洁 22.1.14  &lt;a href=&#34;https://mp.weixin.qq.com/s/STCpEoSpSLIntZglntZJfw&#34;&gt;官网&lt;/a&gt; &lt;a href=&#34;https://mp.weixin.qq.com/s/1hKslZkERA8okJuSfhX6rw&#34;&gt;实习僧链接&lt;/a&gt; 放弃 还没准备好&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;字节 日常实习&lt;/li&gt;
&lt;li&gt;微软 正式批 22.1.17
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/0kwiVC9tAH5GeaIE60dOqw&#34;&gt;微软校招 | 2022暑期实习招聘正式启动！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.qq.com/doc/DV0NGWmVhVGFPR1dz&#34;&gt;微软2022暑期实习招聘 - 求职干货大宝书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽德投资
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/6BoymRfQs2j0HkXMQK40gQ&#34;&gt;春招提前批，速拿OFFER | 宽德投资2022校招 - 信息技术部专场&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220114111046898.png&#34; alt=&#34;image-20220114111046898&#34; style=&#34;zoom:30%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;方向&#34;&gt;方向&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;核心业务 &amp;gt; 核心业务基础架构 &amp;gt; 边缘业务基础架构 &amp;gt; 边缘业务&lt;/li&gt;
&lt;li&gt;尽量不要去内部系统开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面试中&#34;&gt;面试中&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面试中写算法题，要多和面试官交流&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写之前，问清楚数据量、数据约束&lt;/li&gt;
&lt;li&gt;写的过程中，边写边阐述思路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说话不要太急、平和、不咄咄逼人（仅针对我自己）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试中考察算法题，能给出解决方案当然最好，但同样重要的是&lt;strong&gt;展示&lt;/strong&gt;，因为是在面试，哪怕想出解决方案了，如果不能很好的展示，也是没用的。要学会清晰展示自己的思考过程、思路，还可以多和面试官进行交流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思路和沟通能力，比解出答案更重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反问的时候可以问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是哪个部分、部门主要是做什么的&lt;/li&gt;
&lt;li&gt;面试流程：一共有几面&lt;/li&gt;
&lt;li&gt;面试表现&lt;/li&gt;
&lt;li&gt;对于提升自己，面试官有什么建议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;职业规划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备一段最能体现我编程能力的代码 https://www.nowcoder.com/discuss/425657?channel=-1&amp;amp;source_id=subject_nctrack&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试前提前准备一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“为什么投我们公司或者我们小组或者后台研发”
&lt;ul&gt;
&lt;li&gt;平台比较大，对自身发展有帮助&lt;/li&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220204111621730.png&#34; alt=&#34;image-20220204111621730&#34; style=&#34;zoom:30%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;评价一下自己前几面的表现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;演技&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最近读了哪些书：假装读过，然后往八股文引&lt;/li&gt;
&lt;li&gt;脑筋急转弯：不要直接给最优解，体现思考过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软实力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持自信&lt;/li&gt;
&lt;li&gt;学会用积极的情绪感染面试官，提供情绪价值
&lt;ul&gt;
&lt;li&gt;活泼一点、积极向上、大大方方、自然不拘谨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回答面试官问题时，可以用生动形象的例子，这样可能效果更好，也能体现自己的思考&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导面试官&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试时灵活点，不要太憨，学会引导面试官&lt;/li&gt;
&lt;li&gt;聊项目时，可以引导到八股文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试前，看一看对应公司的面经，提前做准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试时问一下对方是哪个部门的，方便后续面试时做相应的准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://b23.tv/ajxmk5&#34;&gt;如何回答面试官最后一个问题——钻石版-哔哩哔哩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;其次就是面试总结了。面试过程当中我建议大家开启手机录音。这样方便事后复盘，我是每次都会再听一遍自己的录音，不论是写面经还是琢磨自己的回答有录音真的方便很多。因为面试期间的紧张感会让你很难用最好的描述回答清楚问题，那么事后总结就会让你在下次遇到同样的问题的时候回答的更好。如果说大家有小伙伴在一起战斗的话那么经常互相分享经验真的会决定你能不能拿到offer，大家的经验会让你迅速成长，说实话面试实习这2月也是我成长的最快的一个阶段。&lt;br&gt;
最后就是信息。在面试结束的时候，一般面试官都会问：你有什么问题问我。这个时候我个人最经常问的就是这个部门正在做什么，如果我进来我会接触到什么。面试官才是最了解这个部门的人，只有从他的口里得到的信息才是最真实也是最有用的，通过他的回答你会了解到这个部门做的产品或者是使用的技术，对于自己的学习方向也有很大的指向作用。其次，我会问的问题就是：您认为我在哪些方面可以提高自己。这个问题其实从侧面可以让你获取你此次面试的结果。因为这个问题不像问我面试能不能过这样直白的面试禁忌。一般面试官会指明他认为你的缺点，如果他在说的时候带有建议的语气以及对你其他方面的肯定那基本是十拿九稳了，再不济有大佬对你的一个建议指导对你自己查漏补缺也是非常有帮助的。说下我自己的经历吧，我在面阿里云3面的时候，那位p9大佬在我问完这个问题之后不仅肯定了我的一些表现还给我推荐了2本书建议我去阅读，这真的是非常良好的面试体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/56655579&#34;&gt;cyc2018大佬的面经&lt;/a&gt; 读后总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于面试官的问题，要能回答到点上；对于自己擅长的知识点，要学会展开讲。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试过程中，要表现得比较自信（不要自大，也不要自卑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这次面试我表现地非常自信，自己知道的知识都很有信心地表达出来，被问到不会的内容也不会那么慌张，和面试官探讨一些细节，然后说说自己的想法，还有自己看过相关的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整个春招过程中，会被拒很多次，但要时刻保持信心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要学会把问题往自己擅长的领域引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当被问到没有掌握的知识，可以通过讨论的方式，给出大概的思路，因为很多技术都是相通的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;位运算的问题，面试官让我之后完善了再发给他，过后我写了详细文档讲解了思路，以及使用 JUnit 进行了详细的单元测试，把文档和代码都发给了他&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;非技术问题回答的支支吾吾，然后面试官开始质疑我说的内容，给我压力，我没有当场反驳，就说了“哦，好像是这样的”。因为面试官全程都绷着脸，所以我也比较紧张，很多问题没回答好。&lt;/p&gt;
&lt;p&gt;这次面试失败的主要原因是自己在应对这种压力时处理地不是很好，主要体现在失去信心以及紧张。&lt;/p&gt;
&lt;p&gt;解决方法也简单，做好充分准备来保持信心，受到质疑的时候积极反驳，紧张的时候及时调整心态，可以试试深呼吸或者喝水。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试中还会涉及到非技术性问题，要有心理准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;面完之后我立马查了一下那个错排问题，证实了我的答案是正确的，于是写了一个详细的文档，联系 HR 让她发给面试官&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试回答不要太简单，适当展开，把知道的都说出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保持谦逊的态度。&lt;/strong&gt;：不要不懂装懂，不会的问题可以自己分析并提出自己的见解，对面试官提出的问题，&lt;strong&gt;可以当成和面试官的一次讨论&lt;/strong&gt;，不要紧张。&lt;strong&gt;不会的问题，可以在最后的提问环节，再和面试官深入探讨一波&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;展示对知识的热情&lt;/strong&gt;。对面试官提出的问题，你一定要绘声绘色的去回答，讲出自己的理解，而不是非常死板的死记硬背。知识是背下来的还是真正理解的，一般老辣的面试官深入问一下就心里有数了，当然这个是建立你对知识充分了解的基础上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**能说什么就说什么。**面试的时候，永远不是看你知不知道，而是看你知道多少，所以说面试官提出问题，&lt;strong&gt;你在思考的时候，一定要简单提一下你的思考过程&lt;/strong&gt;，主要是表现自己掌握的知识量，这样即使你没有回答到点上，你也会比什么都不说得到更好的评价。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**尝试和面试官产生共鸣。**也许很多时候，面试官提出的问题，他自己都没有想到答案，所以这个时候你要尝试站在和他同一水平上，进行平等交流讨论，一般来说面试官都会对你产生回应，从而使得这场面试更加和谐，增加你成功的几率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试完一家，总结好经验，就let it go吧，即使挂了也不要影响信心和心情，面试很多情况看缘分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求职过程中别和身边的人对比 ，别自我怀疑，专注于过程，别在意结果，反思总结，心态别崩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坚持 &lt;strong&gt;+&lt;/strong&gt; 努力 ，不到最后一刻别放弃&lt;/p&gt;
&lt;p&gt;by https://zhuanlan.zhihu.com/p/357871900&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把所有面试中的不顺利都当作是压力面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试难的部门，不一定就是好部门&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般是部门HR会先打电话联系我，然后再安排面试官进行面试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护好自己的面评&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放弃春招面试，可能导致秋招不给面试机会&lt;/li&gt;
&lt;li&gt;任何一场面试，都不要放松，都要重视&lt;/li&gt;
&lt;li&gt;不要相信“提前批 不影响 正式批”，任何一场面试都会有面评记录，后续面试面试官会看的！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试时，遇到不会的知识点，不用担心，面试更看重的是思维+表达+沟通+学习能力，而不是已经掌握了多少&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内推&#34;&gt;内推&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lzy 上海 量化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;误入凡尘里 B站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xxb 阿里云&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gc 微信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;有想加入字节跳动 &lt;strong&gt;基础架构&lt;/strong&gt; 的同学可以找我内推呀 大量实习和提前批HC！（请搜索基础架构才是~）&lt;br&gt;
直推部门老大直接面试无笔试：可以把简历发送至&lt;a href=&#34;mailto:zhuhaochuan.snow@bytedance.com&#34;&gt;zhuhaochuan.snow@bytedance.com&lt;/a&gt; （注明实习还是校招，岗位）&lt;br&gt;
投递链接：https://job.toutiao.com/s/JNAvu8A&lt;br&gt;
内推码:QDZH4QP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;liuqiyang@bytedance.com&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;北京图森未来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;基础架构&lt;/p&gt;
&lt;p&gt;目前我也是图森在南京大学的校园大使，大家有想去实习和工作的可以私信我内推呀&lt;/p&gt;
&lt;p&gt;https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;春招后&#34;&gt;春招后&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就算春招失利，也不要灰心，秋招还有机会，参考cyc2018大佬的经历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;暑期实习-and-秋招&#34;&gt;暑期实习 and 秋招&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;秋招也要早做准备！&lt;/li&gt;
&lt;li&gt;实习时，可以利用晚上和周末时间来自我提升，因为还需要为秋招做准备&lt;/li&gt;
&lt;li&gt;不要相信实习单位所谓的“一定可以转正成功”&lt;/li&gt;
&lt;li&gt;秋招的面试表现直接影响薪资，且竞争激烈程度大于春招，要更加重视&lt;/li&gt;
&lt;li&gt;秋招很重要，不要为了实习转正牺牲秋招，&lt;strong&gt;给自己更多的选择&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可能会问实习经历，也要准备一下，做了什么？难点是什么？如何解决？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;秋招后&#34;&gt;秋招后&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;秋招结束也不要放弃机会，有一些补录以及春招的机会，说不定比秋招的offer更好&lt;/li&gt;
&lt;/ul&gt;
">春招保卫战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习Java锁机制过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1YB4y1P7xC?p=1&#34;&gt;多线程高并发底层锁机制与优化最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;synchronized&#34;&gt;Synchronized&lt;/h2&gt;
&lt;p&gt;在普通方法上加synchronized，锁的是对象&lt;/p&gt;
&lt;p&gt;在静态方法上加synchronized，锁的是class&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;h4 id=&#34;jdk16之前&#34;&gt;jdk1.6之前&lt;/h4&gt;
&lt;p&gt;对 对象内部的monitor对象 进行加锁，如果加锁失败，进入等待队列，当锁释放时，从等待队列中依次唤醒线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非公平锁：先尝试获取锁，如果失败，则进入等待队列&lt;/li&gt;
&lt;li&gt;公平锁：直接进入等待队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重量级锁&lt;/li&gt;
&lt;li&gt;线程挂起和唤醒时，需要从用户态切换到内核态
&lt;ul&gt;
&lt;li&gt;之所以需要切换到内核态，是因为，挂起和唤醒操作，是依赖于内核程序完成的，只有进入内核态，才能调用内核中的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42013590/article/details/107327439&#34;&gt;什么是CPU的用户态和内核态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java锁机制详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习脑裂问题过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是脑裂问题&#34;&gt;什么是脑裂问题&lt;/h2&gt;
&lt;p&gt;简单说，就是在一个集群中，出现两个master节点&lt;/p&gt;
&lt;p&gt;原本，一个集群中，只有一个master节点，可以看做是大脑，现在出现了两个，或者多个，就可以想象成大脑分裂了，所以叫脑裂问题&lt;/p&gt;
&lt;h2 id=&#34;成因以及造成的后果&#34;&gt;成因以及造成的后果&lt;/h2&gt;
&lt;p&gt;主要是由网络通信故障导致的&lt;/p&gt;
&lt;p&gt;一般来说，集群中的master节点都是选举产生的，想象一下，假设两个机房之间出现了通信故障，那么分处于两个机房中的节点就会各自选举出master节点，当网络恢复时，就不知道该听哪个master节点的了。&lt;/p&gt;
&lt;h2 id=&#34;如何避免&#34;&gt;如何避免&lt;/h2&gt;
&lt;p&gt;知道了成因，那么，想解决脑裂问题，就需要避免假死亡现象的产生，因为如果master节点正常死亡，监控节点重新选举master节点，是不会产生脑裂问题的。&lt;/p&gt;
&lt;p&gt;有以下三种常见方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;冗余通信：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过半机制（Quorum）：zookeeper采用的防止脑裂问题的方法，通过这个机制，可以确保就算发生了网络故障，也只会有一个master节点被选出&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211106134247658.png&#34; alt=&#34;image-20211106134247658&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享存储隔离（Fencing）：能看到共享资源的节点就表示在集群中，能够获得共享资源的锁的节点就是master，看不到共享资源的节点就不在集群中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u013374645/article/details/93140148&#34;&gt;面试题：Zookeeper是如何解决脑裂问题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/394160966&#34;&gt;分布式系统的“脑裂”到底是个什么玩意？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u014156013/article/details/81226424&#34;&gt;脑裂问题以及如何避免&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">脑裂问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习限流算法过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;计数器&#34;&gt;计数器&lt;/h2&gt;
&lt;p&gt;设置一个计数器counter，其有效时间为1分钟（即每分钟计数器会被重置为0）&lt;/p&gt;
&lt;p&gt;存在临界问题&lt;/p&gt;
&lt;h2 id=&#34;漏桶-leaky-bucket&#34;&gt;漏桶 Leaky Bucket&lt;/h2&gt;
&lt;p&gt;漏桶算法思路很简单，水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，而当入小于出的情况下，漏桶不起任何作用。&lt;/p&gt;
&lt;p&gt;流入：以任意速率往桶中放入水滴。&lt;br&gt;
流出：以固定速率从桶中流出水滴。&lt;/p&gt;
&lt;p&gt;存在效率较低的问题&lt;/p&gt;
&lt;h2 id=&#34;令牌桶-token-bucket&#34;&gt;令牌桶 Token Bucket&lt;/h2&gt;
&lt;p&gt;系统会按恒定 1/QPS 时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水)，如果桶已经满了，令牌就溢出了。如果桶未满，令牌可以积累。新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。&lt;/p&gt;
&lt;p&gt;流入：以固定速率从桶中流入水滴&lt;br&gt;
流出：按照任意速率从桶中流出水滴&lt;/p&gt;
&lt;h2 id=&#34;滑动窗口-rolling-window&#34;&gt;滑动窗口 Rolling Window&lt;/h2&gt;
&lt;p&gt;滑动窗口代表一段时间，将滑动窗口段划分成多个小格，通过统计滑动窗口中的总请求数，判断是否触发限流。每过一段时间，都将窗口往前移动。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/v2-b2fca280cb01069bc3b30c8b55f9d973_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/duanxz/p/4123068.html&#34;&gt;常见限流算法介绍（漏桶算法、令牌桶算法）及实现--待整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/122431276&#34;&gt;精度不够，滑动时间来凑「限流算法第二把法器：滑动时间窗口算法」- 第301篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">限流算法学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习JVM垃圾回收过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1T34y1X7xx?p=2&amp;amp;spm_id_from=pageDriver&#34;&gt;一节课掌握ZGC垃圾回收器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;手动回收的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄漏&lt;/li&gt;
&lt;li&gt;重复回收（多线程）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用计数的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;循环引用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923134958252.png&#34; alt=&#34;image-20210923134958252&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc工作原理&#34;&gt;GC工作原理&lt;/h2&gt;
&lt;h3 id=&#34;minor-gc新生代gc&#34;&gt;Minor GC（新生代GC）&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png&#34; alt=&#34;image-20210727152911187&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等&lt;/li&gt;
&lt;li&gt;根可达算法：将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为&lt;strong&gt;非垃圾对象&lt;/strong&gt;，其余未标记的对象都是垃圾对象。&lt;/li&gt;
&lt;li&gt;每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。&lt;/li&gt;
&lt;li&gt;如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minor-gc-vs-full-gc&#34;&gt;Minor GC VS Full GC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。&lt;/li&gt;
&lt;li&gt;Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短&lt;/li&gt;
&lt;li&gt;算法不同：
&lt;ul&gt;
&lt;li&gt;Mnior GC用空间换时间，需要两个内存空间，直接Copy&lt;/li&gt;
&lt;li&gt;Full GC用时间换空间，需要Mark+Compact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zgc垃圾回收器&#34;&gt;ZGC垃圾回收器&lt;/h2&gt;
&lt;p&gt;将堆划分成3部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小页面（2M）：对象小于256KB&lt;/li&gt;
&lt;li&gt;中页面（32M）：对象在256KM~4MB&lt;/li&gt;
&lt;li&gt;大页面（&amp;gt;32M）：对象大于4M&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指针着色：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png&#34; alt=&#34;image-20210923143727759&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。&lt;/li&gt;
&lt;li&gt;并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）&lt;/li&gt;
&lt;li&gt;再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。&lt;/li&gt;
&lt;li&gt;并发转移准备：筛选需要转移的分区&lt;/li&gt;
&lt;li&gt;初始转移：转移与GC Roots直接关联的对象&lt;/li&gt;
&lt;li&gt;并发转移：转发表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么初始标记阶段，不标记所有对象？&lt;/p&gt;
&lt;p&gt;因为耗时少！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么不直接进行并发标记？即，初始标记的意义是什么？&lt;/p&gt;
&lt;p&gt;初始标记的意义：找根对象&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png&#34; alt=&#34;image-20210924093232733&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;z的含义&#34;&gt;Z的含义&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可能大伙还惦记这标题吧？&lt;strong&gt;ZGC 的 Z 是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实没啥意思，就是个名字而已。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/yessimida/article/details/109763732&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;其他垃圾回收器&#34;&gt;其他垃圾回收器&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png&#34; alt=&#34;image-20210923142511010&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新生代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial：标记-复制算法&lt;/li&gt;
&lt;li&gt;ParNew：标记-复制算法+多线程+STW尽量短&lt;/li&gt;
&lt;li&gt;Parallel Scavenge：标记-复制算法+多线程+吞吐量可控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial Old：标记-整理算法&lt;/li&gt;
&lt;li&gt;Parallel Old：标记-整理算法+多线程&lt;/li&gt;
&lt;li&gt;CMS：标记-清除算法+STW尽量短
&lt;ul&gt;
&lt;li&gt;初始标记、并发标记、重新标记、并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jdk9 默认的收集器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区+分代&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/aef0f4765098&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZGC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STW极短&lt;/li&gt;
&lt;li&gt;分区思想&lt;/li&gt;
&lt;li&gt;染色指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/kevin7234/p/10644654.html&#34;&gt;jvm minor gc 为什么比 full gc 快很多&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/35172533&#34;&gt;为什么minor gc比full gc/major gc快？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java垃圾回收（GC）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习Zookeeper过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1av411w7hp?from=search&amp;amp;seid=1946340734056821588&amp;amp;spm_id_from=333.337.0.0&#34;&gt;分布式架构Zookeeper入门实战到底层原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一致性&#34;&gt;一致性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。
&lt;ul&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。&lt;/li&gt;
&lt;li&gt;弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;zookeeper只保证最终一致性&lt;/p&gt;
&lt;h2 id=&#34;zookeeper-最终一致性-实现原理&#34;&gt;zookeeper 最终一致性 实现原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210916135047212.png&#34; alt=&#34;image-20210916135047212&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Zab协议
&lt;ul&gt;
&lt;li&gt;领导者选举机制
&lt;ul&gt;
&lt;li&gt;比较两个节点谁的数据更&lt;strong&gt;新&lt;/strong&gt; (zxid)，如果zxid相等，则比较myid，myid越大越好。zxid为请求id，对应每一个请求，且越靠后的请求，zxid越大。myid对应node节点，每个节点都有一个互不相等的myid，由配置文件指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过半机制&lt;/li&gt;
&lt;li&gt;两阶段提交机制
&lt;ul&gt;
&lt;li&gt;预提交&lt;/li&gt;
&lt;li&gt;ACK（过半机制）&lt;/li&gt;
&lt;li&gt;提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Zab协议的问题：
&lt;ul&gt;
&lt;li&gt;节点越多，写请求处理越慢，因为需要等待半数节点返回ACK&lt;/li&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;新增观察者，不参与两阶段提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/546b9dd86c91&#34;&gt;弱一致性、强一致性、最终一致性、顺序一致性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Zookeeper学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录如何实现一个秒杀系统，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1CE411s7xN?p=2&amp;amp;spm_id_from=pageDriver&#34;&gt;1小时带你用Redis轻松实现秒杀系统（附秒杀系统优化实战）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是秒杀系统&#34;&gt;什么是秒杀系统&lt;/h2&gt;
&lt;p&gt;其实主要的业务流程就是下订单、减库存，只是，该业务流程是在高并发、大流量的场景下进行的。&lt;/p&gt;
&lt;h2 id=&#34;并发量&#34;&gt;并发量&lt;/h2&gt;
&lt;p&gt;一般秒杀系统的并发量是万级别的，几万、几十万、几百万。&lt;/p&gt;
&lt;p&gt;单机MySQL的并发量一般为几百，最多一千。&lt;/p&gt;
&lt;p&gt;单机Tomcat的并发量一般也为几百。&lt;/p&gt;
&lt;p&gt;单机Redis的并发量一般为几万。&lt;/p&gt;
&lt;h2 id=&#34;优化前&#34;&gt;优化前&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://gitee.com/Bule-Zst/picture/raw/master/Seckill-%E4%BC%98%E5%8C%96%E5%89%8D.jpg&#34;&gt;项目下载&lt;/a&gt;（为了省事，我把文件后缀改成jpg了，这样直接用图床帮我存到云端）&lt;/p&gt;
&lt;p&gt;就是一个简单的购物系统，先下单之后再减库存，这个系统在业务逻辑上是没有bug的，最主要的问题就是性能差。&lt;/p&gt;
&lt;p&gt;需要注意的是，在系统里用到了事务，从而保证下单和减库存是原子操作，这里补充说一下Springboot事务失效的两个常见原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部调用：事务基于AOP，会对事务对象包装一个代理对象，因此不能直接调用事务对象的方法，应该使用Springboot的依赖注入，使用注入对象的方法。&lt;/li&gt;
&lt;li&gt;数据库存储引擎不支持：MyISAM是不支持事务的，所以可以检查一下数据库表的存储引擎，如果是MyISAM，需要改成InnoDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;吞吐量为130/s&lt;/p&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;h3 id=&#34;redis缓存&#34;&gt;Redis缓存&lt;/h3&gt;
&lt;p&gt;使用redis做缓存&lt;/p&gt;
&lt;p&gt;在秒杀之前，把商品库存信息放到redis中&lt;/p&gt;
&lt;p&gt;在秒杀时，先对redis中的库存执行decrement方法，之后判断返回结果是否小于0，如果返回结果大于等于0，则进行秒杀业务，否则说明库存为零。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;吞吐量为1400/s&lt;/p&gt;
&lt;h4 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h4&gt;
&lt;p&gt;缓存不一致问题：一旦秒杀业务过程中发生错误导致事务回滚，那么redis中的库存信息就和数据库中的不一致了。&lt;/p&gt;
&lt;p&gt;解决方案：如果事务中出现报错，就在catch语句中让库存加一。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jvm缓存&#34;&gt;JVM缓存&lt;/h3&gt;
&lt;p&gt;使用ConcurrentHashMap在JVM级别做缓存，当发现redis中库存为零后，使用ConcurrentHashMap标记当前商品为False。&lt;/p&gt;
&lt;p&gt;当收到秒杀请求时，首先判断ConcurrentHashMap中当前商品是否被标记，如果被标记了，说明库存为零，直接return。&lt;/p&gt;
&lt;p&gt;使用JVM级别的缓存能更好地提高系统性能，因为redis缓存是需要和redis服务做交互的，伴随网络请求，因此性能没有JVM级别快。&lt;/p&gt;
&lt;p&gt;吞吐量为：1815/s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if( concurrentHashMap.get(id) != null ) {
    return &amp;quot;fail&amp;quot;;
}

Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    concurrentHashMap.put( id, true );
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;存在的问题-2&#34;&gt;存在的问题&lt;/h4&gt;
&lt;p&gt;JVM级缓存与redis缓存不一致，主要有两种场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当秒杀业务中存在异常时，会对redis和concurrentHashMap进行恢复，对redis中的缓存进行increment操作，对ConcurrentHashMap进行remove操作，但此时，redis中的库存很可能是负数的情况，因为在高并发情况下，大量请求被接受，所以redis会执行大量的decrement操作，虽然后续会执行increment操作进行恢复，但是有概率在新的请求被处理时，increment操作还未执行，当新的请求进来后，会发现redis中库存为负数，从而在concurrentHashMap进行标记。所以最终，redis中的库存数可能不为0，而concurrentHashMap中对应的商品却被标记了。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210914163636067.png&#34; alt=&#34;image-20210914163636067&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在分布式场景下，不同JVM中的concurrentHashMap很难保证同步，可能在某个JVM中对hashMap进行了恢复，但是别的JVM中，hashMap并没有进行恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是分布式导致的不一致问题，可以使用zookeeper解决。当zookeeper中节点的数据发生改变后，zookeeper会主动通知监听该节点的进程，从而实现分布式下JVM级的缓存同步。之所以使用zookeeper，是因为zookeeper是CP的模型，能较好保证各节点之间的一致性。&lt;/li&gt;
&lt;li&gt;如果是单机不一致问题，则借助lua脚本，让redis的减一操作和恢复操作原子化，因为之前出问题的原因就是decr和incr二者之间不具有原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;修复-lua&#34;&gt;修复-lua&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if( concurrentHashMap.get(id) != null ) {
    return &amp;quot;fail&amp;quot;;
}

String RELEASE_LOCK_LUA_SCRIPT = &amp;quot;if redis.call(&#39;decr&#39;, KEYS[1]) == -1 then redis.call(&#39;incr&#39;, KEYS[1]) return &#39;-1&#39; else return redis.call(&#39;get&#39;, KEYS[1]) end&amp;quot;;
DefaultRedisScript&amp;lt;String&amp;gt; redisScript = new DefaultRedisScript&amp;lt;&amp;gt;(RELEASE_LOCK_LUA_SCRIPT,String.class);
String result = stringRedisTemplate.execute(redisScript, Collections.singletonList(id+&amp;quot;&amp;quot;) );
if( result.equals(&amp;quot;-1&amp;quot;) ) {
    concurrentHashMap.put( id, true );
    return &amp;quot;fail&amp;quot;;
}

try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
return &amp;quot;ok&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;吞吐量：1700/s&lt;/p&gt;
&lt;h3 id=&#34;其他优化手段&#34;&gt;其他优化手段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限流降级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis集群：提高redis并发量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微服务架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步下单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端优化：静态页面、CDN&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">秒杀系统-实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录优化MySQL慢查询的完整过程以及心得体会。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;随机生成了50w条数据，具体步骤可以参考这篇博客：&lt;a href=&#34;https://blog.csdn.net/qq_36994788/article/details/73216961&#34;&gt;mysql插入千万条随机数据&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;
&lt;p&gt;Explain语句结果中各个字段分表表示什么：&lt;/p&gt;
&lt;p&gt;各字段含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样&lt;/li&gt;
&lt;li&gt;select_type : 查询类型，有简单查询、联合查询、子查询等&lt;/li&gt;
&lt;li&gt;type：针对单表的查询方式
&lt;ul&gt;
&lt;li&gt;all、index、range、ref、eq_ref、const，从左到右效率依次提升&lt;/li&gt;
&lt;li&gt;all：全表扫描&lt;/li&gt;
&lt;li&gt;index：根据索引的顺序全表扫描&lt;/li&gt;
&lt;li&gt;range：索引范围查询，between、&amp;gt;、&amp;lt;、in&lt;/li&gt;
&lt;li&gt;ref：查询条件使用索引，但不是唯一索引&lt;/li&gt;
&lt;li&gt;eq_ref：查询条件使用唯一索引&lt;/li&gt;
&lt;li&gt;const：查询条件使用主键，优化器会把查询优化为一个常量&lt;/li&gt;
&lt;li&gt;by https://blog.csdn.net/dennis211/article/details/78170079&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys：可能用到的索引&lt;/li&gt;
&lt;li&gt;key : 实际用到的索引&lt;/li&gt;
&lt;li&gt;rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）&lt;/li&gt;
&lt;li&gt;Extra：
&lt;ul&gt;
&lt;li&gt;Impossible where：查询条件为false&lt;/li&gt;
&lt;li&gt;Using where：顺序扫描，where 条件查询&lt;/li&gt;
&lt;li&gt;Using index：覆盖索引&lt;/li&gt;
&lt;li&gt;Using index condition：索引下推
&lt;ul&gt;
&lt;li&gt;根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表&lt;/li&gt;
&lt;li&gt;在表上建立联合索引（name, age）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table1 where name like &amp;quot;张%&amp;quot; and age = 23;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102404385.png&#34; alt=&#34;image-20210913102404385&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913125829371.png&#34; alt=&#34;image-20210913125829371&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;优化前统计&#34;&gt;优化前统计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select * from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.55s&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开始优化&#34;&gt;开始优化&lt;/h2&gt;
&lt;h3 id=&#34;是否走了索引&#34;&gt;是否走了索引&lt;/h3&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102307124.png&#34; alt=&#34;image-20210913102307124&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;结果分析：&lt;/p&gt;
&lt;p&gt;Extra中为Using where，表示未使用索引，根据where条件顺序扫描&lt;/p&gt;
&lt;p&gt;解决方案：对deptno列建立索引&lt;/p&gt;
&lt;p&gt;建立索引后，Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105003822.png&#34; alt=&#34;image-20210913105003822&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;时间: 3.636s&lt;/p&gt;
&lt;p&gt;结果分析：时间反而变长了，猜测，可能是发生了回表操作。&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;p&gt;尝试只select deptno，从而使用覆盖索引。&lt;/p&gt;
&lt;p&gt;select deptno from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.095s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110312538.png&#34; alt=&#34;image-20210913110312538&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意到Extra出现Using index，表示使用了覆盖索引。&lt;/p&gt;
&lt;p&gt;尝试select ename，在这种情况下，会发生回表操作&lt;/p&gt;
&lt;p&gt;select ename from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 3.189s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110337524.png&#34; alt=&#34;image-20210913110337524&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;未使用覆盖索引&lt;/p&gt;
&lt;p&gt;建立联合索引，(deptno, ename)&lt;/p&gt;
&lt;p&gt;select ename from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.033s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105937845.png&#34; alt=&#34;image-20210913105937845&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用了覆盖索引&lt;/p&gt;
&lt;p&gt;验证结束&lt;/p&gt;
&lt;h3 id=&#34;是否是最优索引&#34;&gt;是否是最优索引&lt;/h3&gt;
&lt;p&gt;where条件只对deptno进行了约束，因此是最优索引&lt;/p&gt;
&lt;h3 id=&#34;是否查询了过多字段&#34;&gt;是否查询了过多字段&lt;/h3&gt;
&lt;p&gt;select *，查询字段过多，应根据实际业务需要，减少查询字段，例如只查询ename和deptno，这样就可以使用联合索引进行优化。&lt;/p&gt;
&lt;h3 id=&#34;是否应该进行分库分表&#34;&gt;是否应该进行分库分表&lt;/h3&gt;
&lt;p&gt;暂时不考虑分库分表&lt;/p&gt;
&lt;h3 id=&#34;是否数据库服务所在机器性能过低&#34;&gt;是否数据库服务所在机器性能过低&lt;/h3&gt;
&lt;p&gt;暂时不考虑机器性能&lt;/p&gt;
">MySQL慢查询优化-实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习ConcurrentHashMap过程中的学习笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/4dTDHcwa7M9&#34;&gt;ConcurrentHashMap底层原理与源码分析深入详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;非线程安全&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210901135831288.png&#34; alt=&#34;image-20210901135831288&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;hashtable&#34;&gt;Hashtable&lt;/h2&gt;
&lt;p&gt;线程安全：对put方法加synchronized锁&lt;/p&gt;
&lt;p&gt;缺点：性能差&lt;/p&gt;
&lt;h2 id=&#34;concurrenthashmap-jdk17&#34;&gt;ConcurrentHashMap jdk1.7&lt;/h2&gt;
&lt;p&gt;class Segment extends Reentralock&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210901141125962.png&#34; alt=&#34;image-20210901141125962&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;segments数组长度为2的幂，为什么？因为计算下标时需要 &lt;code&gt;h &amp;amp; (length-1)&lt;/code&gt;，因此，必须是2的幂。&lt;/p&gt;
&lt;p&gt;同时，Segment对象内部的数组，长度也是2的幂，大小为 &lt;code&gt;initialCapacity / concurrencyLevel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据initialCapacity、loadFactor和concurrencyLevel，计算segments数组的大小、segment对象内部table的大小和threshold&lt;/li&gt;
&lt;li&gt;然后，初始化Segment对象，并放到segments[0]&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    while (ssize &amp;lt; concurrencyLevel) {
        ++sshift;
        ssize &amp;lt;&amp;lt;= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &amp;lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &amp;lt; c)
        cap &amp;lt;&amp;lt;= 1;
    // create segments and segments[0]
    Segment&amp;lt;K,V&amp;gt; s0 =
        new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
    Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;put&#34;&gt;put&lt;/h3&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key获取Segment对象，如果不存在，则初始化，使用CAS赋值给segments数组&lt;/li&gt;
&lt;li&gt;尝试对Segment对象进行加锁
&lt;ul&gt;
&lt;li&gt;如果加锁失败，则边尝试加锁，边遍历table[key]&lt;/li&gt;
&lt;li&gt;如果遍历过程中，找到了对应的entry对象，则&lt;strong&gt;停止遍历&lt;/strong&gt;。如果遍历完，依旧没有找到entry对象，则新建entry对象，然后&lt;strong&gt;停止遍历&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;停止遍历后
&lt;ul&gt;
&lt;li&gt;继续尝试加锁，如果尝试次数超过 &lt;code&gt;MAX_SCAN_RETRIES&lt;/code&gt;，则调用lock方法，阻塞加锁&lt;/li&gt;
&lt;li&gt;如果在尝试加锁过程中，发现table[key]被修改（first != table[key]），则重新开始遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只有当新建entry对象时，才会在加锁后获取到entry对象，其余情况下，获取到的都为null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加锁成功后，开始遍历table[key]
&lt;ul&gt;
&lt;li&gt;如果找到对应entry对象，则修改其value值&lt;/li&gt;
&lt;li&gt;如果没有找到entry对象，则判断之前是否已经新建过entry对象，如果没有，则新建。将新建的entry对象加入到table[key]的头结点之前，然后判断是否需要进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    Segment&amp;lt;K,V&amp;gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        int index = (tab.length - 1) &amp;amp; hash;
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}

private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value) {
    HashEntry&amp;lt;K,V&amp;gt; first = entryForHash(this, hash);
    HashEntry&amp;lt;K,V&amp;gt; e = first;
    HashEntry&amp;lt;K,V&amp;gt; node = null;
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        HashEntry&amp;lt;K,V&amp;gt; f; // to recheck first below
        if (retries &amp;lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries &amp;gt; MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries &amp;amp; 1) == 0 &amp;amp;&amp;amp;
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;扩容&#34;&gt;扩容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先，segment数组的长度是不会变的，与并发级别（concurrencyLevel）相同，扩容只在segment对象内部进行&lt;/li&gt;
&lt;li&gt;在put方法中，若segment中元素个数超过threshold，则进行rehash。
&lt;ul&gt;
&lt;li&gt;将table大小扩展一倍，并对所有元素放到新table中，同时根据比例因子更新threshold&lt;/li&gt;
&lt;li&gt;这里有一个需要说明的地方，在转移中，会去寻找最后一节不需要改动的链表，然后将其整个移动到新table中。怎么理解呢？因为在移动过程中，需要重复创建Entry，比较耗费资源，所以能尽量不创建就不创建。因此，转移过程中，会先找到 lastRun 节点，该节点后面的节点对应的hash值和该节点都一样，所以可以一起移动到新table中。然后再对lastRun节点之前的节点一个一个进行转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//扩容，Segment中，只对Segment中的HashEntry[]扩容
@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
private void rehash(HashEntry&amp;lt;K,V&amp;gt; node) {
	HashEntry&amp;lt;K,V&amp;gt;[] oldTable = table;//保存老的HashEntry[]
	int oldCapacity = oldTable.length;
	int newCapacity = oldCapacity &amp;lt;&amp;lt; 1;//扩容为原来的2倍
	threshold = (int)(newCapacity * loadFactor);//计算新的阈值
	HashEntry&amp;lt;K,V&amp;gt;[] newTable =
		(HashEntry&amp;lt;K,V&amp;gt;[]) new HashEntry[newCapacity];//创建新的HashEntry[]
	int sizeMask = newCapacity - 1;
	for (int i = 0; i &amp;lt; oldCapacity ; i++) {//循环移动老的数组中的元素
		HashEntry&amp;lt;K,V&amp;gt; e = oldTable[i];
		if (e != null) {
			HashEntry&amp;lt;K,V&amp;gt; next = e.next;
			int idx = e.hash &amp;amp; sizeMask;//计算在HashEntry[]中存放的位置
			if (next == null)   //当前节点的下一个节点为null，说明当前链表就一个节点
				newTable[idx] = e;//直接赋值
			else { //存在链表
				HashEntry&amp;lt;K,V&amp;gt; lastRun = e;
				int lastIdx = idx;
				//循环找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
				for (HashEntry&amp;lt;K,V&amp;gt; last = next;
					 last != null;
					 last = last.next) {
					int k = last.hash &amp;amp; sizeMask;
					if (k != lastIdx) {
						lastIdx = k;
						lastRun = last;
					}
				}
				newTable[lastIdx] = lastRun;//复制链表
				//处理lastRun之前的节点，这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
				for (HashEntry&amp;lt;K,V&amp;gt; p = e; p != lastRun; p = p.next) {
					V v = p.value;
					int h = p.hash;
					int k = h &amp;amp; sizeMask;
					HashEntry&amp;lt;K,V&amp;gt; n = newTable[k];
					newTable[k] = new HashEntry&amp;lt;K,V&amp;gt;(h, p.key, v, n);
				}
			}
		}
	}
	 // 将新加的 node 放到新数组中刚刚的两个链表之一的头部
	int nodeIndex = node.hash &amp;amp; sizeMask;
	node.setNext(newTable[nodeIndex]);
	newTable[nodeIndex] = node;
	table = newTable;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;concurrenthashmap-jdk18&#34;&gt;ConcurrentHashMap jdk1.8&lt;/h2&gt;
&lt;h3 id=&#34;sizectl&#34;&gt;sizeCtl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-1：正在初始化&lt;/li&gt;
&lt;li&gt;0：未进行初始化&lt;/li&gt;
&lt;li&gt;&amp;gt;0：
&lt;ul&gt;
&lt;li&gt;若还未进行初始化，则为初始化时 &lt;code&gt;tabel&lt;/code&gt; 的容量&lt;/li&gt;
&lt;li&gt;else，为触发下一次扩容的阈值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果sizeCtl小于0，则说明正在进行初始化，通过 &lt;code&gt;Thread.yield()&lt;/code&gt; 让出CPU时间&lt;/li&gt;
&lt;li&gt;else
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;sizeCtl&lt;/code&gt; 的值赋值为 &lt;code&gt;sc&lt;/code&gt;，作为备份，然后将sizeCtl赋值为-1
&lt;ul&gt;
&lt;li&gt;如果sc大于0，初始化长度为sc的table&lt;/li&gt;
&lt;li&gt;else，初始化长度为 &lt;code&gt;DEFAULT_CAPACITY&lt;/code&gt; 的table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;n-(n&amp;gt;&amp;gt;&amp;gt;2)&lt;/code&gt; 的值赋值给sizeCtl，&lt;code&gt;n-(n&amp;gt;&amp;gt;&amp;gt;2)&lt;/code&gt; 表示 &lt;code&gt;0.75*n&lt;/code&gt; ，所以sizeCtl为触发下一次扩容的阈值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Node&amp;lt;K,V&amp;gt;[] initTable() {
    Node&amp;lt;K,V&amp;gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &amp;lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                    table = tab = nt;
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;put-2&#34;&gt;put&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;for循环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果table为空，则初始化table，然后重新循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为空，则初始化node节点，然后放到table[i]中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果“放”操作成功，则结束循环&lt;/li&gt;
&lt;li&gt;因为存在并发，“放”的操作可能失败，如果失败，则重新循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]的状态是MOVED，说明当前正在扩容，则帮忙一起扩容，扩容结束后，重新循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以上3个条件都不满足，则对table[i]加锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为链表，则遍历链表，并维护binCount变量，寻找key是否存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在，则更新value，结束遍历&lt;/li&gt;
&lt;li&gt;如果不存在，利用尾插法，插入新的node节点，结束遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为红黑树，则向红黑树中插入node节点，将binCount设为2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入完成后，如果binCount大于等于TREEIFY_THRESHOLD（默认为8），则将table[i]由链表转换成红黑树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果key在原先链表、红黑树中不存在（即，需要插入新节点），则调用 &lt;code&gt;addCount(1L, binCount)&lt;/code&gt; 将count加1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;链表转红黑树&#34;&gt;链表转红黑树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据链表，生成新的TreeNode类型的双向链表，hd为头结点&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;TreeBin(TreeNode&amp;lt;K,V&amp;gt; b)&lt;/code&gt; 构造函数，由双向链表转成红黑树&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int index) {
    Node&amp;lt;K,V&amp;gt; b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            tryPresize(n &amp;lt;&amp;lt; 1);
        else if ((b = tabAt(tab, index)) != null &amp;amp;&amp;amp; b.hash &amp;gt;= 0) {
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
                    for (Node&amp;lt;K,V&amp;gt; e = b; e != null; e = e.next) {
                        TreeNode&amp;lt;K,V&amp;gt; p =
                            new TreeNode&amp;lt;K,V&amp;gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin&amp;lt;K,V&amp;gt;(hd));
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;treebin与treenode&#34;&gt;TreeBin与TreeNode&lt;/h6&gt;
&lt;p&gt;在jdk1.8的HashMap中，没有使用TreeBin，为什么ConcurrentHashMap中使用了TreeBin？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免红黑树头结点发生变化：
&lt;ul&gt;
&lt;li&gt;在节点插入到红黑树的过程中，头结点可能会因为左移而改变，但是在ConcurrentHashMap中，是需要对头结点进行加锁操作的，一旦头结点发生改变，那么别的线程，就不会受到锁的限制，从而造成错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;addcount&#34;&gt;addCount&lt;/h4&gt;
&lt;p&gt;功能梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让ConcurrentHashMap的size加x&lt;/li&gt;
&lt;li&gt;在满足一定条件的情况下，对ConcurrentHashMap进行扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流程梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加x部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对ConcurrentHashMap的size进行加x操作有两种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对counterCells加x（可以先看size方法，加深对counterCells的理解）&lt;/li&gt;
&lt;li&gt;对baseCount加x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先判断counterCells是否为空，如果不为空，则进入if内部，对counterCells加x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果counterCells为空，则尝试对baseCount进行加x操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果成功，则结束，进入后续扩容部分&lt;/li&gt;
&lt;li&gt;如果失败，则同样进入if内部，对counterCells加x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对counterCells加x的操作流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果counterCells为空，则①&lt;/li&gt;
&lt;li&gt;如果counterCells不为空，但是length小于等于0，则①
&lt;ul&gt;
&lt;li&gt;这里补充一点，代码里的写法是 &lt;code&gt;(m = as.length - 1) &amp;lt; 0&lt;/code&gt; ，为什么要这么做呢，因为后续需要使用m进行与操作获取数组下标位置，与的时候是需要用 &lt;code&gt;length-1&lt;/code&gt; 的，所以直接在上面的判断中进行赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果counterCells不为空，且length也大于0，则判断对应下标位置的元素 &lt;code&gt;as[ThreadLocalRandom.getProbe() &amp;amp; m]&lt;/code&gt; 是否为空，如果为空，则①&lt;/li&gt;
&lt;li&gt;如果对应下标位置的元素也不为空，则尝试直接对该元素进行加x操作，如果失败，则①&lt;/li&gt;
&lt;li&gt;①：调用 &lt;code&gt;fullAddCount(x, uncontended)&lt;/code&gt; 对counterCells加x，addCount方法结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩容部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不进行扩容的情况
&lt;ul&gt;
&lt;li&gt;check小于0&lt;/li&gt;
&lt;li&gt;对counterCells进行加x操作，并且check小于等于1&lt;/li&gt;
&lt;li&gt;调用fullAddCount对counterCells进行加x操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &amp;lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
        if (check &amp;lt;= 1)
            return;
        s = sumCount();
    }
    if (check &amp;gt;= 0) {
        Node&amp;lt;K,V&amp;gt;[] tab, nt; int n, sc;
        while (s &amp;gt;= (long)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != null &amp;amp;&amp;amp;
               (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc &amp;lt; 0) {
                if ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &amp;lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;fulladdcount&#34;&gt;fullAddCount&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;使用线程的探针值对h进行赋值&lt;/li&gt;
&lt;li&gt;for循环
&lt;ul&gt;
&lt;li&gt;如果counterCells不为空，且长度等于0
&lt;ul&gt;
&lt;li&gt;如果counterCells数组对应下标位置元素为空
&lt;ul&gt;
&lt;li&gt;将collide赋值为false&lt;/li&gt;
&lt;li&gt;如果counterCells未被其他线程占用，则尝试使用x为对应位置进行初始化，如果初始化成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果wasUncontended为false，则将wasUncontended改为true。
&lt;ul&gt;
&lt;li&gt;wasUncontended：表示上一次没有冲突&lt;/li&gt;
&lt;li&gt;如果为false，则说明有冲突，所以直接跳到最后一条语句，更新h的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尝试使用CAS对数组对应下标位置的元素加x
&lt;ul&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;更新h的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;else，如果cellsBusy为0（说明counterCells没有被其他线程占用）
&lt;ul&gt;
&lt;li&gt;则对counterCells进行初始化，初始化为长度为2的数组，并将x的值添加到数组中&lt;/li&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;else，尝试对baseCount进行加x操作
&lt;ul&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void fullAddCount(long x, boolean wasUncontended) {
    int h;
    if ((h = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit();      // force initialization
        h = ThreadLocalRandom.getProbe();
        wasUncontended = true;
    }
    
    boolean collide = false;                // True if last slot nonempty
    for (;;) {
        CounterCell[] as; CounterCell a; int n; long v;
        if ((as = counterCells) != null &amp;amp;&amp;amp; (n = as.length) &amp;gt; 0) {
            if ((a = as[(n - 1) &amp;amp; h]) == null) {
                if (cellsBusy == 0) {            // Try to attach new Cell
                    CounterCell r = new CounterCell(x); // Optimistic create
                    if (cellsBusy == 0 &amp;amp;&amp;amp;
                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                        boolean created = false;
                        try {               // Recheck under lock
                            CounterCell[] rs; int m, j;
                            if ((rs = counterCells) != null &amp;amp;&amp;amp;
                                (m = rs.length) &amp;gt; 0 &amp;amp;&amp;amp;
                                rs[j = (m - 1) &amp;amp; h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                break;
            else if (counterCells != as || n &amp;gt;= NCPU)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 &amp;amp;&amp;amp;
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                try {
                    if (counterCells == as) {// Expand table unless stale
                        CounterCell[] rs = new CounterCell[n &amp;lt;&amp;lt; 1];
                        for (int i = 0; i &amp;lt; n; ++i)
                            rs[i] = as[i];
                        counterCells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = ThreadLocalRandom.advanceProbe(h);
        }
        else if (cellsBusy == 0 &amp;amp;&amp;amp; counterCells == as &amp;amp;&amp;amp;
                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
            boolean init = false;
            try {                           // Initialize table
                if (counterCells == as) {
                    CounterCell[] rs = new CounterCell[2];
                    rs[h &amp;amp; 1] = new CounterCell(x);
                    counterCells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
            break;                          // Fall back on using base
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;size&#34;&gt;size&lt;/h3&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36625757/article/details/90074355&#34;&gt;JDK1.7&amp;amp;1.8中ConcurrentHashMap解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1H64y1X7yM?p=6&#34;&gt;我敢说这是B站最详细的hashmap及ConcurrentHashMap底层原理解析，16个小时带你吃透所有知识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">ConcurrentHashMap详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-28-微服务架构与Spring Cloud Alibaba框架学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习微服务架构与Spring Cloud Alibaba框架过程中的学习笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/bJKCoGeUWY7&#34;&gt;微服务Spring Cloud Alibaba三高架构实战视频.mp4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/1TgXEyrFN2p&#34;&gt;阿里微服务架构Spring Cloud Alibaba源码深度剖析视频.mp4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;微服务架构的优势劣势&#34;&gt;微服务架构的优势劣势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;单一服务崩溃，不会影响其他服务的正常运行&lt;/li&gt;
&lt;li&gt;方便大型团队的开发和管理&lt;/li&gt;
&lt;li&gt;方便对特定服务的扩容&lt;/li&gt;
&lt;li&gt;不同服务使用不同的数据库，便于数据库的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;增加运维难度&lt;/li&gt;
&lt;li&gt;引发分布式事务问题&lt;/li&gt;
&lt;li&gt;bug定位困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务扩容方案&#34;&gt;服务扩容方案&lt;/h2&gt;
&lt;h3 id=&#34;nginx负载均衡&#34;&gt;nginx负载均衡&lt;/h3&gt;
&lt;p&gt;需要手动修改nginx配置，对运维要求较高&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-alibaba&#34;&gt;Spring Cloud Alibaba&lt;/h3&gt;
&lt;p&gt;使用注册中心组件-nacos&lt;/p&gt;
&lt;h4 id=&#34;实现原理&#34;&gt;实现原理&lt;/h4&gt;
&lt;p&gt;客户端：默认集成Ribbon，Ribbon定时从Nacos上拉取相关信息。当客户端通过rest调用服务时，会被Ribbon拦截，Ribbon会根据本地的服务信息替换链接。Ribbon默认使用的是轮询负载均衡。&lt;/p&gt;
&lt;p&gt;服务端：服务端启动后，会向Nacos注册服务，并开启心跳任务，定时向Nacos发送消息以证明自身存活。&lt;/p&gt;
&lt;h2 id=&#34;高可用&#34;&gt;高可用&lt;/h2&gt;
&lt;p&gt;核心链路中，某些服务未调用成功，则触发服务降级。服务降级可通过 sentinel组件 实现。&lt;/p&gt;
&lt;p&gt;sentinel组件还可以帮我们实现限流、熔断功能。&lt;/p&gt;
&lt;p&gt;限流：限制访问量。&lt;/p&gt;
&lt;p&gt;熔断：对于大概率失败的请求调用，直接调用降级服务。&lt;/p&gt;
&lt;h3 id=&#34;限流算法&#34;&gt;限流算法&lt;/h3&gt;
&lt;p&gt;滑动时间窗、漏桶、令牌桶&lt;/p&gt;
&lt;h2 id=&#34;高并发&#34;&gt;高并发&lt;/h2&gt;
&lt;h3 id=&#34;nacos&#34;&gt;nacos&lt;/h3&gt;
&lt;p&gt;如何解决读写冲突问题：读写分离，在副本上进行写，写完之后再覆盖掉原有数据。&lt;/p&gt;
&lt;h2 id=&#34;高扩展&#34;&gt;高扩展&lt;/h2&gt;
&lt;h3 id=&#34;nacos-2&#34;&gt;nacos&lt;/h3&gt;
&lt;p&gt;namespace -&amp;gt; group -&amp;gt; cluster -&amp;gt; instance&lt;/p&gt;
&lt;p&gt;namespace: test, dev...&lt;/p&gt;
&lt;p&gt;group: 交易微服务分组、仓储微服务分组&lt;/p&gt;
&lt;p&gt;cluster: 多地部署，深圳、杭州、北京、成都&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082845291.png&#34; alt=&#34;image-20210830082845291&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082920845.png&#34; alt=&#34;image-20210830082920845&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h2&gt;
&lt;p&gt;借助 seata组件 完成&lt;/p&gt;
">微服务架构与Spring Cloud Alibaba框架学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-26-HashMap详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习 HashMap 过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;扩容机制&#34;&gt;扩容机制&lt;/h2&gt;
&lt;p&gt;首先要了解 HashMap 的底层结构，如图所示，数组+单向链表（红黑树）。&lt;/p&gt;
&lt;p&gt;当单链表长度大于8时，~~数组长度达到64时，~~会由链表转换成红黑树。（依据：源码）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &amp;amp;&amp;amp;
        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
        break;
    p = e;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210826131403378.png&#34; alt=&#34;image-20210826131403378&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;初始化时，容量为16，当添加超过16*0.75=12个元素后，容量会被扩容到32，之后会扩容到64。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;初始时，数组长度为16，当数组中超过16*0.75=12个位置被使用后，数组会被扩容到32，之后会扩容到64。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这里需要注意的是，必须是数组中12个位置被使用过，并不是说HashMap中存放12个元素，这里容易混淆。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;同样，附上代码：&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (++size &amp;gt; threshold)
    resize();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比例因子：&lt;/p&gt;
&lt;p&gt;默认为0.75，也就是说，虽然数组长度为16，但只能存放16*0.75=12个元素。&lt;/p&gt;
&lt;h2 id=&#34;看源码梳理put方法逻辑&#34;&gt;看源码，梳理put方法逻辑&lt;/h2&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;首先根据key计算hash值&lt;/li&gt;
&lt;li&gt;根据hash值，从table中取出node
&lt;ul&gt;
&lt;li&gt;如果node为空，则根据key-value构造node，放到table相应位置中，并将size++，如果size超过阈值（容量*比例因子），则会进行扩容操作。&lt;/li&gt;
&lt;li&gt;如果node不为空
&lt;ul&gt;
&lt;li&gt;如果node为红黑树，则会调用putTreeVal，向树中添加元素&lt;/li&gt;
&lt;li&gt;如果node为单链表，则会遍历单链表
&lt;ul&gt;
&lt;li&gt;如果找到与key-value相等的元素，则直接返回。&lt;/li&gt;
&lt;li&gt;如果没找到，则在尾部新建节点。新建后，如果发现链表长度大于TREEIFY_THRESHOLD（默认为8），则会将单链表转为红黑树。&lt;/li&gt;
&lt;li&gt;分支逻辑：在转换过程中，如果发现当前table数组的大小小于MIN_TREEIFY_CAPACITY（默认为64），则不会进行转换，而是进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xpsallwell/article/details/88071038&#34;&gt;ConcurrentHashMap扩容原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zuokaopuqingnian/article/details/79508730&#34;&gt;ArrayList HashMap ConcurrentHashMap扩容机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">HashMap详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-23-AQS、CAS学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习AQS、CAS过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cas的应用&#34;&gt;CAS的应用&lt;/h2&gt;
&lt;p&gt;保证原子性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面我们了解了cas是什么了，那么它能解决什么问题呢？它可以解决多线程并发安全的问题，以前我们对一些多线程操作的代码都是使用synchronize关键字，来保证线程安全的问题；现在我们将cas放入到多线程环境里我们看一下它是怎么解决的，我们假设有A、B两个线程同时执行一个int值value自增的代码，并且同时获取了当前的value，我们还要假设线程B比A快了那么0.00000001s，所以B先执行，线程B执行了cas操作之后，发现当前值和预期值相符，就执行了自增操作，此时这个value = value + 1;然后A开始执行，A也执行了cas操作，但是此时value的值和它当时取到的值已经不一样了，所以此次操作失败，重新取值然后比较成功，然后将value值更新，这样两个线程进入，value值自增了两次，符合我们的预期。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ln_6am/article/details/85642853&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mulinsen77/article/details/84583716&#34;&gt;AQS详解（面试）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/40025595&#34;&gt;AQS 如何使用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011506543/article/details/82392338&#34;&gt;JAVA CAS实现原理与使用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">AQS、CAS学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-10-Spring中Bean、AOP、事务学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Spring Bean、AOP、事务过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/JBxJZYEJADm&#34;&gt;Spring之IOC、AOP、事务底层原理详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;bean&#34;&gt;Bean&lt;/h2&gt;
&lt;p&gt;Bean对象默认为单例Bean，即根据Bean的name获取对象，相同name对应相同的对象。如果是独立Bean，就算name相同，也依旧是不同的对象。&lt;/p&gt;
&lt;h3 id=&#34;bean-vs-对象&#34;&gt;Bean VS 对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：Bean一定是对象，但对象不一定是Bean，只有被Spring管理的对象才是Bean对象。&lt;/li&gt;
&lt;li&gt;特性：Bean对象中的Bean&lt;strong&gt;子&lt;/strong&gt;对象，会被Spring自动注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean创建流程&#34;&gt;Bean创建流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;实例化（无参构造方法）&lt;/li&gt;
&lt;li&gt;依赖注入
&lt;ol&gt;
&lt;li&gt;初始化前：@PostConstruct&lt;/li&gt;
&lt;li&gt;初始化：InitializingBean&lt;/li&gt;
&lt;li&gt;初始化后：AOP，生成代理对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring容器&#34;&gt;Spring容器&lt;/h2&gt;
&lt;p&gt;本质上是Map，先根据.class进行寻找，如果找到的结果不唯一，则继续根据name进行寻找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService2 ) {
	不报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	不报错
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP&lt;/h2&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;p&gt;具有事务的对象为代理对象，切面逻辑为“开启事务”。&lt;/p&gt;
&lt;h3 id=&#34;事务失效&#34;&gt;事务失效&lt;/h3&gt;
&lt;h4 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;MySQL默认存储引擎是MyISAM，该存储引擎不知道事务，需要切换成InnoDB。&lt;/p&gt;
&lt;h4 id=&#34;内部调用&#34;&gt;内部调用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional
public void test() {
	jdbcTemplate.execute(&amp;quot;insert t1 values(1,1,1)&amp;quot;);
	a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码不会报错，原因是：&lt;/p&gt;
&lt;p&gt;事务开启的逻辑是在代理对象中进行的，上述代码中a()方法的调用是在target对象中进行的，因此在调用a()方法时，不会触发事务相关的逻辑，因此事务失效。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private UserService userService;

@Transactional
public void test() {
	jdbcTemplate.execute(&amp;quot;insert t1 values(1,1,1)&amp;quot;);
	userService.a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Bean初始化，为什么有了initializingBean，还要PostConstructor&lt;/li&gt;
&lt;/ul&gt;
">Spring中Bean、AOP、事务学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-28-JMM（Java内存模型）学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习JMM过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/B67o2UcNvG8&#34;&gt;深入理解并发内存模型JMM与内存屏障&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java内存模型&#34;&gt;Java内存模型&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210728151840865.png&#34; alt=&#34;image-20210728151840865&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;对于静态变量，每个线程中会存储变量副本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要不影响到变量的值、变量不参与运算，则不会从主内存中拉取，比如while、if、赋值给其他变量、作为方法参数等&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ren421259121/article/details/90447853&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下程序会死循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static boolean exit = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread() {
            @Override
            public void run() {
                while( !exit ) {

                }
                System.out.println( &amp;quot;end&amp;quot; );
            }
        }.start();
        Thread.sleep(2000);
        exit = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jmm的原子操作&#34;&gt;JMM的原子操作&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210729144205406.png&#34; alt=&#34;image-20210729144205406&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;volatile&#34;&gt;volatile&lt;/h2&gt;
&lt;p&gt;作用：保证多线程间共享变量的可见性、有序性。不保证原子性，原子性需通过synchronized保证。&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM级：禁止JVM优化：指令重排、使用寄存器&lt;/li&gt;
&lt;li&gt;CPU级：利用CPU lock指令为总线加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可见性&#34;&gt;可见性&lt;/h3&gt;
&lt;h4 id=&#34;缓存一致性协议-vs-volatile&#34;&gt;缓存一致性协议 VS volatile&lt;/h4&gt;
&lt;h5 id=&#34;缓存一致性协议mesi&#34;&gt;缓存一致性协议（MESI）&lt;/h5&gt;
&lt;p&gt;四种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M（Modified）：在缓存行中被标记为Modified的值，与主存中的值不同，这个值将会在它被读取之前写入内存，并且状态置为Shared。&lt;/li&gt;
&lt;li&gt;E（Exclusive）：在缓存行中被标记为Exclusive的值与主存中的值一致，被读取时置为Shared状态，被写时置为Modified状态。&lt;/li&gt;
&lt;li&gt;S（Shared）：值也可能存在于其他缓存中，但是它的值和主存中的值一致。&lt;/li&gt;
&lt;li&gt;I（Invalid）：缓存行无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于状态之间的转换以及更详细介绍MESI的内容，可以看这篇博客：https://www.cnblogs.com/igoodful/p/9493156.html&lt;/p&gt;
&lt;p&gt;做个总结，MESI协议，保证了各CPU缓存之间的一致性。&lt;/p&gt;
&lt;h5 id=&#34;volatile是否多余&#34;&gt;volatile是否多余&lt;/h5&gt;
&lt;p&gt;既然MESI协议可以保证各CPU缓存之间数据的一致性（可见性），那么为什么还需要volatile关键词来保证各线程之间数据的一致性（可见性）呢？volatile关键字是否多余？&lt;/p&gt;
&lt;p&gt;答：不多余&lt;/p&gt;
&lt;p&gt;理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;出发点不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MESI协议保证了主内存和各CPU缓存的一致，而volatile保证了java进程中各线程之间的一致性。如果没有MESI，那么各线程之间一定是不一致的，但只有MESI，也不能完全保证各线程间的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现的功能不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MESI的功能上文已经说过了，即，保证了各CPU缓存之间的一致性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;防止JVM优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止数据从CPU cache以外的地方读取，这里做一下说明，MESI只能保证主内存和CPU缓存（CPU cache）的一致性，但CPU中还有很多额外的组件用于数据存储，这些组件可以提高CPU数据读写的效率，而这些组件的一致性MESI是不保证的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 MESI只是保证了多核cpu的独占cache之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。有些arm和power架构的cpu还可能有load buffer或者invalid queue等等。&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/296949412&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证多个变量的顺序一致，即，consistency。因为volatile会对总线加锁，且防止指令重排，所以可以保证用volatile修饰的多个变量之间的操作顺序。而MESI只能保证单个变量的操作顺序，即coherence。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coherence deals with maintaining a global order in which writes to a single location or single variable are seen by all processors.&lt;/p&gt;
&lt;p&gt;Consistency deals with the ordering of operations to multiple locations with respect to all processors.&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/296949412&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;s&gt;### CPU lock指令&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;CPU lock指令会将对应缓存行的状态改成E，并立即修改主内存中的数据。其他CPU通过总线嗅探机制，监听到数据的修改，将自己工作内存中的缓存行状态改成I。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;如果不使用volatile关键字，JVM则不会使用lock指令，此时，对变量的修改会导致缓存行的状态变成M，并不会修改主内存的数据，因此会导致不同线程中共享变量数据不一致。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;之所以不修改主内存，是因为对主内存的操作相对于CPU操作来说过于耗时，因此不会频繁操作主内存。&lt;/s&gt;&lt;/p&gt;
&lt;h4 id=&#34;reference&#34;&gt;Reference&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xrq730/p/7048693.html&#34;&gt;就是要你懂Java中volatile关键字实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/63120810&#34;&gt;java多线程在单核CPU上，还是需要volatile synchronized吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序性&#34;&gt;有序性&lt;/h3&gt;
&lt;h4 id=&#34;重排序原则&#34;&gt;重排序原则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;as-if-serial：不管怎么重排序 (编译器和处理器为了提高并行度)，(单线程) 程序的执行结果不能被改变。&lt;/li&gt;
&lt;li&gt;happens-before：本质上其实和第一点类似，就是保证单线程程序的语义不被改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试题：单例模式下对象半初始化问题&lt;/p&gt;
&lt;h4 id=&#34;内存屏障&#34;&gt;内存屏障&lt;/h4&gt;
&lt;p&gt;JVM内存屏障指令：LoadLoad, LoadStore, StoreLoad, StoreStore&lt;/p&gt;
&lt;p&gt;对于volatile修饰的变量，在JVM级，会在该操作前后添加内存屏障指令，在CPU级，会通过lock指令实现内存屏障。&lt;/p&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;volatile有什么特点和synchornized相比有什么区别&#34;&gt;volatile有什么特点，和synchornized相比有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;volatile的特点：保证可见性和有序性，不保证原子性&lt;/li&gt;
&lt;li&gt;volatile VS synchronized
&lt;ul&gt;
&lt;li&gt;修饰对象不同：volatile修饰变量，synchronized修饰方法和代码块&lt;/li&gt;
&lt;li&gt;原子性：volatile不保证，synchronized保证&lt;/li&gt;
&lt;li&gt;是否造成阻塞：volatile不会，synchronized会&lt;/li&gt;
&lt;li&gt;volatile为轻量级锁，synchronized为重量级锁&lt;/li&gt;
&lt;li&gt;都保证原子性和有序性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">JMM（Java内存模型）学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习K8S-Scheduler过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;amp;seid=1977024601217253447&#34;&gt;阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;调度器功能：负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。&lt;/p&gt;
&lt;p&gt;什么是Pod：Pod是K8S中最小的调度单元，Pod和docker容器的关系就相当于docker容器和进程，在目前的技术环境下，往往一个服务依赖于多个docker容器，因此，k8s中提出了Pod的概念，使用Pod对docker容器进行打包，统一进行调度。&lt;/p&gt;
&lt;h2 id=&#34;对pod进行自定义排序&#34;&gt;对Pod进行自定义排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按名称排序：kubectl get pods --sort-by=.metadata.name&lt;/li&gt;
&lt;li&gt;按创建时间进行排序：kubectl get pods --sort-by=.metadata.creationTimestamp&lt;/li&gt;
&lt;li&gt;按启动时间进行排序：kubectl get pods --sort-by=.status.startTime&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/m0_50434960/article/details/114851074&#34;&gt;k8s:Kubernetes 调度器介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/bfaa566f17fe&#34;&gt;细说kubernetes - 为什么是pod？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/yangyuliufeng/p/14257928.html&#34;&gt;k8s调度器扩展机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;amp;seid=1977024601217253447&#34;&gt;阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">K8S-Scheduler学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习JVM性能调优过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/mmv27Dfr291&#34;&gt;双十一亿级电商系统JVM性能调优实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java虚拟机组成&#34;&gt;Java虚拟机组成&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png&#34; alt=&#34;image-20210727153842086&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;类装载子系统&lt;/li&gt;
&lt;li&gt;字节码执行引擎&lt;/li&gt;
&lt;li&gt;运行时数据区（内存模型）
&lt;ul&gt;
&lt;li&gt;栈（线程）
&lt;ul&gt;
&lt;li&gt;存放程序运行过程中的数据&lt;/li&gt;
&lt;li&gt;栈 -&amp;gt; 线程 -&amp;gt; 方法
&lt;ul&gt;
&lt;li&gt;从栈中划分一块区域给线程，再从这块区域中划分一块给方法&lt;/li&gt;
&lt;li&gt;方法中的局部变量就存在对应区域内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序计数器：记录每个线程当前运行的代码在方法区中的位置&lt;/li&gt;
&lt;li&gt;堆：存放程序运行过程中产生的对象&lt;/li&gt;
&lt;li&gt;方法区（元空间）：常量+静态变量+类信息&lt;/li&gt;
&lt;li&gt;本地方法栈：和上文的栈类似，只是，这里存放的是本地（native）方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc工作原理&#34;&gt;GC工作原理&lt;/h2&gt;
&lt;h3 id=&#34;minor-gc新生代gc&#34;&gt;Minor GC（新生代GC）&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png&#34; alt=&#34;image-20210727152911187&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等&lt;/li&gt;
&lt;li&gt;将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为&lt;strong&gt;非垃圾对象&lt;/strong&gt;，其余未标记的对象都是垃圾对象。&lt;/li&gt;
&lt;li&gt;每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。&lt;/li&gt;
&lt;li&gt;如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minor-gc-vs-full-gc&#34;&gt;Minor GC VS Full GC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。&lt;/li&gt;
&lt;li&gt;Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短&lt;/li&gt;
&lt;li&gt;算法不同：
&lt;ul&gt;
&lt;li&gt;Mnior GC用空间换时间，需要两个内存空间，直接Copy&lt;/li&gt;
&lt;li&gt;Full GC用时间换空间，需要Mark+Compact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/kevin7234/p/10644654.html&#34;&gt;jvm minor gc 为什么比 full gc 快很多&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/35172533&#34;&gt;为什么minor gc比full gc/major gc快？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arthas工具&#34;&gt;Arthas工具&lt;/h2&gt;
&lt;p&gt;阿里JVM性能调优工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dashboard：显示监控仪表盘&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155106380.png&#34; alt=&#34;image-20210727155106380&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thread thread_id：显示占用CPU较多的代码行数&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155209073.png&#34; alt=&#34;image-20210727155209073&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jad：反编译运行中的代码&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155320962.png&#34; alt=&#34;image-20210727155320962&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能调优&#34;&gt;性能调优&lt;/h2&gt;
&lt;p&gt;目的：减少 STW 的次数。&lt;/p&gt;
&lt;p&gt;STW: Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。&lt;/p&gt;
&lt;p&gt;Full GC的SWT时间远大于Minor GC。&lt;/p&gt;
&lt;p&gt;调优方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。&lt;/li&gt;
&lt;li&gt;对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。&lt;/li&gt;
&lt;li&gt;使用不同的垃圾收集器，不同收集器，适用于不同的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png&#34; alt=&#34;image-20210727162355407&#34; style=&#34;zoom:55%;&#34; /&gt;
">JVM性能调优学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-19-非对称加密的应用/"" data-c="
          &lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;稍微提一下原理&lt;/p&gt;
&lt;p&gt;主要原理是，用一定的数学方法生成一对密钥对（公钥+私钥），公钥加密后，私钥可以解密，同时，私钥加密后，公钥也可以解密。&lt;/p&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;h3 id=&#34;数据传输&#34;&gt;数据传输&lt;/h3&gt;
&lt;p&gt;1、A生成一对密钥对，把公钥发给B。&lt;/p&gt;
&lt;p&gt;2、B把需要传输的数据用公钥进行加密，然后发给A。&lt;/p&gt;
&lt;p&gt;3、A收到后，用私钥进行解密，即可获取数据。&lt;/p&gt;
&lt;h4 id=&#34;如何防截获&#34;&gt;如何防截获&lt;/h4&gt;
&lt;p&gt;使用报文摘要算法&lt;/p&gt;
&lt;p&gt;接上文&lt;/p&gt;
&lt;p&gt;B在第2步传数据时，使用报文摘要算法对所发数据进行摘要生成，之后，用自己的私钥对摘要进行加密，然后伴随数据一起发给A。&lt;/p&gt;
&lt;p&gt;A在收到后，对自己的私钥对数据进行解密，从而获取数据，之后再用B的公钥对摘要进行解密，然后比对收到的数据和摘要是否匹配，从而验证数据是否被篡改。&lt;/p&gt;
&lt;h3 id=&#34;身份验证&#34;&gt;身份验证&lt;/h3&gt;
&lt;p&gt;A要证明自己的身份&lt;/p&gt;
&lt;p&gt;B向A发送一段数据&lt;/p&gt;
&lt;p&gt;A用自己的私钥进行加密，然后发回给B，B用A的公钥进行解密，比对数据是否为自己发给A的数据，从而验证A的身份。&lt;/p&gt;
">非对称加密的应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-15-在Docker容器内创建新的Docker容器/"" data-c="
          &lt;h2 id=&#34;要解决的问题&#34;&gt;要解决的问题&lt;/h2&gt;
&lt;p&gt;这篇文章主要解决的问题如标题所述：如何在Docker容器内创建新的Docker容器。受限于标题长度，没法详细描述要解决的问题，因此，第一节首先讲一下问题场景。&lt;/p&gt;
&lt;p&gt;随着Docker技术以及微服务结构的普及，现在越来越多的应用被打包放在Docker容器中，并且，为了采用微服务的架构，应用通常是需要拆分成多个Docker容器的。&lt;/p&gt;
&lt;p&gt;那么，这就带来了一个问题，如何在一个Docker容器内去控制别的Docker容器。这里需要啰嗦一句，我想表达的意思并不是在一个Docker容器的内部创建新的Docker容器，而是说，在一个Docker容器内部，控制宿主机，让其创建新的Docker容器。&lt;/p&gt;
&lt;p&gt;问题描述讲完了，接下来说一下如何实现。&lt;/p&gt;
&lt;h2 id=&#34;如何解决&#34;&gt;如何解决&lt;/h2&gt;
&lt;p&gt;解决这个问题，就需要涉及到Docker的通信机制。&lt;/p&gt;
&lt;p&gt;Docker分为服务端和客户端。当服务端启动后，会在/var/run/文件夹中创建docker.sock这个文件，并且会持续监听这个文件。当有请求被写到docker.sock文件时，Docker服务端就会执行相应的操作。&lt;/p&gt;
&lt;p&gt;以往我们使用docker run等命令时，其实本质上也是往docker.sock文件中写请求。&lt;/p&gt;
&lt;p&gt;了解到这一点后，我们在创建Docker容器时，就可以把宿主机的docker.sock文件挂载到容器内部，这样，便可以在容器内部控制宿主机对容器的操作了。&lt;/p&gt;
&lt;p&gt;一共有两种方式，第一种是，在容器内部安装docker客户端，然后便可以像在宿主机中一样，使用docker命令，不同的地方时，docker命令控制的并不是容器内部的Docker服务端，而是宿主机中的Docker服务端。&lt;/p&gt;
&lt;p&gt;可以使用如下命令进行容器的创建&lt;code&gt;curl -XPOST --unix-socket /var/run/docker.sock -d &#39;{&amp;quot;Image&amp;quot;:&amp;quot;centos&amp;quot;}&#39; -H &#39;Content-Type: application/json&#39; http://localhost/containers/create&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二种方法是，使用docker-java，通过java api操作宿主机中的Docker服务端。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/dd0c814680ba&#34;&gt;解析 /var/run/docker.sock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/94224305&#34;&gt;Docker客户端连接远程Docker服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">在Docker容器内创建新的Docker容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-02-Leetcode 169. 多数元素/"" data-c="
          &lt;p&gt;题目链接：&lt;a href=&#34;https://leetcode-cn.com/problems/majority-element/&#34;&gt;169. 多数元素&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210702100456543.png&#34; alt=&#34;image-20210702100456543&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;h3 id=&#34;哈希表&#34;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        unordered_map&amp;lt;int, int&amp;gt; counts;
        int majority = 0, cnt = 0;
        for (int num: nums) {
            ++counts[num];
            if (counts[num] &amp;gt; cnt) {
                majority = num;
                cnt = counts[num];
            }
        }
        return majority;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分治&#34;&gt;分治&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(logn)&lt;/p&gt;
&lt;p&gt;思路：如果数 &lt;code&gt;a&lt;/code&gt; 是数组 &lt;code&gt;nums&lt;/code&gt; 的众数，如果我们将 &lt;code&gt;nums&lt;/code&gt; 分成两部分，那么 &lt;code&gt;a&lt;/code&gt; 必定是至少一部分的众数（&lt;/p&gt;
&lt;h4 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h4&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;​&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T(n)=2T({n\over2})+2n​
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主定理：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T(n)=aT({n\over b})+O(n^d) \\
T(n) = \left\{ \begin{array}{lr} 
O(n^d) &amp;amp; d &amp;gt; log_ba \\
O(n^dlogn) &amp;amp; d = log_ba \\
O(b^{log_ba}) &amp;amp; d &amp;lt; log_ba
\end{array} \right.
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.149108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.6273239999999998em;vertical-align:-1.5636619999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.49999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎩&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.15001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.30002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-l&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.063662em;&#34;&gt;&lt;span style=&#34;top:-4.214554em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0054459999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.7963380000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5636619999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-r&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.063662em;&#34;&gt;&lt;span style=&#34;top:-4.214554em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0054459999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.7963380000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5636619999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
    int count_in_range(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int lo, int hi) {
        int count = 0;
        for (int i = lo; i &amp;lt;= hi; ++i)
            if (nums[i] == target)
                ++count;
        return count;
    }
    int majority_element_rec(vector&amp;lt;int&amp;gt;&amp;amp; nums, int lo, int hi) {
        if (lo == hi)
            return nums[lo];
        int mid = (lo + hi) / 2;
        int left_majority = majority_element_rec(nums, lo, mid);
        int right_majority = majority_element_rec(nums, mid + 1, hi);
        if (count_in_range(nums, left_majority, lo, hi) &amp;gt; (hi - lo + 1) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, lo, hi) &amp;gt; (hi - lo + 1) / 2)
            return right_majority;
        return -1;
    }
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;
&lt;h4 id=&#34;快速排序&#34;&gt;快速排序&lt;/h4&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(logn) 栈空间&lt;/p&gt;
&lt;h4 id=&#34;堆排序&#34;&gt;堆排序&lt;/h4&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;随机化&#34;&gt;随机化&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;p&gt;思路：随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。&lt;/p&gt;
&lt;p&gt;期望：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∞&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;msubsup&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E=lim_{n\to+\infty}\sum_{i=1}^n i * {1\over 2^i}=2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.104002em;vertical-align:-0.29971000000000003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.25833100000000003em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;→&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;∞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;&lt;span class=&#34;mop op-symbol small-op&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.804292em;&#34;&gt;&lt;span style=&#34;top:-2.40029em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.2029em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.29971000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7570857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.786em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        while (true) {
            int candidate = nums[rand() % nums.size()];
            int count = 0;
            for (int num : nums)
                if (num == candidate)
                    ++count;
            if (count &amp;gt; nums.size() / 2)
                return candidate;
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多数投票算法&#34;&gt;多数投票算法&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nums:      [#, 7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:     7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      0  1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
               7  7  7  7  7  7   7  7   7  7  7  7   7  7  7  7
value:      0  1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测count是否为0，如果为0，就用当前数组的元素值更新candidate。&lt;/li&gt;
&lt;li&gt;如果当前数组的元素值和candidate相同，那么，count++，否则，count--。&lt;/li&gt;
&lt;li&gt;当数组遍历完时，当前的candidate，就是我们要的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count永远不为负数。&lt;/li&gt;
&lt;li&gt;当candidate和最终答案不相同时，count和value呈相反数；如果candidate和最终答案相同，count和value是相等的。&lt;/li&gt;
&lt;li&gt;value的最终值等于：7的个数-非7的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多数投票算法证明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果候选人不是7，则7会和其他&lt;strong&gt;非&lt;/strong&gt;候选人一起反对候选人，所以候选人一定会下台(count==0时发生换届选举)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果候选人是7，则 7 会支持自己，其他候选人会反对，但因为 7 票数超过一半，所以 7 一定会成功当选&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count &amp;lt; 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 169. 多数元素</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-29-Jmeter ThreadGroup LoopController各参数含义梳理/"" data-c="
          &lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ThreadGroup guiclass=&amp;quot;ThreadGroupGui&amp;quot; testclass=&amp;quot;ThreadGroup&amp;quot; testname=&amp;quot;线程组&amp;quot; enabled=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.on_sample_error&amp;quot;&amp;gt;continue&amp;lt;/stringProp&amp;gt;
	&amp;lt;elementProp name=&amp;quot;ThreadGroup.main_controller&amp;quot; elementType=&amp;quot;LoopController&amp;quot; guiclass=&amp;quot;LoopControlPanel&amp;quot; testclass=&amp;quot;LoopController&amp;quot; testname=&amp;quot;循环控制器&amp;quot; enabled=&amp;quot;true&amp;quot;&amp;gt;
		&amp;lt;boolProp name=&amp;quot;LoopController.continue_forever&amp;quot;&amp;gt;false&amp;lt;/boolProp&amp;gt;
		&amp;lt;intProp name=&amp;quot;LoopController.loops&amp;quot;&amp;gt;-1&amp;lt;/intProp&amp;gt;
	&amp;lt;/elementProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.num_threads&amp;quot;&amp;gt;20&amp;lt;/stringProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.ramp_time&amp;quot;&amp;gt;1&amp;lt;/stringProp&amp;gt;
	&amp;lt;boolProp name=&amp;quot;ThreadGroup.scheduler&amp;quot;&amp;gt;true&amp;lt;/boolProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.duration&amp;quot;&amp;gt;600&amp;lt;/stringProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.delay&amp;quot;&amp;gt;&amp;lt;/stringProp&amp;gt;
	&amp;lt;boolProp name=&amp;quot;ThreadGroup.same_user_on_next_iteration&amp;quot;&amp;gt;true&amp;lt;/boolProp&amp;gt;
&amp;lt;/ThreadGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数说明&#34;&gt;参数说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ThreadGroup.num_threads：并发线程数&lt;/li&gt;
&lt;li&gt;LoopController.loops：每个线程的循环次数，-1表示无限循环。&lt;/li&gt;
&lt;li&gt;压测的总请求数：ThreadGroup.num_threads * LoopController.loops&lt;/li&gt;
&lt;li&gt;调度器配置
&lt;ul&gt;
&lt;li&gt;ThreadGroup.duration：线程组的持续时间&lt;/li&gt;
&lt;li&gt;ThreadGroup.delay：启动延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ThreadGroup.scheduler：调度器是否生效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;压测是否结束&#34;&gt;压测是否结束&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果调度器不生效，则线程组达到循环次数后，压测结束。&lt;/li&gt;
&lt;li&gt;如果调度器生效，则每次循环结束后，都会检查持续时间，如果大于ThreadGroup.duration，则压测结束。在此过程中，如果线程组达到循环次数，也会结束压测。&lt;/li&gt;
&lt;/ul&gt;
">Jmeter ThreadGroup LoopController各参数含义梳理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-25-OpenResty学习笔记/"" data-c="
          &lt;h2 id=&#34;是什么-能做什么&#34;&gt;是什么、能做什么&lt;/h2&gt;
&lt;p&gt;OpenResty 是一个基于 Nginx 的 Web 平台。Web开发人员可以使用 OpenResty 搭建 Web 平台。借助于OpenResty，开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种由 C 语言实现的功能模块，从而实现特定的Web 业务需求。&lt;/p&gt;
&lt;p&gt;OpenResty 本质上是集成了 Lua 组件的 Nginx，是Nginx Plus。&lt;/p&gt;
&lt;h2 id=&#34;优点-缺点是什么&#34;&gt;优点、缺点是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;高并发
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相较于apache（200-300）、tomcat（1000），Nginx可以支持几万的并发量，因此，我们常常使用Nginx做负载均衡，OpenResty的出现，使得开发人员可以依托 Lua 脚本在 Nginx 的内部添加业务代码，充分利用Nginx高并发的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高性能的原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多线程+IO多路复用。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_30764137/article/details/98058884&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;暂未发现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://www.runoob.com/w3cnote/openresty-intro.html&lt;/li&gt;
&lt;li&gt;https://www.zhihu.com/question/266535644?sort=created&lt;/li&gt;
&lt;/ul&gt;
">OpenResty学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-24-跳表/"" data-c="
          &lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树（AVL）媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。&lt;/p&gt;
&lt;p&gt;https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624182132534.png&#34; alt=&#34;image-20210624182132534&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624191004554.png&#34; alt=&#34;image-20210624191004554&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;学过数据结构的都知道，在单链表中查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过2分的方式缩减时间复杂度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205210928206&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211105653&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。&lt;/p&gt;
&lt;p&gt;那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211246498&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？&lt;/p&gt;
&lt;p&gt;如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。&lt;/p&gt;
&lt;p&gt;至此为止，我们引入了最理想的跳跃表，但是如果想要在上图中插入或者删除一个元素呢？比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。我们知道，平衡二叉树的调整是一件令人头痛的事情，左旋右旋左右旋……一般人还真记不住，而调整一个理想的跳跃表将是一个比调整平衡二叉树还复杂的操作。幸运的是，我们并不需要通过复杂的操作调整连接来维护这样完美的跳跃表。有一种基于概率统计的插入算法，也能得到时间复杂度为O(logn)的查询效率，这种跳跃表才是我们真正要实现的。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;h3 id=&#34;抛硬币&#34;&gt;抛硬币&lt;/h3&gt;
&lt;p&gt;先讨论插入，我们先看理想的跳跃表结构，L2层的元素个数是L1层元素个数的1/2，L3层的元素个数是L2层的元素个数的1/2，以此类推。从这里，我们可以想到，只要在插入时尽量保证上一层的元素个数是下一层元素的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么样才能在插入时保证上一层元素个数是下一层元素个数的1/2呢？很简单，抛硬币就能解决了！假设元素X要插入跳跃表，很显然，L1层肯定要插入X。那么L2层要不要插入X呢？我们希望上层元素个数是下层元素个数的1/2，所以我们有1/2的概率希望X插入L2层，那么抛一下硬币吧，正面就插入，反面就不插入。那么L3到底要不要插入X呢？相对于L2层，我们还是希望1/2的概率插入，那么继续抛硬币吧！以此类推，元素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。&lt;/p&gt;
&lt;p&gt;在此还是以上图为例：跳跃表的初试状态如下图，表中没有一个元素：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212059243&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果我们要插入元素2，首先是在底部插入元素2，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212313963&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我们抛硬币，结果是正面，那么我们要将2插入到L2层，如下图:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212409123&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;继续抛硬币，结果是反面，那么元素2的插入操作就停止了，插入后的表结构就是上图所示。接下来，我们插入元素33，跟元素2的插入一样，现在L1层插入33，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212458264&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后抛硬币，结果是反面，那么元素33的插入操作就结束了，插入后的表结构就是上图所示。接下来，我们插入元素55，首先在L1插入55，插入后如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212553339&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后抛硬币，结果是正面，那么L2层需要插入55，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212659309&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;继续抛硬币，结果又是正面，那么L3层需要插入55，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212712590&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以此类推，我们插入剩余的元素。当然因为规模小，结果很可能不是一个理想的跳跃表。但是如果元素个数n的规模很大，学过概率论的同学都知道，最终的表结构肯定非常接近于理想跳跃表。&lt;/p&gt;
&lt;p&gt;当然，这样的分析在感性上是很直接的，但是时间复杂度的证明实在复杂，在此我就不深究了，感兴趣的可以去看关于跳跃表的paper。再讨论删除，删除操作没什么讲的，直接删除元素，然后调整一下删除元素后的指针即可。跟普通的链表删除操作完全一样。再来讨论一下时间复杂度，插入和删除的时间复杂度就是查询元素插入位置的时间复杂度，这不难理解，所以是O(logn)。&lt;/p&gt;
&lt;h3 id=&#34;随机数&#34;&gt;随机数&lt;/h3&gt;
&lt;p&gt;在上一节中，我们采用抛硬币的方式来决定新元素插入的最高层数，这当然不能在程序中实现。代码中，我们采用随机数生成的方式来获取新元素插入的最高层数。我们先估摸一下n的规模，然后定义跳跃表的最大层数maxLevel，那么底层，也就是第0层，元素是一定要插入的，概率为1；最高层，也就是maxLevel层，元素插入的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.099108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们先随机生成一个范围为0~&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel}-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.932438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一个整数r。那么元素r小于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8491079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的概率为1/2，r小于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8491079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的概率为1/4，……，r小于2的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0991079999999998em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，r小于1的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.099108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举例，假设maxLevel为4，那么r的范围为0~15，则r小于8的概率为1/2，r小于4的概率为1/4，r小于2的概率为1/8，r小于1的概率为1/16。1/16正好是maxLevel层插入元素的概率，以此类推。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624193459656.png&#34; alt=&#34;image-20210624193459656&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以上分析是随机数算法的关键。算法跟实现跟语言无关，以下贴一下C++语言的代码实现。&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Node* next;&lt;/p&gt;
&lt;p&gt;Node* next[MAXL];&lt;/p&gt;
&lt;p&gt;next[2] = null;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct SkipListNode {
    int val;
    vector&amp;lt;SkipListNode *&amp;gt; level;
    SkipListNode (int _val, int sz=32) : val(_val), level(sz, nullptr) {}
};

class Skiplist {
public:
    SkipListNode *head, *tail;
    int level, length;
    static int MAXL = 32;

    Skiplist() {
        level = length = 0;
        tail = new SkipListNode(INT_MAX, 0);
        head = new SkipListNode(-INT_MAX);
        for (int i = 0; i &amp;lt; MAXL; ++i) {
            head-&amp;gt;level[i] = tail;
        }
    }

    SkipListNode* find(int val) {
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
        }
        p = p-&amp;gt;level[0];
        return p;
    }

    bool search(int target) {
        SkipListNode *p = find(target);
        return p-&amp;gt;val == target;
    }

    void add(int val) {
        vector&amp;lt;SkipListNode *&amp;gt; update(MAXL);
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
            update[i] = p;
        }
        int lv = randomLevel();
        if (lv &amp;gt; level) {
            lv = ++level;
            update[lv - 1] = head;
        }
        SkipListNode *newNode = new SkipListNode(val, lv);
        for (int i = lv - 1; i &amp;gt;= 0; --i) {
            p = update[i];
            newNode-&amp;gt;level[i] = p-&amp;gt;level[i];
            p-&amp;gt;level[i] = newNode;
        }
        ++length;
    }

    bool erase(int val) {
        vector&amp;lt;SkipListNode *&amp;gt; update(MAXL + 1);
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
            update[i] = p;
        }
        p = p-&amp;gt;level[0];
        if (p-&amp;gt;val != val) return false;
        for (int i = 0; i &amp;lt; level; ++i) {
            if (update[i]-&amp;gt;level[i] != p) {
                break;
            }
            update[i]-&amp;gt;level[i] = p-&amp;gt;level[i];
        }
        while (level &amp;gt; 0 &amp;amp;&amp;amp; head-&amp;gt;level[level - 1] == tail)
            --level;
        --length;
        return true;
    }

    int randomLevel() {
        int level, r = rand(), target = INT_MAX/2;
        level = 0;
        for (int i = 1; i &amp;lt; MAXL; i++)
            if( r &amp;gt; INT_MAX-target ) {
                level = i;
                target /= 2;
            } else {
                break;
            }
        return level+1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习&#34;&gt;练习&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/design-skiplist/&#34;&gt;1206. 设计跳表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u013709270/article/details/53470428&lt;/li&gt;
&lt;/ul&gt;
">跳表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-09-Kafka学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Kafka过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coding.imooc.com/class/434.html&#34;&gt;Kafka多维度系统精讲，从入门到熟练掌握&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;课程大纲：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210609101437740.png&#34; alt=&#34;image-20210609101437740&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;partition&#34;&gt;Partition&lt;/h2&gt;
&lt;p&gt;Partition 在 Kafka 中是分区的意思。&lt;/p&gt;
&lt;p&gt;Kafka 中每个 Topic 可以划分多个分区，同一个 Topic 下的不同分区包含的消息是不同的。&lt;/p&gt;
&lt;p&gt;Kafka 通过 offset 可以保证消息在分区中的顺序性，但是跨分区是无序的，即 Kafka 只保证在同一个分区内的消息是有序的。&lt;/p&gt;
&lt;p&gt;每一条消息发送到 broker 的时候，会根据 Partition 的分区规则计算，然后选择将该消息存储到哪一个 Partition。&lt;/p&gt;
&lt;p&gt;参考资料：https://blog.csdn.net/lzb348110175/article/details/100764105&lt;/p&gt;
&lt;p&gt;Partition和Consumer的关系不能是1对多，即，一个Partition由多个Comsumer进行消费。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是由Consumer的消费机制决定的，Consumer在拿到消息后，需要在处理完后向Kafka提交处理结果，即，告诉Kafka这批消息已经处理好了（可以以自动的方式进行提交，也可以手动提交）。而在Kafka中，最小颗粒度的数据存储就是Partition，那么，如果有两个Consumer同时消费一个Partiton，就会导致线程不安全，即，两个Consumer同时拿到数据，然后导致数据冲突。&lt;/li&gt;
&lt;li&gt;如果是多个Consumer对应多个Partition，则不会出现这个情况，因为不同Partition之间是不会相互影响的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解读源码&#34;&gt;解读源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Producer在创建时，会新建发送线程，该线程会定时批量发送所有的消息。因此，Kafka是批量发送，不是调用一次send就发送一次，所以效率较高。&lt;/li&gt;
&lt;li&gt;当调用send后，会将消息存储在batch（批次）中，当达到一定阈值时，发送线程会自动进行消息的批量发送。因此，严格意义上，消息发送不是由send实现的。&lt;/li&gt;
&lt;li&gt;Kafka是线程安全的，可以多线程复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Producer
&lt;ul&gt;
&lt;li&gt;ACKS_CONFIG：消息传递保障&lt;/li&gt;
&lt;li&gt;RETRIES_CONFIG：发送失败后重试次数&lt;/li&gt;
&lt;li&gt;BATCH_SIZE_CONFIG：最大批次容量&lt;/li&gt;
&lt;li&gt;LINGER_MS_CONFIG：批量发送间隔时间&lt;/li&gt;
&lt;li&gt;BUFFER_MEMORY_CONFIG：缓存大小&lt;/li&gt;
&lt;li&gt;BATCH_SIZE &lt;strong&gt;VS&lt;/strong&gt; BUFFER_MEMORY
&lt;ul&gt;
&lt;li&gt;参考资料：https://blog.csdn.net/u010711495/article/details/113250402&lt;/li&gt;
&lt;li&gt;Kafka的所有信息都会存在缓存中，包括配置信息、消息等，一旦缓存满了，Kafka就会禁止用户再发送消息；而对于最大批次容量，当批次实际大小达到最大批次容量时，就会触发发送线程的发送；因此，一般缓存大小都是大于最大批次容量的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;KEY_SERIALIZER_CLASS_CONFIG：key序列化类&lt;/li&gt;
&lt;li&gt;VALUE_SERIALIZER_CLASS_CONFIG：value序列化类&lt;/li&gt;
&lt;li&gt;PARTITIONER_CLASS_CONFIG：自定义partition选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息传递保障&#34;&gt;消息传递保障&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最多一次：发了就不管了&lt;/li&gt;
&lt;li&gt;最少一次：一直发，直到收到响应&lt;/li&gt;
&lt;li&gt;正好一次：一直发，直到收到响应，但是接收方需要去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;key的作用&#34;&gt;Key的作用&lt;/h2&gt;
&lt;p&gt;Kafka的消息是一对键值对，Key在Kafka中的主要作用是选择分区，若用户没有指定分区，则Kafka会根据key的hash决定分区的选择。&lt;/p&gt;
&lt;p&gt;Kafka在设计时使用键值对的形式，可以为使用者提供功能上的扩展，例如可以自定义分区规则，将相同key的消息放在同一个分区中。&lt;/p&gt;
&lt;p&gt;当然，如果某些业务场景下对key没有特殊要求，这个字段也是可以不填的。&lt;/p&gt;
&lt;h2 id=&#34;kafka-vs-redis&#34;&gt;Kafka VS Redis&lt;/h2&gt;
&lt;p&gt;Redis List的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持重复消费：消息一旦被消费，就会从 Redis 中删除，无法再被其他消费者消费。&lt;/li&gt;
&lt;li&gt;消息丢失：消费者获取消息后，若发生异常宕机，则消息就会丢失。&lt;/li&gt;
&lt;li&gt;当List达到最大长度，则无法继续添加新的消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis Pub/Sub的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息丢失
&lt;ul&gt;
&lt;li&gt;消费者下线&lt;/li&gt;
&lt;li&gt;Redis 宕机&lt;/li&gt;
&lt;li&gt;消息堆积：当消息超过消费者缓冲区大小，Redis 会强制消费者下线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考资料：https://www.jianshu.com/p/c37368c867f8&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lzb348110175/category_9309572.html&#34;&gt;CSDN kafka-扛麻袋的少年&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Kafka学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-27-NIO与epoll模型学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习BIO NIO AIO、epoll模型、Netty框架过程中的笔记，学习资料为文档及视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/aLXiPUwmRs4&#34;&gt;深入Hotspot源码与Linux内核理解NIO与Netty线程模型-预习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/hyVcrKK9xHF&#34;&gt;深入Hotspot源码与Linux内核理解NIO与Netty线程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/5nSfgiayKS5&#34;&gt;高性能网络通信框架Netty从入门到核心源码剖析-预习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/H5MPxB4cCcd&#34;&gt;高性能网络通信框架Netty从入门到核心源码剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;bio-blocking-io&#34;&gt;BIO-Blocking IO&lt;/h2&gt;
&lt;h3 id=&#34;基本写法&#34;&gt;基本写法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    BufferedReader reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
    System.out.println( reader.readLine() );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：并发量为1&lt;/p&gt;
&lt;h3 id=&#34;优化1使用多线程进行优化&#34;&gt;优化1：使用多线程进行优化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    new Thread() {
        @Override
        public void run() {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
                System.out.println( reader.readLine() );
            } catch (IOException e) {
                e.printStackTrace();
            }
            
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：存在C10K问题，当并发量过大时，因为开的线程太多，会被内存挤爆。&lt;/p&gt;
&lt;h3 id=&#34;优化2使用线程池进行优化&#34;&gt;优化2：使用线程池进行优化&lt;/h3&gt;
&lt;p&gt;缺点：并发数会受到线程池中线程数的约束&lt;/p&gt;
&lt;h3 id=&#34;共同问题&#34;&gt;共同问题&lt;/h3&gt;
&lt;p&gt;可能会存在建立连接后不发数据的情况，导致该线程阻塞，降低系统性能&lt;/p&gt;
&lt;h2 id=&#34;nio-non-blocking-io&#34;&gt;NIO-Non-blocking IO&lt;/h2&gt;
&lt;h3 id=&#34;基本写法-2&#34;&gt;基本写法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
List&amp;lt;SocketChannel&amp;gt; socketChannelList = new ArrayList&amp;lt;&amp;gt;();
while( true ) {
    SocketChannel socketChannel = serverChannel.accept();
    if( socketChannel != null ) {
        socketChannel.configureBlocking( false );
        socketChannelList.add( socketChannel );
    }
    Iterator&amp;lt;SocketChannel&amp;gt; iterator = socketChannelList.iterator();
    while( iterator.hasNext() ) {
        SocketChannel socketChannel1 = iterator.next();
        ByteBuffer byteBuffer = ByteBuffer.allocate(128);
        int len = socketChannel1.read( byteBuffer );
        if( len &amp;gt; 0 ) {
            System.out.println( new String(byteBuffer.array()));
        } else if( len == -1 ) {
            iterator.remove();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对所有连接进行轮询，判断是否发送数据，但可能大部分连接都没有发送数据（空轮询）&lt;/li&gt;
&lt;li&gt;C10K问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优化使用selector进行优化&#34;&gt;优化：使用selector进行优化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
Selector selector = Selector.open();
serverChannel.register( selector, SelectionKey.OP_ACCEPT );
while( true ) {
    selector.select();
    Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
    Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
    while( iterator.hasNext() ) {
        SelectionKey selectionKey = iterator.next();
        if( selectionKey.isAcceptable() ) {
            ServerSocketChannel serverChannel1 = (ServerSocketChannel) selectionKey.channel();
            SocketChannel socketChannel = serverChannel1.accept();
            socketChannel.register( selector, SelectionKey.OP_READ );
        } else if( selectionKey.isReadable() ) {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(128);
            int len = socketChannel.read( byteBuffer );
            if( len &amp;gt; 0 ) {
                System.out.println( new String(byteBuffer.array()));
            } else if( len == -1 ) {
                iterator.remove();
            }
        }
        iterator.remove();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;selector原理&#34;&gt;Selector原理&lt;/h3&gt;
&lt;p&gt;在linux环境下，selector基于epoll实现（在windows环境下，不基于epoll）。&lt;/p&gt;
&lt;p&gt;使用epoll_create创建epoll对象，使用epoll_ctl进行注册，使用epoll_wait进行阻塞监听。&lt;/p&gt;
&lt;p&gt;Java调用操作系统的内核函数来创建Socket，获取到Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符，将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知。&lt;/p&gt;
&lt;p&gt;epoll基于“回调”实现监听。&lt;/p&gt;
&lt;p&gt;在Selector中，连接建立、数据读取都依赖于系统函数，例如，连接建立依赖于accept函数。因此，Selector可以使用epoll监听系统函数的调用，从而实现对连接建立、数据读取的监听。&lt;/p&gt;
&lt;p&gt;本质上，epoll监听的是文件描述符的状态（可读、可写）&lt;/p&gt;
&lt;h3 id=&#34;对selector的理解&#34;&gt;对Selector的理解&lt;/h3&gt;
&lt;p&gt;在Selector的实现中，看似是存在阻塞的（&lt;code&gt;selector.select()&lt;/code&gt;），但Selector依旧属于同步非阻塞IO的范畴，这是因为，这里所谓的阻塞，指的是当有多个连接希望建立时，因为正在处理某个连接的建立，导致其他连接无法被处理（连接被阻塞了），因此，这里所谓的阻塞，面向的对象是连接，当然，也可以是数据的读取，而不是程序的阻塞。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;selector.select()&lt;/code&gt;方法，当没有连接希望建立时，会阻塞，一旦有连接希望建立，则会立刻结束阻塞，且当有多个连接希望建立时，多个连接之间也不会有相互影响（即，因为线程A的建立，导致线程B建立请求的阻塞）。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;selector.select()&lt;/code&gt;方法的内部，其实调用的是&lt;code&gt;epoll_wait&lt;/code&gt;方法，这个方法是异步非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;对epoll的理解&#34;&gt;对epoll的理解&lt;/h3&gt;
&lt;p&gt;epoll本质上还是属于NIO的，虽然它的内部实现是基于“回调”的。&lt;/p&gt;
&lt;p&gt;这句话怎么理解？&lt;/p&gt;
&lt;p&gt;在epoll中，会有一个就绪队列，当监听的fd（文件描述符）完成某个操作（完成连接、读取数据完成等）时，内核会触发epoll的回调函数，回调函数会把该fd放入就绪队列里。&lt;code&gt;epoll_wait&lt;/code&gt; 会监听就绪队列，当就绪队列中存在fd时，则会返回。&lt;/p&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/h2604396739/article/details/82534253&#34;&gt;BIO\NIO\AIO再理解，nio轮询方式与epoll&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nio与aio-asynchronous-io-的区别&#34;&gt;NIO与AIO (Asynchronous IO) 的区别&lt;/h2&gt;
&lt;p&gt;NIO为同步非阻塞IO，会在程序中进行轮询，当发现有事件发生后，会对事件进行处理。&lt;/p&gt;
&lt;p&gt;AIO为异步非阻塞IO，预先写好处理逻辑，当有事件发生后，处理函数会被调用，用于处理事件（观察者模式）。&lt;/p&gt;
&lt;h2 id=&#34;对io多路复用的理解&#34;&gt;对IO多路复用的理解&lt;/h2&gt;
&lt;p&gt;如果不使用IO多路复用技术，那么对于每一个请求，都需要一个线程去进行管理，而如果使用了IO多路复用技术，则可以使用一个线程去管理多个请求，这里所谓的复用，指的是线程的复用。&lt;/p&gt;
&lt;p&gt;对于select和poll，使用的是轮询，即，在一个线程中，遍历所有的请求。而epoll，使用的是回调，即，当收到内核的通知后，将请求放到就绪队列中，同时，用 &lt;code&gt;epoll_wait&lt;/code&gt; 监听就绪队列。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210813163540811.png&#34; alt=&#34;image-20210813163540811&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/32163005&#34;&gt;IO 多路复用是什么意思？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty&#34;&gt;Netty&lt;/h2&gt;
&lt;h3 id=&#34;零拷贝机制&#34;&gt;零拷贝机制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210824140232560.png&#34; alt=&#34;image-20210824140232560&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">BIO NIO AIO、epoll模型、Netty框架学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-14-RESTHeart学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Zabbix过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://restheart.org/docs/try/&#34;&gt;Try RESTHeart Online&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/rongfengliang/p/9584470.html&#34;&gt;restheart 基本使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;PS：在RESTHeart中，如果要更新的item不存在，则会自动进行创建。&lt;/p&gt;
&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;h3 id=&#34;创建文档&#34;&gt;创建文档&lt;/h3&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;获取&#34;&gt;获取&lt;/h2&gt;
&lt;h3 id=&#34;获取集合中所有文档&#34;&gt;获取集合中所有文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;获取特定文档&#34;&gt;获取特定文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;指定过滤条件获取集合中的部分文档&#34;&gt;指定过滤条件，获取集合中的部分文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id?filter={&#39;from&#39;:&#39;you&#39;}&amp;amp;pagesize=2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;
&lt;h3 id=&#34;更新数据库&#34;&gt;更新数据库&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新集合&#34;&gt;更新集合&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新整个文档&#34;&gt;更新整个文档&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新文档中的部分内容&#34;&gt;更新文档中的部分内容&lt;/h3&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
">RESTHeart学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-14-Zabbix学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Zabbix过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zsythink.net/archives/790&#34;&gt;zabbix从放弃到入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
">Zabbix学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-13-Celery学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Celery过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/22304455&#34;&gt;使用Celery-小明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210513101505012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Celery学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-12-MongoDB学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习MongoDB过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xiaohuiduan/p/11403891.html&#34;&gt;Mongodb最基础入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/64352&#34;&gt;什么场景应该用 MongoDB ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/32071167&#34;&gt;MongoDB 应用场景?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mongodb使用场景&#34;&gt;MongoDB使用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用方便
&lt;ul&gt;
&lt;li&gt;增加字段不用改表结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可进行地理位置查询&lt;/li&gt;
&lt;li&gt;方便扩展&lt;/li&gt;
&lt;/ul&gt;
">MongoDB学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-08-redis学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习redis过程中的笔记，学习资料为视频及pdf，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/2Fg2Arj1Doe&#34;&gt;双十一秒杀系统后端Redis高并发架构实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/N7WiV8Wgjm9&#34;&gt;亿级流量新浪微博与微信Redis架构实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/e1jtR4D15kz&#34;&gt;Redis常见面试题汇总.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/CprZdykwNd2&#34;&gt;Redis持久化、主从与哨兵架构详解.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/1HdqGt4krK1&#34;&gt;Redis命令参考手册完整版.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分布式&#34;&gt;分布式&lt;/h2&gt;
&lt;h3 id=&#34;分布式并发场景中可能存在的问题&#34;&gt;分布式并发场景中可能存在的问题&lt;/h3&gt;
&lt;p&gt;使用synchronized对代码块加锁，但因为是分布式，多个应用同时访问redis，依旧无法解决并发冲突问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508160113749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;redis实现分布式锁&#34;&gt;Redis实现分布式锁&lt;/h3&gt;
&lt;p&gt;使用SETNX实现分布式锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存在的问题：因为某些原因，锁在用完后没有成功释放，如，功能代码块抛异常、系统宕机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加过期时间：&lt;/li&gt;
&lt;li&gt;存在的问题：
&lt;ul&gt;
&lt;li&gt;实际业务执行时间可能会大于过期时间：进程A执行过慢，导致锁自动被释放，之后进程B进行加锁，开始处理业务，然后进程A执行完，释放B的锁，又导致进程C进行加锁，无限循环，最终导致锁永久失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：自己的锁只有自己可以释放（或者过期自动释放）
&lt;ul&gt;
&lt;li&gt;存在的问题：
&lt;ul&gt;
&lt;li&gt;还是&lt;strong&gt;过期时间&lt;/strong&gt;的锅：当进程A需要释放锁的时候，从redis获取锁的value，发现是自己加的锁，但随后，锁因为过期时间，自动失效，进程B随即进行加锁，然后进程A释放锁，就导致会把进程B的锁释放掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;锁续命：另开一个线程，持续进行加锁操作，例如过期时间是30s，则每10s加一次锁，保证业务执行过程中，锁不会自动失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式锁的性能问题&#34;&gt;分布式锁的性能问题&lt;/h3&gt;
&lt;p&gt;使用分布式锁，本质上是让所有web请求串行化执行，执行效率较低。&lt;/p&gt;
&lt;p&gt;解决方案：分段加锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例：秒杀场景下，为了防止超卖，需要使用分布式锁，例如商品数量为200个，那么可以划分成10分，分别进行加锁，这样可以提高约10倍的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存-数据库双写不一致问题&#34;&gt;缓存、数据库双写不一致问题&lt;/h2&gt;
&lt;p&gt;场景1：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213252468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;场景2：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213547682.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;不一致&lt;/strong&gt;：数据库里数据为6，缓存为10&lt;/p&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;比较不推荐的做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟双删&lt;/li&gt;
&lt;li&gt;内存队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读多写少
&lt;ul&gt;
&lt;li&gt;分布式锁：通过读写锁进行优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读多写多，对一致性要求不高
&lt;ul&gt;
&lt;li&gt;给缓存设置过期时间，保证双写不一致的最大时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读多写多，对一致性要求高
&lt;ul&gt;
&lt;li&gt;不要用缓存：因为缓存更新后，可能过了几秒，就又要进行更新。这种情况下，不如不用缓存。&lt;/li&gt;
&lt;li&gt;使用canal中间件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;p&gt;全称：Remote Dictionary Server&lt;/p&gt;
&lt;h3 id=&#34;为什么性能高&#34;&gt;为什么性能高&lt;/h3&gt;
&lt;p&gt;对性能的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消极
&lt;ul&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;积极
&lt;ul&gt;
&lt;li&gt;内存操作&lt;/li&gt;
&lt;li&gt;基于epoll的多路复用模型&lt;/li&gt;
&lt;li&gt;高效的数据存储结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据存储结构&#34;&gt;数据存储结构&lt;/h4&gt;
&lt;p&gt;redis使用哈希表存储key-value对&lt;/p&gt;
&lt;p&gt;在redis中有对象和数据结构的概念，redis对象利用不同的数据结构进行存储，例如，String对象可以用int数据结构进行存储，也可以用SDS数据结构进行存储。&lt;/p&gt;
&lt;p&gt;对不同类型的对象，内部存储逻辑不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDS数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;embstr：小于等于44字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png&#34; alt=&#34;image-20210528141323986&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw：大于44字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png&#34; alt=&#34;image-20210528141338577&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;embstr与raw的区别是，embstr只会申请一次内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hash对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png&#34; alt=&#34;image-20210525101358367&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表：空间占用大，查找快&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：数据数量较少或所占空间较少时，使用压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链表：空间占用更多，但添加、删除元素时，效率高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速列表：Redis3.2之后，用快速列表代替压缩列表和链表&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png&#34; alt=&#34;image-20210528150649602&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数集合&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳表：查找快，但更占空间且更新性能低&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png&#34; alt=&#34;image-20210524163213876&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当元素个数超过&lt;code&gt;zset-max-ziplist-entries&lt;/code&gt;，切换成跳表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;epoll多路复用模型&#34;&gt;epoll多路复用模型&lt;/h4&gt;
&lt;h5 id=&#34;redis为什么要用epollredis为什么采用单线程&#34;&gt;redis为什么要用epoll（redis为什么采用单线程）&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;redis是单线程的：redis是内存操作，虽然内存的速度比CPU慢，但依旧很快，CPU的利用率较高，无需使用多线程提高CPU的利用率。在正常程序中，因为包含大量IO操作，CPU使用率不高，此时，使用多线程可以提高CPU利用率，优化性能。&lt;/li&gt;
&lt;li&gt;对于单线程的应用，当用户进行网络请求后，该线程会被阻塞，等待用户输入。线程被阻塞，也就意味着整个进程、整个redis被阻塞。若等待用户输入时间较长，则在高并发场景下，会极大影响redis性能。&lt;/li&gt;
&lt;li&gt;因此，redis需要将等待用户输入这一操作委托给系统去完成，即，redis基于系统提供的epoll实现了多路复用模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;epoll的实现原理&#34;&gt;epoll的实现原理&lt;/h5&gt;
&lt;h5 id=&#34;redis如何使用epoll&#34;&gt;redis如何使用epoll&lt;/h5&gt;
&lt;p&gt;epoll_create&lt;/p&gt;
&lt;p&gt;epoll_ctl&lt;/p&gt;
&lt;p&gt;epoll_wait&lt;/p&gt;
&lt;h3 id=&#34;不同数据类型的适用场景&#34;&gt;不同数据类型的适用场景&lt;/h3&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单值缓存&lt;/li&gt;
&lt;li&gt;对象缓存：JSON字符串&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;计数器&lt;/li&gt;
&lt;li&gt;分布式系统全局序列号
&lt;ul&gt;
&lt;li&gt;分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象缓存
&lt;ul&gt;
&lt;li&gt;与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现栈、队列、拥塞队列&lt;/li&gt;
&lt;li&gt;消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽奖功能：因为set有srandmember、spop方法&lt;/li&gt;
&lt;li&gt;点赞功能：频繁添加、删除、比较元素，用set效率比list好&lt;/li&gt;
&lt;li&gt;关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZSet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备份策略&#34;&gt;备份策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份&lt;/li&gt;
&lt;li&gt;每天都保留一份当日的数据备份到一个目录中去，保留最近1个月的备份&lt;/li&gt;
&lt;li&gt;每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主从架构&#34;&gt;主从架构&lt;/h3&gt;
&lt;p&gt;防止单点redis宕机，对业务造成影响&lt;/p&gt;
&lt;p&gt;使用主从架构，子节点同步父节点信息，当父节点宕机后，用子节点代替父节点继续提供服务&lt;/p&gt;
&lt;p&gt;主从节点切换导致锁丢失：使用zookeeper代替redis&lt;/p&gt;
&lt;p&gt;redis vs zookeeper：redis性能更好；zookeeper一致性更好。&lt;/p&gt;
&lt;h3 id=&#34;哨兵机制&#34;&gt;哨兵机制&lt;/h3&gt;
&lt;p&gt;1、故障节点主观下线&lt;/p&gt;
&lt;p&gt;2、故障节点客观下线&lt;/p&gt;
&lt;p&gt;3、Sentinel集群选举Leader&lt;/p&gt;
&lt;p&gt;4、Sentinel Leader决定新主节点&lt;/p&gt;
&lt;p&gt;详细资料：&lt;a href=&#34;https://blog.csdn.net/weixin_28871885/article/details/113315639&#34;&gt;redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;lua脚本&#34;&gt;Lua脚本&lt;/h3&gt;
&lt;p&gt;Lua脚本可以植入redis内部进行运行&lt;/p&gt;
&lt;p&gt;Lua脚本的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少网络开销：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。&lt;/li&gt;
&lt;li&gt;原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。&lt;/li&gt;
&lt;li&gt;替代redis的事务功能：redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐如果要使用redis的事务功能可以用redis lua替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-vs-kafka&#34;&gt;Redis vs Kafka&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112907568&#34;&gt;花5min就能搞清楚redis和zookeeper分布式锁的区别，太有必要读一下了&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;面试&#34;&gt;面试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA&#34;&gt;整理好了，Redis面试题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hunternet/p/11306690.html&#34;&gt;Redis数据结构——压缩列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_45401061/article/details/107382276&#34;&gt;面试官：Redis 为什么这么快？除了基于内存操作还有其他原因吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u011663149/article/details/85307615&#34;&gt;Redis为什么是单线程、及高并发快的大原因详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yyoc97/article/details/85804654&#34;&gt;从redis为什么单线程还那么快到epoll的设计原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_28871885/article/details/113315639&#34;&gt;redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">redis学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-07-docker学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习docker过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ke.qq.com/course/3385294?taid=11066554472179662&#34;&gt;Docker部署微服务实战&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 设置yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# 安装docker
yum -y install docker-ce # ce为社区版
# 启动docker
service docker start
# 验证
docker version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;h3 id=&#34;镜像相关&#34;&gt;镜像相关&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 搜索镜像
docker search java
# 下载镜像
docker pull java:8
docker pull nginx:1.14
# 列出本地镜像
docker images
# 删除镜像
docker rmi java:8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;容器相关&#34;&gt;容器相关&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 新建并启动容器
docker run -d -p 91:80 -net=bridge(default)/host nginx
# 列出容器
docker ps
# 启动/停止容器
docker start/stop container_id
# 查看容器信息
docker inspect container_id
# 进入容器
docker container exec -it container_id /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;好处&#34;&gt;好处&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将主流的中间件打包成docker，可实现快速部署。因为docker的使用，如启动和关闭，命令都是相同的，所以可以使用脚本实现自动化的部署。而如果不使用docker，不同的中间件都有一套对应的运维命令，运维工作的效率将会降低很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker技术提供了一种管理机制，可以对各种制品进行统一管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 的镜像机制提供了一种更高级的通用的应用制品（artifact）包，也就是大家说的集装箱能力。原来各种操作系统或编程语言都有各自己的制品机制，Ubuntu 的 deb，RedHat 的 RPM，Java 的 JAR、WAR，各自的依赖管理，制品库都不相同。应用从源码打包，分发到制品库，再部署到服务器，很难抽象出一种通用的流程和机制。而有了 Docker 的镜像以及镜像仓库标准之后，这个流程终于可以标准化了。于是雨后春笋般冒出很多镜像管理仓库，这在以前的制品管理领域是很难想象的，以前貌似也就 Java 领域的 nexus 和 artifactory 略完备些。&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;amp;mid=2653548284&amp;amp;idx=1&amp;amp;sn=9243449fac7e86342f84da3a6a87453c&amp;amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;amp;scene=21#wechat_redirect&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 指定基础镜像
FROM nginx
# 执行命令
RUN echo &amp;quot;hello, world!&amp;quot; &amp;gt; hello.html
# 复制文件到容器
ADD a.jar /app.jar
# 声明需要暴露的端口
EXPOSE 8761
# 配置容器启动后执行的命令
ENTRYPOINT[&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]

docker build -t nginx:hello .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;virtual-machines-vs-docker&#34;&gt;Virtual Machines VS Docker&lt;/h2&gt;
&lt;p&gt;OS：虚拟机有实实在在的操作系统；Docker通过引擎虚拟操作系统&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210507193822675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">docker学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-25-NOJ优化-PHP-Laravel/"" data-c="
          &lt;p&gt;这篇文章，主要介绍一下NOJ的部署。&lt;/p&gt;
&lt;p&gt;主要参考这篇文章：https://njuptaaa.github.io/docs/#/noj/guide/deploy&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;
&lt;h3 id=&#34;安装环境&#34;&gt;安装环境&lt;/h3&gt;
&lt;p&gt;需要安装的环境有：Apache、PHP、Composer、MySQL、Redis&lt;/p&gt;
&lt;p&gt;Apache和MySQL在我本地已经有了，直接跳过。&lt;/p&gt;
&lt;p&gt;对于PHP和Composer，直接在官网下载，需要注意的是，对于Composer，直接下载可执行的安装包就行；对于PHP，需要下载的是zip，而不是source code，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175552450.png&#34; alt=&#34;image-20210425175552450&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;PHP压缩包下载完，解压到任意文件夹中，然后运行Composer的安装程序，在安装过程中，需要指定php的路径，选择解压后文件夹中的php.exe：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175722912.png&#34; alt=&#34;image-20210425175722912&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;git-clone&#34;&gt;git-clone&lt;/h3&gt;
&lt;p&gt;在这一步，需要注意的是，需要把noj项目克隆到apache或者nginx的文件夹下，并将其中的public文件夹设置成根目录。&lt;/p&gt;
&lt;h3 id=&#34;composer-install&#34;&gt;composer install&lt;/h3&gt;
&lt;h4 id=&#34;your-lock-file-does-not-contain-a-compatible-set-of-packages-please-run-composer-update&#34;&gt;Your lock file does not contain a compatible set of packages. Please run composer update.&lt;/h4&gt;
&lt;p&gt;环境配置好后，就可以开始安装项目了，使用&lt;code&gt;composer install&lt;/code&gt;进行安装，但我本地报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E:\NOJ&amp;gt;composer install
Installing dependencies from lock file (including require-dev)
Verifying lock file contents can be installed on current platform.
Your lock file does not contain a compatible set of packages. Please run composer update.

  Problem 1
    - grubersjoe/bing-daily-photo is locked to version v2.0.0 and an update of this package was not requested.
    - grubersjoe/bing-daily-photo v2.0.0 requires ext-intl * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s intl extension.
  Problem 2
    - intervention/image is locked to version 2.5.1 and an update of this package was not requested.
    - intervention/image 2.5.1 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 3
    - league/flysystem is locked to version 1.1.3 and an update of this package was not requested.
    - league/flysystem 1.1.3 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 4
    - league/mime-type-detection is locked to version 1.5.1 and an update of this package was not requested.
    - league/mime-type-detection 1.5.1 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 5
    - phpoffice/phpspreadsheet is locked to version 1.15.0 and an update of this package was not requested.
    - phpoffice/phpspreadsheet 1.15.0 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 6
    - league/flysystem 1.1.3 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
    - spatie/laravel-backup 6.13.1 requires league/flysystem ^1.0.49 -&amp;gt; satisfiable by league/flysystem[1.1.3].
    - spatie/laravel-backup is locked to version 6.13.1 and an update of this package was not requested.

To enable extensions, verify that they are enabled in your .ini files:
    - E:\environment\php\php-7.3.27-nts-Win32-VC15-x64\php.ini
You can also run `php --ini` inside terminal to see which files are used by PHP in CLI mode.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;composer install --ignore-platform-reqs&lt;/code&gt;就不会报错了。&lt;/p&gt;
&lt;h4 id=&#34;the-process-class-relies-on-proc_open-which-is-not-available-on-your-php-installation&#34;&gt;The Process class relies on proc_open, which is not available on your PHP installation.&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lw545034502/article/details/96450335&#34;&gt;（亲测可用）The Process class relies on proc_open, which is not available on your PHP installation.解决方案！&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;php-routes的使用&#34;&gt;php routes的使用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/yaoliuyang/p/12298780.html&#34;&gt;thinkphp中路由的基本使用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;nginx配置&#34;&gt;nginx配置&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/96149578&#34;&gt;PHP]深度解析Nginx下的PHP框架路由实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目信息&#34;&gt;项目信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;submit：提交到后台&lt;/li&gt;
&lt;li&gt;pedding：队列中准备提交&lt;/li&gt;
&lt;li&gt;waiting：已提交，等待结果&lt;/li&gt;
&lt;li&gt;submitting -&amp;gt; pedding -&amp;gt; waiting -&amp;gt; accept&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;p&gt;01:08开始&lt;/p&gt;
&lt;p&gt;前面，主要是介绍项目&lt;/p&gt;
&lt;h3 id=&#34;优化1实时更新榜单&#34;&gt;优化1：实时更新榜单&lt;/h3&gt;
&lt;p&gt;06:00&lt;/p&gt;
&lt;p&gt;目前是一分钟更新一次，从数据库读取到redis中&lt;/p&gt;
&lt;p&gt;优化思路：1、使用增量更新，当有新的AC事件发生时，更新内存中的redis缓存；2、客户端，对于提交记录，循环查询结果，查询操作为异步，循环间隔为5s，使用内存锁避免查询冲突&lt;/p&gt;
&lt;p&gt;目前的问题：对于每个提交记录，被更新了10几次。&lt;/p&gt;
&lt;h3 id=&#34;优化2容器化&#34;&gt;优化2：容器化&lt;/h3&gt;
&lt;p&gt;将各个功能点封装成docker容器&lt;/p&gt;
&lt;h3 id=&#34;优化3管理功能界面&#34;&gt;优化3：管理功能界面&lt;/h3&gt;
&lt;p&gt;74:28&lt;/p&gt;
&lt;h2 id=&#34;phpstore&#34;&gt;PhpStore&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/ljh101/article/details/112549860&#34;&gt;composer require --dev barryvdh/laravel-ide-helper报错解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[&lt;a href=&#34;https://my.oschina.net/anziguoer/blog/647367&#34;&gt;Phpstorm 安装 laravel扩展，laravel代码提示插件&lt;/a&gt;](https://my.oschina.net/anziguoer/blog/647367)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后台参考这里的代码https://github.com/ZsgsDesign/HASAAOSE/tree/main/app/Admin&lt;/p&gt;
">NOJ优化-PHP-Laravel</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/"" data-c="
          &lt;p&gt;本文主要是对 &lt;a href=&#34;https://wym0120.github.io/2021/04/12/cmmi/&#34;&gt;[课堂笔记] 软件过程改进 &lt;/a&gt;这篇文章的一些个人补充&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;过程的定义&#34;&gt;过程的定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IEEE: Sequence of steps performed for a given purpose.
&lt;ul&gt;
&lt;li&gt;为给定目的执行的步骤顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a SP ecified end result.
&lt;ul&gt;
&lt;li&gt;人员、材料、能源、设备和程序 在工作活动中的逻辑组织，旨在产生SP（特定实践）确认的最终结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMMI GLOSSARY: A set of interrelated activities, which transform inputs into outputs, to achieve a given purpose (These activities can be mapped to one or more practices in CMMI process areas to allow a model to be useful for process improvement and process appraisal.)
&lt;ul&gt;
&lt;li&gt;一组相互关联的活动，这些活动将输入转化为输出，以实现给定的目的（这些活动可以映射到CMMI过程域中的一个或多个实践，以使模型可用于流程改进和流程评估。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过程和过程域的关系&#34;&gt;过程和过程域的关系&lt;/h2&gt;
&lt;p&gt;过程域中包含若干过程。&lt;/p&gt;
&lt;h2 id=&#34;连续式表示法与阶段式表示法&#34;&gt;连续式表示法与阶段式表示法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;连续式表示法：选择一个特定的过程域进行改进。&lt;/li&gt;
&lt;li&gt;阶段式表示法：选择某一成熟度级别下的多个过程域进行改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等价阶段式定级&#34;&gt;等价阶段式定级&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CL：capability level 能力等级&lt;/li&gt;
&lt;li&gt;ML：maturity level 成熟度级别&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过程模型&#34;&gt;过程模型&lt;/h2&gt;
&lt;p&gt;过程模型是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。&lt;/p&gt;
&lt;p&gt;CMMI 开发模型就是一种过程模型。&lt;/p&gt;
&lt;h2 id=&#34;cmmi来源于哪三个模型-研究机构&#34;&gt;CMMI来源于哪三个模型 ，研究机构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;软件工程 sw-cmm&lt;/li&gt;
&lt;li&gt;系统工程 EIA/IS&lt;/li&gt;
&lt;li&gt;集成化产品和过程开发 IPD-CMM&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210416144801516.png&#34; alt=&#34;image-20210416144801516&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;已管理和已定义的区别&#34;&gt;已管理和已定义的区别&lt;/h2&gt;
&lt;p&gt;已管理：标准、过程描述与规程在过程的每个特定实例中（如在某一特定项目中）都可能有很大的不同。&lt;/p&gt;
&lt;p&gt;已定义：项目的标准、过程描述与规程是从组织的标准过程集中裁剪得来，以适应特定的项目或组织级单位，因而就更为一致，除非是裁剪指南所允许的差别。&lt;/p&gt;
&lt;h2 id=&#34;过程域&#34;&gt;过程域&lt;/h2&gt;
&lt;h3 id=&#34;工程类&#34;&gt;工程类&lt;/h3&gt;
&lt;h4 id=&#34;确认与验证的区别&#34;&gt;确认与验证的区别&lt;/h4&gt;
&lt;p&gt;确认：确认产品实际的用途是否符合其预期的用途；做了正确的事。&lt;/p&gt;
&lt;p&gt;验证：验证工作产品（or 产品）的功能是否符合需求；正确地做了事。&lt;/p&gt;
&lt;h3 id=&#34;支持类&#34;&gt;支持类&lt;/h3&gt;
&lt;h4 id=&#34;度量与分析-and-过程与产品质量保证&#34;&gt;度量与分析 and 过程与产品质量保证&lt;/h4&gt;
&lt;p&gt;PPQA专注于质量，而MA则是对一切过程提供度量与分析。当对质量进行度量与分析时，个人认为MA与PPQA是等价的，因此，MA的范围更广，而PPQA则专注于质量方面。&lt;/p&gt;
&lt;h2 id=&#34;ppt中问题整理&#34;&gt;PPT中问题整理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;requirements traceability：需求可追溯性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A to B and vice versa：A符合B，反之亦然&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Budget and funding：预算和资金&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Staff：职员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Facilities：设施&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;peer review meetings：同行评审会议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delinquent：拖欠的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;People are not meeting schedules.：人们没有遵守时间表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;likelihood：可能性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;motion sensors：运动传感器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;contract：合同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;COTS were used for the keypad; sensors were secured from suppliers; and the controller consists of re-used PASS in-house software.：键盘上使用了COTS； 传感器由供应商提供保护； 控制器由重复使用的PASS内部软件组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;incorporating experiences：整合经验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;appraisal metrics：评估指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align with：对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All PASS projects follow the standard process exactly as is.：所有PASS项目都完全按照标准流程进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trace：追溯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tailoring：裁剪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spiral lifecycle：螺旋生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简答题列表&#34;&gt;简答题列表&lt;/h2&gt;
&lt;h3 id=&#34;过程域相关&#34;&gt;过程域相关&lt;/h3&gt;
&lt;p&gt;Lv4组织级过程性能(OPP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x.y.z代表着什么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2项目监督与控制(PMC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目监控点选择的原则？原因&lt;/li&gt;
&lt;li&gt;SG2中的相关实践约定，需要采取纠偏措施的问题来源&lt;/li&gt;
&lt;li&gt;纠偏行动的先决条件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2项目计划(PP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PP过程域在项目中的作用域&lt;/li&gt;
&lt;li&gt;计划制定的原则？&lt;/li&gt;
&lt;li&gt;一般的估算方法有哪几个？区别&lt;/li&gt;
&lt;li&gt;什么是承诺管理？承诺的分类&lt;/li&gt;
&lt;li&gt;PP中“建立”和“维护”两个活动的解释？&lt;/li&gt;
&lt;li&gt;估算目标: 不是尽可能客观描述代码行/工作量（永远不可能实现估算），而是得到一个数字&lt;strong&gt;数字对不对不重要，重要的是大家认可&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2需求管理(REQM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(需求跟踪的方法) 需求跟踪矩阵的使用&lt;/li&gt;
&lt;li&gt;(获得需求承诺) 应该获得那些人的承诺&lt;/li&gt;
&lt;li&gt;识别需求不一致性的最有效方法&lt;/li&gt;
&lt;li&gt;敏捷对于需求的态度是拥抱变更，但这是不正确的，大部分开发人员还是希望能够close开发&lt;/li&gt;
&lt;li&gt;Scrum对于需求的态度是不响应一个SP rint中的需求变更(目标不变)，只是记录到backlog，可能会在下一个迭代响应变更&lt;/li&gt;
&lt;li&gt;理解双向可跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv4量化项目管理(QPM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OPP 和 QPM 的关联&lt;/li&gt;
&lt;li&gt;QPM SP1.2 和之前过程定义的区别 （和 IPM 的区别）&lt;/li&gt;
&lt;li&gt;QPM 和 OPM 的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3产品集成(PI)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设你是产品集成的负责人，拒绝那些不合格的产品组件。定义哪些验收标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3验证 (VER)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VAL 和 VER的关键区别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2度量与分析(MA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;度量分析的作用体现在哪些方面？(从项目和组织两个角度分析)&lt;/li&gt;
&lt;li&gt;度量的目的要支持质量的目标&lt;/li&gt;
&lt;li&gt;如何满足度量的可追踪性(哪些工作产品可以满足)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2配置管理(CM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个软件开发过程中会产生很多工作产品artifacts/work product，但是并不是所有产品都是值得管理的，要去掉一些不那么重要的产品，确保重要的（为了让交付有完整性的）工作产品被管理。其实就是为了减少工作量。&lt;/li&gt;
&lt;li&gt;CCB: Change Control Board&lt;/li&gt;
&lt;li&gt;配置管理员的主要职责&lt;/li&gt;
&lt;li&gt;配置项标示的规则，什么情况下改写Vx.y.z中的x和y？什么说情况下改写z？规则是怎样的&lt;/li&gt;
&lt;li&gt;配置管理系统的等级？三个概念库如何体现配置库的等级？配置库需要注意什么&lt;/li&gt;
&lt;li&gt;基线的定义和特点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2过程与产品质量保证(PPQA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件项目质量的分类&lt;/li&gt;
&lt;li&gt;QA行使的角色&lt;/li&gt;
&lt;li&gt;解释 PPQA QA SQA NC QC&lt;/li&gt;
&lt;li&gt;QA 和 QC差别？&lt;/li&gt;
&lt;li&gt;执行PPQA的工具方法&lt;/li&gt;
&lt;li&gt;简述评审一般过程、审计一般过程&lt;/li&gt;
&lt;li&gt;QA人员以及PPQA过程的质量保证如何实现&lt;/li&gt;
&lt;li&gt;如何评价&amp;quot;测试驱动开发TDD可以显著提升质量&amp;quot;这一说法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3决策分析与解决(DAR)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何评价 &amp;quot;CMMI 是官僚、重文档的&amp;quot;这一说法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv5原因分析与解决(CAR)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAR 在本质上做的是什么&lt;/li&gt;
&lt;li&gt;CAR 一定是选坏的吗&lt;/li&gt;
&lt;li&gt;CAR 实际上是依赖于 OPM 进行执行的&lt;/li&gt;
&lt;li&gt;CAR 的理念是不犯错比犯了错再改正更好&lt;/li&gt;
&lt;li&gt;CAR 在4级和5级的不同&lt;/li&gt;
&lt;li&gt;CAR 为什么需要和 OPM 配合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ppt&#34;&gt;ppt&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Which of the following examples of requirements traceability are adequate?&lt;/li&gt;
&lt;li&gt;PASS is planning their resources. What project resources should be included?&lt;/li&gt;
&lt;li&gt;Project Management and Control&lt;/li&gt;
&lt;li&gt;Risk Management&lt;/li&gt;
&lt;li&gt;Supplier Agreement Management&lt;/li&gt;
&lt;li&gt;Which CM SPs could have prevented the problem?&lt;/li&gt;
&lt;li&gt;Which are process evaluations? Which are product evaluations?&lt;/li&gt;
&lt;li&gt;Which of the following are adequate for verification procedures and criteria?&lt;/li&gt;
&lt;li&gt;Which are verification and which are validation?&lt;/li&gt;
&lt;li&gt;Which of the following show incorporating experiences?&lt;/li&gt;
&lt;li&gt;Which PASS scenarios align with IPM?&lt;/li&gt;
&lt;li&gt;Organizational Process Definition&lt;/li&gt;
&lt;li&gt;Organizational Training&lt;/li&gt;
&lt;li&gt;VER SG2 SG3: SG3包含SG2&lt;/li&gt;
&lt;li&gt;持续集成 vs 大爆炸集成&lt;/li&gt;
&lt;/ul&gt;
">南京大学-软件过程改进-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/"" data-c="
          &lt;h2 id=&#34;b树-b树索引&#34;&gt;B树、B+树索引&lt;/h2&gt;
&lt;h3 id=&#34;阶的含义&#34;&gt;阶的含义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;上限：每个节点最多有 M 个子树&lt;/li&gt;
&lt;li&gt;下限：
&lt;ul&gt;
&lt;li&gt;根节点至少2个子树
&lt;ul&gt;
&lt;li&gt;非根节点至少有⌈M /2⌉个子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;画结构&#34;&gt;画结构&lt;/h3&gt;
&lt;p&gt;B+树&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415160910412.png&#34; alt=&#34;image-20210415160910412&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418174758526.png&#34; alt=&#34;image-20210418174758526&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418175351820.png&#34; alt=&#34;image-20210418175351820&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;b树使用场景&#34;&gt;B+树使用场景&lt;/h3&gt;
&lt;p&gt;能做的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全键值：Where x=123&lt;/li&gt;
&lt;li&gt;键值范围：Where 45&amp;lt;x&amp;lt;123&lt;/li&gt;
&lt;li&gt;键前缀查找：where x LIKE ‘J%’&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候能用，什么时候不能用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一般索引，都能用，除非查询优化器发现用了索引后，会导致性能降低，则不会使用索引，例如因为索引占用空间太大，导致IO操作耗时较高。&lt;/li&gt;
&lt;li&gt;对于复合索引，如果违反最左匹配原则，则不能用。例如，对(x,y)建立索引，但对y进行查询，则不能用。&lt;/li&gt;
&lt;li&gt;对于一个有索引的列作出函数查询，Select * from t where f(indexed_col) = value&lt;/li&gt;
&lt;li&gt;隐形函数查询，比如查询SQL中存在隐式类型转换，比如no为VARCHAR类型，但是查询时把该字段当做INT类型查询：SELECT * FROM T WHERE no = 2124&lt;/li&gt;
&lt;li&gt;没有正确的统计信息，造成查询优化器无法做出正确的选择&lt;/li&gt;
&lt;li&gt;含前导模糊查询的Like语法不能使用索引（”%XXX”）&lt;/li&gt;
&lt;li&gt;B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候应该用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅当要通过索引访问表中很少一部分行&lt;/li&gt;
&lt;li&gt;虽然查询行数比较多，但索引包含多个字段，而要访问的字段全部包含在索引中时，查找只需通过索引而不用访问全表时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候不应该用（没找到答案，自己的理解）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当需要查询的数据占表总数据的比重很大时，不应该使用索引，因为查询优化器会发现，使用索引的效率不如全表遍历。&lt;/li&gt;
&lt;li&gt;写密集型事务：频繁修改索引，增加开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分区&#34;&gt;分区&lt;/h2&gt;
&lt;h3 id=&#34;分区是干嘛用的&#34;&gt;分区是干嘛用的&lt;/h3&gt;
&lt;p&gt;分区就是将一个大表根据条件分割成若干个小表，是一种数据分组方式，能够提高并发性和并行性。对于多用户并发访问情况，查询效率可能较高。&lt;/p&gt;
&lt;p&gt;表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件）上&lt;/p&gt;
&lt;h3 id=&#34;根据分区键partition-key的类型分类分区有哪几种类型&#34;&gt;根据分区键（Partition Key）的类型分类，分区有哪几种类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希分区：对分区键进行哈希运算，根据运算结果进行分区。 &lt;s&gt;把不同的列随机平均的分布到不同的物理环境，达到备份和恢复（写 undo 和 redo文件）效率高，降低错误回滚压力（为了管理）。&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;范围分区：根据连续数据的范围对数据进行分区~~。把字段的值分布到一个物理范围~~，这个范围是你在创建分区时指定的分区键决定的。这种分区方式是最为常用的。&lt;/li&gt;
&lt;li&gt;列表分区：把不同的列存到不同的分区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何选择分区键-选择原则是什么&#34;&gt;如何选择分区键、选择原则是什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希分区：根据分区键，可以快速找到记录，但对范围检索没有任何帮助。更接近于非数据驱动的循环分区，用于负载均衡，提高并发的能力。&lt;/li&gt;
&lt;li&gt;范围分区：比较常用，非常适合处理历史数据。&lt;/li&gt;
&lt;li&gt;列表分区：查询时，通常只查询某几个字段，或者，某几个字段通常一起被查询。但，每个分区都必须有主键，因此会造成冗余。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;按什么字段进行分区要整体考虑，因为：更新分区键会引起移动数据，应该避免这么做。当数据分区键均匀分布时，分区表查询收益最大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;h3 id=&#34;处理模式操作模式批处理与实时系统&#34;&gt;处理模式（操作模式）：批处理与实时系统&lt;/h3&gt;
&lt;p&gt;9.2 为性能设计（下）.mp4，17:09&lt;/p&gt;
&lt;h4 id=&#34;基本逻辑&#34;&gt;基本逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异步处理模式：可以允许用户发出操作之后去做其他工作，数据库进行集中的批处理，当处理完毕后通知用户，但是实时性不好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步处理时模式：用户必须等待数据库操作并返回结果，期间不能做其它操作。适合数据库进行实时交易。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;好坏&#34;&gt;好坏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当操作过于复杂，需要横跨很多系统、物理环境，实时系统中不可控的因素就会变多，此时就需要采用异步处理模式。&lt;/li&gt;
&lt;li&gt;异步处理模式：健壮性、稳定性更强。&lt;/li&gt;
&lt;li&gt;同步处理模式：满足实时性的要求，在某些特定业务下，这是必须的，比如银行转账业务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;选择&#34;&gt;选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;由系统需求和所需处理的数据的物理结构决定的，大部分情况下，同步和异步是共存的，不能先入为主得认为业务必须同步。&lt;/li&gt;
&lt;li&gt;从性能的角度，如果对实时性没有要求，则可以考虑尝试使用批处理模式&lt;/li&gt;
&lt;li&gt;在批处理模式下，更容易暴露性能问题，因为批处理需要压榨硬件资源，而实时系统只有在高并发或大数据量的情况下才可能暴露性能问题，而当实时系统暴露出性能问题后，可能会极大影响正常业务的开展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储模式集中式与分布式&#34;&gt;存储模式：集中式与分布式&lt;/h3&gt;
&lt;p&gt;9.2 为性能设计（下）.mp4，11:31&lt;/p&gt;
&lt;h4 id=&#34;基本逻辑-2&#34;&gt;基本逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分布式数据存储：将数据分散存储在多台独立的设备上，一般情况下，多台设备在地理位置上相对分散。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中式数据存储：将数据集中存储在一台或多台设备上，一般情况下，存储设备在地理位置上相对集中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;好坏-2&#34;&gt;好坏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分布式数据系统：
&lt;ul&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;复杂度高、健壮性低、管理成本高&lt;/li&gt;
&lt;li&gt;保密性不易控制&lt;/li&gt;
&lt;li&gt;多个副本的一致性难以保证&lt;/li&gt;
&lt;li&gt;不同数据源数据的结合极为困难
&lt;ul&gt;
&lt;li&gt;数据传输开销大&lt;/li&gt;
&lt;li&gt;脱离数据源的环境，数据源无法从数据规划中获益（物理结构、索引）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;单一节点的负担低&lt;/li&gt;
&lt;li&gt;具有更灵活的体系结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集中式
&lt;ul&gt;
&lt;li&gt;缺点：单点故障，会带来很大损失，因此常常需要热备份或灾难备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;选择-2&#34;&gt;选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;平衡、折中
&lt;ul&gt;
&lt;li&gt;全球性的数据，若集中存储，则跨大陆的访问速度将大幅降低（离数据越近，访问越快）；但从另一个角度看，因为集中式避免了分布式中的数据传输，并可以利用数据规划，因此查询速度快。&lt;/li&gt;
&lt;li&gt;集中式存储的访问吞吐量有上限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-查询优化器是如何工作的&#34;&gt;SQL-查询优化器是如何工作的&lt;/h2&gt;
&lt;p&gt;4.1 SQL优化.mp4，13:38&lt;/p&gt;
&lt;p&gt;优化是在数据处理的真正被执行的时候发生&lt;/p&gt;
&lt;p&gt;不同结果的关系表达式在实际环境下执行的效率千差万别&lt;/p&gt;
&lt;p&gt;查询优化器如何权衡哪种优化更好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于成本的优化器 CBO：综合考虑所有的情况。现在最常用的优化器类型。&lt;/li&gt;
&lt;li&gt;基于规则的优化器 RBO：根据预定义的规则进行优化，例如加减的权重是1，乘除的权重是2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SQL的执行顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL、语法语义检查、解析（软解析+硬解析）、执行计划、执行引擎、存储引擎、数据库&lt;/li&gt;
&lt;li&gt;解析是整个SQL优化最消耗资源的环节，其中硬解析是最重要的一部分。&lt;/li&gt;
&lt;li&gt;执行计划：Plan，二进制的执行代码&lt;/li&gt;
&lt;li&gt;解析+生成执行计划是查询优化器最重要的工作&lt;/li&gt;
&lt;li&gt;生成执行计划后，抛入执行引擎，从数据库中读取数据，然后返回。&lt;/li&gt;
&lt;li&gt;语法分析：判断一条SQL语句的语法是否符合SQL的规范，代价小&lt;/li&gt;
&lt;li&gt;语义分析：判断该SQL语句所访问的对象是否准确，且用户是否有相应的权限，代价小&lt;/li&gt;
&lt;li&gt;硬解析：对提交的sql完全重新从头进行解析(当在共享池中找不到已解析好的结果时将会进行此操作)&lt;/li&gt;
&lt;li&gt;软解析：如果在共享池中找到了与之完全相同的sql解析好的结果后，会跳过硬解析的后两步，代价小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化器只能对关系领域进行优化&lt;/p&gt;
&lt;p&gt;优化器的有效范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化器需要借助数据库中找到的信息&lt;/li&gt;
&lt;li&gt;能进行数学意义上的等价变换&lt;/li&gt;
&lt;li&gt;优化器考虑整体响应时间&lt;/li&gt;
&lt;li&gt;优化器改善的是独立的查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库设计-层次结构&#34;&gt;数据库设计-层次结构&lt;/h2&gt;
&lt;p&gt;6.1 处理层次结构.mp4，12:17&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邻接模型：id、pid&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兄弟节点是无序的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物化路径模型：1、1.1、1.1.2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兄弟节点是有序的&lt;/li&gt;
&lt;li&gt;方便扩展：3层结构扩展层4层&lt;/li&gt;
&lt;li&gt;查询语句编写简单，找出适当的记录并缩排显示比较容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嵌套集合模型：left_num、right_num，所有子节点都在left_num和right_num之间&lt;/p&gt;
&lt;p&gt;上述3种树状表结构设计都满足三范式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种查询方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下（Vandamme查询）
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;connect by current = &lt;em&gt;prior&lt;/em&gt; previous，非关系型查询方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103050088.png&#34; alt=&#34;image-20210420103050088&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用with as，首先定义起始点，之后对两个select语句进行union all，通过递归查询不断根据父记录生成子记录。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103019003.png&#34; alt=&#34;image-20210420103019003&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql不支持connect by，也不支持with as，因此只能事先知道树的深度，然后手动union&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算深度：path字符串长度 减去 去掉点之后的path字符串长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定需要查询的path前缀，之后使用模糊查询获取结果，然后对path进行排序，即可&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103422776.png&#34; alt=&#34;image-20210420103422776&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上（Hignland查询）
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;connect by previous = &lt;em&gt;prior&lt;/em&gt; current&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;指定需要查询的叶子结点，之后使用模糊查询获取父节点&lt;/li&gt;
&lt;li&gt;会存在重复记录，因此需要使用distinct&lt;/li&gt;
&lt;li&gt;排序问题：对distinct的结果进行select，并按path进行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;性能最好，每秒返回的查询记录数最多，只需要处理数值关系，但性能会收到迭代操作的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;中等，因为涉及到字符串操作&lt;/li&gt;
&lt;li&gt;计算深度、缩排函数 比较费时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上
&lt;ul&gt;
&lt;li&gt;和自顶向下类似，邻接最好，物化路径中等&lt;/li&gt;
&lt;li&gt;当不能用connect by和with as时，可以使用物化路径模型作为替代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">南京大学-高级数据库开发技术-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-13-南京大学-高级算法课程-复习笔记/"" data-c="
          &lt;h2 id=&#34;蛮力法&#34;&gt;蛮力法&lt;/h2&gt;
&lt;p&gt;算法思想：在不考虑时间、空间效率的情况下，寻求问题的解决方案&lt;/p&gt;
&lt;p&gt;DFS BFS 连通性、环路&lt;/p&gt;
&lt;h2 id=&#34;分治&#34;&gt;分治&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;思想：分而治之&lt;/p&gt;
&lt;p&gt;分(Divide): 递归解决较小的问题，直到终止层或者可以解决的时候停下来&lt;br&gt;
治(Conquer): 递归求解，如果问题够小直接求解&lt;br&gt;
合并(Combine): 用子问题的解合并构建父问题&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/zhang971105/article/details/115759963&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;归并排序合并排序&#34;&gt;归并排序（合并排序）&lt;/h3&gt;
&lt;p&gt;归并排序的主要缺点是该算法需要额外的线性空间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418125331240.png&#34; alt=&#34;image-20210418125331240&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;减治&#34;&gt;减治&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用给定实例下问题的解和较小规模实例下相同问题的解之间的关系。&lt;/li&gt;
&lt;li&gt;可以从顶至下（递归地）也可以自底向上（非递归地）地运用该关系。&lt;/li&gt;
&lt;li&gt;与分治法不同，减治法只针对其部分子问题进行求解，同时也是采取划分后选择计算的思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减常量：插入排序、深度优先、广度优先遍历&lt;/li&gt;
&lt;li&gt;减常因子：折半查找、三份查找&lt;/li&gt;
&lt;li&gt;减可变规模：欧几里得最大公约数、选择问题、插值查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;减治法与分治法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二项查找规模减半的两个子问题只有一个问题需要解决，是减治法。分治求和，规模减半的两个子问题都需要求解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成组合对象&#34;&gt;生成组合对象&lt;/h3&gt;
&lt;h4 id=&#34;johnson-trotter算法&#34;&gt;Johnson-Trotter算法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419101235692.png&#34; alt=&#34;image-20210419101235692&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;减一法&#34;&gt;减一法&lt;/h4&gt;
&lt;p&gt;生成n-1个数的排列&lt;br&gt;
将第n个数依次插入n-1个数的每一个排列中&lt;br&gt;
缺点：记录所有中间结果，耗费存储空间&lt;/p&gt;
&lt;h3 id=&#34;插值查找&#34;&gt;插值查找&lt;/h3&gt;
&lt;p&gt;与折半查找类似，只是确定mid的方式有所改变：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415110033670.png&#34; alt=&#34;image-20210415110033670&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最坏情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要在[1,10]中查到2，但多数元素分布在[1,2]之前&lt;/li&gt;
&lt;li&gt;每次插值查找都只能减少1个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动机：在预测顺序数组是均匀排布的假设前提下，使用插值查找可以在时间复杂度O(log logn)的情况下比&lt;strong&gt;折半查找&lt;/strong&gt;O(logn)花费更少的查找次数。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/zhang971105/article/details/115760010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果在遍历的过程中，发现某个顶点有一条边指向已经访问过的顶点，且这个已访问过的顶点不是当前顶点的父节点（这里的父节点表示DFS遍历顺序中的父节点），则说明图包含环。&lt;/li&gt;
&lt;li&gt;判断连通性：若vis数组存在0值，则该节点未被访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhang971105/article/details/115760010&#34;&gt;【算法复习】减治算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变治&#34;&gt;变治&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个更简单的实例——&lt;strong&gt;实例化简&lt;/strong&gt;——预排序，将问题变为排序好的列表的问题：高斯消去法&lt;/li&gt;
&lt;li&gt;一个实例的不同表现——&lt;strong&gt;改变表现&lt;/strong&gt;——平衡查找树、堆——改变数据结构：霍纳法则&lt;/li&gt;
&lt;li&gt;变为另一个问题的实例——&lt;strong&gt;问题化简&lt;/strong&gt;——对NP难问题和NP完全问题的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高斯消去法-实例化简&#34;&gt;高斯消去法-实例化简&lt;/h3&gt;
&lt;p&gt;n元一次方程组求解&lt;/p&gt;
&lt;p&gt;将方程组系数变为一个下三角全部是0的矩阵&lt;/p&gt;
&lt;p&gt;思想：将n元一次方程组求解实例化简为一个容易求解的实例。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618454369592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;转换方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用第一个方程的一个倍数和第二个方程求差，将第二个方程中x1系数变为0；同样与其它方程求差，将所有x1系数变为0；&lt;/li&gt;
&lt;li&gt;再用第二个方程与其它方程作同样操作，将所有第二个方程后的所有x2系数变为0；&lt;/li&gt;
&lt;li&gt;最终得到下三角为0的系数矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419085806002.png&#34; alt=&#34;image-20210419085806002&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;霍纳法则-改变表现&#34;&gt;霍纳法则-改变表现&lt;/h3&gt;
&lt;p&gt;经过霍纳法则变换的多项式只需要执行 n 次乘法运算便可以得到 n 阶多项式的值，使得原本&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;复杂度的计算变为O(n)，加快运算速度。&lt;/p&gt;
&lt;p&gt;用于快速计算多项式的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415110131949.png&#34; alt=&#34;image-20210415110131949&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419090914753.png&#34; alt=&#34;image-20210419090914753&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;二进制幂&#34;&gt;二进制幂&lt;/h4&gt;
&lt;p&gt;基于改变表现的求幂的算法&lt;/p&gt;
&lt;p&gt;任何一个数，都可以变成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.849108em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的累加和，例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1 = 2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5=2^2+2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;6=2^2+2^1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^n=a^{p(2)}=a^{\sum_{i=0}^n{b_i*2^i}}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.664392em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8879999999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8879999999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9944599999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9944599999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mop mtight&#34;&gt;&lt;span class=&#34;mop op-symbol small-op mtight&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7385428571428572em;&#34;&gt;&lt;span style=&#34;top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32143857142857146em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace mtight&#34; style=&#34;margin-right:0.19516666666666668em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9020857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的多项式，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;只能取0或者1。&lt;/p&gt;
&lt;p&gt;有两种计算方法，从左到右和从右到左。&lt;/p&gt;
&lt;p&gt;以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^{13}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为例，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;13=1*2^3+1*2^2+0*2^1+1*2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&#34;从左到右&#34;&gt;从左到右&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415111446604.png&#34; alt=&#34;image-20210415111446604&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每一次，先平方，然后，如果n的二进制位为1，则乘上一个a。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419091410008.png&#34; alt=&#34;image-20210419091410008&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;从右到左&#34;&gt;从右到左&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415111618512.png&#34; alt=&#34;image-20210415111618512&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;预先准备好a的各个幂次的结果，如果n的二进制位为1，则将对应幂次运算结果乘到最终答案中。&lt;/p&gt;
&lt;p&gt;（话说，这不是快速幂吗？）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419091431205.png&#34; alt=&#34;image-20210419091431205&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;霍纳法则，也可以延伸到X进制的情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415112335441.png&#34; alt=&#34;image-20210415112335441&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/riasky/p/3509097.html&#34;&gt;霍纳法则和二进制幂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;时空权衡&#34;&gt;时空权衡&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入增强：对输入进行&lt;strong&gt;预处理&lt;/strong&gt;，存储&lt;strong&gt;额外信息&lt;/strong&gt;，以加速后续问题的求解。
&lt;ul&gt;
&lt;li&gt;计数排序（比较计数、分布计数）&lt;/li&gt;
&lt;li&gt;字符串匹配：Boyer-Moore算法和Horspool提出的简化版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预构造：使用&lt;strong&gt;额外的空间&lt;/strong&gt;存储输入（比简单存储更多的空间），以实现更快、更方便的存取。
&lt;ul&gt;
&lt;li&gt;散列法&lt;/li&gt;
&lt;li&gt;B树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计数排序&#34;&gt;计数排序&lt;/h3&gt;
&lt;p&gt;比较计数：对数组中的元素两两进行比较，计算Count数组。Count[i]表示比第i个数小的数的个数。&lt;/p&gt;
&lt;p&gt;分布计数：预先知道待排数组的范围，统计每个元素出现的次数。&lt;/p&gt;
&lt;h3 id=&#34;祖先问题&#34;&gt;祖先问题&lt;/h3&gt;
&lt;p&gt;要求在一棵给定的n顶点二叉树中，确定一个顶点u是否是顶点v的祖先。设计一个属于O(n)的输入增强算法，使我们可以在常量时间内获得树的每一对顶点的足够信息，来对问题求解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分析：一个顶点u是顶点v的祖先，当前仅当先序遍历u在v的前面，并且后序遍历u在v的后面。第一个条件，先序遍历u在v的前面，代表要么u是v的祖先，要么u在公共祖先的左子树中而v在公共祖先的右子树中；第二个条件，后序遍历u在v的后面，代表要么u是v的祖先，要么u在公共祖先的右子树中而v在公共祖先的左子树中。综合两个条件，我们可以知道确定一个顶点u是否是顶点v的祖先，其充分必要条件是先序遍历u在v的前面，并且后序遍历u在v的后面。&lt;/p&gt;
&lt;p&gt;解答：在O(n)时间对二叉树进行先序遍历和后序遍历，在常量时间内对需要比较的两个节点在先序和后序中比较次序，确定顶点u是否是顶点v的祖先。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_30432997/article/details/85282116&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;字符串匹配&#34;&gt;字符串匹配&lt;/h3&gt;
&lt;p&gt;要求在一个较长的n个字符的串（称为&lt;strong&gt;文本&lt;/strong&gt;）中，寻找一个给定的m个字符的串（称为&lt;strong&gt;模式&lt;/strong&gt;）&lt;/p&gt;
&lt;h4 id=&#34;蛮力法-2&#34;&gt;蛮力法&lt;/h4&gt;
&lt;p&gt;简单地&lt;strong&gt;从左到右&lt;/strong&gt;比较模式和文本中每一个对应的字符，如果不匹配，把模式向右移动一格，再进行下一轮尝试，&lt;strong&gt;最差效率为O(nm)&lt;/strong&gt;，随机文本的平均效率O(n+m)=O(n)&lt;/p&gt;
&lt;h4 id=&#34;horspool算法&#34;&gt;Horspool算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;先将文本与模式左对齐&lt;/li&gt;
&lt;li&gt;从模式的最后一个字符从后往前进行匹配。&lt;/li&gt;
&lt;li&gt;如果全部匹配成功，则结束。&lt;/li&gt;
&lt;li&gt;如果匹配失败，分情况讨论：
&lt;ul&gt;
&lt;li&gt;规定：文本中与模式最后一个字符对应的字符为c&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618387864255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;当模式的前m-1个字符中不存在c时，将模式右移m位。&lt;/li&gt;
&lt;li&gt;当模式的前m-1个字符中存在c时，将模式右移，使模式中的c与文本中的c对齐。&lt;/li&gt;
&lt;li&gt;回到第2步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时空权衡优化思路-输入增强：&lt;br&gt;
预先计算t数组，t[c]表示：当匹配失败，且文本中对应的字符为c时，模式需要右移的位数。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618388234611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;boyer-moore算法&#34;&gt;Boyer-Moore算法&lt;/h4&gt;
&lt;p&gt;Boyer-Moore算法是Horspool算法的升级版，同时运用了坏字符原则和好后缀原则。&lt;/p&gt;
&lt;p&gt;在我们进行匹配的时候，我们将第一次碰到的不匹配的字符称为坏字符，而将碰到坏字符之前所匹配到的字符串称为好后缀。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618390709878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;坏字符原则之前已经介绍过了，就是Horspool算法的核心。这里重点介绍一下好后缀原则。&lt;/p&gt;
&lt;p&gt;和坏字符原则一样，我们需要维护一个好后缀数组，那么好后缀数组的含义是什么呢？&lt;/p&gt;
&lt;p&gt;它的含义是，需要往前最少数几位，才能让后缀或者后缀的子串匹配上。&lt;/p&gt;
&lt;p&gt;我们用S数组表示好后缀数组。S[k]表示的是长度为k的后缀 ，即a[m-k, m-k+1 ... m-2, m-1]。&lt;/p&gt;
&lt;p&gt;我们以BAOBAB举例子。&lt;/p&gt;
&lt;p&gt;S[1] = 2：表示，B这个后缀，需要最少往前数2位，就能让其匹配上了。&lt;br&gt;
再详细说一下，对于BAOBAB，倒数第三个字符也是B，因此只需要往前数2位，就能让后缀B匹配上了。&lt;/p&gt;
&lt;p&gt;我们再来看S[2]，它对应的后缀是AB，但是AB无法匹配，因此我们取子后缀B，这里需要注意，因为我们取的是子后缀，因此如果是类似BB、CB的情况，是无法匹配的，因为原后缀是AB。因此，和子后缀B匹配的只有首位的B，因此S[2] = 5。&lt;/p&gt;
&lt;p&gt;这就是好后缀数组的含义。好后缀数组的意义在于，利用了已匹配的字符串的信息，增加了每次移动的位数。&lt;/p&gt;
&lt;p&gt;大家可以试一下，如果移动位数少于好后缀数组的值，那么一定是无法匹配上的。&lt;/p&gt;
&lt;p&gt;好后缀数组的计算过程可以参考这篇文章：&lt;a href=&#34;https://blog.csdn.net/qq_35423154/article/details/109137798&#34;&gt;字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于坏字符原则和好后缀原则，取最大值进行移动。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;参考资料-3&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35423154/article/details/109137798&#34;&gt;字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;思考题&#34;&gt;思考题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用字符串匹配算法匹配到一个相同字符串后，要查找下一个匹配子串，移动距离是多少？&lt;/li&gt;
&lt;li&gt;如果只用坏符号移动表或者好后缀移动表，BM算法能够正确工作吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;递归与动态规划的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都需要找到递推关系&lt;/li&gt;
&lt;li&gt;不同点：
&lt;ul&gt;
&lt;li&gt;动态规划是自底向上，从停止条件逐步计算出问题的解。&lt;/li&gt;
&lt;li&gt;递归是自顶向下，从问题出发，利用递推式逐步减小问题规模，当达到停止条件时，逐步返回，最终求出问题的解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分治法与动态规划的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分治方法&lt;/strong&gt;将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态规划&lt;/strong&gt;应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。这种情况下使用分治算法会重复求解那些子子问题而浪费时间。&lt;/li&gt;
&lt;li&gt;By: https://blog.csdn.net/zhang971105/article/details/115759889&lt;/li&gt;
&lt;li&gt;动态规划注重：与其对交叠的子问题一次一次求解，还不如对每个较小的子问题只求解一次并把结果记录在表中。&lt;/li&gt;
&lt;li&gt;By：https://jinzengnju.github.io/2018/05/22/leetcode高级算法/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最优二叉查找树&#34;&gt;最优二叉查找树&lt;/h3&gt;
&lt;p&gt;假设一次搜索的实际代价为检查的节点的个数，即所发现的节点的深度加1，一次搜索所花费的预期成本为：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E(T) = \sum_{i=1}^n {(depth(k_i)+1)*p_i}+\sum_{i=0}^n{(depth(d_i)+1)*q_i}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.929066em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.6513970000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.929066em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.6513970000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最优二叉查找树：一次搜索所花费的预期成本最小。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e[i,j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示对于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_i,...,k_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和虚拟节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d_{i-1}, ..., d_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 最优 BST 的期望搜索成本。&lt;/p&gt;
&lt;p&gt;因此，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E(T) = e[1,n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w[i,j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示对一棵关键字 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_i, ..., k_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子树，其概率总和：&lt;/p&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲
w[i,j] &amp;amp;= \sum…&#39;&gt;\begin{align*}
w[i,j] &amp;amp;= \sum_{k=i}^j p_k + \sum_{k=i-1}^jq_k \\
 &amp;amp; = p_r + w[i,r-1] + w[r+1,j] \\
 &amp;amp; = w[i,j-1] + p_j + q_j
 \end{align*}
&lt;/p&gt;
&lt;p&gt;综上所述：&lt;/p&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
e[i,j] &amp;amp; = p_r…&#39;&gt;\begin{align}
e[i,j] &amp;amp; = p_r + (e[i,r-1]+w[i,r-1])+(e[r+1,j]+w[r+1,j]) \\
&amp;amp; =e[i,r-1]+e[r+1,j]+w[i,j]
\end{align}
&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419092052208.png&#34; alt=&#34;image-20210419092052208&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;参考资料-4&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xiajun07061225/article/details/8088784&#34;&gt;【算法学习】最优二叉查找树（动态规划）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/henuliulei/p/10074216.html&#34;&gt;最优二叉查找树_动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;背包问题&#34;&gt;背包问题&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# w[i]表示第i个物品的重量, v[i]表示第i个物品的价值, 下标从V开始
# S表示背包总空间, N表示总共多少个物品
Algorithm bag:
    # N+1行S+1列
    dp = [[0 for i in range(S + 1)] for j in range(N + 1)]
    for i in range(1, N+1):
        for j in range(1, S+1):
            if j &amp;gt;= w[i]: # 判断此时背包空间是否大于此时物品重量
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
            else:
            	dp[i][j] = dp[i-1][j]
                
    # 返回在空间为S时前N个物品的最大价值
    return dp[N][S] 

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料-5&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhang971105/article/details/115759889&#34;&gt;【算法复习】动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;迭代改进&#34;&gt;迭代改进&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;贪婪：采用每步最优策略，逐步构造问题的解。最终生成的解，不一定是最优解。&lt;/s&gt;（不考）&lt;/li&gt;
&lt;li&gt;迭代改进：先生成一个可行解，然后，不断通过小的、局部的改变对其进行优化，使目标函数更优。当目标函数无法再优化时，则为最优解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现过程中可能遇到的困难：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何生成可行解？&lt;/li&gt;
&lt;li&gt;如何判断是局部最优解？&lt;/li&gt;
&lt;li&gt;如何判断局部最优解是全局最优解？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法实例：遗传算法、蚁群算法、梯度下降算法。&lt;/p&gt;
&lt;h3 id=&#34;线性规划&#34;&gt;线性规划&lt;/h3&gt;
&lt;p&gt;线性规划问题：在一系列线性约束下，求一个包含若干变量的线性方程的最优解。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618313856251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;极值定理&#34;&gt;极值定理&lt;/h4&gt;
&lt;p&gt;极值定理：可行区域非空的任意线性规划问题有最优解，且最优解总能够在其可行区域的一个&lt;strong&gt;极点&lt;/strong&gt;上找到。&lt;/p&gt;
&lt;p&gt;利用极值定理解决线性规划问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成可行区域的所有极点&lt;/li&gt;
&lt;li&gt;计算所有极点对应的问题解，保留最优的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;极值定理存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法生成所有的极点&lt;/li&gt;
&lt;li&gt;无法遍历所有的极点（当问题规模变大，极点个数呈爆炸式增长，无法全部遍历）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单纯形法&#34;&gt;单纯形法&lt;/h4&gt;
&lt;p&gt;算法思想：先在可行区域中找到一个极点，然后检查在邻接极点处是否能够优化，如果能，则继续处理该邻接极点；如果不能，则当前极点即为最优解。&lt;/p&gt;
&lt;p&gt;局限性：&lt;br&gt;
- 只能解决最大化问题&lt;br&gt;
- 所有变量都非负&lt;br&gt;
- 除 非负约束 外，其余约束都必须为等式。&lt;/p&gt;
&lt;h5 id=&#34;线性规划问题的标准形式&#34;&gt;线性规划问题的标准形式&lt;/h5&gt;
&lt;p&gt;能够解决的线性规划问题的标准形式：m个等式约束、n个变量。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618377842782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如何转化为标准形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小化转为最大化——通过改变目标函数系数正负号&lt;/li&gt;
&lt;li&gt;不等问题转为相等问题——通过松弛变量，将松弛变量定义为&amp;gt;=0的新变量&lt;/li&gt;
&lt;li&gt;没有非负约束的变量添加约束——定义为 两个带非负约束的新变量的差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转化为标准形式的好处：可以用一种简单的方法确定可行区域的极点&lt;br&gt;
确定方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将约束中的n-m个非基本变量设置成0，利用m个等式求出剩余m个基本变量的解。&lt;/li&gt;
&lt;li&gt;如果能求出唯一解，则得到一个基本解。&lt;/li&gt;
&lt;li&gt;如果得到的基本解的所有值都非负，则为基本可行解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本解与区域内的交点一一对应。&lt;br&gt;
基本可行解与可行区域的极点一一对应。&lt;/p&gt;
&lt;h5 id=&#34;单纯形表&#34;&gt;单纯形表&lt;/h5&gt;
&lt;p&gt;单纯形&lt;strong&gt;表&lt;/strong&gt;：解决线性规划问题的一种方法、工具，其中，蕴含了单纯形法的思想。&lt;/p&gt;
&lt;p&gt;单纯形表的计算过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求得一个基本可行解，作为初始单纯形表。&lt;/li&gt;
&lt;li&gt;不断根据规则计算得到下一个单纯形表，每张单纯形表对应一个极点。&lt;/li&gt;
&lt;li&gt;对于每张单纯形表，判断是否是最优解或是否有界。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体讲解：&lt;a href=&#34;https://www.bilibili.com/video/BV16t411F7Zu?t=697&#34;&gt;十分钟带你学单纯形法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最优：目标行都为非负。&lt;br&gt;
无界：被选中的非基本变量对应的系数全部小于等于零，则无界，说明目标函数可以无限制增大。详解：&lt;a href=&#34;https://www.zhihu.com/question/24146260&#34;&gt;运筹学单纯形法无界解的判定原理是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何确定入基变量：（各教材不一样，本文以老师ppt为准）从非基本变量中选择，选择目标行系数最小的变量作为入基变量。&lt;br&gt;
如何确定出基变量：各行变量值除以入基变量所在列对应的系数，取最小。需要注意的是，需要忽略掉系数 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\le&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 0的那些行。&lt;/p&gt;
&lt;p&gt;单纯形表原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;线性规划之单纯形法【超详解+图解】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xvshu/article/details/23288787&#34;&gt;运筹学·单纯形法——原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;是否能够使用单纯形法解决背包问题如果能请给出解法过程并请指出这是不是一个解决该问题的好算法如果不能请说明原因&#34;&gt;是否能够使用单纯形法解决背包问题？如果能，请给出解法过程，并请指出这是不是一个解决该问题的好算法？如果不能，请说明原因。&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;解答：可以通过单纯形法解决背包问题的连续版本，因为它是一般线性规划问题的一个特例。然而，它不是解决这个问题的好方法，因为它可以通过基于贪婪法的更简单的算法更有效地解决。由于对问题变量施加的完整性（0-1）约束，单纯形法无法解决0-1版本的背包问题。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_30432997/article/details/85283898&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;为什么基本可行解与可行区域的极点一一对应&#34;&gt;为什么基本可行解与可行区域的极点一一对应？&lt;/h5&gt;
&lt;p&gt;我们从二维来理解这个问题，对于高维，也是同样的道理，只是二维比较好描述、且比较好理解。&lt;/p&gt;
&lt;p&gt;要解答这个问题，我们先尝试理解另一个问题，为什么基本解与图上的交点一一对应？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618367158808.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图，我们能看到很多的交点，在这些交点中，有一些是可行区域的极点，有一些不是。对于那些是可行区域极点的交点，它们对应了基本可行解；对于那些不是可行区域极点的交点，它们对应了基本非可行解，也就是除了基本可行解以外的那些基本解。&lt;/p&gt;
&lt;p&gt;我们回到线性规划问题，如下的线性约束一共有3个不等式，但其实本质上应该是4个，对于第三个不等式，可以拆成2个不等式，即&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1 \ge 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7859700000000001em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_2 \ge 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7859700000000001em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618367306612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们只有两个变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），那么从4个不等式中，任取两个，就会得到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一组解。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C_4^2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0622159999999998em;vertical-align:-0.24810799999999997em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的值为6，因此上图中一共有6个交点。&lt;/p&gt;
&lt;p&gt;用更一般的形式说明一下：&lt;/p&gt;
&lt;p&gt;原约束方程：&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618368676328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;标准化后的约束方程：&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618368705133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们用n表示所有变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2, x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数，m表示基本变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。在线性约束标准化的过程中，m也表示新加入的松弛变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。&lt;/p&gt;
&lt;p&gt;根据n和m的定义，我们可以得出，n-m表示原约束方程中变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。因此，我们只需要确定n-m个方程，就可以求出原约束方程中变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的值，从而求出目标函数的值。&lt;/p&gt;
&lt;p&gt;那么如何将线性约束方程与单纯形表结合起来呢，如果看了之前&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;讲原理的博客&lt;/a&gt;，我们就会知道，每一张单纯形表，其实本质上都是将n-m个非基本变量的值设为0，然后算出原约束方程中n-m个变量的值，从而求出目标表达式的值。&lt;/p&gt;
&lt;p&gt;那么，我们将n-m个非基本变量的值设为0，其实就是选择了n-m个不等式。如上所述，当我们选择了n-m个不等式，就能确定原约束方程中n-m个变量的值，也就相当于确定了一个交点。&lt;/p&gt;
&lt;p&gt;如果这个交点又是可行区域内的交点，那么其就是可行区域的极点，在单纯形表中的体现就是，基本解的值非负。&lt;/p&gt;
&lt;h5 id=&#34;参考资料-6&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;线性规划之单纯形法【超详解+图解】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV16t411F7Zu?t=697&#34;&gt;十分钟带你学单纯形法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xvshu/article/details/23288787&#34;&gt;运筹学·单纯形法——原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/39071505/answer/131945180&#34;&gt;怎么用简单的语言理解基变量与非基变量？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/26840528/answer/34257469&#34;&gt;如何理解线性规划中的单纯形法和单纯形表？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/24146260&#34;&gt;运筹学单纯形法无界解的判定原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他一些小知识点&#34;&gt;其他一些小知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2-3树是最简单的B-树结构，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树也是一种BST。&lt;/li&gt;
&lt;li&gt;堆
&lt;ul&gt;
&lt;li&gt;堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。&lt;/li&gt;
&lt;li&gt;使用数组实现堆。对于每一个非叶子节点的父母节点i，其子女将会位于2i与2i+1的位置。（达到这种效果必须要求数组实现时，索引位置为0的地方空出来）。&lt;/li&gt;
&lt;li&gt;堆总是满足下列性质：
&lt;ul&gt;
&lt;li&gt;堆中某个结点的值总是不大于或不小于其父结点的值&lt;/li&gt;
&lt;li&gt;堆总是一棵完全二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。&lt;/li&gt;
&lt;li&gt;从最后的父母节点开始，依次向上检查是否满足父母优势。如果不满足，把节点的键K值和它子女的最大键进行交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B树元素的插入：
&lt;ul&gt;
&lt;li&gt;如果要插入的节点已经没有空间，该叶子一分为2，把后面一半的记录放在一个新节点中。在这之后，新节点中最小的键K‘以及指向它的指针要插入到原来的叶子的父母中，递归该过程一直到根中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料-7&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jinzengnju.github.io/2018/05/22/leetcode%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/&#34;&gt;leetcode高级算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">南京大学-高级算法课程-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-10-使用码云（gitee）提升博客访问速度/"" data-c="
          &lt;p&gt;之前写过文章，通过Gridea+github搭建个人博客 &lt;a href=&#34;https://bule-zst.gitee.io/ji-yu-grideagithubcoding-da-jian-jing-tai-bo-ke/&#34;&gt;基于Gridea+github/coding搭建静态博客&lt;/a&gt;，但使用了一段时间后，发现加载速度实在是太慢了，而且cdn更新也不太稳定。&lt;/p&gt;
&lt;p&gt;今天突发奇想，可以使用码云部署自己的个人博客，说干就干。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gridea个人博客搭建的原理&#34;&gt;Gridea个人博客搭建的原理&lt;/h1&gt;
&lt;p&gt;首先，和大家讲一下Gridea个人博客的搭建原理，如果只想看操作步骤的话，可以跳过这一节。&lt;/p&gt;
&lt;p&gt;Github为我们提供了一个功能，叫github pages，可以用于展示&lt;strong&gt;静态&lt;/strong&gt;网页，Gridea正是利用了github pages这一功能来搭建博客的。&lt;/p&gt;
&lt;p&gt;我们在github上创建项目后，可以为项目开启github pages功能，开启后，访问对应的网址，就会加载项目中的静态网页，例如在项目根目录下放入index.html文件，当访问项目时，就会展示index.html中的内容。&lt;/p&gt;
&lt;p&gt;而，只要是git系列的产品，理论上都有pages的功能，码云也不例外，因此，我们可以将Gridea生成的博客项目推送到码云项目中，然后开启码云项目的pages功能，就可以利用码云来搭建博客了。&lt;/p&gt;
&lt;h1 id=&#34;具体操作步骤&#34;&gt;具体操作步骤&lt;/h1&gt;
&lt;h2 id=&#34;码云&#34;&gt;码云&lt;/h2&gt;
&lt;p&gt;首先，需要在码云上创建项目，并开启pages功能，具体可参考&lt;a href=&#34;https://gitee.com/help/articles/4136#article-header0&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里提一些容易忽略的细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，和github不一样，在码云中创建的项目的项目名，需要和用户名一样。&lt;/li&gt;
&lt;li&gt;第二，在创建完项目后，需要开启pages服务。&lt;/li&gt;
&lt;li&gt;第三，记得要往项目中添加index.html文件，这一步主要用于测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成参考文章中的步骤后，访问网址（用户名.gitee.io），看看能不能加载出内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618028959506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;修改gridea配置&#34;&gt;修改Gridea配置&lt;/h2&gt;
&lt;p&gt;第二步，需要修改Gridea中的配置&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029063220.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其余地方都不变，只需要修改图中红色框框出来的域名，改成码云对应的网址（用户名.gitee.io）&lt;/p&gt;
&lt;h2 id=&#34;推送项目到码云并更新pages服务&#34;&gt;推送项目到码云，并更新pages服务&lt;/h2&gt;
&lt;p&gt;第三步，需要将Gridea生成的个人博客项目推送到码云上，在这一步中，我用的是git可视化管理工具-gtikraken，如果git基本功比较好的，也可以在git bash中进行操作。&lt;/p&gt;
&lt;p&gt;首先用gitkraken打开本地个人博客项目，目录是：/个人博客项目根目录/output&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029373237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开后会发现，有一个remote，这个就是之前我们配置的github仓库&lt;/p&gt;
&lt;p&gt;我们将码云中创建的项目也添加到remote中&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029472492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后，点击Gridea中的同步，将本地博客项目同步到github项目中。&lt;/p&gt;
&lt;p&gt;之后点击push按钮，将本地项目推送到码云项目中。在点击push按钮后，可能会让我们选择需要推送的目标仓库，注意要选择码云中的项目。&lt;/p&gt;
&lt;p&gt;在推送完成后，回到码云项目中，点击Gitee Pages按钮，进入pages管理界面&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029658643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击更新按钮&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029730998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在更新完成后，访问博客网址（用户名.gitee.io），就能看到博客的内容了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029790776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
&lt;p&gt;最后还需要说一点，就是，每次推送博客更新到码云项目后，都需要点击pages中的更新按钮进行更新，这是因为对于免费版的码云，不支持pages的自动更新。&lt;/p&gt;
&lt;p&gt;虽然这样好像有点麻烦，对我觉得，相对于github的访问速度来说，我还是更偏向于码云一些。&lt;/p&gt;
">使用码云（gitee）提升博客访问速度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-03-31-MySQL性能优化/"" data-c="
          &lt;p&gt;from &lt;a href=&#34;https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web&#34;&gt;https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;MySQL慢查询 优化手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引：使用MySQL工具，如explain，看一下查询有没有走索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;p&gt;索引是帮助MySQL高效获取数据的&lt;strong&gt;排好序&lt;/strong&gt;的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据结构可视化网站：&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&#34;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;索引的常见数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树
&lt;ul&gt;
&lt;li&gt;二叉搜索树：
&lt;ul&gt;
&lt;li&gt;优化思路：使用二叉搜索树，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;缺点-退化。当数据递增或递减时，会退化成链表，如，1, 2, 3, 4, 5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉平衡树
&lt;ul&gt;
&lt;li&gt;优化思路：减少二叉树层数，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;红黑树：缺点-效率低。虽然会自平衡，但当数据量达到500w时，可能树的高度会达到20层，如果查询的数据在叶子结点，20次IO操作依旧很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多路平衡树
&lt;ul&gt;
&lt;li&gt;优化思路：扩展每个节点，使其包含多个索引元素，更进一步减少二叉树层数，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;B Tree&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B+ Tree&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;目前MySQL索引采用的数据结构&lt;/li&gt;
&lt;li&gt;MySQL中，默认情况下，每个节点可占用的空间大小为16KB。3层B+Tree，约可以存放2000w个索引元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B-Tree与B+Tree的比较
&lt;ul&gt;
&lt;li&gt;把数据统一存放在叶子结点中，好处是，非叶子结点可以包含更多的索引元素，因此树的高度更低。&lt;/li&gt;
&lt;li&gt;叶子结点之前的连接：更好地支持范围查找。B-树如果要做范围查询，则需要定位到第一个元素后，进行中序遍历。&lt;/li&gt;
&lt;li&gt;B+树，每次都会查到叶子结点才结束，因此查询时间较稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash表
&lt;ul&gt;
&lt;li&gt;Hash表的效率很多情况下优于B+树&lt;/li&gt;
&lt;li&gt;不选择Hash表的原因：
&lt;ul&gt;
&lt;li&gt;Hash冲突（次要）：当存在大量Hash冲突时，会导致链表变长，降低效率。但当链表过长时，MySQL会进行ReHash操作，降低链表长度。&lt;/li&gt;
&lt;li&gt;不支持范围查询（主要）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从二叉搜索树到二叉平衡术再到多路平衡树，本质上是逐步降低了磁盘IO次数，那为什么不把所有索引元素都放到一个节点中？这样，只需要一次IO操作就行了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当数据量大的时候，太占内存了，并且有的时候，可能内存容量不允许这么做。&lt;/li&gt;
&lt;li&gt;当所有索引都读取到内存后，索引数量太多，可能500w，二分查找效率也会降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么主键推荐用整型，而不是UUID？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较效率。在索引中，会进行多次比较，整形比较速度更快。&lt;/li&gt;
&lt;li&gt;存储空间。UUID是字符串，更占空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么 MySQL 官方建议使用自增主键作为表的主键？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/39e5b433bbaf&#34;&gt;https://www.jianshu.com/p/39e5b433bbaf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;聚集索引：叶子结点包含完整的数据记录。例如，InnoDB的主键索引。对于每张表，聚集索引最多只有一个；对于InnoDB表，聚集索引有且仅有一个。&lt;br&gt;
非聚集索引：索引文件和数据文件是分离的。&lt;br&gt;
聚集索引效率高，因为非聚集索引拿到数据地址后，还需要一次IO操作，才能获取数据。&lt;/p&gt;
&lt;p&gt;联合索引：本质还是B+树，只是在比大小时，按字段顺序，依次进行比较&lt;/p&gt;
&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;p&gt;存储引擎是针对表的，不同表可以设置不同的存储引擎。&lt;/p&gt;
&lt;p&gt;数据库中存储的数据，默认放在安装目录下的data文件夹中。&lt;br&gt;
一个数据库，对应一个文件夹。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617329696374.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一个数据表，对应文件夹中的多个同名文件，不同存储引擎对应的文件结构不一样。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617330056948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.frm：frame，表结构的相关信息&lt;/li&gt;
&lt;li&gt;InnoDB
&lt;ul&gt;
&lt;li&gt;.ibd：表中的数据及索引。InnoDB的数据和索引，是存储在一起的。&lt;/li&gt;
&lt;li&gt;主键索引：
&lt;ul&gt;
&lt;li&gt;索引用B+数的结构存储，数据存储在B+数的叶子结点上。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617331007626.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二级索引（普通索引）
&lt;ul&gt;
&lt;li&gt;索引用B+树存储，叶子结点存放&lt;strong&gt;主键&lt;/strong&gt;信息，获取到主键后，需要再次从主键索引中获取数据信息（回表操作）。&lt;/li&gt;
&lt;li&gt;二级索引存主键信息：
&lt;ul&gt;
&lt;li&gt;优点：因为表数据是存在索引中的，伴随索引节点的分裂，表数据的磁盘地址会发生改变，存主键信息避免了二级索引的维护工作。&lt;/li&gt;
&lt;li&gt;缺点：1、回表操作，比较耗时；2、存主键，导致二级索引更占空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617331631874.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若表中没有主键，存储引擎会先在表中寻找，看是否存在非空唯一索引，若存在，则对该列或该索引建立聚集索引，若不存在，则维护一个额外的隐藏列（6字节的rowid），用于建立聚集索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MyISAM
&lt;ul&gt;
&lt;li&gt;.MYD：MyISAM Data，表中的数据&lt;/li&gt;
&lt;li&gt;.MYI：MyISAM Index，索引的相关信息&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617330872488.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引优化原则&#34;&gt;索引优化原则&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;最左前缀原则：对于联合索引，如果要用，那么必须按照建索引时字段的先后顺序去用，不能跳过任何一个字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;简历&#34;&gt;简历&lt;/h1&gt;
&lt;p&gt;不要光罗列会的技术，要深入地写，写技术细节。&lt;/p&gt;
&lt;h1 id=&#34;面试题&#34;&gt;面试题&lt;/h1&gt;
&lt;h2 id=&#34;说说建立索引的优势-负面影响和原则&#34;&gt;说说建立索引的优势、负面影响和原则?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;提高检索速度&lt;/li&gt;
&lt;li&gt;唯一性索引，保证数据的唯一性&lt;/li&gt;
&lt;li&gt;加速表与表之间的连接&lt;/li&gt;
&lt;li&gt;减少分组和排序的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负面影响：
&lt;ul&gt;
&lt;li&gt;耗时：创建和维护，都需要消耗时间，耗时随数据量增加而增加&lt;/li&gt;
&lt;li&gt;占空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原则：
&lt;ul&gt;
&lt;li&gt;什么时候该建
&lt;ul&gt;
&lt;li&gt;在最频繁使用的、用以缩小查询范围的字段上建立索引&lt;/li&gt;
&lt;li&gt;在最频繁使用的、需要排序的字段上建立索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么时候不该建
&lt;ul&gt;
&lt;li&gt;对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引&lt;/li&gt;
&lt;li&gt;对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)、uuid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;说说sql事务隔离级别&#34;&gt;说说SQL事务隔离级别?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;读未提交(read uncommitted）是指，一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读提交(read committed)是指，一个事务提交之后，它做的变更才会被其他事务看到。&lt;/li&gt;
&lt;li&gt;可重复读(repeatable read)是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。&lt;/li&gt;
&lt;li&gt;串行化 (serializable ) ，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210818155116207.png&#34; alt=&#34;image-20210818155116207&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;b树相对于b树的优势&#34;&gt;B+树相对于B树的优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把数据统一存放在叶子结点中，好处是，非叶子结点可以包含更多的索引元素，因此树的高度更低。&lt;/li&gt;
&lt;li&gt;叶子结点之前的连接：更好地支持范围查找。B-树如果要做范围查询，则需要定位到第一个元素后，进行中序遍历。&lt;/li&gt;
&lt;li&gt;B+树，每次都会查到叶子结点才结束，因此查询时间较稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/uyu0lKz2_N5BYgITKz71CQ&#34;&gt;什么是数据库的 “缓存池” ？（万字干货）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_16162981/article/details/70142166&#34;&gt;全文检索原理及实现方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">MySQL性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-01-06-Jetbrains系列产品重置试用方法/"" data-c="
          &lt;p&gt;本站惯例：本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。&lt;/p&gt;
&lt;p&gt;没错，jetbrains-agent这个项目停止了。市面上漫天飞的各种最新都是其他大神的魔改版本。&lt;br&gt;
我不是要专门写个博文来说明jetbrains-agent项目已经停止，然后缅怀感叹一番。这篇文章是想和大家聊聊另一种思路。&lt;/p&gt;
&lt;h1 id=&#34;0x0-项目背景&#34;&gt;0x0. 项目背景&lt;/h1&gt;
&lt;p&gt;Jetbrains家的产品有一个很良心的地方，他会允许你试用30天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。&lt;br&gt;
但很多时候会出现一种情况：IDE并不能按照我们实际的试用时间来计算。&lt;br&gt;
我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）&lt;br&gt;
发现了吗？你未能真的有30天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？&lt;/p&gt;
&lt;p&gt;事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。但切记不要无休止的一直试用，这并不是这个插件的本意！&lt;/p&gt;
&lt;h1 id=&#34;0x1-如何安装&#34;&gt;0x1. 如何安装&lt;/h1&gt;
&lt;h2 id=&#34;1-插件市场安装&#34;&gt;1). 插件市场安装：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在Settings/Preferences... -&amp;gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io&lt;/li&gt;
&lt;li&gt;搜索：&lt;code&gt;IDE Eval Reset&lt;/code&gt;插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？&lt;/li&gt;
&lt;li&gt;插件会提示安装成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-下载安装&#34;&gt;2). 下载安装：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;点击这个&lt;a href=&#34;https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip&#34;&gt;链接(v2.1.6)&lt;/a&gt;下载插件的zip包（macOS可能会自动解压，然后把zip包丢进回收站）&lt;/li&gt;
&lt;li&gt;通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&amp;gt; Plugins 里手动安装插件（Install Plugin From Disk...）&lt;/li&gt;
&lt;li&gt;插件会提示安装成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x2-如何使用&#34;&gt;0x2. 如何使用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）&lt;/li&gt;
&lt;li&gt;也可以手动唤出插件的主界面：
&lt;ul&gt;
&lt;li&gt;如果IDE没有打开项目，在Welcome界面点击菜单：Get Help -&amp;gt; Eval Reset&lt;/li&gt;
&lt;li&gt;如果IDE打开了项目，点击菜单：Help -&amp;gt; Eval Reset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：
&lt;ul&gt;
&lt;li&gt;按钮：Reload 用来刷新界面上的显示信息。&lt;/li&gt;
&lt;li&gt;按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（此为手动重置方式）&lt;/li&gt;
&lt;li&gt;勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x3-如何更新&#34;&gt;0x3. 如何更新&lt;/h1&gt;
&lt;h2 id=&#34;1-插件更新机制推荐&#34;&gt;1). 插件更新机制（推荐）：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。&lt;/li&gt;
&lt;li&gt;点击IDE的&lt;code&gt;Check for Updates...&lt;/code&gt;菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。&lt;/li&gt;
&lt;li&gt;插件更新可能会需要重启IDE。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-手动更新&#34;&gt;2). 手动更新：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从本页面下载最新的插件zip包安装更新。参考本文：&lt;code&gt;下载安装&lt;/code&gt;小节。&lt;/li&gt;
&lt;li&gt;插件更新需要重启IDE。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x4-一些说明&#34;&gt;0x4. 一些说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本插件默认不会显示其主界面，如果你需要，参考本文：&lt;code&gt;如何使用&lt;/code&gt;小节。&lt;/li&gt;
&lt;li&gt;市场付费插件的试用信息也会一并重置。&lt;/li&gt;
&lt;li&gt;对于某些付费插件（如: Iedis 2, MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：
&lt;ul&gt;
&lt;li&gt;如果IDE没有打开项目，在Welcome界面点击菜单：Configure -&amp;gt; Edit Custom VM Options... -&amp;gt; 移除 -javaagent: 开头的行。&lt;/li&gt;
&lt;li&gt;如果IDE打开了项目，点击菜单：Help -&amp;gt; Edit Custom VM Options... -&amp;gt; 移除 -javaagent: 开头的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重置需要重启IDE生效！&lt;/li&gt;
&lt;li&gt;重置后并不弹出Licenses对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。&lt;/li&gt;
&lt;li&gt;如果长达25天不曾有任何重置动作，IDE会有通知询问你是否进行重置。&lt;/li&gt;
&lt;li&gt;如果勾选：Auto reset before per restart ，重置是静默无感知的。&lt;/li&gt;
&lt;li&gt;简单来说：勾选了Auto reset before per restart则无需再管，一劳永逸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x5-开源信息&#34;&gt;0x5. 开源信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;插件是学习研究项目，源代码是开放的。源码仓库地址：&lt;a href=&#34;https://gitee.com/pengzhile/ide-eval-resetter&#34;&gt;Gitee&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你有更好的想法，欢迎给我提Pull Request来共同研究完善。&lt;/li&gt;
&lt;li&gt;插件源码使用：GPL-2.0开源协议发布。&lt;/li&gt;
&lt;li&gt;插件使用PHP编写，毕竟PHP是世界上最好的编程语言！&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x6-支持的产品&#34;&gt;0x6. 支持的产品&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;AppCode&lt;/li&gt;
&lt;li&gt;CLion&lt;/li&gt;
&lt;li&gt;DataGrip&lt;/li&gt;
&lt;li&gt;GoLand&lt;/li&gt;
&lt;li&gt;PhpStorm&lt;/li&gt;
&lt;li&gt;PyCharm&lt;/li&gt;
&lt;li&gt;Rider&lt;/li&gt;
&lt;li&gt;RubyMine&lt;/li&gt;
&lt;li&gt;WebStorm&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://zhile.io/2020/11/18/jetbrains-eval-reset.html&#34;&gt;https://zhile.io/2020/11/18/jetbrains-eval-reset.html&lt;/a&gt;&lt;/p&gt;
">Jetbrains系列产品重置试用方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/"" data-c="
          &lt;h1 id=&#34;题意&#34;&gt;题意&lt;/h1&gt;
&lt;p&gt;给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。&lt;/p&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;解题思路&lt;/h1&gt;
&lt;h2 id=&#34;暴力搜索&#34;&gt;暴力搜索&lt;/h2&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/munderover&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M[n,k] = min^n_{j=1}\{max\{ \ M[j,k-1], \ \sum^{n-1}_{i=j}A_i\}\}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.133108em;vertical-align:-0.383108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714392em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1130000000000004em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.383108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.2148900000000005em;vertical-align:-1.4137769999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8011130000000006em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.4137769999999998em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，n表示数组长度，k表示数组分成几段。&lt;br&gt;
初始化条件：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/munderover&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M[1,k] = A_0 \\ M[n,1] = \sum^{n-1}_{i=0}A_i
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.0787820000000004em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8011130000000004em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.300005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;递归算法拥有指数时间的复杂度，并且会重复计算一些M值。这类的算法一般可以使用动态规划进行优化。使用数组保存一些已经计算得到的值，采用自底向上进行计算&lt;/p&gt;
&lt;h2 id=&#34;二分查找&#34;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;此题可以想象成把数据按顺序装入桶中，m即是给定的桶数，问桶的容量至少应该为多少才能恰好把这些数装入k个桶中（按顺序装的）。&lt;/p&gt;
&lt;p&gt;首先我们可以知道，桶的容量最少不会小于数组中的最大值，即桶容量的最小值（小于的话，这个数没法装进任何桶中），假设只需要一个桶，那么其容量应该是数组所有元素的和，即桶容量的最大值；其次，桶数量越多，需要的桶的容量就可以越少，即随着桶容量的增加，需要的桶的数量非递增的（二分查找就是利用这点）；我们要求的就是在给定的桶数量m的时候，找最小的桶容量就可以把所有的数依次装入k个桶中。在二分查找的过程中，对于当前的桶容量，我们可以计算出需要的最少桶数requiredPainters，如果需要的桶数量大于给定的桶数量k，说明桶容量太小了，只需在后面找对应的最小容量使需要的桶数恰好等于k；如果计算需要的桶数量小于等于k，说明桶容量可能大了（也可能正好是要找的最小桶容量），不管怎样，该桶容量之后的桶容量肯定不用考虑了（肯定大于最小桶容量），这样再次缩小查找的范围，继续循环直到终止，终止时，当前的桶容量既是最小的桶容量。&lt;/p&gt;
&lt;p&gt;对于数组 1 2 3 4 5 6 7，假设k=3，最小桶容量为7（要5个桶），最大桶容量为28（一个桶）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1609316379450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一行表示桶容量，第二行表示需要的桶数，即要求桶数量恰为k的最小桶容量。&lt;/p&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool judge( vector&amp;lt;int&amp;gt;&amp;amp; nums, int capacity, int num ) {
        int curCapacity = capacity;
        for( int i = 0; i &amp;lt; nums.size(); ++i ) {
            if( curCapacity &amp;lt; nums[i] ) {
                num--;
                if( num == 0 ) {
                    return false;
                }
                curCapacity = capacity;
                i--;
            } else {
                curCapacity -= nums[i];
            }
        }
        return true;
    }
    int splitArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int m) {
        int max, min;
        int sum = 0;
        for( int i = 0; i &amp;lt; nums.size(); ++i ) {
            sum += nums[i];
        }
        max = sum; // 成功的情况
        min = 0; // 失败的情况
        while( min&amp;lt;max-1 ) { // 当两者相邻，就退出
            int mid = ( min+max ) / 2;
            if( judge(nums,mid,m) ) {
                max = mid;
            } else {
                min = mid;
            }
        }
        return max;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.cnblogs.com/ygh1229/p/10637504.html&#34;&gt;https://www.cnblogs.com/ygh1229/p/10637504.html&lt;/a&gt;&lt;/p&gt;
">LeetCode 410. 分割数组的最大值</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/"" data-c="
          &lt;p&gt;1、首先查看telnet运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -a | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出为空，表示没有开启该服务&lt;/p&gt;
&lt;p&gt;2、安装openbsd-inetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install openbsd-inetd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果已经安装过了，会提示已经安装过了，直接执行下面的步骤就可以了。&lt;/p&gt;
&lt;p&gt;3、安装telnetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install telnetd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完之后，查看/etc/inetd.conf的内容会多了一行telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat /etc/inetd.conf | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出： telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd&lt;/p&gt;
&lt;p&gt;4、重启openbsd-inetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/init.d/openbsd-inetd restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：* Restarting internet superserver inetd&lt;/p&gt;
&lt;p&gt;5、查看telnet运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -a | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：tcp　　0　　0 :telnet　　😗　　LISTEN&lt;/p&gt;
&lt;p&gt;此时表明已经开启了telnet服务。&lt;/p&gt;
&lt;p&gt;6、telnet登陆测试&lt;/p&gt;
&lt;p&gt;&lt;code&gt;telnet 127.0.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出： Trying 127.0.0.1… Connected to 127.0.0.1. Escape character is ‘^]’. （停在这里的时候要按Ctrl+] 然后回车）&lt;/p&gt;
&lt;p&gt;telnet&amp;gt; （表示登陆成功）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.cnblogs.com/taomylife/p/7552424.html&#34;&gt;https://www.cnblogs.com/taomylife/p/7552424.html&lt;/a&gt;&lt;/p&gt;
">Ubuntu下配置telnet环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-26-算法题精选/"" data-c="
          &lt;p&gt;本文档整理了笔者在刷题过程中遇到的、比较不错的题目，并进行了分类整理，供大家参考。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;打表&#34;&gt;打表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/UVA100&#34;&gt;UVA100 The 3n + 1 problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;并查集&#34;&gt;并查集&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1111&#34;&gt;P1111 修复公路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二分&#34;&gt;二分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/split-array-largest-sum/&#34;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/magnetic-force-between-two-balls/&#34;&gt;1552. 两球之间的磁力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/63/description?_from=cat&#34;&gt;63 · 搜索旋转排序数组 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分治&#34;&gt;分治&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1257&#34;&gt;P1257 平面上的最接近点对&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/merge-k-sorted-lists/&#34;&gt;23. 合并K个升序链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快排&#34;&gt;快排&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&#34;&gt;215. 数组中的第K个最大元素&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/valid-parentheses/&#34;&gt;20. 有效的括号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/&#34;&gt;150. 逆波兰表达式求值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/tag-validator/&#34;&gt;591. 标签验证器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单调栈&#34;&gt;单调栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/daily-temperatures/&#34;&gt;739. 每日温度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/next-greater-element-i/&#34;&gt;496. 下一个更大元素 I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-k-digits/&#34;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&#34;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water/&#34;&gt;42. 接雨水&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/&#34;&gt;84. 柱状图中最大的矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/maximal-rectangle/&#34;&gt;85. 最大矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-duplicate-letters/&#34;&gt;316. 去除重复字母&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/online-stock-span/&#34;&gt;901. 股票价格跨度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;中缀转后缀&#34;&gt;中缀转后缀&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/basic-calculator/&#34;&gt;224. 基本计算器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/basic-calculator-ii/&#34;&gt;227. 基本计算器 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单调队列&#34;&gt;单调队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/sliding-window-maximum/&#34;&gt;239. 滑动窗口最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/137/&#34;&gt;135. 最大子序和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/subarrays-with-k-different-integers/&#34;&gt;992. K 个不同整数的子数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/insertion-sort-list/147/&#34;&gt;147. 对链表进行插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/&#34;&gt;25. K 个一组翻转链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&#34;&gt;297. 二叉树的序列化与反序列化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/1691/description?_from=cat&#34;&gt;1691 · 买卖股票的最佳时机 V&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/merge-k-sorted-lists/&#34;&gt;23. 合并K个升序链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dp&#34;&gt;dp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364845&#34;&gt;ZOJ 1346 Comparing Your Heroes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/maximal-rectangle/&#34;&gt;85. 最大矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water/&#34;&gt;42. 接雨水&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/partition-equal-subset-sum/&#34;&gt;416. 分割等和子集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/longest-increasing-subsequence/&#34;&gt;300. 最长递增子序列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/interleaving-string/&#34;&gt;97. 交错字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers/&#34;&gt;1977. 划分数字的方案数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/cherry-pickup/&#34;&gt;741. 摘樱桃&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/232311&#34;&gt;Zet&#39;ubou Another&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;旅行商问题&#34;&gt;旅行商问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d&#34;&gt;毕业旅行问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模拟&#34;&gt;模拟&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/tag-validator/&#34;&gt;591. 标签验证器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;双指针&#34;&gt;双指针&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/3sum/&#34;&gt;15. 三数之和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;全排列生成算法&#34;&gt;全排列生成算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/permutations-ii/&#34;&gt;47. 全排列 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;快速幂&#34;&gt;快速幂&lt;/h1&gt;
&lt;h2 id=&#34;矩阵快速幂&#34;&gt;矩阵快速幂&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1962&#34;&gt;P1962 斐波那契数列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;字符串&#34;&gt;字符串&lt;/h1&gt;
&lt;h2 id=&#34;kmp&#34;&gt;KMP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/implement-strstr/&#34;&gt;28. 实现 strStr()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩展kmp&#34;&gt;扩展KMP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=4763&#34;&gt;HDU 4763 Theme Section&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;图论&#34;&gt;图论&lt;/h1&gt;
&lt;h2 id=&#34;最短路&#34;&gt;最短路&lt;/h2&gt;
&lt;h3 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://practice.geeksforgeeks.org/problems/minimum-cost-path3833/1&#34;&gt;Minimum Cost Path&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数论&#34;&gt;数论&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/11185/B&#34;&gt;Non-interger Area&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-substring-with-given-hash-value/&#34;&gt;5994. 查找给定哈希值的子串&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算几何&#34;&gt;计算几何&lt;/h2&gt;
&lt;h3 id=&#34;凸包&#34;&gt;凸包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/erect-the-fence/&#34;&gt;587. 安装栅栏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;离散化&#34;&gt;离散化&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/232311&#34;&gt;Zet&#39;ubou Another&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;差分&#34;&gt;差分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/11185/C&#34;&gt;Division&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/&#34;&gt;995. K 连续位的最小翻转次数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/&#34;&gt;1674. 使数组互补的最少操作次数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;思维&#34;&gt;思维&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/pairs-with-same-manhattan-and-euclidean-distance/&#34;&gt;Pairs with same Manhattan and Euclidean distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://practice.geeksforgeeks.org/problems/geek-collects-the-balls5515/1&#34;&gt;Geek collects the balls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&#34;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/word-subsets/&#34;&gt;916. 单词子集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/iterator-for-combination/&#34;&gt;1286. 字母组合迭代器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/797/description?_from=cat&#34;&gt;797 · 到达一个数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/snapshot-array/&#34;&gt;1146. 快照数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/my-calendar-i/&#34;&gt;729. 我的日程安排表 I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/my-calendar-ii/&#34;&gt;731. 我的日程安排表 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多数投票算法&#34;&gt;多数投票算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;随机化&#34;&gt;随机化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;搜索&#34;&gt;搜索&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/&#34;&gt;1263. 推箱子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">算法题精选</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-26-与技术相关的文章、博客、网站的汇总/"" data-c="
          &lt;p&gt;这篇文章主要收藏了一些与技术相关的文章、博客、网站，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平时工作学习中遇到的问题的解决方案&lt;/li&gt;
&lt;li&gt;学习资源网站&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://start.spring.io/&#34;&gt;快速创建SpringBoot项目-Spring Initializr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;windows子系统&#34;&gt;Windows子系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-6---install-your-linux-distribution-of-choice&#34;&gt;适用于 Linux 的 Windows 子系统安装指南 (Windows 10)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wulaa/p/7943550.html&#34;&gt;linux改变apt-get安装源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/stickmangod/article/details/85316142/&#34;&gt;E: Sub-process /usr/bin/dpkg returned an error code (1)解决办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/silno/article/details/107498696&#34;&gt;linux 修改ip后不能访问大网的问题解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/63c328ca208d&#34;&gt;Java Agent简介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;环境安装&#34;&gt;环境安装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/java/technologies/downloads/archive/&#34;&gt;Previous Java releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.codebaoku.com/jdk/jdk-oracle-account.html&#34;&gt;Oracle 共享账号 用于JDK下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;android&#34;&gt;Android&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/niuba123456/article/details/90450135#t4&#34;&gt;使用adb获取设备信息： failed to start daemon error: cannot connect to daemon&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;推荐使用换端口号的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lfd.uci.edu/~gohlke/pythonlibs/&#34;&gt;Python安装包大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45523851/article/details/110674141&#34;&gt;Could not build wheels for cryptography which use PEP 517 and cannot be installed directly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qm5132/article/details/105619531/&#34;&gt;python和Microsoft Visual C++ Build Tools版本安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/pyyong2011/article/details/105045883/&#34;&gt;python: cookies 解密问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;django&#34;&gt;Django&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/356405945&#34;&gt;手把手教你用Django实现RESTful接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qiyihan/article/details/105468754&#34;&gt;覃超五毒神掌步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分治&#34;&gt;分治&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33935895/article/details/103261211&#34;&gt;算法]分治法解最近对问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/q547550831/article/details/51541527&#34;&gt;分治法——棋盘覆盖问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;凸包&#34;&gt;凸包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/l1l1/p/9432876.html&#34;&gt;求凸包（安德鲁算法）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/peng0614/article/details/81193484&#34;&gt;【计算几何/凸包】安德鲁算法（Andrew&#39;s Algorithm）详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/21923021&#34;&gt;如何更好地理解和掌握 KMP 算法?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ethsonliu.com/2019/06/extended-kmp.html&#34;&gt;扩展 KMP 算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;学习网站&#34;&gt;学习网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/learning&#34;&gt;阿里云-开发者学院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ke.qq.com/&#34;&gt;腾讯课堂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fortify破解&#34;&gt;Fortify破解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.shungg.cn/tag/Fortify19.1.0%E7%A0%B4%E8%A7%A3%E7%89%88/&#34;&gt;标签 Fortify19.1.0破解版 下的文章&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/drive/folder/60d975363027965796944370938057922389184e&#34;&gt;Fortify SCA 20.1.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.52pojie.cn/thread-1085767-1-1.html&#34;&gt;fortify license 破解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhonghuan1992/article/details/38358183&#34;&gt;迪米特法则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uml&#34;&gt;UML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wglla/article/details/52225571&#34;&gt;uml图六种箭头的含义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/mafeng/p/7909450.html&#34;&gt;位图（BitMap）索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/majunzhu/article/details/100163523&#34;&gt;数据库分库分表策略和分库分表后数据的查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kafka&#34;&gt;Kafka&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hunternet/p/11017000.html&#34;&gt;docker 安装kafka&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;悟空架构&#34;&gt;悟空架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451958620&amp;amp;idx=1&amp;amp;sn=2b68a7579fe43f185b9479e257f6b8ea&amp;amp;chksm=8d1c12c3ba6b9bd5d12b50b3685759053204d63e2fadf8989ad1c8cafde01f0791f37320612d&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0909GosYFr1BPWpDIiHTMimh&amp;amp;sharer_sharetime=1631186094285&amp;amp;sharer_shareid=909e580e119d7a6d472174ec4df35366#rd&#34;&gt;1 W 字+ | 硬刚 MySQL（典藏版）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451958264&amp;amp;idx=1&amp;amp;sn=f7c990e26332cb1b86256f0515b921fd&amp;amp;chksm=8d1c1067ba6b9971e0391682dd97edb2dda9e8fff55aa77aa1d15e5337edee69d10d0340bcd9&amp;amp;scene=178&amp;amp;cur_album_id=2006564214110224387#rd&#34;&gt;面试突击：多线程 | 水帘洞版（免费下载）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式&#34;&gt;分布式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaomi-info.github.io/2020/01/02/distributed-transaction/&#34;&gt;分布式事务，这一篇就够了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;科研&#34;&gt;科研&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/80767310&#34;&gt;学术邮箱命名指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33653203/article/details/111124871&#34;&gt;Yandex降低内存的做法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">与技术相关的文章、博客、网站的汇总</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/valine/"" data-c="
          &lt;p&gt;这篇文章主要用于让python脚本定时评论，唤醒Valine。&lt;/p&gt;
">Valine</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-21-NexT主题设置Valine评论系统邮件提醒/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天无意间看到很久之前写的一篇文章有新的评论，而评论时间呢也是10天以前的。这就有点伤了啊，别人兴致冲冲地提了疑惑，而我却10天后才看到。经过这一茬，意识到评论提醒功能的重要性。由于我使用的是hexo+NexT主题+Valine评论系统，自然而然地就去&lt;a href=&#34;https://valine.js.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valine官网&lt;/a&gt;看了看，没想到还真有提醒的功能「&lt;a href=&#34;https://valine.js.org/notify.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;邮件提醒&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;这里就给大家讲讲Valine中如何配置邮件提醒功能。&lt;/p&gt;
&lt;h2 id=&#34;Valine邮件提醒&#34;&gt;&lt;a href=&#34;#Valine邮件提醒&#34; class=&#34;headerlink&#34; title=&#34;Valine邮件提醒&#34;&gt;&lt;/a&gt;Valine邮件提醒&lt;/h2&gt;&lt;p&gt;Valine评论功能是基于&lt;a href=&#34;https://leancloud.cn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leancloud&lt;/a&gt;的，Valine评论功能还不能跑起来的可以看看我之前写的文章《&lt;a href=&#34;/2345860311#comment_system&#34;&gt;Hexo使用NexT主题及配置&lt;/a&gt;》，其中就有详细的使用说明，这里就不展开了。&lt;/p&gt;
&lt;p&gt;Valine官方提供的邮件提醒功能是基于&lt;code&gt;Leancloud的密码重置邮件提醒&lt;/code&gt;，操作步骤如下：&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Leancloud&lt;/code&gt;&amp;gt;选择你的评论所存放的&lt;code&gt;应用&lt;/code&gt;&amp;gt;&lt;code&gt;设置&lt;/code&gt;&amp;gt;&lt;code&gt;邮件模板&lt;/code&gt;，按下图设置好用于&lt;code&gt;重置密码&lt;/code&gt;的邮件主题&amp;gt;然后保存:&lt;/p&gt;
![](http://Bule-Zst.gitee.io/post-images/1608560201989.jpg)
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改邮件主题：&lt;code&gt;你在  的评论收到了新的评论&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改内容：将下面的代码复制到“内容”中，并将其中的&lt;code&gt;你的网址首页链接&lt;/code&gt;改为你的网址首页链接。&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Hi, {{username}}&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;你在 {{appname}} 的评论收到了新的回复，请点击查看：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;href&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;你的网址首页链接&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;style&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;马上查看&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击“保存”按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;span class=&#34;label label-info&#34;&gt;NexT主题配置文件&lt;/span&gt;，搜索&lt;code&gt;valine&lt;/code&gt;（快速定位），将其中的&lt;code&gt;notify&lt;/code&gt;改为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;# Valine.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# You can get your appid and appkey from https://leancloud.cn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# more info please open https://valine.js.org&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;valine:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  enable: true&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  appid:  gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  appkey: susRJyHS8Fq1SyKXg0r9ad65&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  notify: true # mail notifier , https://github.com/xCss/Valine/wiki&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  verify: false # Verification code&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  placeholder: 您的评论可以一针见血 (*^ω^*)~~ # comment box placeholder&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  avatar: mm # gravatar style&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  guest_info: nick,mail,link # custom comment header&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  pageSize: 10 # pagination size&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;&lt;a href=&#34;#注意事项&#34; class=&#34;headerlink&#34; title=&#34;注意事项&#34;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;发送次数过多，可能会暂时被Leancloud 屏蔽邮件发送功能  &lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;邮件提醒&lt;/code&gt;功能使用的&lt;code&gt;Leancloud的密码重置邮件提醒&lt;/code&gt;，只能传递&lt;code&gt;昵称&lt;/code&gt;、&lt;code&gt;邮箱&lt;/code&gt;两个属性，所以邮件提醒链接&lt;code&gt;无法直达指定文章页&lt;/code&gt;。&lt;strong&gt;请悉知&lt;/strong&gt;。  &lt;/li&gt;
&lt;li&gt;开启&lt;code&gt;邮件提醒&lt;/code&gt;会默认开启&lt;code&gt;验证码&lt;/code&gt;选项。  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;该功能目前还在测试阶段，谨慎使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前&lt;code&gt;邮件提醒&lt;/code&gt;正处于测试阶段，仅在&lt;code&gt;子级&lt;/code&gt;对存在邮件地址的&lt;code&gt;父级&lt;/code&gt;发表评论时发送邮件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三方支持&#34;&gt;&lt;a href=&#34;#第三方支持&#34; class=&#34;headerlink&#34; title=&#34;第三方支持&#34;&gt;&lt;/a&gt;第三方支持&lt;/h2&gt;&lt;p&gt;这里重点讲一下第三方&lt;code&gt;邮件提醒&lt;/code&gt;：&lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valine-Admin&lt;/a&gt; (by &lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@zhaojun1998&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;这也先需要将Valine的评论功能成功跑起来。&lt;/p&gt;
&lt;p&gt;然后进入 &lt;a href=&#34;https://leancloud.cn/dashboard/applist.html#/apps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leancloud&lt;/a&gt; 对应的 Valine 应用中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击 &lt;code&gt;云引擎 -&amp;gt; 设置&lt;/code&gt; 填写代码库并保存：&lt;code&gt;https://github.com/zhaojun1998/Valine-Admin&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560645315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;切换到部署标签页，分支使用 master，点击部署即可：&lt;br&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560340962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560360122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置云引擎的环境变量&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560540352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;必选参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SITE_NAME&lt;/code&gt; : 网站名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SITE_URL&lt;/code&gt; : 网站地址, &lt;strong&gt;最后不要加 &lt;code&gt;/&lt;/code&gt; 。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_USER&lt;/code&gt; : SMTP 服务用户名，一般为邮箱地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_PASS&lt;/code&gt; : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_SERVICE&lt;/code&gt; : 邮件服务提供商，支持 &lt;code&gt;QQ&lt;/code&gt;、&lt;code&gt;163&lt;/code&gt;、&lt;code&gt;126&lt;/code&gt;、&lt;code&gt;Gmail&lt;/code&gt;、&lt;code&gt;&#34;Yahoo&#34;&lt;/code&gt;、&lt;code&gt;......&lt;/code&gt;  ，全部支持请参考 : &lt;a href=&#34;https://nodemailer.com/smtp/well-known/#supported-services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nodemailer Supported services&lt;/a&gt;。 — &lt;em&gt;如这里没有你使用的邮件提供商，请查看&lt;a href=&#34;/高级配置.md#自定义邮件服务器&#34;&gt;自定义邮件服务器&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENDER_NAME&lt;/code&gt; : 寄件人名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于我使用的是我自己的企业邮箱，所以这边的&lt;code&gt;SMTP_SERVICE&lt;/code&gt;就不适用了，需要用这三个参数替换：&lt;code&gt;SMTP_HOST&lt;/code&gt;、&lt;code&gt;SMTP_PORT&lt;/code&gt;、&lt;code&gt;SMTP_SECURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;详细说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SMTP_HOST&lt;/code&gt; : 邮件服务提供商 SMTP 地址，如 qq : &lt;code&gt;smtp.qq.com&lt;/code&gt;，&lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_PORT&lt;/code&gt; : 邮件服务提供商 SMTP 端口, &lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_SECURE&lt;/code&gt; : 是否启用加密, 默认为 &lt;code&gt;true&lt;/code&gt;，一般不需要设置，如有特殊请自行配置。 &lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果也同我一样使用阿里云企业邮箱，&lt;code&gt;SMTP_HOST&lt;/code&gt;、&lt;code&gt;SMTP_PORT&lt;/code&gt;、&lt;code&gt;SMTP_SECURE&lt;/code&gt;可以照我的写。&lt;/p&gt;
&lt;p&gt;可以看到上图中，我的自定义环境变量还多了2个，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TO_EMAIL&lt;/code&gt;：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到&lt;code&gt;SMTP_USER&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEMPLATE_NAME&lt;/code&gt;：设置提醒邮件的主题，目前内置了两款主题，分别为 &lt;code&gt;default&lt;/code&gt; 与 &lt;code&gt;rainbow&lt;/code&gt;。默认为 &lt;code&gt;default&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Web-评论管理&#34;&gt;&lt;a href=&#34;#Web-评论管理&#34; class=&#34;headerlink&#34; title=&#34;Web 评论管理&#34;&gt;&lt;/a&gt;Web 评论管理&lt;/h3&gt;&lt;p&gt;此项目还为 Valine 提供了更方便的评论管理功能，可以在 web 端对评论进行查看与删除操作。配置方式如下。&lt;/p&gt;
![](http://Bule-Zst.gitee.io/post-images/1608560421062.png)
&lt;p&gt;后台登录需要账号密码，需要在这里设置，只需要填写 &lt;code&gt;email&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;username&lt;/code&gt;，这三个字段即可, 使用  &lt;code&gt;email&lt;/code&gt; 作为账号登陆即可。（为了安全考虑，此 &lt;code&gt;email&lt;/code&gt; 必须为配置中的 &lt;code&gt;SMTP_USER&lt;/code&gt; 或 &lt;code&gt;TO_EMAIL&lt;/code&gt;， 否则不允许登录）&lt;br&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560447539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Web 后台目前仅有 &lt;code&gt;查看&lt;/code&gt; 与 &lt;code&gt;删除&lt;/code&gt; 功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;LeanCloud-休眠策略&#34;&gt;&lt;a href=&#34;#LeanCloud-休眠策略&#34; class=&#34;headerlink&#34; title=&#34;LeanCloud 休眠策略&#34;&gt;&lt;/a&gt;LeanCloud 休眠策略&lt;/h3&gt;&lt;p&gt;免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天必须休眠 6 个小时&lt;/li&gt;
&lt;li&gt;30 分钟内没有外部请求，则休眠。&lt;/li&gt;
&lt;li&gt;休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。&lt;/p&gt;
&lt;p&gt;附 &lt;code&gt;Linux crontab&lt;/code&gt; 定时器代码：&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注 : 此 &lt;code&gt;crontab&lt;/code&gt; 不是 &lt;code&gt;LeanCloud&lt;/code&gt; 后台的定时任务，如果你没有 &lt;code&gt;Linux&lt;/code&gt; 服务器来配置此定时器，那么可以在此 &lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin/issues/1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issues&lt;/a&gt; 中回复&lt;strong&gt;zhaojun1998&lt;/strong&gt;，让他帮你加上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注&#34;&gt;&lt;a href=&#34;#注&#34; class=&#34;headerlink&#34; title=&#34;注&#34;&gt;&lt;/a&gt;注&lt;/h3&gt;&lt;p&gt;&lt;strong class=&#34;lable-red&#34;&gt;更新新版本与更改环境变量均需要重启容器后生效。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;重启容器&#34;&gt;&lt;a href=&#34;#重启容器&#34; class=&#34;headerlink&#34; title=&#34;重启容器&#34;&gt;&lt;/a&gt;重启容器&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560469789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.nhtzj.com/3315416634/&#34;&gt;https://www.nhtzj.com/3315416634/&lt;/a&gt;&lt;/p&gt;
">NexT主题设置Valine评论系统邮件提醒</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-20-防御式编程（Defensive Programming）/"" data-c="
          &lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;新的一年开始了，大家都立下了什么新年flag呢？好久没有更新简书了，最近在看《代码大全》对于第八章的防御式编程颇有感慨，正好最近又是在准备公司的技术分享，索性用&lt;code&gt;md&lt;/code&gt;写了篇博文，总结了一下又增加了一些我个人的理解，在这里跟各位分享一下。&lt;/p&gt;
&lt;h1 id=&#34;defensive-programming&#34;&gt;Defensive Programming&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456004690.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;防御式编程（Defensive Programming）&lt;/strong&gt;是提高软件质量技术的有益辅助手段&lt;/p&gt;
&lt;p&gt;怎么理解呢？防御式编程思想的理解可以参考防御式驾驶：&lt;/p&gt;
&lt;p&gt;在防御式驾驶中要建立这样一种思维，那就是你水远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456590306.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;防御式编程的主要思想是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更一般地说，其核心想法是要承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点来编程序，这种思想是将可能出现的错误造成的影响控制在有限的范围内。&lt;/p&gt;
&lt;h2 id=&#34;保护程序免遭非法输入数据的破坏&#34;&gt;保护程序免遭非法输入数据的破坏&lt;/h2&gt;
&lt;p&gt;计算机领域有着一句&lt;code&gt;GIGO(Garbage In Garbage Out)&lt;/code&gt;俗语，翻译过来就是&lt;code&gt;垃圾进，垃圾出&lt;/code&gt;，意思就是&lt;code&gt;有垃圾数据进来后，出来的也是垃圾数据&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456659523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而就目前而言，对于已经成型的产品可能单单是这种原则并不适用，而是应该做到&lt;code&gt;垃圾进，什么也不出&lt;/code&gt;、&lt;code&gt;垃圾进，出去的是错误提示&lt;/code&gt;、&lt;code&gt;垃圾进，经过筛选提取，出去的是有用信息&lt;/code&gt;或是&lt;code&gt;不许垃圾进来&lt;/code&gt;。换句话说，&lt;code&gt;GIGO&lt;/code&gt;于今天的标准看来已然是差劲程序的标志了。&lt;/p&gt;
&lt;p&gt;防御式编程针对垃圾进这种情况，有以下三种方法处理：&lt;/p&gt;
&lt;h4&gt; 1、检查所有来源于外部的数据&lt;/h4&gt;
&lt;p&gt;当从文件、用户、网络或其他外部接口中获取数据时，应检查所获得的数据值，以确保它在允许的范围内。&lt;/p&gt;
&lt;h4&gt; 2、检查子程序所有输入参数的值&lt;/h4&gt;
&lt;p&gt;检查子程序输入参数的值，事实上和检查来源于外部的数据一样，只不过数据来源于其他子程序而非外部接口。&lt;/p&gt;
&lt;h4&gt; 3、决定如何处理错误的输入数据&lt;/h4&gt;
&lt;p&gt;一旦检测到非法的参数，你该如何处理它呢？根据情况的不同，你可以选择适合你的&lt;code&gt;错误处理技术&lt;/code&gt;或&lt;code&gt;断言&lt;/code&gt;来处理。&lt;/p&gt;
&lt;p&gt;接下来我们将针对以上所说的情况讲解防御式编程中需要掌握的方式：&lt;/p&gt;
&lt;h2 id=&#34;断言&#34;&gt;断言&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456704145.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;断言是指在开发期间使用的、让程序在运行时进行自检的代码（通常为宏或一个子程序）。断言为真则程序正常运行，断言为假则意味着代码中发生了错误。&lt;/p&gt;
&lt;p&gt;举个例子：一份客户信息程序要求包含记录数不超过10，我们加一个断言。当记录数小于10，断言会默默无语两眼泪，当超过10，断言就会大声的说程序中存在一个错误！&lt;/p&gt;
&lt;p&gt;断言对于大型复杂程序或可靠性要求极高的程序来说尤为重要。通过使用断言，程序员能更快速排查出因修改代码或者别的原因，而弄进程序里不匹配的接口和错误等。&lt;/p&gt;
&lt;p&gt;OC中内置的断言：（&lt;strong&gt;iOS每个线程都可以指定断言处理器。想设置一个 NSAssertionHandler 的子类来处理失败的断言，在线程的 threadDictionary 对象中设置 NSAssertionHandlerKey 字段即可&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;对NSAssertionHandler有兴趣的童鞋请移步：&lt;a href=&#34;https://nshipster.cn/nsassertionhandler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define NSAssert(condition, desc, ...)  \
    do {                \
    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
    if (__builtin_expect(!(condition), 0)) {        \
            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
            __assert_file__ = __assert_file__ ? __assert_file__ : @&amp;quot;&amp;lt;Unknown File&amp;gt;&amp;quot;; \
        [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
        object:self file:__assert_file__ \
            lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
    }               \
        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
    } while(0)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面将介绍一下断言使用时的建议：&lt;/p&gt;
&lt;h4&gt; 1、建立自己的断言机制&lt;/h4&gt;
&lt;p&gt;很多时候，系统自带的断言无法满足我们的需求，比如iOS断言在release模式下会失效，那么我们可以自定义断言来适应我们的项目&lt;/p&gt;
&lt;p&gt;下面是C++的断言宏示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#define ASSERT(condition, message) {    \
    if (!condition) {                   \
        Log(&amp;quot;ERROR &amp;quot;,condition,message);\
        exit( EXIT_FAILURE );           \
    }                                   \
}                                       \

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OC中示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define WYHAssert(condition, desc)  \
if (DEBUG) {                        \
   NSAssert(condition, desc);       \
}else {                             \
   NSString *app_build = [[NSBundle mainBundle].infoDictionary objectForKey:@&amp;quot;CFBundleVersion&amp;quot;]; \
NSLog(@&amp;quot;Assert Error condition:%@ (desc: %@) \n Occur in &amp;lt;%s&amp;gt;&amp;lt;第%d行&amp;gt; , AppBuildVersion:%@&amp;quot;,condition,desc,__FILE__,__LINE__,app_build); \
   [LogModule postLog];                            \
} \
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt; 2、用错误处理代码处理预期发生的状况，用断言去处理那些不可发生的错误！&lt;/h4&gt;
&lt;p&gt;断言和错误处理代码的区别：&lt;/p&gt;
&lt;p&gt;断言是用来检查永远不该发生的情况，而错误处理代码(error-handling code)是用来检查不太可能经常发生的情况，这些情况是能在写代码时被预料的，且在产品正式上线时也要处理这些情况，因而说错误处理通常用来检查有害的输入数据，而断言是用于检查代码中的bug ！&lt;/p&gt;
&lt;p&gt;有种方式可以让你更好理解断言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把断言看做是可执行的注解，你不能依赖它来让代码正常工作，但与编程语言中的注解相比，它更能主动地对程序中的假定做出说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt; 3、利用断言来注解前条件和后条件&lt;/h4&gt;
&lt;p&gt;前条件（先验条件）和后条件(后验条件)专有名词最初来自于&lt;a href=&#34;https://baike.baidu.com/item/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1/2180000?fr=aladdin&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;契约式设计(Design by Contract)(DbC)&lt;/a&gt;，使用契约式设计时，每个子程序或类与程序的其余部分都形成了一份契约。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很多语言都有对这种断言的支持。然而DbC认为这些契约对于软件的正确性至关重要，它们应当是设计过程的一部分。实际上，DbC提倡首先写断言。（百度百科）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前条件：子程序或类的调用方代码再调用子程序或实例化对象之前要确保为真的属性。前条件是调用方对其所调用的代码要承担的义务。&lt;/p&gt;
&lt;p&gt;后条件：子程序或类在执行结束后要确保为真的属性，后条件是子程序或类对调用方代码所承担的责任。&lt;/p&gt;
&lt;p&gt;而断言是用来说明前后条件的有利工具。&lt;/p&gt;
&lt;p&gt;下面举个例子说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/// 警报站坐标
private class EStationCoordinate: NSObject {

    var latitude: Float?
    
    var longitude: Float?
    
    var elevation: Float = 0.0
    
    init(_ latitude: Float,_ longitude: Float,_ elevation: Float) {
        super.init()
        
        self.latitude = latitude
        self.longitude = longitude
        self.elevation = elevation
    }
}


/// 取得报警站坐标
///
/// - Parameters:
///   - latitude: &amp;lt;#latitude description#&amp;gt;
///   - longitude: &amp;lt;#longitude description#&amp;gt;
///   - elevation: &amp;lt;#elevation description#&amp;gt;
/// - Returns: &amp;lt;#return value description#&amp;gt;
private func createEmergencyCoordinate(_ latitude: Float,_ longitude: Float,_ elevation: Float) -&amp;gt; EStationCoordinate {
    
    // precondition
    assert(-90 &amp;lt;= latitude &amp;amp;&amp;amp; latitude &amp;lt;= 90, &amp;quot;latitude must within range !&amp;quot;);
    
    assert(0 &amp;lt;= longitude &amp;amp;&amp;amp; longitude &amp;lt; 360, &amp;quot;longitude must within range !&amp;quot;);
    
    assert(100 &amp;lt;= elevation &amp;amp;&amp;amp; elevation &amp;lt; 500, &amp;quot;elevation must within range !&amp;quot;);
    
    // handle .... searching in local
    
    // postcondition
    assert(isContain, &amp;quot;local not contain this coordinate !&amp;quot;)
    
    var coordinate = EStationCoordinate(latitude,longitude,elevation)
    
    return coordinate
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果变量latitude、longitude和elevation都是来源于系统外部，那么就应该用错误处理代码来检查和处理非法的数值，而如果变量的值是源于可信的系统内部，并且这段程序是基于这些值不会超出合法范围的假定而设计，使用断言则是非常合适的。&lt;/p&gt;
&lt;h4&gt; 4、避免将需要执行的子程序放到断言中&lt;/h4&gt;
&lt;p&gt;如果把需要执行的子程序代码写在断言的codition条件里，那么当你关闭断言功能时，编译器很可能就把这些代码排除在外了，下面举一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)postFileToServer {
    
    // .... make file
    
    NSAssert([self compressFileToZip], @&amp;quot;File can&#39;t be compressed !&amp;quot;);
    
    // ... post to server 
}

- (BOOL)compressFileToZip {
    
    //... compress file and create a zip path !
    if (zipPath.length &amp;gt; 0) {
        
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样如果未编译断言，则condition语句的子程序也将不会执行，应修改为以下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)postFileToServer {
    
    // .... make file
    BOOL isCompressSuccess = [self compressFileToZip];
    
    NSAssert(isCompressSuccess, @&amp;quot;File can&#39;t be compressed !&amp;quot;);
    
    // ... post to server
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;错误处理技术&#34;&gt;错误处理技术&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456741675.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;前面我们提过了，断言是处理程序代码中那些不应发生的错误，那么又如何处理那些我们预料之内的可能发生的错误呢？&lt;/p&gt;
&lt;p&gt;首先我们要明确对于程序而言，处理错误最恰当的方式是要根据程序软件的类别而定，进而言之就是对于程序的两个概念：&lt;em&gt;健壮性与正确性&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt; 程序的健壮性 &lt;/h4&gt;&lt;/h4&gt;
&lt;p&gt;定义：健壮性具体指的是系统在不正常的输入或不正常的外部环境下仍能表现出正常的程度。&lt;/p&gt;
&lt;p&gt;健壮性的原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断尝试采取措施来包容错误的输入以此让程序正常运转（对自己的代码要保守，对用户的行为要开放）&lt;/li&gt;
&lt;li&gt;考虑各种各样的极端情况，没有impossible&lt;/li&gt;
&lt;li&gt;即使终止执行，也要准确/无歧义的向用户展示全面的错误信息&lt;/li&gt;
&lt;li&gt;错误信息有助于进行debug&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：视频游戏中的绘图子程序接收到了一个错误的颜色输入，那么在设计的时候可以针对这种情况，采用它的默认背景色或前景色继续绘制，而不是让程序崩溃或退出。&lt;/p&gt;
&lt;h4&gt; 程序的正确性&lt;/h4&gt;
&lt;p&gt;定义：正确性意味着程序永不返回不准确的结果，即使这样做会不返回结果或是直接退出程序。&lt;/p&gt;
&lt;p&gt;例如：在设计控制治疗癌症病人的放疗设备的软件时，当软件接收到错误的放射剂量，那么也许直接关闭程序就是最佳的选择，哪怕重启也比冒险施放错误的放射剂量要好的多。&lt;/p&gt;
&lt;p&gt;总结，两者之间的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确性：永不给用户错误的结果，哪怕是退出程序&lt;/li&gt;
&lt;li&gt;健壮性：尽可能的保持软件运行而不是总是退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了程序的健壮性与正确性，我们就可以采用以下几种手段，或结合起来使用错误处理技术：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、返回中立值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时，处理错误的最佳做法就是继续执行操作并简单的返回一个没有危害的值。&lt;/p&gt;
&lt;p&gt;比如，一个基于输入颜色的绘图子程序接收到了一个错误的颜色输入，它可以忽略这个错误的颜色，而是采用默认的底色或前景色继续进行绘制，而不是直接崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、换用下一个正确的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在处理轮询查询状态的子程序时，如果某次查询出的输出数据错误或有误，大可以忽略本次错误的数据，继续等待下一次轮询时读取正确的数据&lt;br&gt;
&lt;p&gt;（例如，如果你以每秒100次的速度读取体温计的数据，如果某一次得到的数据有误，我们可以再等上1/100秒后继续读取正确的数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、返回与前次相同的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是举上一个例子，如果体温计在1/100秒读取到的是一个错误数据，那么大可以返回上一次正确的数据，因为温度在1/100秒内变化不会太大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、换用最接近的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，当我们在编写一个滑块在规定区域内滑动的程序时，如果滑块超过规定区域，我们可以取最接近于超过区域的安全数值返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、把警告信息记录到日志文件中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在检测到错误数据时，可以选择在日志文件中记录一条警告信息，然后继续执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、返回一个错误状态码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以决定只让徐彤的某些部分处理错误，其他部分则不在局部处理错误，而是简单的返回一个错误码。&lt;/p&gt;
&lt;p&gt;比如在用户信息编辑页面有一个保存按钮，当某些信息填写错误时，这时只是记录一个错误码，当点击保存按钮时才去判断验证这个错误码是否存在，决定是否允许用户执行下一步操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、调用错误处理子程序或对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把错误处理都集中在一个全局的错误处理子程序或对象中，这种方法优点在于能把错误处理的职责集中到一起，从而让调试变得更简单。而代价则是整个程序都要知道这个集中点，并与之紧密耦合。&lt;/p&gt;
&lt;p&gt;什么意思呢？比如在一系列有上下文关系的请求中，针对所有的请求错误，我们只封装一个错误管理类来集中管理这些错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、当错误发生时显示出错消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法可以把错误处理的开销减到最小，然而你需要衡量此时的错误消息对于用户而言是否是友善的，相反对于攻击者而言，尽量不要让他们利用错误信息来发现如何攻击这个系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、关闭程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些更偏向于&lt;code&gt;正确性&lt;/code&gt;的程序，当检测到错误发生时，也许关闭程序是最佳的选择。&lt;/p&gt;
&lt;p&gt;如上面谈到的&lt;code&gt;癌症病人的放疗设备的软件&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456771734.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异常处理，英文名为exceptional handling, 是代替日渐衰落的error code方法的新法，提供error code 所未能具体的优势。异常处理分离了接收和处理错误代码。这个功能理清了编程者的思绪，也帮助代码增强了可读性，方便了维护者的阅读和理解。 异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理使用 try、catch 和 finally 关键字来尝试可能未成功的操作，处理失败，以及在事后清理资源。(百度百科)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在一个子程序中遇到了预料之外的情况，但并不知道如何处理的话，你就可以选择抛出一个异常。&lt;/p&gt;
&lt;p&gt;异常的基本结构是：子程序使用throw抛出一个异常对象，再被调用链上层其他子程序的try-catch语句捕获。(&lt;strong&gt;内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;我知道听到这，肯定有人懵逼了，我们来看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)tryFirstException {
    @try {
        // 1
        [self trySecondException];
        
    } @catch (NSException *exception) {
        //2
        NSLog(@&amp;quot;First reason:%@&amp;quot;,exception.reason);
        
    } @finally {
        //3
    }
    //4
}

+ (void)trySecondException {
    @try {
        //5
        [self tryThirldException];
        
    } @catch (NSException *exception) {
        //6
        @throw exception; //如果将这段代码注释后又会怎样？
        NSLog(@&amp;quot;Second reason:%@&amp;quot;,exception.reason);
    } @finally {
        //7
    }
    //8
}

+ (void)tryThirldException {
    //9
    @throw [NSException exceptionWithName:@&amp;quot;Exc&amp;quot; reason:@&amp;quot;no reason!&amp;quot; userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有人知道程序应该怎么执行吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;许多常见的程序设计语言，包括Actionscript，Ada，BlitzMax，C++，C#，D，ECMAScript，Eiffel，Java，ML，Object Pascal（如Delphi，Free Pascal等），Objective-C，Ocaml，PHP（version 5），PL/1，Prolog，Python，REALbasic，Ruby，Visual Prolog以及大多数.NET程序设计语言，内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止。一般在这个异常处理代码的搜索过程中逐级完成栈卷回（stack unwinding）。但Common Lisp是个例外，它不采取栈卷回，因此允许异常处理完后在抛出异常的代码处原地恢复执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面将给予一些使用异常的建议：&lt;/p&gt;
&lt;h4&gt; 1、用异常通知程序的其他部分，发生了不可忽略的错误&lt;/h4&gt;
&lt;p&gt;异常机制的优越之处，在于它能提供一种无法被忽略的错误通知机制。其他错误处理技术有可能会导致错误在不知不觉中向外扩散，而异常则消除了这种可能性。&lt;/p&gt;
&lt;h4&gt; 2、只在真正例外的情况下才抛出异常&lt;/h4&gt;
&lt;p&gt;仅在真正例外的情况下才使用异常————换句话说，就是仅在其他编码实践方法无法解决的情况下才使用异常。这种情况跟断言相似————都是用来处理那些不仅罕见甚至永远不该发生的情况。&lt;/p&gt;
&lt;h4&gt; 3、不能用异常来推卸责任&lt;/h4&gt;
&lt;p&gt;如果某种错误情况可以在局部处理，那就应该在局部处理它。不要把本可以处理的错误当成一个未被捕获的异常抛出去。&lt;/p&gt;
&lt;h4&gt; 4、避免在构造函数和析构函数中抛出异常，除非你在同一个地方把它们捕获&lt;/h4&gt;
&lt;p&gt;如果尝试在构造函数或析构函数中抛出异常，则处理异常将变得非常复杂。&lt;br&gt;
&lt;p&gt;比如在C++中，只有对象在完全构造之后才能调用析构函数，也就是说如果再构造函数中抛出异常，就不会调用析构函数，从而造成潜在的资源泄漏。&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt; 5、在恰当的抽象层次抛出异常&lt;/h4&gt;
&lt;p&gt;当你决定把一个异常传给调用方时，请确保异常的抽象层次与子程序的接口抽象层次一致。&lt;br&gt;
&lt;p&gt;（比如在A类的某一子程序中，有一个getDefenseId的方法，在方法中的某些步骤中，我们抛出了一个文件读写错误的异常，这本应由层次更低的内部类F专职去做的事，却错误的在A类中抛出异常，破坏了封装性，也暴露了一些私有的实现细节，这显然不是我们想要的）&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt; 6、在异常消息中加入关于导致异常发生的全部信息&lt;/h4&gt;
&lt;p&gt;比如因为一个索引值错误而抛出的，就应该在异常消息中包含索引的上下界限一级非法的索引下标值等信息。&lt;/p&gt;
&lt;h4&gt; 7、避免使用空的catch语句&lt;/h4&gt;
&lt;p&gt;不要视图敷衍一个不知该如何处理的异常&lt;/p&gt;
&lt;h4&gt; 8、考虑创建一个集中的异常报告机制&lt;/h4&gt;
&lt;p&gt;封装一个异常报告的子程序（或基类）专门快速方便的报告程序中需要主动抛出的异常（异常处理器），将对于异常的使用更加标准化&lt;/p&gt;
&lt;h4&gt; 9、考虑异常的替换机制&lt;/h4&gt;
&lt;p&gt;虽然一些编程语言对于异常的支持已有5~10年甚至更久的历史，但关于如何安全使用异常的经验仍然还是很少。&lt;/p&gt;
&lt;p&gt;拿iOS举例，&lt;code&gt;Apple.inc&lt;/code&gt;虽然同时提供了错误处理（&lt;code&gt;NSError&lt;/code&gt;）和异常处理（&lt;code&gt;Exception&lt;/code&gt;）两种机制，但是Apple不建议我们主动去使用Exception，更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Important: In many environments, use of exceptions is fairly commonplace. For example, you might throw an exception to signal that a routine could not execute normally—such as when a file is missing or data could not be parsed correctly. Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors. Instead you should use the return value of a method or function to indicate that an error has occurred, and provide information about the problem in an error object. For more information, see Error Handling Programming Guide.&lt;/p&gt;
&lt;p&gt;(developer.apple.com)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感兴趣的童鞋请移步苹果官网 &lt;a href=&#34;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多说一句，虽然apple不推荐我们经常主动使用Exception，但针对于crash的异常捕捉，iOS是可以通过&lt;code&gt;NSSetUncaughtExceptionHandler&lt;/code&gt;来捕获大部分crash的，但值得注意的是无法捕获那些由于&lt;code&gt;内存溢出&lt;/code&gt;、&lt;code&gt;野指针BAD_ACCESS&lt;/code&gt;导致的crash，比如&lt;code&gt;Flurry&lt;/code&gt;中对&lt;code&gt;crash&lt;/code&gt;处理就是这么运作的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - (void) uncaughtExceptionHandler(NSException *exception) 
    {
        [Flurry logError:@&amp;quot;Uncaught&amp;quot; message:@&amp;quot;Crash!&amp;quot; exception:exception];
    }
 
    - (void)applicationDidFinishLaunching:(UIApplication *)application
    {
        NSSetUncaughtExceptionHandler(&amp;amp;uncaughtExceptionHandler);
        [Flurry startSession:@&amp;quot;YOUR_API_KEY&amp;quot;];
        // ....
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;隔栏&#34;&gt;隔栏&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456801568.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;隔栏是防御式编程中的一种容损策略，举个例子，大家可以这样来理解：&lt;/p&gt;
&lt;p&gt;船体外壳上装备隔离舱，如果船只与冰山相撞导致船体破裂，隔离舱就会被封闭起来，从而保护船体的其余部分不会受到影响。&lt;br&gt;
&lt;p&gt;（&lt;code&gt;隔栏&lt;/code&gt;过去叫&lt;code&gt;防火墙&lt;/code&gt;，但现在&lt;code&gt;防火墙&lt;/code&gt;这一术语常用来代指阻止恶意网络攻击）&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456820092.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;5毛钱特效&lt;/code&gt;翻译过来就是：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608457186869.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;左侧外部接口数据假定是肮脏的不可信的，中间这些类（子程序）构成&lt;code&gt;隔栏&lt;/code&gt;，负责清理和验证数据并返回可信的数据，最右侧的类（子程序）全部在假定数据干净（安全）的基础上工作，这样可以让大部分的代码无须再担负检查错误数据的职责！&lt;/p&gt;
&lt;p&gt;这种策略可以拟一个比较生动的例子，可以看做是手术室里使用的一种策略。&lt;br&gt;
&lt;p&gt;任何东西在允许进入手术室之前都要经过消毒处理，因此手术室里的任何东西都可以认为是安全的。这其中最核心的设计决策是&lt;code&gt;规定什么可以进入手术室，什么不可以，还有把手术室的门设在哪里&lt;/code&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;在编程中也是如此，约定哪些子程序可认为是在安全区域里的，哪些又是在安全区域外的，哪些负责清理数据（完成这一工作最简单的方法是在得到外部数据时，立即进行清理，不过数据往往需要经过一层以上的清理，因此多层清理有时也是必须的）&lt;/p&gt;
&lt;p&gt;隔栏的应用：&lt;br&gt;
&lt;p&gt;隔栏的使用使断言和错误处理有了清晰的区分，隔栏外部的程序应该使用错误处理技术，在那里对数据做的任何处理假定都是不安全的。而隔栏内部的程序里就应该使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。如果隔栏内部的子程序检测到了错误的数据，那么应该是程序里的错误而不是程序外的错误。&lt;/p&gt;&lt;/p&gt;
&lt;h2 id=&#34;辅助调试代码&#34;&gt;辅助调试代码&lt;/h2&gt;
&lt;p&gt;防御式编程的另一重要方面就是使用调试助手（辅助调试代码），调试助手非常之强大👍，可以帮助我们快速检查错误。&lt;/p&gt;
&lt;p&gt;应用在开发期间应牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具。&lt;/p&gt;
&lt;h4&gt; 1、应尽早的引入辅助调试代码&lt;/h4&gt;
&lt;p&gt;越早进入辅助调试代码，它能够提供的帮助也越大。如果你经常遇到某些问题，尝试自己编写或引入一些&lt;code&gt;辅助调试代码&lt;/code&gt;，它就会自始至终在项目中帮助你。&lt;/p&gt;
&lt;h4&gt; 2、采用进攻式编程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456836309.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;什么又是进攻式编程，其实这也是防御式编程中的一种习惯，其思想在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量让异常的情况在开发期间暴露出来，而在产品上线时自我恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如你有一段switch case语句用来处理事件，在开发期间应尽量考虑所有你能预料得到的情况并作出处理，另外在default case语句中，如果是开发阶段可以采用&lt;code&gt;进攻式编程处理&lt;/code&gt;，而在产品正式上线期间，针对default case应更稳妥一些，比如记录错误日志。&lt;/p&gt;
&lt;p&gt;下面列举一下进攻式编程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保断言语句使程序终止运行&lt;/li&gt;
&lt;li&gt;完全填充分配到的所有内存&lt;/li&gt;
&lt;li&gt;完全填充己分配到的所有文件或流&lt;/li&gt;
&lt;li&gt;确保每一个case 语句中的default分支或else 分支都能产生严重错误（如终止程序）&lt;/li&gt;
&lt;li&gt;在删除一个对象之前把它填满垃圾数据&lt;/li&gt;
&lt;li&gt;让程序将错误日志主动用电子邮件或推送发送给开发者（安防目前采用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt; 3、计划移除调试辅助的代码&lt;/h4&gt;
&lt;p&gt;如果是商用软件，调试用的代码有时会使软件的体积变大且速度变慢，从而给程序造成巨大的性能影响。要事先做好准备计划，避免调试用的代码和程序原代码纠缠不清，下面列举一些可以选择的移除方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用类似ant和make这样的版本控制工具&lt;/p&gt;
&lt;p&gt;（可以从同一套源码编译出不同版本的程序。在开发模式下，你可以让make工具把所有的调试代码都包含进来一起编译。而在产品上线期间，把那些调试代码排除在外。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用内置的预处理器（&lt;code&gt;C++ #字符为预处理器指令，包含#if、#warning、#include、#define等&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;（如果你所用的编程环境里有预处理器，你可以用预处理器来包含或排除调试的代码）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- (void)handleSomething {
    
#ifdef DEBUG
    
    [self debugF];//通常为一些debug用的耗时操作
#else
    
    [self releaseF];
#endif
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为应用增加调试模式的入口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的应用需要同时支持两种模式（发布和调试），那么我们可以自定义进入调试模式的入口，而不是针对编译层次的DEBUG，我们的调试代码的嵌入也依赖于这个调试模式是否开启，下面将演示安防app内定义的调试模式。&lt;/p&gt;
&lt;h2 id=&#34;对防御式编程采取防御的姿态&#34;&gt;对防御式编程采取防御的姿态&lt;/h2&gt;
&lt;p&gt;说了这么多，那么是不是防御式代码越多越好呢？&lt;/p&gt;
&lt;p&gt;其实也不是，多度的防御式编程也会引起问题，如果你在每一个能想到的地方都用每一种能想到的方法来检查参数、处理错误，那么你的程序会变得臃肿而缓慢，更糟的事，多度的防御式代码换来的是软件的复杂度。&lt;/p&gt;
&lt;p&gt;这说明，防御式编程引入的代码也并非不会有缺陷，和其他代码一样，你同样能轻而易举的在防御式编程添加的代码中找到错误，尤其是当你随手编写这些代时更是如此。&lt;/p&gt;
&lt;p&gt;因此，要考虑好什么地方需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序代码中对错误处理的方式远比&lt;code&gt;GIGO&lt;/code&gt;复杂的多。&lt;/li&gt;
&lt;li&gt;防御式编程技术可以让错误更容易发现问题、更容易修改，并减少错误对产品代码的破坏。&lt;/li&gt;
&lt;li&gt;遵从防御式编程的思想去开发，会让你在开发阶段就提前处理了许多问题，提高代码质量，降低测试周期，要做到主动去发现错误并做出处理（&lt;strong&gt;千万不要存侥幸心理，明明可以多考虑几种情况，偏偏却要忽略它们的可能性&lt;/strong&gt;），而不是等到bug隐式的出现所带来的未曾预料的灾难。&lt;/li&gt;
&lt;li&gt;错误处理技术更适用于暴露的接口程序或类，而断言则更强调不可允许的错误，多适用于不暴露在外的私有方法（或内部类）。&lt;/li&gt;
&lt;li&gt;处理错误最恰当的方式是要根据程序软件的类别而定，更倾向于&lt;strong&gt;正确性&lt;/strong&gt;还是&lt;strong&gt;健壮性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;异常提供了一种与代码正常流程角度不同的错误处理手段，但同时也应该在异常和其他错误处理手段之间进行权衡比较，比如iOS中就很少采用异常处理机制。&lt;/li&gt;
&lt;li&gt;合理的运用辅助调试代码，会让你不管是在开发还是发布阶段都能更快速定位问题，并从容地解决问题。（预处理器就是个很好的选择）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，我对于防御式编程的理解是，我认为程序的好坏与其健壮性（和正确性）有很大的联系，所有的程序开发人员都要对它有足够的重视，主动去迎战错误，从一点一滴开始做起，不要忽视任何的细节，不能盲目依赖测试去发现bug，而是以测试驱动编程，不断地思考可能发生的问题以进行预防，做一个聪明的程序员。这才是防御式编程所告诉我们的事 ！&lt;/p&gt;
&lt;h2 id=&#34;推荐&#34;&gt;推荐&lt;/h2&gt;
&lt;p&gt;最后列举一下文中出现的引用来源及一些推荐看的文章或书籍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《代码大全第2版》第八章防御式编程&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1yfmqkf84CJ6Zpbj4-_TlUQ&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;《Writing Solid Code》断言的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1DYNOJrl7AJLhlRCY4gCnDQ&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;《Object-Oriented Software Construction》中有关于契约式设计的前置条件、后置条件、不变式的权威概述。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nshipster.cn/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;苹果对于Exception Handling介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.jianshu.com/p/34f1dfa3aa8e&#34;&gt;https://www.jianshu.com/p/34f1dfa3aa8e&lt;/a&gt;&lt;/p&gt;
">防御式编程（Defensive Programming）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-18-完全小白教程：使用Coding Pages和Gridea搭建个人博客/"" data-c="
          &lt;div class=&#34;RichText ztext Post-RichText&#34;&gt;&lt;p&gt;2020/07/14更新&lt;/p&gt;&lt;p&gt;如果严格按照教程步骤操作了，还是出现远程连接失败的问题，可以尝试修改仓库名，例如我的仓库名叫myblog，在Gridea配置里，把仓库名设为myblog/myblog。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_b.png&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;778&#34; data-rawheight=&#34;85&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;778&#34; data-original=&#34;https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;hr&gt;&lt;p&gt;上一篇文章写了使用Github Pages和Gridea来搭建个人博客：&lt;/p&gt;&lt;a target=&#34;_blank&#34; href=&#34;https://zhuanlan.zhihu.com/p/165948546&#34; data-draft-node=&#34;block&#34; data-draft-type=&#34;link-card&#34; data-image=&#34;https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg&#34; data-image-width=&#34;1280&#34; data-image-height=&#34;720&#34; class=&#34;LinkCard LinkCard--hasImage&#34; data-za-detail-view-id=&#34;172&#34;&gt;&lt;span class=&#34;LinkCard-backdrop&#34; style=&#34;background-image:url(https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg)&#34;&gt;&lt;/span&gt;&lt;span class=&#34;LinkCard-content&#34;&gt;&lt;span class=&#34;LinkCard-text&#34;&gt;&lt;span class=&#34;LinkCard-title&#34; data-text=&#34;true&#34;&gt;海边的卡夫卡：完全小白教程：使用Github Pages和Gridea搭建个人博客&lt;/span&gt;&lt;span class=&#34;LinkCard-meta&#34;&gt;&lt;span style=&#34;display:inline-flex;align-items:center&#34;&gt;&amp;#8203;&lt;svg class=&#34;Zi Zi--InsertLink&#34; fill=&#34;currentColor&#34; viewBox=&#34;0 0 24 24&#34; width=&#34;17&#34; height=&#34;17&#34;&gt;&lt;path d=&#34;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/span&gt;zhuanlan.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;LinkCard-imageCell&#34;&gt;&lt;img class=&#34;LinkCard-image LinkCard-image--horizontal&#34; alt=&#34;图标&#34; src=&#34;https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;但Github毕竟是国外的服务器，访问速度很慢，如果你只是想要在国内访问你的博客，你完全可以使用国内的&lt;b&gt;Coding Pages&lt;/b&gt;来代替Github Pages。&lt;/p&gt;&lt;h2&gt;1 Coding Pages开通&lt;/h2&gt;&lt;h3&gt;1.1 Coding账号注册&lt;/h3&gt;&lt;p&gt;原来的Coding个人版合并到团队版了，所以这里我详细说下Coding的注册。&lt;/p&gt;&lt;p&gt;进入&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//e.coding.net/signup%3F_ga%3D2.238701378.316970461.1592676170-1921038398.1592620024&#34; class=&#34; wrap external&#34; target=&#34;_blank&#34; rel=&#34;nofollow noreferrer&#34;&gt;注册页面&lt;/a&gt;，创建新团队，这个团队名称要记住，后面要用到，然后创建用户，完成注册。&lt;/p&gt;&lt;h3&gt;1.2 创建项目&lt;/h3&gt;&lt;p&gt;登录后，点击项目，发现只有一个示例项目，我们新建一个项目。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;939&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_r.jpg&#34;/&gt;
&lt;/figure&gt;&lt;p&gt;选择第一个——代码托管项目。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1550&#34; data-rawheight=&#34;689&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1550&#34; data-original=&#34;https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;然后填写项目名称，往下拉点完成创建。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1049&#34; data-rawheight=&#34;766&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1049&#34; data-original=&#34;https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;创建后是这样的，点左下角的项目设置。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点功能开关，把&lt;b&gt;持续集成&lt;/b&gt;和&lt;b&gt;持续部署&lt;/b&gt;开关打开。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;进入代码仓库，如果还没有初始化，就先初始化仓库，勾选那个readme，就可以初始化了。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1917&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1917&#34; data-original=&#34;https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h3&gt;1.3 实名认证&lt;/h3&gt;&lt;p&gt;点网页左上角猴子的图标回主页，点左下角团队设置。团队所有者在【团队管理】-&amp;gt;【团队设置】-&amp;gt;【实名认证】，可进行团队实名认证。实名认证后，团队将可以使用 Pages 部署等产品功能。&lt;/p&gt;&lt;h3&gt;1.4 使用静态网站服务&lt;/h3&gt;&lt;p&gt;回到myblog项目，点【持续部署】-&amp;gt;【静态网站】-&amp;gt;【立即发布静态网站】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1916&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1916&#34; data-original=&#34;https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;名称还是叫myblog吧，保存。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1916&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1916&#34; data-original=&#34;https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;这里就是你的博客访问地址了（我的有两个，是因为我已经绑定域名了），不过现在点开，会显示404，别急嘛。点右上角的设置，来绑定域名，毕竟他给的这个网址好难记QAQ&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点了设置后，往下拉，绑定域名，保存修改。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1622&#34; data-rawheight=&#34;517&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1622&#34; data-original=&#34;https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h3&gt;1.5 生成令牌&lt;/h3&gt;&lt;p&gt;右上角头像点开，点【个人设置】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;458&#34; data-rawheight=&#34;347&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;458&#34; data-original=&#34;https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点【访问令牌】-&amp;gt;【新建令牌】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1403&#34; data-rawheight=&#34;625&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1403&#34; data-original=&#34;https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;你可以把权限都勾上，然后点【创建令牌】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1237&#34; data-rawheight=&#34;910&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1237&#34; data-original=&#34;https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点这个图标复制令牌，另外你的令牌用户名也是后面要用到的。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1097&#34; data-rawheight=&#34;262&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1097&#34; data-original=&#34;https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h2&gt;2 Gridea远程部署&lt;/h2&gt;&lt;p&gt;Gridea下载请参考我上一篇文章，运行Gridea，配置。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1484&#34; data-rawheight=&#34;992&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1484&#34; data-original=&#34;https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;blockquote&gt;如果你没有绑定域名，就填他提供给你的网址，CNAME就不填。&lt;br&gt;仓库用户名为你的&lt;b&gt;团队名&lt;/b&gt;。&lt;/blockquote&gt;&lt;p&gt;保存后，点检测远程连接，如果没有问题就可以同步了。&lt;/p&gt;&lt;p&gt;OK，可以正常访问了~&lt;/p&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://zhuanlan.zhihu.com/p/166114376&#34;&gt;https://zhuanlan.zhihu.com/p/166114376&lt;/a&gt;&lt;/p&gt;
">完全小白教程：使用Coding Pages和Gridea搭建个人博客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-18-基于Gridea+github搭建静态博客/"" data-c="
          &lt;div class=&#34;text &#34;&gt;
                &lt;h3 id=&#34;写在开头&#34;&gt;写在开头&lt;/h3&gt;
&lt;p&gt;为什么要写这篇博客呢，因为Gridea目前还处于未被发现的阶段，使用的用户很少。官方的文档里是使用视频进行介绍，配置过程中反复回调进度条比较麻烦，因此撰写该文章方便新加入的用户学习经验。同时将一些可能出现的问题总结在文章中，防止大家踩坑~&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;前提&#34;&gt;前提&lt;/h3&gt;
&lt;p&gt;拥有一个Github账号 / 拥有一个Coding账号（如果没有请前往注册）&lt;br&gt;
Github地址：https://github.com/&lt;br&gt;
Coding地址：https://coding.net/&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;1下载安装git工具&#34;&gt;1.下载安装Git工具&lt;/h3&gt;
&lt;p&gt;该工具的用处本文不作介绍，毕竟是个“程序员”都知道。&lt;br&gt;
下载地址：Git下载&lt;br&gt;
选择适合自己的电脑版本下载安装即可。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;2gridea下载安装&#34;&gt;2.Gridea下载安装&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/1.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
选择适合自己的版本下载安装即可。&lt;br&gt;
安装完后打开软件，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/2.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
PS：这也是我为啥放弃hexo转用Gridea的原因，颜值高，还有专门的桌面端软件配套使用。另外平心而论，Gridea配置起来比hexo简单很多。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;3github静态pages配置&#34;&gt;3.GitHub静态Pages配置&lt;/h3&gt;
&lt;p&gt;(1)进入Github新建一个仓库。&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/3.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
其中用户名尽量和Owner名字保持一致（不然可能会出现问题）&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
(2)新建完仓库后，访问 https:// + 你仓库的名字，如下图&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/4.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
如果访问404失败便是配置出现问题，请仔细查看自己的步骤。如果显示出来一个几乎空白的页面便是成功。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
(3)打开个人设置&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/5.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/6.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/7.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/8.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/8.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
接下来会生成一串密钥，请把它们保存到一个文档里（因为之后可能就会找不到了）&lt;br&gt;
接下来就基本OK啦，开始最终配置&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/9.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
当上方显示远程连接成功后，保存配置。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
然后点击左侧同步。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
接下来重新访问 用户名.github.io&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/10.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/10.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;4-coding静态页面配置&#34;&gt;4. Coding静态页面配置&lt;/h3&gt;
&lt;p&gt;为什么还需要配置Coding呢？&lt;br&gt;
答：Coding和Github属于两个托管平台。即以上步骤便已经算配置好你的个人博客了。那为什么还需要如下步骤呢？第一.存储在两个平台较为安全 第二.Github静态页面访问起来速度较慢，同时会被一些搜索引擎屏蔽掉，即你的博客无法被百度搜到，写的文章只能自娱自乐。&lt;br&gt;
ps:经过了以上步骤，这里我们快速讲解。大同小异。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
首先在个人设置里修改自己的用户名（仅针对于刚刚注册的用户）&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/11.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/11.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
由于Coding平台版本更新，曾经的配置方法部分失效。&lt;br&gt;
建议借鉴该文章：&lt;br&gt;
&lt;a href=&#34;http://liyuanbo.top/post/grideacoding-page-ge-ren-wang-zhan-da-jian/&#34;&gt;Gridea+Coding Page个人网站搭建&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;可能出现的问题&#34;&gt;可能出现的问题&lt;/h3&gt;
&lt;p&gt;1.在点击检测远程连接时，总是失败，但是自己步骤都做了。&lt;br&gt;
答：检查自己是否成功安装Git。&lt;br&gt;
2.Gridea软件&lt;br&gt;
如果安装在其他文件夹时，请务必修改设置。&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/12.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/12.png&#34; style=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://ericam.top/post/ji-yu-grideagithubcoding-da-jian-ge-ren-jing-tai-bo-ke/&#34;&gt;https://ericam.top/post/ji-yu-grideagithubcoding-da-jian-ge-ren-jing-tai-bo-ke/&lt;/a&gt;&lt;/p&gt;
">基于Gridea+github搭建静态博客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-11-09-论文转述 Design Pattern Implementation in Java and AspectJ/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/74c24bb20c5d42869f844b9f2f1e154c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;摘要&#34;&gt;摘要&lt;/h1&gt;
&lt;h1 id=&#34;二-既定挑战&#34;&gt;二、既定挑战&lt;/h1&gt;
&lt;p&gt;许多作者已经确定了当模式在特定的软件系统中具体化时会出现的挑战。其中，三个最重要的挑战与实现、文档和组合有关。&lt;/p&gt;
&lt;p&gt;设计模式的实现通常有许多不良的相关影响。因为模式影响系统结构，并且它们的实现也受到系统结构的影响，所以模式实现通常是根据使用情况定制的。这可能导致它们“消失在代码中”，并失去模块化。这使得很难区分模式、具体实例和涉及的对象模型。在系统中添加或移除模式通常是一种侵入性的、难以逆转的改变。&lt;strong&gt;因此，虽然设计模式是可重用的，但它的实现通常不是&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模式代码的侵入性，以及它与其他代码的分散和纠缠造成了文档问题。如果在一个系统中使用了多个模式，跟踪一个设计模式的特定实例会变得很困难，尤其是当类涉及到多个模式时(即，如果有模式覆盖/组合)。&lt;/p&gt;
&lt;p&gt;模式组合导致的不仅仅是文档问题。对包含相同类的多个模式的系统进行推理本来就很困难，因为这种组合会产生大量相互依赖的类。这是一个重要的主题，因为一些设计模式在他们的解决方案中显式地使用其他模式。&lt;/p&gt;
&lt;h1 id=&#34;三-研究格式&#34;&gt;三、研究格式&lt;/h1&gt;
&lt;p&gt;本文中的发现是基于对GoF设计模式的Java和AspectJ实现的比较分析。&lt;/p&gt;
&lt;p&gt;对于23种GoF模式中的每一种，我们都创建了一个利用该模式的小示例，并在Java和AspectJ中实现了该示例（&lt;a href=&#34;http://www.cs.ubc.ca/labs/spl/projects/aodps.html&#34;&gt;代码下载[已失效]&lt;/a&gt;）。Java实现对应于GoF书中的示例C++实现，并做了一些小的调整，以解决C++和Java之间的差异(缺乏多重继承等)。大多数模式都有许多实现变体和替代方案。如果一个模式提供了不止一个可能的实现，我们选择一个看起来最普遍适用的。&lt;/p&gt;
&lt;p&gt;AspectJ实现是迭代开发的。AspectJ结构允许许多不同的实现，通常有不同的权衡。我们的目标是充分研究每个模式的明确定义的实现的设计空间。我们最终总共创建了57个不同的实现，每个模式从1到7个不等。第4节讨论了一些权衡和设计决策。&lt;/p&gt;
&lt;h1 id=&#34;四-结果&#34;&gt;四、结果&lt;/h1&gt;
&lt;p&gt;本节介绍了GoF设计模式的具体实例的AspectJ和Java实现的比较。第4.1节详细讨论了观察者模式。我们使用这个讨论来呈现大多数AspectJ解决方案共有的属性。其余的模式是基于第4.1节中的概念提出的。&lt;/p&gt;
&lt;h2 id=&#34;41-例子-观察者模式&#34;&gt;4.1 例子: 观察者模式&lt;/h2&gt;
&lt;p&gt;观察者模式的意图是“在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有从属对象都会被自动通知和更新”。观察者模式的面向对象实现，比如GoF书(第300-303页)中的示例代码，通常向所有潜在的主题添加一个字段，存储对该特定主题感兴趣的观察者列表。当一个主体想要向它的观察者报告状态改变时，它调用它自己的通知方法，该方法又调用列表中所有观察者的更新方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/79c76dde9f844d689e4171f3532faffe~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;考虑一个简单图形包中观察者模式的具体例子，如图1所示。在这样的系统中，观察者模式将被用来使图形元素的突变操作更新屏幕。如图所示，实现这种模式的代码分布在各个类中。&lt;/p&gt;
&lt;p&gt;所有参与者(即点和线)必须知道他们在模式中的角色，并因此拥有模式代码。从类中添加或删除角色需要更改该类。改变通知机制(例如在推和拉模型之间切换[9])需要改变所有参与的类。&lt;/p&gt;
&lt;h3 id=&#34;411-抽象的观察者模式&#34;&gt;4.1.1 抽象的观察者模式&lt;/h3&gt;
&lt;p&gt;在观察者模式的结构中，一些部分是模式的所有潜在实例化所共有的，而其他部分是每个实例化所特有的。所有实例共有的部分是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主体和观察者角色的存在(即有些类作为观察者，有些作为主体)。&lt;/li&gt;
&lt;li&gt;维护从受试者到观察者的映射。&lt;/li&gt;
&lt;li&gt;一般更新逻辑:主题更改触发观察者更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;模式的每个实例化的特定部分是:&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;哪些课可以是主题，哪些可以是观察者。&lt;/li&gt;
&lt;li&gt;引发观察者更新的一组感兴趣的主题变化&lt;/li&gt;
&lt;li&gt;当更新逻辑需要时，更新每种观察者的具体方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e973ed1a3bdd48dd86f594112908369f~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们开发了AspectJ代码，它反映了可重用部分和实例特定部分的分离。抽象方面封装了可概括的部分(1-3)，而模式的每个实例的方面的一个具体扩展填充了特定的部分(4-6)。图2显示了可重用的ObserverProtocol方面。&lt;/p&gt;
&lt;h4 id=&#34;4111-主体和观察者的角色&#34;&gt;4.1.1.1 主体和观察者的角色&lt;/h4&gt;
&lt;p&gt;角色被实现为名为主题和观察者的受保护的内部接口(图2，第3-4行)。它们的主要目的是允许在模式实现的上下文中正确地输入主题和观察者，比如在像addObserver这样的方法中。ObserverProtocol方面的具体扩展将角色分配给特定的类(见下文)。&lt;/p&gt;
&lt;p&gt;这些接口是受保护的，因为它们将只由ObserverProtocol及其具体扩展使用。方面和扩展之外的任何代码都不需要根据这些角色来处理对象。&lt;/p&gt;
&lt;p&gt;这些接口是空的，因为模式没有定义主题或观察者角色的方法。通常在主体和观察者上定义的方法是在方面本身上定义的(见下文)。&lt;/p&gt;
&lt;p&gt;对于可抽象的模式，我们必须决定将角色接口放在哪里。两个位置是可能的:要么作为抽象方面内部的私有接口，要么作为单独的公共接口。我们是根据角色接口是否引入了客户端访问的功能来做出这个决定的，即向客户端公开功能(如策略、迭代器等)或者不公开(如观察者的情况)。如果角色没有客户端可访问的功能，它将只在模式方面被引用。因为这个原因，我们把它放在抽象方面。在另一种情况下，我们将接口移动到一个单独的文件中，以便于引用。&lt;/p&gt;
&lt;h4 id=&#34;4112-主体-观察者映射&#34;&gt;4.1.1.2 主体-观察者映射&lt;/h4&gt;
&lt;p&gt;AspectJ代码中映射的实现被本地化为ObserverProtocol方面。它是通过使用链表的弱散列映射来存储每个主题的观察者来实现的(第6行)。由于每个模式实例都由ObserverProtocol的一个具体子方面表示，因此每个实例都有自己的映射。&lt;/p&gt;
&lt;p&gt;对主题-观察者映射的改变可以通过具体子方面继承的公共的添加观察者和移除观察者方法(第21-26行)来实现。为了让屏幕对象成为点对象的观察者，客户在适当的子方面调用这些方法(例如颜色观察者):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ColorObserving.aspectOf().addObserver(P, S); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私有的getObservers方法只在内部使用。它按需创建适当的二级数据结构(链表)(第8-19行)。请注意，在这个实现中，主题-观察者映射数据结构集中在每个具体的扩展中。对抽象模式方面进行子类化的所有具体方面都将自动拥有一个单独的字段副本。这遵循[9]中给出的结构。这在某些情况下会造成瓶颈。通过用一种使用更分散的数据结构的方法覆盖getObservers，可以在每个模式实例的基础上修复这些问题。&lt;/p&gt;
&lt;p&gt;一般来说，只要模式解决方案需要参与者之间的映射(即责任链中处理程序的后继字段)，并且模式实现是可抽象的，我们就可以在参与者上定义一个字段，或者将映射保留在抽象方面的中心数据结构中(如本例所示)。无论选择哪种方法，对数据结构的访问点都是特定于实例的方面，这样涉及相同参与者的模式的不同实例都是可能的，并且不会混淆。&lt;/p&gt;
&lt;h4 id=&#34;4113-更新逻辑&#34;&gt;4.1.1.3 更新逻辑&lt;/h4&gt;
&lt;p&gt;在可重用方面，更新逻辑实现了一个一般概念，即主题可以以需要更新所有观察者的方式进行更改。这个实现并没有精确地定义什么构成了一个改变，或者观察者应该如何被更新。一般更新逻辑由三部分组成:&lt;/p&gt;
&lt;p&gt;感兴趣的变化描述了概念操作，即程序执行中的一组点，在这些点上，主体应该更新其观察者(以通知他们其状态的变化)。在AspectJ中，这类点的集合用切入点构造来标识。在可重用方面，我们只知道有感兴趣的修改，但我们不知道它们是什么。因此，我们定义了一个名为subjectChange的抽象切入点，它将被实例特定的子方面具体化(第28-29行)。&lt;/p&gt;
&lt;p&gt;在可重用部分，我们只知道观察者必须在模式的上下文中更新，但是不能预测如何最好地实现。我们定义了一个抽象的更新方法updateObserver，它将为每个模式实例具体化(第31-32行)。这样，观察者模式的每个实例都可以选择自己的更新机制。&lt;/p&gt;
&lt;p&gt;最后，可重用方面根据上面提到的可推广的实现部分来实现更新逻辑。这个逻辑包含在后一条建议中(第34-39行)。这个建议是这样的:每当执行到达一个与主题匹配的连接点时，改变切入点，然后更新适当主题的所有观察者。&lt;/p&gt;
&lt;h3 id=&#34;412-特定于模式实例的具体方面&#34;&gt;4.1.2 特定于模式实例的具体方面&lt;/h3&gt;
&lt;p&gt;ObserverProtocol的每个具体子方面定义了一种特定的观察关系，换句话说就是一个模式实例。在这种关系中，可以有任意数量的主体，每个主体有任意数量的观察者。子方面定义了三件事:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扮演受试者和观察者角色的分类。这是通过使用declare parents构造来完成的，该构造将超类或超接口添加到类中，以分配抽象方面中定义的角色。&lt;/li&gt;
&lt;li&gt;需要更新观察者的关于该主题的概念性操作。这是通过具体化subjectChange切入点来实现的。&lt;/li&gt;
&lt;li&gt;如何更新观察者？这是通过具体化updateObserver来实现的。更新的推或拉模式之间的选择不再是必要的，因为此时我们可以访问主题和观察者，并且可以定制更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;declare parents构造是AspectJ开放类机制的一部分，它允许方面修改现有的类而不改变它们的代码。这种开放的类机制可以将字段、方法或者——在这种情况下——接口附加到现有的类上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/913640c699a8455988c17999d6cd7f25~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图3显示了观察者模式的两个不同实例，包括点、线和屏幕类。在这两种情况下，点和线扮演主体的角色，屏幕扮演观察者的角色。第一个观察颜色变化，第二个观察坐标变化。&lt;/p&gt;
&lt;p&gt;请注意，第13行和第31行中的类型转换预计会随着AspectJ对泛型的计划支持而消失。这样就有可能创建包含角色分配并且类型安全的参数化子方面。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/c5396bacab2a489f851b5925364d7ec6~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;特定的类可以在同一个模式实例或不同的模式实例中扮演一个或两个主体和观察者的角色。图4显示了第三个模式实例，其中屏幕同时充当主体和观察者。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/a123.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在AspectJ版本中，与观察者和主题之间的关系相关的所有代码都被移动到一个方面中，这改变了模块之间的依赖关系。图5显示了这种情况的结构。&lt;/p&gt;
&lt;h3 id=&#34;413-此实现的属性&#34;&gt;4.1.3 此实现的属性&lt;/h3&gt;
&lt;p&gt;观察者模式的这种实现具有以下密切相关的模块化属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部性——实现观察者模式的所有代码都在抽象和具体的观察者方面，没有一个在参与者类中。参与者类完全不受模式上下文的约束，因此参与者之间没有耦合。每个观察者模式实例的潜在变化被限制在一个地方。&lt;/li&gt;
&lt;li&gt;可重用性——核心模式代码是抽象的和可重用的。ObserverProtocol的实现概括了整个模式行为。抽象方面可以在多个观察者模式实例中重用和共享。对于每个模式实例，我们只需要定义一个具体的方面。&lt;/li&gt;
&lt;li&gt;合成透明性——因为模式参与者的实现与模式无关，如果一个主体或观察者参与多个观察关系，他们的代码不会变得更复杂，模式实例也不会混淆。该模式的每个实例都可以独立推理。&lt;/li&gt;
&lt;li&gt;(不)可插入性——因为主体和观察者不需要知道他们在任何模式实例中的角色，所以可以在系统中使用模式和不使用模式之间切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-其他模式&#34;&gt;4.2 其他模式&lt;/h2&gt;
&lt;p&gt;在下文中，我们将描述剩余的22种GoF模式，以及AspectJ实现与纯Java版本的不同之处。模式按共同特征分组，无论是模式结构还是它们的AspectJ实现。&lt;/p&gt;
&lt;h3 id=&#34;421-复合-命令-中介-责任链角色仅用于模式方面&#34;&gt;4.2.1 复合、命令、中介、责任链：角色仅用于模式方面&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6777d81cba204229b0863e0bd56dbdd7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;类似于观察者模式，这些模式引入了&lt;strong&gt;不需要客户端可访问接口的角色&lt;/strong&gt;，并且只在模式中使用。在AspectJ中，这样的角色是用空的(受保护的)接口实现的。它们引入的类型在模式协议中使用。每个模式的一个抽象方面定义了角色，并在可能的情况下附加了默认实现(参见图6的部分抽象组合方面)。&lt;/p&gt;
&lt;p&gt;对于涉及特定概念操作的模式，抽象模式方面引入了一个抽象切入点(为模式的每个实例具体化)，它捕获应该触发重要事件的连接点(例如命令模式中命令的执行)。就像在观察者的例子中一样，建议(在之后、之前或周围)负责调用适当的方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f8a70c3386784d638547cc4ba22ba0ff~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在复合情况下，为了允许遍历模式固有的树结构，我们定义了让访问者遍历和/或改变结构的工具。这些来访者是在具体方面定义的。有关如何从组合结构中收集统计数据的示例，请参见图7。在这个例子中，我们展示了一个为文件系统建模的复合模式的实例。目录是复合的，文件是叶。该示例显示了如何计算文件系统所需的磁盘空间，假设文件对象具有大小字段。同样，客户端使用方面的公共方法来访问新功能。参与者的适当方法是私下介绍的，只能通过方面看到。&lt;/p&gt;
&lt;h3 id=&#34;422-单例模式-原型模式-备忘录模式-迭代器模式-享元模式作为对象工厂的方面&#34;&gt;4.2.2 单例模式、原型模式、备忘录模式、迭代器模式、享元模式：作为对象工厂的方面&lt;/h3&gt;
&lt;p&gt;这些模式管理对特定对象实例的访问。它们都向客户提供工厂方法，并共享按需创建策略。模式在AspectJ中是抽象的(可重用的)，在Aspect中有工厂代码。&lt;/p&gt;
&lt;p&gt;在AspectJ实现中，工厂方法要么是抽象Aspect的参数化方法，要么附加到参与者的方法中。如果使用前一种方法，模式的多个实例透明地组成，即使所有的工厂方法都有相同的名称。&lt;strong&gt;单例&lt;/strong&gt;的情况很特殊，因为我们可以使用“环绕”建议将原始构造函数转换为工厂方法，并在所有构造函数调用中返回唯一的对象。&lt;/p&gt;
&lt;p&gt;参数化的工厂方法也可以根据诺德伯格的工厂示例[18]来实现：工厂方法为空(返回null或默认对象)。其他返回值由该方法的Advice提供。如果参数合适，Advice创建一个新的匹配对象；否则，它将继续正常执行。这使得我们可以在不改变代码的情况下扩展工厂(就新产品而言)。参与者不再需要有模式代码；原始对象和它的表示或访问器(纪念品，迭代器)之间的紧密耦合将从参与者中移除。&lt;/p&gt;
&lt;h3 id=&#34;423-适配器-装饰器-策略-访问者-代理语言结构&#34;&gt;4.2.3 适配器、装饰器、策略、访问者、代理：语言结构&lt;/h3&gt;
&lt;p&gt;使用AspectJ，一些模式的实现完全消失了，因为AspectJ语言构造直接实现了它们。这在不同程度上适用于这些模式。&lt;/p&gt;
&lt;p&gt;适配器和访问者模式可以通过扩展适配器的接口来实现(通过AspectJ的开放类机制)。装饰器、策略和代理有基于附加建议的替代实现(在[18]中为装饰器提到)。&lt;/p&gt;
&lt;p&gt;虽然更简单、更模块化，但这些方法有其固有的局限性。Decorator基于建议的实现失去了它的动态操作属性(Decorator的动态重新排序)，因此不太灵活。当我们想用另一个具有相同名称和参数但返回类型不同的方法替换现有方法时，适配器的接口扩展不能以这种方式实现。&lt;/p&gt;
&lt;p&gt;使用上述方法，保护或委托代理可以实现为可重用的，但是代理模式的一些应用程序要求代理和主体是两个不同的对象(例如远程代理和虚拟代理)。在这些情况下，Java和AspectJ实现是相同的。&lt;/p&gt;
&lt;h3 id=&#34;424-抽象工厂模式工厂方法模式模板模式建造者模式桥接模式多重继承&#34;&gt;4.2.4 抽象工厂模式，工厂方法模式，模板模式，建造者模式，桥接模式：多重继承&lt;/h3&gt;
&lt;p&gt;这些模式在结构上是相似的：继承用于区分不同但相关的实现。因为这已经在面向对象中很好地实现了，所以这些模式不能被给予更多可重用的实现。然而，使用AspectJ，可以用接口替换GoF解决方案中提到的抽象类，而不会失去将(默认)实现附加到它们的方法的能力。对于Java，如果我们想为模式代码中的方法定义一个默认实现，我们就不能使用接口。在这方面，AspectJ的开放类机制有效地提供了一种有限形式的多重继承。&lt;/p&gt;
&lt;p&gt;除此之外，建造者模式和桥接模式还有以下额外的实现注意事项。&lt;br&gt;
对于建造者模式，一个Aspect可以拦截对创建方法的调用，并使用Advice用替代实现来替换它们(参见上面的策略)。&lt;br&gt;
对于桥接模式，抽象和实现者的解耦可以通过使用诺德伯格建议的多态Advice来实现[24]。虽然这种方法减少了参与者之间的耦合，但是当涉及到动态改变实现者时，它就不那么灵活了。&lt;/p&gt;
&lt;h3 id=&#34;426-外观模式没有从aspectj中获益&#34;&gt;4.2.6 外观模式：没有从AspectJ中获益&lt;/h3&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;p&gt;对于这种模式，AspectJ方法在结构上与Java实现没有什么不同。Façade为子系统的一组接口提供了统一的接口，使子系统更易于使用。这个例子主要需要名字空间管理和良好的编码风格。&lt;/p&gt;
&lt;h1 id=&#34;五-分析&#34;&gt;五、分析&lt;/h1&gt;
&lt;p&gt;在这一节中，我们分析了之前观察到的用AspectJ实现模式的好处。分析分为三个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在许多模式重新实现中观察到的一般改进。&lt;/li&gt;
&lt;li&gt;与特定模式相关的具体改进。&lt;/li&gt;
&lt;li&gt;模式中横切结构的起源，以及观察到的改进与模式中横切结构的存在相关的演示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;51-总体改进&#34;&gt;5.1 总体改进&lt;/h2&gt;
&lt;p&gt;对于许多模式来说，AspectJ实现体现了几个密切相关的模块化好处:局部性、可重用性、依赖性反转、透明的可组合性和(不)可插入性。试图说哪一个是主要的是困难的，相反，我们简单地描述它们并讨论它们的一些相互关系。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/68d760a110a5407aa036ad77a1225b0d~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;23个GoF模式中的17个的AspectJ实现是本地化的。对于其中的12个，局部性使得实现的核心部分能够被抽象成可重用的代码。在17个中的14个中，我们观察到了模式实例的透明可组合性，因此多个模式可以有共享的参与者(见表1)。&lt;/p&gt;
&lt;p&gt;AspectJ实现的改进主要是由于颠倒了依赖性，因此模式代码依赖于参与者，而不是相反。这与局部性直接相关——模式和参与者之间的所有依赖都被本地化在模式代码中。&lt;/p&gt;
&lt;h2 id=&#34;52-具体改进&#34;&gt;5.2 具体改进&lt;/h2&gt;
&lt;h3 id=&#34;521-单例模式&#34;&gt;5.2.1 单例模式&lt;/h3&gt;
&lt;p&gt;模式实现的AspectJ版本打开了两个在Java中不可能的设计选项：&lt;br&gt;
第一，Singleton是继承属性，还是说，我们存在错误的继承？&lt;br&gt;
第二，我们是希望一个专门的工厂方法来提供单例模式的实例，还是希望构造函数在被调用时返回它？&lt;/p&gt;
&lt;p&gt;我们决定实现继承的Singleton属性，但是如果需要的话，我们提供了从Singleton保护中排除特定子类的工具。&lt;/p&gt;
&lt;p&gt;第二，我们认为使用构造函数而不是专用的工厂方法是有益的。如果需要，工厂可以直接在类中实现，或者作为一个透明组合的Aspect来实现。&lt;/p&gt;
&lt;h3 id=&#34;522-多重继承与java&#34;&gt;5.2.2 多重继承与Java&lt;/h3&gt;
&lt;p&gt;正如最初提出的，一些GoF模式在其实现中利用了多重继承，例如适配器模式的类版本。对于许多模式，参与者在模式中扮演的角色在Java中被实现为抽象类。参与者类从这些抽象类继承接口和默认实现。但是如果参与者类具有模式上下文之外的功能(比如作为观察者模式中的主体或观察者的图形用户界面小部件)，它们通常已经是继承层次的一部分。由于Java缺乏多重继承，在这些情况下的实现可能有些笨拙：在Java中，如果参与者必须继承其角色和其他功能，那么其中一个超类型必须实现为接口。不幸的是，Java中的接口不能包含代码，因此无法附加方法的默认实现。&lt;/p&gt;
&lt;p&gt;AspectJ中的开放类机制为我们提供了一种更灵活的方式来实现这些模式，因为它允许将接口和实现(代码)都附加到现有的类上。&lt;/p&gt;
&lt;h3 id=&#34;523-打破循环依赖&#34;&gt;5.2.3 打破循环依赖&lt;/h3&gt;
&lt;p&gt;一些设计模式管理对象集合之间复杂的交互。在面向对象的实现中，这些类紧密耦合并且相互依赖。引入循环依赖的设计模式的一个例子是中介器，它是在用户界面编程中经常使用的观察者模式的变体。在这里，对同事(如小部件)的更改会触发中介对象(如控制器)的更新。另一方面，作为对此的反应，调解人可能会更新一些或所有同事。&lt;/p&gt;
&lt;h2 id=&#34;53-设计模式的横切结构&#34;&gt;5.3 设计模式的横切结构&lt;/h2&gt;
&lt;p&gt;本节介绍了模式中横切结构的起源，并展示了在模式实现中使用AspectJ的观察到的好处与模式中的横切相关。角色定义了模式中参与者的行为和功能。这种角色的例子有:复合模式的组件、叶和复合，观察者模式的主题和观察者，或者抽象工厂模式的抽象和具体工厂。模式结构中的横切是由不同类型的角色及其与参与者类的交互引起的。&lt;/p&gt;
&lt;p&gt;在一些模式中，角色是定义的：参与者在模式之外没有功能。也就是角色完整的定义了参与者。例如，扮演门面角色的对象为子系统提供统一的接口，并且(通常)没有自己的其他行为。定义角色通常包括客户端可访问的界面。&lt;/p&gt;
&lt;p&gt;在其他模式中，角色是重叠的:它们被分配给在模式之外有功能和责任的类。例如，在观察者模式中，扮演主体和观察者的类不仅仅满足模式要求。例如，在图形用户界面环境中，主题可以是小部件。换句话说，在观察者模式上下文之外有行为的类。因此，主体角色只是现有类的扩充。叠加角色通常没有客户端可访问的界面。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，定义角色往往是通过子类化一个抽象超类来实现不同但相关的行为；叠加的角色通常是定义行为和责任的接口。&lt;/p&gt;
&lt;p&gt;Java中有一个不一致的地方，叠加角色上的方法可能只供模式使用，但是它们必须在接口上定义，这要求它们是公共的。&lt;/p&gt;
&lt;h3 id=&#34;531-角色和横切&#34;&gt;5.3.1 角色和横切&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/4e2f42fcd41c4494a60e89c4af6a5722~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;叠加的角色导致模式和参与者之间三种不同的横切:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;角色可以横切参与者类。即对于1个角色，可以有n个类，1个类可以有n个角色；即如图5所示的主题角色。&lt;/li&gt;
&lt;li&gt;感兴趣的概念操作可以横切一个或多个类中的方法。即一个概念操作可以有n个方法，n个概念操作中可以有1个方法；即触发观察者更新的主题变更操作，如图5所示。&lt;/li&gt;
&lt;li&gt;来自多个模式的角色可以在类和/或方法方面相互横切。也就是说，模式A认为是一个角色的一部分的两个类，模式B可能认为是一个以上的角色，反之亦然。概念操作也是如此；即主体角色和主体变更操作，如图9所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表1显示了模式引入的角色类型和AspectJ实现的观察到的好处之间的关系。设计模式可以分为三类:只有定义角色的，有两种角色的和只有叠加角色的。该表显示，虽然第一组中模式的AspectJ实现没有显示出任何改进，但最后一组中的模式显示出我们确定的所有模块化优势类别的改进。对于具有两种角色的模式，结果取决于特定的模式。&lt;/p&gt;
&lt;p&gt;鉴于AspectJ旨在模块化横切结构，这一结果并不奇怪。主要涉及横切结构的模式在AspectJ实现中被很好地模块化了。&lt;br&gt;
（请注意，AspectJ没有移除模式的横切，而是提供了模块化该结构的机制。）&lt;/p&gt;
&lt;h3 id=&#34;532-预测模型&#34;&gt;5.3.2 预测模型？&lt;/h3&gt;
&lt;p&gt;模式角色之间的紧密联系，模式引入的横切，以及观察到的AspectJ实现的好处，暗示了给定设计模式的AspectJ实现的好处的预测模型。&lt;/p&gt;
&lt;p&gt;通过定义角色，每个抽象单元(类)代表一个单一的概念，即一个类的功能对应于它在模式中的角色。继承用于区分相关但不同的实现。在这种情况下，透明性和可插入性并不是有用的属性，因为每个参与者本质上都只在一个特定的模式实例中有用。&lt;/p&gt;
&lt;p&gt;有叠加行为，情况就不一样了。参与者在模式环境之外有自己的责任和理由。如果我们强迫一个这样的类进入模式上下文，我们至少有两个由一个抽象模块(类)表示的关注点:原始功能和模式特定的行为。由于模块化受到损害，由此产生的混乱和代码重复经常会导致问题。对于这些模式和它们的实现，模式功能和参与者的原始功能的干净模块化是合乎需要的。在AspectJ实现中，通常可以模块化抽象的模式行为，并让每个模式实例有一个方面来分配角色、概念操作和填充实例特定的代码。因为参与者在模式上下文之外确实有一个意义，所以他们并不局限于一个角色或者一个模式实例。&lt;/p&gt;
&lt;p&gt;这个模型对于那些只有定义或只有叠加角色的GoF模式来说似乎是准确的。对其他人来说，预期的好处似乎取决于实现特定角色的参与者的数量。映射到多个参与者的叠加角色(例如，访问者中的元素、组合或组合中的叶)表明了模块化的潜力，即使模式也包括定义角色。&lt;/p&gt;
&lt;h1 id=&#34;七-总结&#34;&gt;七、总结&lt;/h1&gt;
&lt;p&gt;在模式实现中使用AspectJ的改进与模式中&lt;strong&gt;横切结构&lt;/strong&gt;的存在直接相关。这种横切结构出现在将行为叠加到参与者身上的模式中。在这种模式中，角色可以横切参与者类，概念操作可以横切方法(和构造函数)。就共享参与者而言，多个这样的模式也可以相互横切。&lt;/p&gt;
&lt;p&gt;这些改进表现为一组与模块化相关的属性。模式实现更加本地化，并且在很多情况下是可重用的。因为AspectJ解决方案更好地将代码中的依赖与解决方案结构中的依赖联系起来，所以模式的AspectJ实现有时也是可组合的。&lt;/p&gt;
&lt;p&gt;本地化模式实现提供了内在的代码可理解性优势——模式代码的单个命名单元的存在使得模式的存在和结构更加明确。此外，它还为改进代码文档提供了一个锚。&lt;/p&gt;
&lt;p&gt;我们的结果为进一步的实验提出了几个方向，包括将AspectJ应用于更多的模式，试图系统地使用我们的可重用模式实现，以及试图在已知受设计模式思维影响的遗留代码库中使用AspectJ。未来工作的另一个途径是将这些结果与其他定向技术的使用进行比较。&lt;/p&gt;
">论文转述 Design Pattern Implementation in Java and AspectJ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-09-06-SpringBoot jar包运行报错/"" data-c="
          &lt;p&gt;报错信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication
        at com.MainApplication.main(MainApplication.java:10)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 1 more
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;生成jar&#34;&gt;生成jar&lt;/h1&gt;
&lt;p&gt;首先，如果使用的是maven，那么直接执行package指令就可以生成jar包，如下图：&lt;br&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/149a1061ed2c4c5e922605fd60aae2a2~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是，当我们使用&lt;code&gt;java -jar xx.jar&lt;/code&gt;运行时，会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication
        at com.MainApplication.main(MainApplication.java:10)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 1 more
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大概的意思就是缺少依赖。&lt;/p&gt;
&lt;h1 id=&#34;解决jar包依赖问题&#34;&gt;解决jar包依赖问题&lt;/h1&gt;
&lt;p&gt;通过修改pom文件，解决依赖问题。&lt;/p&gt;
&lt;p&gt;在pom文件中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重新打包(package)即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;，随着IDEA的升级，现在开始出现了一个新的标签&lt;code&gt;pluginManagement&lt;/code&gt;，在这个标签里，也同样有&lt;code&gt;plugins&lt;/code&gt;标签，但千万不要把&lt;code&gt;pluginManagement&lt;/code&gt;中的&lt;code&gt;plugins&lt;/code&gt;当成上文中出现的&lt;code&gt;plugins&lt;/code&gt;标签，即下面的写法是错误的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
	&amp;lt;pluginManagement&amp;gt;
	    &amp;lt;plugins&amp;gt;
	        &amp;lt;plugin&amp;gt;
	            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
	        &amp;lt;/plugin&amp;gt;
	    &amp;lt;/plugins&amp;gt;
	&amp;lt;/pluginManagement&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot jar包运行报错</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-07-28-Go cannot find package google.golang.orgprotobuf 解决办法/"" data-c="
          &lt;p&gt;使用Go语言开发时，出现访问Google有些包无法下载问题，解决方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Go的root目录，src下创建文件夹“src\google.golang.org”&lt;/li&gt;
&lt;li&gt;在google.golang.org文件夹中，执行如下代码&lt;code&gt;git clone https://github.com/protocolbuffers/protobuf-go.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将生成的文件夹重命名为protobuf，如下图&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/17394d7e05d34455&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Go cannot find package google.golang.orgprotobuf 解决办法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-07-28-Go语言的反射/"" data-c="
          &lt;p&gt;反射是语言里面非常重要的一个特性，我们经常会看见这个词，但是对于反射没有一个很好的理解，主要是因为对于反射的使用场景不太熟悉。&lt;/p&gt;
&lt;h1 id=&#34;一-理解变量的内在机制&#34;&gt;一、理解变量的内在机制&lt;/h1&gt;
&lt;p&gt;1.类型信息，元信息，是预先定义好的，静态的。&lt;/p&gt;
&lt;p&gt;2.值信息，程序进行过程中，动态变化的。&lt;/p&gt;
&lt;h1 id=&#34;二-反射和空接口&#34;&gt;二、反射和空接口&lt;/h1&gt;
&lt;p&gt;1.空接口相当于一个容器，能接受任何东西。&lt;/p&gt;
&lt;p&gt;2.那怎么判断空接口变量存储的是什么类型呢？之前有使用过类型断言，这只是一个比较基础的方法&lt;/p&gt;
&lt;p&gt;3.如果想获取存储变量的类型信息和值信息就要使用反射机制，所以反射是什么？ 反射就是动态的获取变量类型信息和值信息的机制。&lt;/p&gt;
&lt;h1 id=&#34;三-怎么利用反射分析空接口里面的信息呢&#34;&gt;三、怎么利用反射分析空接口里面的信息呢？&lt;/h1&gt;
&lt;p&gt;①首先利用的是GO语言里面的Reflect包&lt;/p&gt;
&lt;p&gt;②利用包里的TypeOf方法可以获取变量的类型信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflect_typeof(a interface{}) {
    t := reflect.TypeOf(a)
    fmt.Printf(&amp;quot;type of a is:%v\n&amp;quot;, t)
 
    k := t.Kind()
    switch k {
    case reflect.Int64:
        fmt.Printf(&amp;quot;a is int64\n&amp;quot;)
    case reflect.String:
        fmt.Printf(&amp;quot;a is string\n&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用Kind() 可以获取t的类型，如代码所示，这里可以判断a是Int64还是string, 像下面一样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x int64 = 3
    reflect_example(x)
 
    var y string = &amp;quot;hello&amp;quot;
    reflect_example(y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type of a is:int64
a is int64
type of a is:string
a is string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③利用包里的ValueOf方法可以获取变量的值信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflect_value(a interface{}) {
    v := reflect.ValueOf(a)
    k := v.Kind()
    switch k {
    case reflect.Int64:
        fmt.Printf(&amp;quot;a is Int64, store value is:%d\n&amp;quot;, v.Int())
    case reflect.String:
        fmt.Printf(&amp;quot;a is String, store value is:%s\n&amp;quot;, v.String())
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用ValueOf方法可以得到变量的值信息,ValueOf返回的是一个Value结构体类型，有趣的是 可以使用 v.Type() 获取该变量的类型，和上面reflect.TypeOf() 获取的结果一样。&lt;/p&gt;
&lt;p&gt;此外，因为值信息是动态的，所以我们不仅仅可以获取这个变量的类型，还能取得这个变量里面存储的值，利用 v.Int() 、 v.String() 等等就能取得值。如上面的main，调用此函数返回的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a is Int64, store value is:3
a is String, store value is:hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里存在一个问题，如果传进去一个类型，使用了错误的解析，那么将会在运行的时候报错， 例如将  一个string类型强行的v.Int()。&lt;/p&gt;
&lt;p&gt;既然值类型是动态的，能取到保存的值，同样可以设置值。在反射里面有很多set的方法，例如SetFloat、SetInt()、SetString()等可以帮助我们设置值。&lt;/p&gt;
&lt;p&gt;① 下面的例子，我想把 x设置为 6.28，但是会报错！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(x)
    v.SetFloat(6.28)
    fmt.Printf(&amp;quot;After Set Value is %f&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;panic: reflect: reflect.Value.SetFloat using unaddressable value
......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果上说明是不可设置的，为什么呢？ 因为我们的x是一个值类型，而值类型的传递是拷贝了一个副本，当 v := reflect.ValueOf(x) 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 v = reflect.ValueOf(&amp;amp;x)。修改程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    v.SetFloat(6.28)
    fmt.Printf(&amp;quot;After Set Value is %f&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：依然报错！为什么传了地址还报错？因为&amp;amp;x是地址了，所以它的类型就变了，可以通过v.Type()，看下改变成了什么：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    fmt.Printf(&amp;quot;type of v is %v&amp;quot;, v.Type())   //打印的结果是：type of v is *float64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由程序可以知道，这个返回的是一个指针类型的。所以上面SetFloat才会失败，那怎么做？&lt;/p&gt;
&lt;p&gt;我们正常的赋值，如果是地址的话，例如下面：一般我们都会对*y进行赋值, *的意思就是往这个地址里面赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var y *float64 = new(float64)
*y = 10.12
fmt.Printf(&amp;quot;y = %v&amp;quot;, *y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的，我们在反射里面也可以取地址，需要通过 Elem() 方法进行取地址。再次修改程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    fmt.Printf(&amp;quot;type of v is %v\n&amp;quot;, v.Type())
    v.Elem().SetFloat(6.28)
    fmt.Printf(&amp;quot;After set x is %v&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type of v is *float64
After set x is 6.28
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-利用反射获取结构体里面的方法和调用&#34;&gt;四、利用反射获取结构体里面的方法和调用。&lt;/h1&gt;
&lt;h2 id=&#34;1获取结构体的字段&#34;&gt;1.获取结构体的字段&lt;/h2&gt;
&lt;p&gt;我们可以通过上面的方法判断一个变量是不是结构体。&lt;/p&gt;
&lt;p&gt;可以通过 NumField() 获取所有结构体字段的数目、进而遍历，通过Field()方法获取字段的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
    Name  string
    Sex   int
    Age   int
    Score float32
}
 
func main() {
    //创建一个结构体变量
    var s Student = Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(s)
    t := v.Type()
    kind := t.Kind()
     
    //分析s变量的类型，如果是结构体类型，那么遍历所有的字段
    switch kind {
    case reflect.Int64:
        fmt.Printf(&amp;quot;s is int64\n&amp;quot;)
    case reflect.Float32:
        fmt.Printf(&amp;quot;s is int64\n&amp;quot;)
    case reflect.Struct:
        fmt.Printf(&amp;quot;s is struct\n&amp;quot;)
        fmt.Printf(&amp;quot;field num of s is %d\n&amp;quot;, v.NumField())
        //NumFiled()获取字段数，v.Field(i)可以取得下标位置的字段信息，返回的是一个Value类型的值
        for i := 0; i &amp;lt; v.NumField(); i++ {
            field := v.Field(i)
            //打印字段的名称、类型以及值
            fmt.Printf(&amp;quot;name:%s type:%v value:%v\n&amp;quot;,
                t.Field(i).Name, field.Type().Kind(), field.Interface())
        }
    default:
        fmt.Printf(&amp;quot;default\n&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s is struct
field num of s is 4
name:Name type:string value:BigOrange
name:Sex type:int value:1
name:Age type:int value:10
name:Score type:float32 value:80.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要说明几个问题：&lt;/p&gt;
&lt;p&gt;①打印字段名称的时候，使用的是t.Field(i).Name ，Name是静态的，所以属于类型的信息&lt;/p&gt;
&lt;p&gt;②打印值的时候，这里将field.Interface()实际上相当于ValueOf的反操作（&lt;a href=&#34;https://www.cnblogs.com/baicaiyoudu/archive/2016/09/25/5905766.html&#34;&gt;可以参考这篇文章&lt;/a&gt;），所以才能把值打印出来&lt;/p&gt;
&lt;p&gt;③此外如果Student中的Name字段变为name（私有），那么则会报错，不能反射出私有变量 错误信息 &lt;code&gt;panic: reflect.Value.Interface: cannot return value obtained from unexported field or method&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2对结构体内的字段进行赋值操作&#34;&gt;2.对结构体内的字段进行赋值操作&lt;/h2&gt;
&lt;p&gt;参考下面的代码，对上面的Student进行赋值操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    fmt.Printf(&amp;quot;Name:%v, Sex:%v,Age:%v,Score:%v \n&amp;quot;, s.Name, s.Sex, s.Age, s.Score)
    v := reflect.ValueOf(&amp;amp;s)  //这里传的是地址！！！
 
    v.Elem().Field(0).SetString(&amp;quot;ChangeName&amp;quot;)
    v.Elem().FieldByName(&amp;quot;Score&amp;quot;).SetFloat(99.9)
 
    fmt.Printf(&amp;quot;Name:%v, Sex:%v,Age:%v,Score:%v \n&amp;quot;, s.Name, s.Sex, s.Age, s.Score)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name:BigOrange, Sex:1,Age:10,Score:80.1
Name:ChangeName, Sex:1,Age:10,Score:99.9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3获取结构体里面的方法&#34;&gt;3.获取结构体里面的方法&lt;/h2&gt;
&lt;p&gt;可以通过NumMethod()获得接头体里面的方法数量，然后遍历通过Method()获取方法的具体信息。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//新增-设置名称方法
func (s *Student) SetName(name string) {
     fmt.Printf(&amp;quot;有参数方法 通过反射进行调用:%v\n&amp;quot;, s)
     s.Name = name
}
//新增-打印信息方法
func (s *Student) PrintStudent() {
    fmt.Printf(&amp;quot;无参数方法 通过反射进行调用:%v\n&amp;quot;, s)
}
 
func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(&amp;amp;s)
    //取得Type信息
    t := v.Type()
     
    fmt.Printf(&amp;quot;struct student have %d methods\n&amp;quot;, t.NumMethod())
 
    for i := 0; i &amp;lt; t.NumMethod(); i++ {
        method := t.Method(i)
        fmt.Printf(&amp;quot;struct %d method, name:%s type:%v\n&amp;quot;, i, method.Name, method.Type)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct student have 2 methods
struct 0 method, name:PrintStudent type:func(*main.Student)
struct 1 method, name:SetName type:func(*main.Student, string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果中看到我们可以获取方法的名称以及签名信息，并且这个方法的输出顺序是按照字母排列的。&lt;/p&gt;
&lt;p&gt;并且输出结果可以看到一个有趣的现象：结构体的方法其实也是通过函数实现的例如 func(s Student) SetName(name string) 这个方法，反射之后的结果就是 func(main.Student , string) 实际上把Student当参数了。&lt;/p&gt;
&lt;p&gt;此外还可以通过反射来调用这些方法。想要通过反射调用结构体里面的方法，首先要知道方法调用时一个动态的，所以要先通过ValueOf获取值，然后通过获取的值进行方法的调用 ，通过 value里面的Method方法 返回一个方法，然后通过Call方法调用，Call是参数是一个切片，也就是参数的列表。以下是Call方法的定义：可以看到参数是一个Value的数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/31c638c8e4c94fb8b9ddea294a80f9a5~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如下代码展示了如何调用有参数的方法和无参数的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(&amp;amp;s)
 
    //通过reflect.Value获取对应的方法并调用
    m1 := v.MethodByName(&amp;quot;PrintStudent&amp;quot;)
    var args []reflect.Value
    m1.Call(args)
 
    m2 := v.MethodByName(&amp;quot;SetName&amp;quot;)
    var args2 []reflect.Value
    name := &amp;quot;stu01&amp;quot;
    nameVal := reflect.ValueOf(name)
    args2 = append(args2, nameVal)
    m2.Call(args2)
    m1.Call(args)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;BigOrange&amp;quot;, Sex:1, Age:10, Score:80.1}
有参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;BigOrange&amp;quot;, Sex:1, Age:10, Score:80.1}
无参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;stu01&amp;quot;, Sex:1, Age:10, Score:80.1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面格式打印：&lt;/p&gt;
&lt;p&gt;%v      相应值的默认格式。            Printf(&amp;quot;%v&amp;quot;, people)   {zhangsan}，&lt;/p&gt;
&lt;p&gt;%+v     打印结构体时，会添加字段名     Printf(&amp;quot;%+v&amp;quot;, people)  {Name:zhangsan}&lt;/p&gt;
&lt;p&gt;%#v     相应值的Go语法表示            Printf(&amp;quot;#v&amp;quot;, people)   main.Human{Name:&amp;quot;zhangsan&amp;quot;}&lt;/p&gt;
&lt;h1 id=&#34;五-怎么获取结构体里tag的信息&#34;&gt;五、怎么获取结构体里tag的信息。&lt;/h1&gt;
&lt;p&gt;有时候我们在类型上面定义一些tag，例如使用json和数据库的时候。Field()方法返回的StructField结构体中保存着Tag信息，并且Tag信息可以通过一个Get(Key)的方法获取出来，如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
    Name string `json:&amp;quot;jsName&amp;quot; db:&amp;quot;dbName&amp;quot;`
}
 
func main() {
    s := Student{
        Name: &amp;quot;BigOrange&amp;quot;,
    }
    v := reflect.ValueOf(&amp;amp;s)
    t := v.Type()
    field0 := t.Elem().Field(0)
    fmt.Printf(&amp;quot;tag json=%s\n&amp;quot;, field0.Tag.Get(&amp;quot;json&amp;quot;))
    fmt.Printf(&amp;quot;tag db=%s\n&amp;quot;, field0.Tag.Get(&amp;quot;db&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tag json=jsName
tag db=dbName
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-应用场景&#34;&gt;六、应用场景&lt;/h1&gt;
&lt;p&gt;1.序列化和反序列化，比如json, protobuf等各种数据协议&lt;/p&gt;
&lt;p&gt;2.各种数据库的ORM，比如gorm，sqlx等数据库中间件&lt;/p&gt;
&lt;p&gt;3.配置文件解析相关的库，比如yaml、ini等&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from https://www.cnblogs.com/dcz2015/p/11199060.html&lt;/p&gt;
">Go语言的反射</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>




<script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script>

</html>