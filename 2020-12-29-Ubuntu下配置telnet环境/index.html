<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Bule-Zst个人博客">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>Ubuntu下配置telnet环境 | Bule-Zst</title>
<link rel="shortcut icon" href="/favicon.ico?v=1642069768421">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      displayMath: [['$$', '$$'], ["\\[", "\\]"]]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a', 'annotation', 'annotation-xml'],
      ignoreHtmlClass: 'tex2jax_ignore|crayon-.*', // 'crayon-' 开头的类，属于Wordpress代码高亮库，这部分不需要处理，否则会导致显示不正确,这部分是正则式，多条之间用'|'分割
      processHtmlClass: 'tex2jax_process'
    },
    //禁用右键菜单	
    renderActions: {
      addMenu: [0, '', '']
    }
  };
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?52033379f884b28a50e8ebc12b7743f9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="Ubuntu下配置telnet环境" />
  <meta name="keywords" content="Linux" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Bule-Zst</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Bule-Zst</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">50</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">34</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">34</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="http://Bule-Zst.gitee.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/Bule-Zst">
              <i class="fa fa-github" title="Github"></i>
            </a>
          
            <a href="/media/images/QQ.png">
              <i class="fa fa-qq" title="QQ"></i>
            </a>
          
            <a href="/media/images/WeChat.png">
              <i class="fa fa-weixin" title="WeChat"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/">
      Ubuntu下配置telnet环境
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-12-29 18:12:33">2020-12-29</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="http://Bule-Zst.gitee.io/Linux/">
        <span>Linux</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>230<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/2020-12-29-Ubuntu下配置telnet环境/" data-flag-title="Ubuntu下配置telnet环境" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>1、首先查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出为空，表示没有开启该服务</p>
<p>2、安装openbsd-inetd</p>
<p><code>apt-get install openbsd-inetd</code></p>
<p>如果已经安装过了，会提示已经安装过了，直接执行下面的步骤就可以了。</p>
<p>3、安装telnetd</p>
<p><code>apt-get install telnetd</code></p>
<p>安装完之后，查看/etc/inetd.conf的内容会多了一行telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p><code>cat /etc/inetd.conf | grep telnet</code></p>
<p>输出： telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p>4、重启openbsd-inetd</p>
<p><code>/etc/init.d/openbsd-inetd restart</code></p>
<p>输出：* Restarting internet superserver inetd</p>
<p>5、查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出：tcp　　0　　0 :telnet　　😗　　LISTEN</p>
<p>此时表明已经开启了telnet服务。</p>
<p>6、telnet登陆测试</p>
<p><code>telnet 127.0.0.1</code></p>
<p>输出： Trying 127.0.0.1… Connected to 127.0.0.1. Escape character is ‘^]’. （停在这里的时候要按Ctrl+] 然后回车）</p>
<p>telnet&gt; （表示登陆成功）</p>
<hr>
<p>from <a href="https://www.cnblogs.com/taomylife/p/7552424.html">https://www.cnblogs.com/taomylife/p/7552424.html</a></p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Bule-Zst
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/" title="Ubuntu下配置telnet环境">http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="http://Bule-Zst.gitee.io/Linux/"># Linux</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="LeetCode 410. 分割数组的最大值" href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/">LeetCode 410. 分割数组的最大值</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="LeetCode 410. 分割数组的最大值" href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="算法题精选" href="http://Bule-Zst.gitee.io/2020-12-26-算法题精选/">算法题精选</a>
        <a class="nav-mobile-next" title="算法题精选" href="http://Bule-Zst.gitee.io/2020-12-26-算法题精选/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'icyVx6by4LtMh3OUkAxAV9Td-gzGzoHsz',
    appKey: 'BjJojXprANUbtBlAXlKTqVD6',
    avatar: 'mp',
    placeholder: '填上邮箱可以收到我的回复哦 (*^ω^*)~~\n请尽量7点-23点给我评论哦~',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'false',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: -10px;bottom: -23px;"
    data-key="65029773e7e94d1986196a5c0a08cb91">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录与春招相关的一些内容，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明年3月份春招（暑期实习）的备战计划&lt;/li&gt;
&lt;li&gt;春招过程中需要注意的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;备战阶段&#34;&gt;备战阶段&lt;/h2&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java技术栈+计算机基础+算法+项目+加分项（竞赛/开源项目/博客）&lt;/p&gt;
&lt;p&gt;大公司更看重基础知识（八股文），小公司更看中现有能力&lt;/p&gt;
&lt;p&gt;边面试边准备，不要等完全准备好再去面试&lt;/p&gt;
&lt;h3 id=&#34;笔试算法&#34;&gt;笔试（算法）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/cat/&#34;&gt;lintcode CAT模式 天梯上分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codetop.cc/home&#34;&gt;CodeTop 汇总互联网大厂面试的高频考题 帮助面试者更有针对性地准备面试&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;可直接定位特定公司、部门的面试题&lt;/li&gt;
&lt;li&gt;学长学姐都比较推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/study/live/489/1/1&#34;&gt;左神算法笔面试真题精讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/exam-bytedance&#34;&gt;牛客网 名企编程真题&lt;/a&gt;（企业真题可以多刷刷头条 网易 拼多多）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/coding-interviews&#34;&gt;牛客网 剑指offer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/leetcode&#34;&gt;牛客网 经典必刷编程题库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/ta/job-code-high&#34;&gt;牛客网 名企高频面试题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problem-list/2cktkvj/&#34;&gt;LeetCode 热题 HOT 100 官方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problem-list/2ckc81c/&#34;&gt;LeetCode 精选 TOP 面试题 官方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/158977583&#34;&gt;leetcode 精选 by sergio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yuque.com/office/yuque/0/2020/pdf/619289/1605766958275-87ed48a3-0a68-4433-9d3c-b4ea9c829ccb.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fshenjingwa-o51xg%2Fyh6opc%2Fsqqfew%2Fedit&#34;&gt;leetcode 精选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/24964987/answer/182447205&#34;&gt;lintcode 精选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.changgy.com/leetcode-101&#34;&gt;LeetCode 101：和你一起你轻松刷题（C++）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cyc2018.xyz/#%E7%AE%97%E6%B3%95&#34;&gt;Cyc2018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面试题java技术栈计算机基础&#34;&gt;面试题（Java技术栈+计算机基础）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;刷面经！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;备战阶段，就不要去看书或者视频了，书和视频都是用来系统学习知识的，备战阶段要的就是突击！应试！直接刷 &lt;strong&gt;面试题&lt;/strong&gt; 就好~&lt;/p&gt;
&lt;h4 id=&#34;面经&#34;&gt;面经&lt;/h4&gt;
&lt;p&gt;面试题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;&#34;&gt;自己的春招面经 待补充&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.toutiao.com/i6862994550059696654/?tt_from=weixin&amp;amp;utm_campaign=client_share&amp;amp;wxshare_count=1&amp;amp;timestamp=1599958973&amp;amp;app=news_article&amp;amp;utm_source=weixin&amp;amp;utm_medium=toutiao_android&amp;amp;use_new_style=1&amp;amp;req_id=2020091309025201014708310411A6D669&amp;amp;group_id=6862994550059696654&amp;amp;wid=1639135144091&#34;&gt;字节&lt;/a&gt; （后面的广告，直接忽略即可）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/438229187&#34;&gt;字节2&lt;/a&gt; （后面的广告，直接忽略即可）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/293661?from=zhnkw&#34;&gt;合集&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/i29juUTnfOKZQIeY08l4RA&#34;&gt;其他&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/762719?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;合集 南大 22届 硕 Java后端&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/629687?source_id=profile_create_nctrack&amp;amp;channel=-1&#34;&gt;微软+蚂蚁 南大 22届 硕 Java后端 实习面经&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/802981?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=2&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;合集&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cxy师兄-面经.docx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pan.baidu.com/s/1yCCeNMb0FNCJKDIE6EASYA#list/path=%2F&#34;&gt;大厂面经合集：美团、腾讯、字节、虾皮 各方向都有&lt;/a&gt; 提取码【lrp3】 解压码【jk7z】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/172152&#34;&gt;合集 C++ 基础架构方向&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;心路历程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/56655579&#34;&gt;cyc2018大佬的面经&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/762719?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;南大 22届 硕 Java后端&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;八股文&#34;&gt;八股文&lt;/h4&gt;
&lt;p&gt;第一遍刷，抓大放小&lt;/p&gt;
&lt;p&gt;要形成自己的八股文文档，方便后期复习&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://bule-zst.gitee.io/2021-09-30-JavaHan/&#34;&gt;JavaHan&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cyc2018.github.io/CS-Notes/#/&#34;&gt;JavaCyc&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整理了&lt;a href=&#34;http://www.cyc2018.xyz/&#34;&gt;cyc2018&lt;/a&gt;各部分内容pdf版的页数，方便做计划&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211221102750329.png&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://passjava.cn/#/88.Interview/01.Redis/Redis1&#34;&gt;PassJava-面试必备&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cosen1024/Java-Interview&#34;&gt;「Java面试小抄」一份通向理想互联网公司的面试指南，包括 Java基础、集合、Java并发、JVM、MySQL、Redis、Spring、MyBatis、Kafka、操作系统、计算机网络、系统设计、分布式、Java 项目实战等 by 库森&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/column/c_1339954942191271936&#34;&gt;大厂面试 by 程序员库森&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/820419?type=all&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTraceId=&amp;amp;channel=-1&amp;amp;source_id=search_all_nctrack&amp;amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652&#34;&gt;对线面试官系列之Java集合--面试官看了都说好&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面内容主要整理了需要掌握的知识点，但是没有答案，可以先看上面的内容，下面的查缺补漏时用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/discuss/61438?from=zhnkw&#34;&gt;JAVA后端秋招/春招准备方向&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/359264954&#34;&gt;2021春招Java后端开发面试总结【25个技术专题】超详细！&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;项目&#34;&gt;项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;对实习项目的描述还不够好，没有把实习内容的闪光点描述出来，也没有讲清楚为什么做这个项目，自己通过什么方法去做，以及最后的结果&lt;/p&gt;
&lt;p&gt;cyc2018面经 https://zhuanlan.zhihu.com/p/56655579&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何描述自己的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://www.cnblogs.com/JavaArchitect/p/7586949.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;要素&lt;/th&gt;
&lt;th&gt;样式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。&lt;/td&gt;
&lt;td&gt;我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到 JS 等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。&lt;/td&gt;
&lt;td&gt;我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;描述你在项目里的角色&lt;/td&gt;
&lt;td&gt;我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。&lt;/td&gt;
&lt;td&gt;用到了Java里面的集合，JDBC等技术，用到了Spring MVC等框架，用技术连接数据库。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;（这部分的风险自己承担）如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。&lt;/td&gt;
&lt;td&gt;这个系统是部署在 Linux 上的，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;要避免的情况&lt;/th&gt;
&lt;th&gt;正确的做法&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;回答很简单。问什么答什么，往往就用一句话回答&lt;/td&gt;
&lt;td&gt;把你知道的都说出来，重点突出你知道的思想，框架&lt;/td&gt;
&lt;td&gt;问：你SSH用过吗？答：用过。问：在什么项目里用到？答：一个保险项目问：你做了哪方面的事情？答：开发。面试官直接不问了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;说得太流利&lt;/td&gt;
&lt;td&gt;适当停顿，边思考边说&lt;/td&gt;
&lt;td&gt;让面试官感觉你在背准备的东西，这样后面问题就很难&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目介绍时什么都说&lt;/td&gt;
&lt;td&gt;就说些刚才让准备的一些，而且要有逻辑地说&lt;/td&gt;
&lt;td&gt;会让面试官感觉你思路太乱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过多介绍技术细节&lt;/td&gt;
&lt;td&gt;相关技术点到为止，就说你熟悉的技术，等面试官来问&lt;/td&gt;
&lt;td&gt;你说到的所有技术要点，都可能会被深问。面试官一般会有自己的面试节奏，如果你在介绍时就太多说技术细节，很有可能被打断，从而没法说出你准备好的亮点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里只列出了部分，具体内容可以看链接，感觉写的挺好的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/121136858&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何介绍自己的项目：STAR法则（背景+目标+行动+结果）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景+目标：要做什么&lt;/li&gt;
&lt;li&gt;项目整体功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行动：干了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简短&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责的模块&lt;/li&gt;
&lt;li&gt;担任的角色与职责&lt;/li&gt;
&lt;li&gt;所用的技术点
&lt;ul&gt;
&lt;li&gt;用了什么技术，同类型的技术有哪些，有什么区别，为什么选择这个&lt;/li&gt;
&lt;li&gt;介绍时，只需要提用了什么技术，但是后面 3 个问题需要提前准备，防止面试官问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;详细&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难点是什么（不知道如何实现 或者 实现后出现了bug）&lt;/li&gt;
&lt;li&gt;亮点是什么&lt;/li&gt;
&lt;li&gt;技术点：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目性能、项目成果&lt;/li&gt;
&lt;li&gt;对项目的&lt;strong&gt;思考&lt;/strong&gt;（优化点和不足）以及&lt;strong&gt;收获&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;智力题&#34;&gt;智力题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;智力题（或者叫，逻辑思维题、脑筋急转弯），需要提前准备一下&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简历&#34;&gt;简历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;专业技能，注明熟练度：熟悉、熟练掌握、精通&lt;/li&gt;
&lt;li&gt;不要罗列技术，而是突出，自己通过 XX 技术实现了什么&lt;/li&gt;
&lt;li&gt;简历命名：姓名+学校+岗位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/zvideo/1289637611880026112?utm_source=qq&amp;amp;utm_medium=social&amp;amp;utm_oi=747689983887814656&#34;&gt;建议收藏！小白简历这样改，一秒成为优秀简历！秋招必备，让你offer拿到手软！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU2OTY4Nzk1Mw==&amp;amp;mid=2247485451&amp;amp;idx=1&amp;amp;sn=6a722f682d1df07404cc79b5aaf41a87&amp;amp;chksm=fcfba2f5cb8c2be30908bc0bf2146c8203d4f055780d6b64d9b2e5570d96b5b0bfae9d872432&amp;amp;scene=21#wechat_redirect&#34;&gt;通过 BAT 面试的程序员简历长什么样? 附简历模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cyc2018.github.io/page.html&#34;&gt;cyc2018 大佬的网页简历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;春招开始&#34;&gt;春招开始&lt;/h2&gt;
&lt;h3 id=&#34;投递&#34;&gt;投递&lt;/h3&gt;
&lt;h4 id=&#34;心得&#34;&gt;心得&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;海投！一定要海投！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;疯狂面试，可以积累经验&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;但有一点需要注意&lt;/strong&gt;，就是如果最终拿到实习资格，然后拒掉，会不会影响后期秋招？这个到时候要再确认一下。&lt;/li&gt;
&lt;li&gt;对于一些自己不想去的公司或者部门，也可以试着投递，增加经验（如果是部门，提前了解清楚投递会不会影响到自己想去的部门）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;早投递机会更大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎了解一下boss直聘，到时候找实习，可以把简历放到boss直聘上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;首先就是策略，一开始最好不要立刻投大厂，因为一上来就面大厂的话容易崩，刚开始面的人少所以难度也会相对高一些，有的还凑合的会被大厂当备胎，很难受的。其次就是能内推就不要走官网，能免笔试免笔试，不是说笔试难度大还是咋地，这玩意其实是玄学，因为你说你一个人做呢没问题，大神嘛无所谓但是你保不齐别人是一个实验室或者一个班级的人在做，如果遇到点坑的题目，你交代了，别人合作做出来了那你被挂能怪谁呢。还有就是如果大家也是合作做题的话，oj的查重或者作弊系统的判别现在越来越严，如果保不齐你被抓到了，可能就被企业拉黑，然后你还不知道，后面怎么投都没面试机会这是最惨的。还有就是大家都是一起做的，然后分数也差不多，但是别人接到了面试而你没有，我就遇到了这样的情况，就很玄学我都怀疑是随机选的人面试。反正就是笔试有风险，大家还是抱紧学长学姐的大腿，能走内推就内推。但是内推之前还是需要能够了解一下这个部门，大概是做什么的，hc的数量以及技术氛围，这点其实很重要，因为一旦进了流程，你反悔就来不及了，如果过了之后还想换部门那只能重新面试，再走一遍别说多恶心了。其实哪个部门最好或者哪个部门最有前景啥的这些问题，真的很难了解的非常清楚，我就纠结过很久很久，这种事情找不到最优解的，不过还好对我而言现在只是实习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先拿到保底offer，这样心态会好很多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;部门信息整理&#34;&gt;部门信息整理&lt;/h4&gt;
&lt;p&gt;事业群 &amp;gt; 部门 &amp;gt; 中心 &amp;gt; 小组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微众：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贷款科技部：&lt;strong&gt;很核心&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阿里集团（简称集团）
&lt;ul&gt;
&lt;li&gt;阿里云：很香&lt;/li&gt;
&lt;li&gt;天猫精灵团队：&lt;/li&gt;
&lt;li&gt;钉钉：&lt;/li&gt;
&lt;li&gt;一面、二面、总监面、交叉部门主管面、HR面；每一面都有一票否决权（包括HR面）&lt;/li&gt;
&lt;li&gt;转正是否成功，很大程度上取决于HR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蚂蚁
&lt;ul&gt;
&lt;li&gt;CTO线-数据与平台技术事业群-蚂蚁智能引擎与数据中台技术事业部-大数据部
&lt;ul&gt;
&lt;li&gt;一面、二面、笔试、三面、四面、HR面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;听同学群里讨论，集团没有蚂蚁好，至少薪资福利这块，没有蚂蚁好&lt;/li&gt;
&lt;li&gt;重视项目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;百度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程效率部门：做内部工具的，对个人成长并不好&lt;/li&gt;
&lt;li&gt;企业智能平台：主要是内部系统，虽然会接触到机器学习和大数据，不太好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础架构&lt;/li&gt;
&lt;li&gt;今日头条：薪资很诱人
&lt;ul&gt;
&lt;li&gt;头条加面有两种情况，一是三轮评级都是 4 可以评 SSP，二是面试官评价差别很大，再面一轮决定是否录用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data：核心部门&lt;/li&gt;
&lt;li&gt;一面、二面、三面，就可以offer了&lt;/li&gt;
&lt;li&gt;重视算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;荣耀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品线部门：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vivo：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;华为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cloud Bu：不错&lt;/li&gt;
&lt;li&gt;车BU智能座舱产品部&lt;/li&gt;
&lt;li&gt;南研所消费者 BG&lt;/li&gt;
&lt;li&gt;cyc2018 拿到了十四级最高的薪资&lt;/li&gt;
&lt;li&gt;不怎么问技术，重视学历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;华泰证券&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息技术部：base南京&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;杭研院&lt;/li&gt;
&lt;li&gt;网易互联网&lt;/li&gt;
&lt;li&gt;网易雷火&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TP-Link&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;腾讯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微信事业群：gc学长说 挺好的&lt;/li&gt;
&lt;li&gt;上海CSIG：很差&lt;/li&gt;
&lt;li&gt;重视算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深兰科技&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创新奇智&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便利蜂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;携程旅行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旷视&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小米&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bilibili&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;商汤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;度小满&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美团&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金服：&lt;/li&gt;
&lt;li&gt;到店：&lt;/li&gt;
&lt;li&gt;重视项目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拼多多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;贝壳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快手&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;360&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外企&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微软&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STCA-M365
&lt;ul&gt;
&lt;li&gt;笔试、一面、Leader面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3轮技术面+1轮AA面，AA面最终决定是否通过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;亚马逊&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谷歌&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虾皮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重视算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;待投&#34;&gt;待投&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU1MTU2NjcxMQ==&amp;amp;mid=2247504396&amp;amp;idx=1&amp;amp;sn=200877c58bd016dbd5d66aefbee154a3&amp;amp;chksm=fb8dfe14ccfa770246c8c5ffd15eb455fea3c1e307ecb0f16ef8365c61463f6bde033c40850d&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1216AelYAleMD4XYJuv0n2FJ&amp;amp;sharer_sharetime=1639639282713&amp;amp;sharer_shareid=02cdcbb08350c969c2db9d032c863a6d#rd&#34;&gt;微软 提前批 22.1.1&lt;/a&gt; 放弃 觉得自己没有准备好&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;宝洁 22.1.14  &lt;a href=&#34;https://mp.weixin.qq.com/s/STCpEoSpSLIntZglntZJfw&#34;&gt;官网&lt;/a&gt; &lt;a href=&#34;https://mp.weixin.qq.com/s/1hKslZkERA8okJuSfhX6rw&#34;&gt;实习僧链接&lt;/a&gt; 放弃 还没准备好&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;字节 日常实习&lt;/li&gt;
&lt;li&gt;微软 正式批 22.1.17
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/0kwiVC9tAH5GeaIE60dOqw&#34;&gt;微软校招 | 2022暑期实习招聘正式启动！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.qq.com/doc/DV0NGWmVhVGFPR1dz&#34;&gt;微软2022暑期实习招聘 - 求职干货大宝书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;方向&#34;&gt;方向&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;核心业务 &amp;gt; 核心业务基础架构 &amp;gt; 边缘业务基础架构 &amp;gt; 边缘业务&lt;/li&gt;
&lt;li&gt;尽量不要去内部系统开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面试中&#34;&gt;面试中&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;演技&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最近读了哪些书：假装读过，然后往八股文引&lt;/li&gt;
&lt;li&gt;脑筋急转弯：不要直接给最优解，体现思考过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软实力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持自信&lt;/li&gt;
&lt;li&gt;学会用积极的情绪感染面试官，提供情绪价值
&lt;ul&gt;
&lt;li&gt;活泼一点、积极向上、大大方方、自然不拘谨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回答面试官问题时，可以用生动形象的例子，这样可能效果更好，也能体现自己的思考&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引导面试官&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试时灵活点，不要太憨，学会引导面试官&lt;/li&gt;
&lt;li&gt;聊项目时，可以引导到八股文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试前，看一看对应公司的面经，提前做准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试时问一下对方是哪个部门的，方便后续面试时做相应的准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://b23.tv/ajxmk5&#34;&gt;如何回答面试官最后一个问题——钻石版-哔哩哔哩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;其次就是面试总结了。面试过程当中我建议大家开启手机录音。这样方便事后复盘，我是每次都会再听一遍自己的录音，不论是写面经还是琢磨自己的回答有录音真的方便很多。因为面试期间的紧张感会让你很难用最好的描述回答清楚问题，那么事后总结就会让你在下次遇到同样的问题的时候回答的更好。如果说大家有小伙伴在一起战斗的话那么经常互相分享经验真的会决定你能不能拿到offer，大家的经验会让你迅速成长，说实话面试实习这2月也是我成长的最快的一个阶段。&lt;br&gt;
最后就是信息。在面试结束的时候，一般面试官都会问：你有什么问题问我。这个时候我个人最经常问的就是这个部门正在做什么，如果我进来我会接触到什么。面试官才是最了解这个部门的人，只有从他的口里得到的信息才是最真实也是最有用的，通过他的回答你会了解到这个部门做的产品或者是使用的技术，对于自己的学习方向也有很大的指向作用。其次，我会问的问题就是：您认为我在哪些方面可以提高自己。这个问题其实从侧面可以让你获取你此次面试的结果。因为这个问题不像问我面试能不能过这样直白的面试禁忌。一般面试官会指明他认为你的缺点，如果他在说的时候带有建议的语气以及对你其他方面的肯定那基本是十拿九稳了，再不济有大佬对你的一个建议指导对你自己查漏补缺也是非常有帮助的。说下我自己的经历吧，我在面阿里云3面的时候，那位p9大佬在我问完这个问题之后不仅肯定了我的一些表现还给我推荐了2本书建议我去阅读，这真的是非常良好的面试体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/56655579&#34;&gt;cyc2018大佬的面经&lt;/a&gt; 读后总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于面试官的问题，要能回答到点上；对于自己擅长的知识点，要学会展开讲。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试过程中，要表现得比较自信（不要自大，也不要自卑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这次面试我表现地非常自信，自己知道的知识都很有信心地表达出来，被问到不会的内容也不会那么慌张，和面试官探讨一些细节，然后说说自己的想法，还有自己看过相关的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整个春招过程中，会被拒很多次，但要时刻保持信心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要学会把问题往自己擅长的领域引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当被问到没有掌握的知识，可以通过讨论的方式，给出大概的思路，因为很多技术都是相通的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;位运算的问题，面试官让我之后完善了再发给他，过后我写了详细文档讲解了思路，以及使用 JUnit 进行了详细的单元测试，把文档和代码都发给了他&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;非技术问题回答的支支吾吾，然后面试官开始质疑我说的内容，给我压力，我没有当场反驳，就说了“哦，好像是这样的”。因为面试官全程都绷着脸，所以我也比较紧张，很多问题没回答好。&lt;/p&gt;
&lt;p&gt;这次面试失败的主要原因是自己在应对这种压力时处理地不是很好，主要体现在失去信心以及紧张。&lt;/p&gt;
&lt;p&gt;解决方法也简单，做好充分准备来保持信心，受到质疑的时候积极反驳，紧张的时候及时调整心态，可以试试深呼吸或者喝水。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试中还会涉及到非技术性问题，要有心理准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;面完之后我立马查了一下那个错排问题，证实了我的答案是正确的，于是写了一个详细的文档，联系 HR 让她发给面试官&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试回答不要太简单，适当展开，把知道的都说出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保持谦逊的态度。&lt;/strong&gt;：不要不懂装懂，不会的问题可以自己分析并提出自己的见解，对面试官提出的问题，&lt;strong&gt;可以当成和面试官的一次讨论&lt;/strong&gt;，不要紧张。&lt;strong&gt;不会的问题，可以在最后的提问环节，再和面试官深入探讨一波&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;展示对知识的热情&lt;/strong&gt;。对面试官提出的问题，你一定要绘声绘色的去回答，讲出自己的理解，而不是非常死板的死记硬背。知识是背下来的还是真正理解的，一般老辣的面试官深入问一下就心里有数了，当然这个是建立你对知识充分了解的基础上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**能说什么就说什么。**面试的时候，永远不是看你知不知道，而是看你知道多少，所以说面试官提出问题，&lt;strong&gt;你在思考的时候，一定要简单提一下你的思考过程&lt;/strong&gt;，主要是表现自己掌握的知识量，这样即使你没有回答到点上，你也会比什么都不说得到更好的评价。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**尝试和面试官产生共鸣。**也许很多时候，面试官提出的问题，他自己都没有想到答案，所以这个时候你要尝试站在和他同一水平上，进行平等交流讨论，一般来说面试官都会对你产生回应，从而使得这场面试更加和谐，增加你成功的几率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试完一家，总结好经验，就let it go吧，即使挂了也不要影响信心和心情，面试很多情况看缘分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求职过程中别和身边的人对比 ，别自我怀疑，专注于过程，别在意结果，反思总结，心态别崩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坚持 &lt;strong&gt;+&lt;/strong&gt; 努力 ，不到最后一刻别放弃&lt;/p&gt;
&lt;p&gt;by https://zhuanlan.zhihu.com/p/357871900&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把所有面试中的不顺利都当作是压力面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试难的部门，不一定就是好部门&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般是部门HR会先打电话联系我，然后再安排面试官进行面试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护好自己的面评&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放弃春招面试，可能导致秋招不给面试机会&lt;/li&gt;
&lt;li&gt;任何一场面试，都不要放松，都要重视&lt;/li&gt;
&lt;li&gt;不要相信“提前批 不影响 正式批”，任何一场面试都会有面评记录，后续面试面试官会看的！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试时，遇到不会的知识点，不用担心，面试更看重的是思维+表达+沟通+学习能力，而不是已经掌握了多少&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内推&#34;&gt;内推&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lzy 上海 量化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;误入凡尘里 B站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xxb 阿里云&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gc 微信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：特立独行MVP&lt;br&gt;
链接：&lt;br&gt;
https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;br&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;有想加入字节跳动 &lt;strong&gt;基础架构&lt;/strong&gt; 的同学可以找我内推呀 大量实习和提前批HC！（请搜索基础架构才是~）&lt;br&gt;
直推部门老大直接面试无笔试：可以把简历发送至&lt;a href=&#34;mailto:zhuhaochuan.snow@bytedance.com&#34;&gt;zhuhaochuan.snow@bytedance.com&lt;/a&gt; （注明实习还是校招，岗位）&lt;br&gt;
投递链接：https://job.toutiao.com/s/JNAvu8A&lt;br&gt;
内推码:QDZH4QP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;liuqiyang@bytedance.com&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;北京图森未来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;基础架构&lt;/p&gt;
&lt;p&gt;目前我也是图森在南京大学的校园大使，大家有想去实习和工作的可以私信我内推呀&lt;/p&gt;
&lt;p&gt;https://www.nowcoder.com/discuss/188367?type=all&amp;amp;order=time&amp;amp;pos=&amp;amp;page=4&amp;amp;channel=1009&amp;amp;source_id=search_all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;春招后&#34;&gt;春招后&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;就算春招失利，也不要灰心，秋招还有机会，参考cyc2018大佬的经历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;暑期实习-and-秋招&#34;&gt;暑期实习 and 秋招&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;秋招也要早做准备！&lt;/li&gt;
&lt;li&gt;实习时，可以利用晚上和周末时间来自我提升，因为还需要为秋招做准备&lt;/li&gt;
&lt;li&gt;不要相信实习单位所谓的“一定可以转正成功”&lt;/li&gt;
&lt;li&gt;秋招的面试表现直接影响薪资，且竞争激烈程度大于春招，要更加重视&lt;/li&gt;
&lt;li&gt;秋招很重要，不要为了实习转正牺牲秋招，&lt;strong&gt;给自己更多的选择&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;秋招后&#34;&gt;秋招后&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;秋招结束也不要放弃机会，有一些补录以及春招的机会，说不定比秋招的offer更好&lt;/li&gt;
&lt;/ul&gt;
">春招保卫战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习Java锁机制过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1YB4y1P7xC?p=1&#34;&gt;多线程高并发底层锁机制与优化最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;synchronized&#34;&gt;Synchronized&lt;/h2&gt;
&lt;p&gt;在普通方法上加synchronized，锁的是对象&lt;/p&gt;
&lt;p&gt;在静态方法上加synchronized，锁的是class&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;h4 id=&#34;jdk16之前&#34;&gt;jdk1.6之前&lt;/h4&gt;
&lt;p&gt;对 对象内部的monitor对象 进行加锁，如果加锁失败，进入等待队列，当锁释放时，从等待队列中依次唤醒线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非公平锁：先尝试获取锁，如果失败，则进入等待队列&lt;/li&gt;
&lt;li&gt;公平锁：直接进入等待队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重量级锁&lt;/li&gt;
&lt;li&gt;线程挂起和唤醒时，需要从用户态切换到内核态
&lt;ul&gt;
&lt;li&gt;之所以需要切换到内核态，是因为，挂起和唤醒操作，是依赖于内核程序完成的，只有进入内核态，才能调用内核中的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_42013590/article/details/107327439&#34;&gt;什么是CPU的用户态和内核态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java锁机制详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习脑裂问题过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是脑裂问题&#34;&gt;什么是脑裂问题&lt;/h2&gt;
&lt;p&gt;简单说，就是在一个集群中，出现两个master节点&lt;/p&gt;
&lt;p&gt;原本，一个集群中，只有一个master节点，可以看做是大脑，现在出现了两个，或者多个，就可以想象成大脑分裂了，所以叫脑裂问题&lt;/p&gt;
&lt;h2 id=&#34;成因以及造成的后果&#34;&gt;成因以及造成的后果&lt;/h2&gt;
&lt;p&gt;主要是由网络通信故障导致的&lt;/p&gt;
&lt;p&gt;一般来说，集群中的master节点都是选举产生的，想象一下，假设两个机房之间出现了通信故障，那么分处于两个机房中的节点就会各自选举出master节点，当网络恢复时，就不知道该听哪个master节点的了。&lt;/p&gt;
&lt;h2 id=&#34;如何避免&#34;&gt;如何避免&lt;/h2&gt;
&lt;p&gt;知道了成因，那么，想解决脑裂问题，就需要避免假死亡现象的产生，因为如果master节点正常死亡，监控节点重新选举master节点，是不会产生脑裂问题的。&lt;/p&gt;
&lt;p&gt;有以下三种常见方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;冗余通信：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过半机制（Quorum）：zookeeper采用的防止脑裂问题的方法，通过这个机制，可以确保就算发生了网络故障，也只会有一个master节点被选出&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211106134247658.png&#34; alt=&#34;image-20211106134247658&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享存储隔离（Fencing）：能看到共享资源的节点就表示在集群中，能够获得共享资源的锁的节点就是master，看不到共享资源的节点就不在集群中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u013374645/article/details/93140148&#34;&gt;面试题：Zookeeper是如何解决脑裂问题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/394160966&#34;&gt;分布式系统的“脑裂”到底是个什么玩意？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u014156013/article/details/81226424&#34;&gt;脑裂问题以及如何避免&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">脑裂问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-30-JavaHan/"" data-c="
          &lt;p&gt;本人的面试八股文（面试小抄），供大家参考。&lt;/p&gt;
&lt;p&gt;JavaHan，致敬 JavaGuide，Han指的是憨，并且感觉读起来比较顺口。&lt;/p&gt;
&lt;p&gt;为了方便检索，我把所有内容都放在一个文档中的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;h4 id=&#34;isp&#34;&gt;ISP&lt;/h4&gt;
&lt;p&gt;互联网服务提供商&lt;/p&gt;
&lt;p&gt;ISP 可以从 互联网管理机构 获得许多 IP 地址，个人或机构向 ISP 缴纳一定的费用就可以接入互联网&lt;/p&gt;
&lt;h4 id=&#34;osi模型-五层模型与-tcpip-模型&#34;&gt;OSI模型、五层模型与 TCP/IP 模型&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20211217120543019.png&#34; alt=&#34;image-20211217120543019&#34; style=&#34;zoom:45%;&#34; /&gt;
&lt;p&gt;五层模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：负责在&lt;strong&gt;具体媒体&lt;/strong&gt;上传输数据&lt;strong&gt;比特流&lt;/strong&gt;，为 数据链路层 屏蔽具体的媒体特性。&lt;/li&gt;
&lt;li&gt;数据链路层：负责在&lt;strong&gt;具体链路&lt;/strong&gt;上传输&lt;strong&gt;数据帧&lt;/strong&gt;，为 网络层 屏蔽具体链路信息（网络层中，主机间的传输，需要经过多条链路）。&lt;/li&gt;
&lt;li&gt;网络层：负责在&lt;strong&gt;主机间&lt;/strong&gt;传输&lt;strong&gt;数据分组&lt;/strong&gt;，为 传输层 屏蔽主机信息。&lt;/li&gt;
&lt;li&gt;传输层：负责在&lt;strong&gt;进程间&lt;/strong&gt;传输数据，为 应用层 屏蔽进程信息。
&lt;ul&gt;
&lt;li&gt;TCP：传输控制协议，面向连接、可靠的数据传输服务，数据单位为&lt;strong&gt;报文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UDP：用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是&lt;strong&gt;用户数据报&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层：负责在&lt;strong&gt;应用间&lt;/strong&gt;传输&lt;strong&gt;报文&lt;/strong&gt;，例如HTTP、DNS协议。&lt;/li&gt;
&lt;li&gt;越底层，数据量越大，逐层封装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSI模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层：负责数据处理，比如，压缩、加密等，使 应用层 无需关心数据内部格式方面的问题。&lt;/li&gt;
&lt;li&gt;会话层：负责会话的连接、维护、断开等。当应用间需要传输数据时，首先需要建立会话；当数据传输完时，会话层会有选择地进行会话的维护；最终，会话层会断开会话。&lt;/li&gt;
&lt;li&gt;五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP 模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将五层模型中的数据链路层和物理层合并为网络接口层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;物理层&#34;&gt;物理层&lt;/h3&gt;
&lt;h3 id=&#34;链路层&#34;&gt;链路层&lt;/h3&gt;
&lt;h4 id=&#34;信道复用技术41种&#34;&gt;信道复用技术（4+1种）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频分复用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时分复用（TDM）：为每个用户分配固定位置的时隙&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/67582ade-d44a-46a6-8757-3c1296cc1ef9.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计时分复用（异步时分复用，STDM）：不固定每个用户在时分复用帧中的位置，只要有数据，就为其分配时隙，用户拿到时隙后，就可以发送数据（注意区分两张图中字母的顺序）&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6283be2a-814a-4a10-84bf-9592533fe6bc.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;码分复用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ppp-协议&#34;&gt;PPP 协议&lt;/h4&gt;
&lt;p&gt;互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。&lt;/p&gt;
&lt;h4 id=&#34;arp-地址解析协议&#34;&gt;ARP 地址解析协议&lt;/h4&gt;
&lt;p&gt;ARP 协议负责根据 IP 地址获取 MAC 地址。&lt;/p&gt;
&lt;p&gt;实现原理：每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果某 IP 地址不存在，则通过广播的形式获取。MAC 地址&lt;/p&gt;
&lt;p&gt;MAC 地址是链路层地址，长度为 6 字节（6*8=48 位），用于唯一标识网络适配器（网卡）。&lt;/p&gt;
&lt;p&gt;一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。&lt;/p&gt;
&lt;h4 id=&#34;网络设备&#34;&gt;网络设备&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;集线器：
&lt;ul&gt;
&lt;li&gt;物理层设备，作用于 比特&lt;/li&gt;
&lt;li&gt;当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口&lt;/li&gt;
&lt;li&gt;如果集线器同时收到两个不同接口的帧，那么就发生了碰撞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换机：
&lt;ul&gt;
&lt;li&gt;链路层设备，作用于 帧&lt;/li&gt;
&lt;li&gt;不会发生碰撞&lt;/li&gt;
&lt;li&gt;能根据 MAC 地址进行存储转发&lt;/li&gt;
&lt;li&gt;具有自学习能力，能自动生成 交换表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层&lt;/h3&gt;
&lt;h4 id=&#34;概述-2&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;网络层的作用：使用 IP 协议，将异构的物理网络连接起来，使得其看起来好像是一个统一的网络&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png&#34; alt=&#34;img&#34; style=&#34;zoom:37%;&#34; /&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地址解析协议 ARP（Address Resolution Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网际控制报文协议 ICMP（Internet Control Message Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网际组管理协议 IGMP（Internet Group Management Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ip-协议&#34;&gt;IP 协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:65%;&#34; /&gt;
&lt;p&gt;IP 地址能够在网络世界唯一标识一台电脑，IP 地址一共有32位，即8个字节。&lt;/p&gt;
&lt;p&gt;IP 地址的编址方式的三个历史阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类编址：
&lt;ul&gt;
&lt;li&gt;不同分类具有不同的网络号长度，并且是固定的&lt;/li&gt;
&lt;li&gt;网络号+主机号&lt;/li&gt;
&lt;li&gt;网络地址：指的是，网络号不变，主机位二进制全为0的 ip 地址，类似于电话号码的区号&lt;/li&gt;
&lt;li&gt;要达到 Internet 上的某个主机，先利用 IP 地址的高位部分（网络地址）找到该主机所在的网络，再利用 IP 地址的低位部分（主机地址）找到该网络中的主机。&lt;/li&gt;
&lt;li&gt;子网掩码，又叫网络掩码、地址掩码。它的作用是，用来指明某个 IP 地址哪些标识位是网络地址，哪些标识位是主机地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子网划分编址：
&lt;ul&gt;
&lt;li&gt;网络号+子网号+主机号&lt;/li&gt;
&lt;li&gt;举例：B 类地址的默认子网掩码为 255.255.0.0（11111111 11111111 00000000 00000000），如果子网占两个比特，那么子网掩码为 255.255.192.0（11111111 11111111 11000000 00000000）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无分类编址（CIDR）：
&lt;ul&gt;
&lt;li&gt;网络前缀号+主机号&lt;/li&gt;
&lt;li&gt;在 IP 地址后面加上网络前缀长度，例如，128.14.35.7/20&lt;/li&gt;
&lt;li&gt;路由聚合与最长前缀匹配：
&lt;ul&gt;
&lt;li&gt;路由聚合：将 200.23.a.b/23 与 200.23.c.d/23 进行聚合，得到200.23.x.x/20，减少路由表项的数量&lt;/li&gt;
&lt;li&gt;最长前缀皮配：如果路由表中存在 A: 200.23.18.0/23 和 B: 200.23.x.x/20，则对于 200.23.18.0/23，选择A与之进行匹配（虽然 B 也能进行匹配，但是不是最长的）&lt;/li&gt;
&lt;li&gt;参考：https://blog.csdn.net/iostream1001001/article/details/78126150&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;icmp-网际控制报文协议&#34;&gt;ICMP 网际控制报文协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e3124763-f75e-46c3-ba82-341e6c98d862.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:43%;&#34; /&gt;
&lt;p&gt;放在 IP 数据报的数据部分，用于实现一些特定的功能，目的是为了更有效地转发 IP 数据报和提高交付成功的机会。&lt;/p&gt;
&lt;p&gt;ICMP 的应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ping：用于测试两台主机之间的连通性。&lt;/li&gt;
&lt;li&gt;Traceroute：用来跟踪一个数据分组从源点到终点的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;vpn-虚拟专用网&#34;&gt;VPN 虚拟专用网&lt;/h4&gt;
&lt;p&gt;如何理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，什么是专用网？主机需要分配 IP 地址才能上网，但往往，一个机构能申请到的 IP 地址是有限的，因此，只能为主机分配本机构内部有效的专用地址。主机间使用专用地址进行通信，构成专用网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是虚拟专用网？指的是，该专用网其实是依托于互联网形成的，所以不是实实在在的专用网，而是虚拟专用网。主机 A 向主机 B 发送数据，数据报的源地址和目的地址都是专用地址，在路由器中，会对数据报进行加密、封装，新的数据报源地址和目的地址都是全球地址。在目的路由接收后，再对数据报进行解密，然后根据专用地址进行转发。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1556770b-8c01-4681-af10-46f1df69202c.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nat-网络地址转换&#34;&gt;NAT 网络地址转换&lt;/h4&gt;
&lt;p&gt;功能：将专业地址转换成全球地址，或将全球地址转换成专用地址，使得机构内部主机可以上网。&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将本地 IP 和全球 IP 一一对应&lt;/li&gt;
&lt;li&gt;缺点：拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网&lt;/li&gt;
&lt;li&gt;解决方案：NAPT 网络地址与端口转换（将传输层的端口号也用上）&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2719067e-b299-4639-9065-bed6729dbf0b.png&#34; alt=&#34;img&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;h4 id=&#34;路由器&#34;&gt;路由器&lt;/h4&gt;
&lt;p&gt;位于网络层，只负责主机间的数据传输&lt;/p&gt;
&lt;p&gt;功能：路由选择与分组转发&lt;/p&gt;
&lt;h4 id=&#34;路由选择协议&#34;&gt;路由选择协议&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内部网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RIP 路由信息协议：基于距离，依靠路由器间交换路由表，获取整个网络的距离信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OSPF 开放式最短路径优先协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Dijkstra 提出的最短路径算法 SPF&lt;/li&gt;
&lt;li&gt;向内部网络中的所有路由器发送信息，且只有当链路状态发生变化时，路由器才会发送信息，因此信息更新过程收敛得更快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BGP 边界网关协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AS 之间的路由选择很困难，因此，BGP 只能寻找一条比较好的路由，而不是最佳路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png&#34; alt=&#34;img&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;
&lt;h4 id=&#34;udp-vs-tcp&#34;&gt;UDP vs TCP&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TCP：
&lt;ul&gt;
&lt;li&gt;传输控制协议，面向连接、可靠（超时重传）的数据传输服务，数据单位为&lt;strong&gt;报文段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每一条 TCP 连接，只能一对一&lt;/li&gt;
&lt;li&gt;有流量控制、拥塞控制&lt;/li&gt;
&lt;li&gt;面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP：
&lt;ul&gt;
&lt;li&gt;用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是&lt;strong&gt;用户数据报&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;n对n，n &amp;gt;= 1&lt;/li&gt;
&lt;li&gt;无流量控制、拥塞控制&lt;/li&gt;
&lt;li&gt;面向报文（对应用层传下来的报文不合并也不拆分，只是添加 UDP 首部）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的三次握手&#34;&gt;TCP 的三次握手&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e92d0ebc-7d46-413b-aec1-34a39602f787.png&#34; alt=&#34;img&#34; style=&#34;zoom:43%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的&lt;strong&gt;序号 x&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，&lt;strong&gt;确认号为 x+1&lt;/strong&gt;，同时也选择一个初始的&lt;strong&gt;序号 y&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;A 收到 B 的连接确认报文后，还要向 B 发出确认，&lt;strong&gt;确认号为 y+1&lt;/strong&gt;，序号为 &lt;strong&gt;x+1&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;B 收到 A 的确认后，连接建立。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三次握手的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。&lt;/li&gt;
&lt;li&gt;客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的四次挥手&#34;&gt;TCP 的四次挥手&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;A 发送连接释放报文，FIN=1。&lt;/li&gt;
&lt;li&gt;B 收到之后发出确认报文，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。&lt;/li&gt;
&lt;li&gt;当 B 不再需要连接时，发送连接释放报文，FIN=1。&lt;/li&gt;
&lt;li&gt;A 收到后发出确认报文，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。&lt;/li&gt;
&lt;li&gt;B 收到 A 的确认后释放连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;四次挥手的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进入 TIME_WAIT 状态的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。&lt;/li&gt;
&lt;li&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp-的滑动窗口&#34;&gt;TCP 的滑动窗口&lt;/h4&gt;
&lt;p&gt;发送方和接收方，都有滑动窗口，接收方通过报文告知发送方自己窗口（接收窗口）的大小，发送方根据接收窗口大小以及其它信息（见拥塞控制那一节）设置自己窗口（发送窗口）的大小&lt;/p&gt;
&lt;p&gt;当发送窗口左侧字节收到确认，右移发送窗口，直到左部第一个字节不是已确认的状态&lt;/p&gt;
&lt;p&gt;接收窗口只会按需进行确认，确认后，右移接收窗口。因此，对于发送窗口来说，收到某个字节的确认，就说明，此字节之前的字节，接收方都已接收。&lt;/p&gt;
&lt;h4 id=&#34;tcp-的流量控制&#34;&gt;TCP 的流量控制&lt;/h4&gt;
&lt;p&gt;接收方通过确认报文中的窗口字段 &lt;strong&gt;影响&lt;/strong&gt; 发送窗口的大小，从而 &lt;strong&gt;影响&lt;/strong&gt; 发送速率（注意，我这里用的是 &lt;strong&gt;影响&lt;/strong&gt;，而不是 &lt;strong&gt;控制&lt;/strong&gt;，见 拥塞控制 那一节，思考原因）&lt;/p&gt;
&lt;p&gt;将窗口字段设置为0，则发送方不能发送数据&lt;/p&gt;
&lt;h4 id=&#34;tcp-的拥塞控制&#34;&gt;TCP 的拥塞控制&lt;/h4&gt;
&lt;p&gt;如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。&lt;/p&gt;
&lt;p&gt;发送窗口大小 = min{ 接收方允许的窗口大小（由确认报文指定），拥塞窗口变量（cwnd） }&lt;/p&gt;
&lt;p&gt;拥塞控制算法（慢开始、拥塞避免、快重传、快恢复）流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将 cwnd 设置为1（&lt;strong&gt;慢开始&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次当收到确认报文后，将 cwnd 加倍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 cwnd &amp;gt;= 慢开始门限 ssthresh 后， cwnd 每次只加一（&lt;strong&gt;拥塞避免&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果出现超时，令 ssthresh = cwnd / 2，然后重新执行慢开始（回到第一步）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果连续收到 3 次重复确认，则说明报文段丢失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即重传丢失报文（快重传）&lt;/li&gt;
&lt;li&gt;并令 ssthresh = cwnd / 2，cwnd = ssthresh （&lt;strong&gt;快恢复&lt;/strong&gt;：无需重新执行慢开始）&lt;/li&gt;
&lt;/ul&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png&#34; alt=&#34;img&#34; style=&#34;zoom:53%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用层&#34;&gt;应用层&lt;/h3&gt;
&lt;h4 id=&#34;ftp-文件传送协议&#34;&gt;FTP 文件传送协议&lt;/h4&gt;
&lt;p&gt;使用 TCP 进行连接，需要两个连接来传送一个文件：控制连接+数据连接&lt;/p&gt;
&lt;h4 id=&#34;dhcp-动态主机配置协议&#34;&gt;DHCP 动态主机配置协议&lt;/h4&gt;
&lt;p&gt;由 DHCP 服务器提供配置信息，无需用户手动进行配置。&lt;/p&gt;
&lt;p&gt;配置信息包括：IP 地址、子网掩码、网关 IP 地址&lt;/p&gt;
&lt;p&gt;DHCP 工作过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。&lt;/li&gt;
&lt;li&gt;如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。&lt;/li&gt;
&lt;li&gt;DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;电子邮件协议&#34;&gt;电子邮件协议&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7b3efa99-d306-4982-8cfb-e7153c33aab4.png&#34; alt=&#34;img&#34; style=&#34;zoom:53%;&#34; /&gt;
&lt;p&gt;电子邮件协议包括：SMTP、POP3、IMAP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送协议：用于将电子邮件从发送服务器发送到接收服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMTP 简单邮件传送协议：，但只支持 ASCII 码的邮件主体。为了解决这个问题，增加了 MIME 多用途互联网邮件扩展类型，MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取协议：用于将电子邮件从接收服务器读取到客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POP3 邮件读取协议：单向通信，从服务器到客户端。旧版中，用户从服务器读取邮件后，就会把邮件删除，新版中可以不删除邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IMAP 网际报文存取协议：双向通信，客户端和服务器上的邮件保持同步，可以同步文件夹、分类等信息。&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/v2-dd366f60ce8a2908e36bcc53a57fc615_720w.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-超文本传输协议&#34;&gt;HTTP 超文本传输协议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;H&lt;/strong&gt;yper &lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol&lt;/p&gt;
&lt;h5 id=&#34;url&#34;&gt;URL&lt;/h5&gt;
&lt;p&gt;全称：统一资源定位符（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;L&lt;/strong&gt;ocator），用于定位资源&lt;/p&gt;
&lt;p&gt;URL 是 URI（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;I&lt;/strong&gt;dentifier，统一资源标识符）的子集，在 URI 的基础上增加了定位能力&lt;/p&gt;
&lt;p&gt;URI 除了包含 URL，还包含 URN（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;N&lt;/strong&gt;ame，统一资源名称），用来定义一个资源的名称，但不具备定位该资源的能力。例如，urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h5 id=&#34;http-状态码&#34;&gt;HTTP 状态码&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;1XX 信息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;100 Continue&lt;/strong&gt; ：表明到目前为止一切正常，客户端可以发送后续请求或者忽略这个响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2XX 成功&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;200 OK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;204 No Content&lt;/strong&gt; ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;206 Partial Content&lt;/strong&gt; ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容，即，不返回全部实体，只返回部分实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3XX 重定向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt; ：永久性重定向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;302 Found&lt;/strong&gt; ：临时性重定向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;303 See Other&lt;/strong&gt; ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。&lt;/li&gt;
&lt;li&gt;注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。也就是说，对于 303，重定向时一定使用 GET 方法，对于 301 和 302，理论上不应该改变请求方法，但是一般浏览器都会把请求方法改成 GET。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt; ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;307 Temporary Redirect&lt;/strong&gt; ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4XX 客户端错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt; ：请求报文中存在语法错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;401 Unauthorized&lt;/strong&gt; ：该状态码表示发送的请求需要有认证信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;403 Forbidden&lt;/strong&gt; ：请求被拒绝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;416 Requested Range Not Satisfiable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5XX 服务器错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt; ：服务器执行请求时发生错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt; ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类别&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Informational（信息性状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Success（成功状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Redirection（重定向状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Client Error（客户端错误状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5XX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Server Error（服务器错误状态码）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;连接管理&#34;&gt;连接管理&lt;/h5&gt;
&lt;p&gt;短连接与长连接：当浏览器访问一个包含多张图片的 HTML 页面时，需要请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。如果要断开连接，需要由客户端或者服务器端提出断开，使用 &lt;code&gt;Connection : close&lt;/code&gt;。从 HTTP/1.1 开始默认是长连接的，之前默认是短连接，如果需要使用长连接，则使用 &lt;code&gt;Connection : Keep-Alive&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。&lt;/p&gt;
&lt;h5 id=&#34;cookie&#34;&gt;Cookie&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;概述：HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 数据保存在客户端本地。Cookie 曾一度用于客户端数据的存储，但现在，Cookie 渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。&lt;/li&gt;
&lt;li&gt;用途：
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建过程：服务器发送的响应报文包含 &lt;strong&gt;Set-Cookie 首部字段&lt;/strong&gt;，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 &lt;strong&gt;Cookie 请求首部字段&lt;/strong&gt;发送给服务器。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。&lt;/li&gt;
&lt;li&gt;持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。在 Set-Cookie 字段中指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域：
&lt;ul&gt;
&lt;li&gt;Domain 标识：指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名（如 developer.mozilla.org）中。&lt;/li&gt;
&lt;li&gt;Path 标识：指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&amp;quot;/&amp;quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：/docs、/docs/Web/。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JavaScript：
&lt;ul&gt;
&lt;li&gt;浏览器通过 &lt;code&gt;document.cookie&lt;/code&gt; 属性可创建新的 Cookie，也可通过该属性访问&lt;strong&gt;非 HttpOnly 标记&lt;/strong&gt;的 Cookie。&lt;/li&gt;
&lt;li&gt;标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 &lt;code&gt;document.cookie&lt;/code&gt; API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Secure 标识：
&lt;ul&gt;
&lt;li&gt;标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。&lt;/li&gt;
&lt;li&gt;但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Session：
&lt;ul&gt;
&lt;li&gt;Session 数据存储在服务端&lt;/li&gt;
&lt;li&gt;使用过程：将数据存储在服务端，生成唯一 Session ID，将 Session ID 作为 Cookie 传给客户端，客户端之后的每个请求都会带有该 Session ID。&lt;/li&gt;
&lt;li&gt;Session ID 安全性问题：应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，避免产生容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。&lt;/li&gt;
&lt;li&gt;若浏览器禁用 Cookie，则需要使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。&lt;/li&gt;
&lt;li&gt;Cookie VS Session：
&lt;ul&gt;
&lt;li&gt;Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；&lt;/li&gt;
&lt;li&gt;Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；&lt;/li&gt;
&lt;li&gt;对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;虚拟主机&#34;&gt;虚拟主机&lt;/h5&gt;
&lt;p&gt;HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。&lt;/p&gt;
&lt;h5 id=&#34;代理&#34;&gt;代理&lt;/h5&gt;
&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;网络访问控制&lt;/li&gt;
&lt;li&gt;访问日志记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正向代理：用户察觉得到&lt;/li&gt;
&lt;li&gt;反向代理：一般位于内部网络中，用户察觉不到&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;https&#34;&gt;HTTPS&lt;/h5&gt;
&lt;p&gt;HTTP 有以下安全性问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被窃听：使用明文进行通信，内容可能会被窃听；&lt;/li&gt;
&lt;li&gt;被伪装：不验证通信方的身份，通信方的身份有可能遭遇伪装；&lt;/li&gt;
&lt;li&gt;被篡改：无法证明报文的完整性，报文有可能遭篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。&lt;/p&gt;
&lt;p&gt;实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer 安全套接字协议）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。&lt;/li&gt;
&lt;li&gt;SSL 是一种为网络通信提供安全及数据完整性的一种安全协议，在传输层与应用层之间对网络连接进行加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ssl-offloading.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h6 id=&#34;加密&#34;&gt;加密&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;对称密钥加密：加密和解密使用同一密钥，运算速度快，无法安全地将密钥传输给通信方&lt;/li&gt;
&lt;li&gt;非对称密钥加密：加密和解密使用不同的密钥，运算速度慢，可以更安全地将公开密钥传输给通信发送方，除了用来加密，还可以用来进行签名&lt;/li&gt;
&lt;li&gt;HTTPS 采用的加密方式：混合加密机制
&lt;ul&gt;
&lt;li&gt;使用非对称密钥加密方式，传输对称密钥加密方式所需要的密钥，从而保证安全性&lt;/li&gt;
&lt;li&gt;获取到密钥后，再使用对称密钥加密方式进行通信，从而保证效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;认证&#34;&gt;认证&lt;/h6&gt;
&lt;p&gt;通过使用 &lt;strong&gt;证书&lt;/strong&gt; 来对通信方进行认证。&lt;/p&gt;
&lt;h6 id=&#34;完整性保护&#34;&gt;完整性保护&lt;/h6&gt;
&lt;p&gt;SSL 提供报文摘要功能来进行完整性保护。&lt;/p&gt;
&lt;p&gt;HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。&lt;/p&gt;
&lt;p&gt;HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。&lt;/p&gt;
&lt;h6 id=&#34;缺点&#34;&gt;缺点&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;因为需要进行加密解密等过程，因此速度会更慢；&lt;/li&gt;
&lt;li&gt;需要支付证书授权的高额费用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;综合应用-web-页面请求过程&#34;&gt;综合应用-Web 页面请求过程&lt;/h3&gt;
&lt;h4 id=&#34;dhcp-配置主机信息&#34;&gt;DHCP 配置主机信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 协议来获取。&lt;/li&gt;
&lt;li&gt;主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。&lt;/li&gt;
&lt;li&gt;该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。&lt;/li&gt;
&lt;li&gt;该数据报则被放置在 MAC 帧中，并将广播到与交换机连接的所有设备。&lt;/li&gt;
&lt;li&gt;连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arp-解析-mac-地址&#34;&gt;ARP 解析 MAC 地址&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。&lt;/li&gt;
&lt;li&gt;主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。&lt;/li&gt;
&lt;li&gt;该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。&lt;/li&gt;
&lt;li&gt;该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。&lt;/li&gt;
&lt;li&gt;DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。&lt;/li&gt;
&lt;li&gt;网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dns-解析域名&#34;&gt;DNS 解析域名&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。&lt;/li&gt;
&lt;li&gt;网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。&lt;/li&gt;
&lt;li&gt;因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。&lt;/li&gt;
&lt;li&gt;到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。&lt;/li&gt;
&lt;li&gt;找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http-请求页面&#34;&gt;HTTP 请求页面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。（其实和上面所提到的 ARP 协议一样，知道了 IP 地址后，依旧需要获取 MAC 地址，但是为了避免冗余，这里就不写了）&lt;/li&gt;
&lt;li&gt;在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。&lt;/li&gt;
&lt;li&gt;HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。&lt;/li&gt;
&lt;li&gt;连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。&lt;/li&gt;
&lt;li&gt;HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。&lt;/li&gt;
&lt;li&gt;浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;socket-套接字&#34;&gt;Socket 套接字&lt;/h3&gt;
&lt;h4 id=&#34;概述-3&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;什么是套接字？答：Socket。&lt;/p&gt;
&lt;p&gt;那么，什么是Socket？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它本质上是一组接口，或者说一种抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谁的接口？谁的抽象？传输层协议的接口或抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有什么用？应用层协议，通过 Socket 可以与传输层协议进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有 Socket 行不行？不行，如果没有 Socket，那么传输层的协议就只是一种概念，无法具体使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样。&lt;br&gt;
&lt;strong&gt;TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;by https://blog.csdn.net/github_34606293/article/details/78230456&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;io-模型&#34;&gt;I/O 模型&lt;/h4&gt;
&lt;p&gt;一个 输入操作 通常包括两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待数据准备好&lt;/li&gt;
&lt;li&gt;从内核向进程复制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个套接字上的输入操作，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。&lt;/li&gt;
&lt;li&gt;第二步就是把数据从内核缓冲区复制到应用进程缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;阻塞式-io&#34;&gt;阻塞式 I/O&lt;/h5&gt;
&lt;p&gt;应用进程被阻塞，直到数据从 内核缓冲区 复制到 应用进程缓冲区 中才返回。&lt;/p&gt;
&lt;p&gt;应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，&lt;strong&gt;这种模型的 CPU 利用率会比较高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意看图，可以加深理解&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492928416812_4.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;非阻塞式-io&#34;&gt;非阻塞式 I/O&lt;/h5&gt;
&lt;p&gt;应用进程执行 recvfrom 之后，如果数据未准备好，则内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知数据是否准备好，这种方式称为轮询（polling）。&lt;/p&gt;
&lt;p&gt;由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929000361_5.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;io-复用selectpollepoll&#34;&gt;I/O 复用（select/poll/epoll）&lt;/h5&gt;
&lt;p&gt;使用 select, poll 或 epoll 等待数据，可以同时等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。&lt;/p&gt;
&lt;p&gt;I/O 复用使得单个进程可以同时处理多个 I/O 事件。又被称为 Event Driven I/O，即事件驱动 I/O。&lt;/p&gt;
&lt;p&gt;如果一个 Web 服务器没有 I/O 复用，那么对于每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929444818_6.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;信号驱动式-iosigio&#34;&gt;信号驱动式 I/O（SIGIO）&lt;/h5&gt;
&lt;p&gt;应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。&lt;/p&gt;
&lt;p&gt;相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492929553651_7.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;异步-ioaio&#34;&gt;异步 I/O（AIO）&lt;/h5&gt;
&lt;p&gt;应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。&lt;/p&gt;
&lt;p&gt;异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。（看图更清晰）&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492930243286_8.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;5-种-io-的比较&#34;&gt;5 种 I/O 的比较&lt;/h5&gt;
&lt;p&gt;这一节主要讨论同步/异步、阻塞/非阻塞的问题，参考：https://www.zhihu.com/question/19732473&lt;/p&gt;
&lt;p&gt;首先讲概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步与异步：主要看调用结果是如何返回的。如果调用结果是由调用者主动等待得到的，那么就算是&lt;strong&gt;同步&lt;/strong&gt;；如果调用结果最终是由被调用者主动通知调用者的（比如通过回调函数），那就就算&lt;strong&gt;异步&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;阻塞与非阻塞：主要看等待结果过程中，调用者的状态。如果等待过程中，调用者啥事都不做，那就是&lt;strong&gt;阻塞&lt;/strong&gt;；如果等待过程中，调用者做了别的事，那就是&lt;strong&gt;非阻塞&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式 I/O：同步 阻塞&lt;/li&gt;
&lt;li&gt;非阻塞式 I/O：同步 第一阶段非阻塞 第二阶段阻塞&lt;/li&gt;
&lt;li&gt;I/O 复用：同步 阻塞&lt;/li&gt;
&lt;li&gt;信号驱动式 I/O：第一阶段异步非阻塞 第二阶段同步阻塞&lt;/li&gt;
&lt;li&gt;异步 I/O：异步 非阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1492928105791_3.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;io-复用&#34;&gt;I/O 复用&lt;/h4&gt;
&lt;p&gt;select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。&lt;/p&gt;
&lt;h5 id=&#34;select-vs-poll&#34;&gt;select vs poll&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;select 和 poll 都可以允许应用程序监听一组文件描述符的状态变化&lt;/li&gt;
&lt;li&gt;select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；&lt;/li&gt;
&lt;li&gt;如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
&lt;ul&gt;
&lt;li&gt;有可能函数调用会立即返回&lt;/li&gt;
&lt;li&gt;也有可能，会持续监听，超时返回&lt;/li&gt;
&lt;li&gt;也有可能，会返回成功，但是读取时报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;select 和 poll 速度都比较慢，每次调用都需要将全部描述符从 应用进程缓冲区 复制到 内核缓冲区（因为 select 和 poll 是系统调用，所以需要将数据拷贝到内核）（&lt;a href=&#34;https://bbs.csdn.net/topics/390696333&#34;&gt;参考资料&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;几乎所有系统都支持 select，部分系统不支持 poll。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;epoll&#34;&gt;epoll&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;epoll_create()&lt;/code&gt; 用于创建 epoll 对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_ctl()&lt;/code&gt; 用于向内核注册新的描述符或者是改变某个文件描述符的监听事件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epoll_wait()&lt;/code&gt; 用于得到事件完成的描述符&lt;/p&gt;
&lt;p&gt;已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数，内核会将 I/O 准备好的描述符加入到一个链表中进行管理，等待 &lt;code&gt;epoll_wait()&lt;/code&gt; 的调用&lt;/p&gt;
&lt;p&gt;从上面的描述可以看出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll 只需要将描述符从 进程缓冲区 向 内核缓冲区 拷贝一次（select 和 poll 需要再拷贝出来，然后通过遍历获取事件完成的描述符，而 epoll 只需要通过 &lt;code&gt;epoll_wait()&lt;/code&gt; 直接获取事件完成的描述符）&lt;/li&gt;
&lt;li&gt;并且进程不需要通过轮询来获得事件完成的描述符（&lt;code&gt;epoll_wait()&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;epoll 仅适用于 Linux OS&lt;/p&gt;
&lt;p&gt;epoll 和 poll 一样，没有描述符数量限制&lt;/p&gt;
&lt;p&gt;epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况（当文件描述符关闭，就会从监听列表中删除）&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_27529917/article/details/82945450&#34;&gt;Select和Epoll底层实现的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xiaowenmu1/article/details/90108663&#34;&gt;epoll在多线程下的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;selectpollepoll-的应用场景&#34;&gt;select/poll/epoll 的应用场景&lt;/h5&gt;
&lt;p&gt;很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select：
&lt;ul&gt;
&lt;li&gt;select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。&lt;/li&gt;
&lt;li&gt;select 可移植性更好，几乎被所有主流平台所支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;poll：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。&lt;/li&gt;
&lt;li&gt;epoll：
&lt;ul&gt;
&lt;li&gt;运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接（因为对于 epoll，描述符是存储在内核中的，所以如果是长连接，就可以一直让内核进行监听）&lt;/li&gt;
&lt;li&gt;需要监听的描述符对应的监听事件变化多，而且都非常短暂，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的监听事件改变都需要通过 &lt;code&gt;epoll_ctl()&lt;/code&gt; 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;
&lt;h3 id=&#34;概述-4&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;4 个基本特征：并发、共享、虚拟、异步&lt;/p&gt;
&lt;p&gt;并发 与 并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。&lt;/li&gt;
&lt;li&gt;并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。&lt;/li&gt;
&lt;li&gt;操作系统通过引入进程和线程，使得程序能够并发运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户态与内核态：如果一个进程在用户态需要使用内核态的功能，就需要进行系统调用从而陷入内核，由操作系统代为完成相应功能。&lt;/p&gt;
&lt;h3 id=&#34;进程管理&#34;&gt;进程管理&lt;/h3&gt;
&lt;h4 id=&#34;进程-vs-线程&#34;&gt;进程 VS 线程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进程：资源分配的基本单位&lt;/li&gt;
&lt;li&gt;线程：独立调度的基本单位&lt;/li&gt;
&lt;li&gt;区别与联系
&lt;ul&gt;
&lt;li&gt;一个 进程 中可以有多个 线程，它们共享 进程 资源&lt;/li&gt;
&lt;li&gt;线程 不拥有资源，但可以访问 隶属进程 的资源&lt;/li&gt;
&lt;li&gt;进程 和 线程 都可被调度，隶属不同进程的线程的切换会引起进程切换&lt;/li&gt;
&lt;li&gt;开销不同：
&lt;ul&gt;
&lt;li&gt;进程：
&lt;ul&gt;
&lt;li&gt;创建或撤销：分配或回收资源，如内存空间、I/O 设备等&lt;/li&gt;
&lt;li&gt;切换：当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程：
&lt;ul&gt;
&lt;li&gt;切换：只需保存和设置少量寄存器内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助特定的方法（进程间通信，IPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程状态&#34;&gt;进程状态&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态（ready）：等待被调度&lt;/li&gt;
&lt;li&gt;运行状态（running）&lt;/li&gt;
&lt;li&gt;阻塞状态（waiting）：等待除 CPU 时间以外的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程调度算法&#34;&gt;进程调度算法&lt;/h4&gt;
&lt;p&gt;不同系统的调度算法目标不同，因此需要针对不同系统来讨论调度算法&lt;/p&gt;
&lt;h5 id=&#34;批处理系统&#34;&gt;批处理系统&lt;/h5&gt;
&lt;p&gt;批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 先来先服务 first-come first-serverd（FCFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非抢占式的调度算法，按照请求的顺序进行调度。&lt;/p&gt;
&lt;p&gt;有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 最短作业优先 shortest job first（SJF）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非抢占式的调度算法，按估计运行时间最短的顺序进行调度。&lt;/p&gt;
&lt;p&gt;长作业有可能会饿死（处于一直等待短作业执行完毕的状态）：因为如果一直有短作业到来，那么长作业永远得不到调度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 最短剩余时间优先 shortest remaining time next（SRTN）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最短作业优先的&lt;strong&gt;抢占式&lt;/strong&gt;版本，按剩余运行时间的顺序进行调度。&lt;/p&gt;
&lt;p&gt;当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。&lt;/p&gt;
&lt;h5 id=&#34;交互式系统&#34;&gt;交互式系统&lt;/h5&gt;
&lt;p&gt;交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 时间片轮转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。&lt;/p&gt;
&lt;p&gt;时间片轮转算法的效率和时间片的大小有很大关系。&lt;/p&gt;
&lt;p&gt;因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 优先级调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个进程分配一个优先级，按优先级进行调度。&lt;/p&gt;
&lt;p&gt;为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 多级反馈队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。&lt;/p&gt;
&lt;p&gt;多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。&lt;/p&gt;
&lt;p&gt;每个队列优先权也不同，最上面的优先权最高。因此只有上层队列没有进程在排队，才能调度下层队列上的进程。&lt;/p&gt;
&lt;p&gt;可以将这种调度算法看成是 时间片轮转调度算法和优先级调度算法的结合。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/042cf928-3c8e-4815-ae9c-f2780202c68f.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h5 id=&#34;实时系统&#34;&gt;实时系统&lt;/h5&gt;
&lt;p&gt;实时系统要求一个请求在一个确定时间内得到响应。&lt;/p&gt;
&lt;p&gt;分为硬实时和软实时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬实时：必须满足绝对的截止时间&lt;/li&gt;
&lt;li&gt;软实时：可以容忍一定的超时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程同步&#34;&gt;进程同步&lt;/h4&gt;
&lt;h5 id=&#34;临界资源与临界区&#34;&gt;临界资源与临界区&lt;/h5&gt;
&lt;p&gt;临界资源：一次只能供一个进程使用的资源&lt;/p&gt;
&lt;p&gt;对临界资源进行访问的那段代码称为临界区&lt;/p&gt;
&lt;h5 id=&#34;互斥-同步与通信&#34;&gt;互斥、同步与通信&lt;/h5&gt;
&lt;p&gt;进程通信的详细内容看后续章节，这里只是先简单描述一下它们之间在概念上的异同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥：解决进程间竞争关系（间接制约关系）的手段
&lt;ul&gt;
&lt;li&gt;互斥比较好理解，就是解决进程间的竞争，最典型的例子就是对资源的进程，如临界资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步：解决进程间协作关系（直接制约关系）的手段
&lt;ul&gt;
&lt;li&gt;进程间有时需要合作完成某项任务，当某个进程提前完成后，需要等待其他进程完成才能继续，此时就需要进程同步来解决这个问题。也就是说，进程同步解决的是，进程间执行顺序的问题。&lt;/li&gt;
&lt;li&gt;互斥也可以看做是一种进程同步，通过资源的竞争，使得两个进程间产生了先后关系，即进程 A 必须等待进程 B 执行完才能继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信：进程间互相发送数据
&lt;ul&gt;
&lt;li&gt;进程同步也可以看做是一种进程通信，但是进程同步往往是在进程间发送信号，而不是实际的数据&lt;/li&gt;
&lt;li&gt;进程通信是一种手段，而进程同步是一种目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：https://blog.csdn.net/weixin_41413441/article/details/80548683&lt;/p&gt;
&lt;h5 id=&#34;信号量&#34;&gt;信号量&lt;/h5&gt;
&lt;p&gt;信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;down&lt;/strong&gt; : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;up&lt;/strong&gt; ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。&lt;/p&gt;
&lt;p&gt;如果信号量的取值只能为 0 或者 1，那么就成为了 &lt;strong&gt;互斥量（Mutex）&lt;/strong&gt; ，0 表示临界区已经加锁，1 表示临界区解锁。&lt;/p&gt;
&lt;h5 id=&#34;管程&#34;&gt;管程&lt;/h5&gt;
&lt;p&gt;也是一种解决进程同步的技术&lt;/p&gt;
&lt;p&gt;使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。&lt;/p&gt;
&lt;p&gt;它的思想是，将共享变量以及对其的操作封装起来，并且保证同一时刻只有一个进程可以进入管程&lt;/p&gt;
&lt;p&gt;进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。&lt;/p&gt;
&lt;p&gt;管程引入了 &lt;strong&gt;条件变量&lt;/strong&gt; 以及相关的操作：&lt;strong&gt;wait()&lt;/strong&gt; 和 &lt;strong&gt;signal()&lt;/strong&gt; 来实现同步操作。对&lt;strong&gt;条件变量&lt;/strong&gt;执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。对&lt;strong&gt;条件变量&lt;/strong&gt;执行 signal() 操作会唤醒被阻塞的进程。&lt;/p&gt;
&lt;p&gt;参考：https://www.cnblogs.com/xidongyu/p/10891303.html&lt;/p&gt;
&lt;p&gt;可以看“生产者-消费者问题”中管程的实现加深对管程的理解&lt;/p&gt;
&lt;h5 id=&#34;经典进程同步问题&#34;&gt;经典进程同步问题&lt;/h5&gt;
&lt;h6 id=&#34;生产者-消费者问题&#34;&gt;生产者-消费者问题&lt;/h6&gt;
&lt;p&gt;问题描述：使用一个缓冲区来保存物品，缓冲区容量为 N，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 信号量 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下 3 段话用于帮助理解代码，基础好的同学也可直接看代码进行理解。&lt;/p&gt;
&lt;p&gt;因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。&lt;/p&gt;
&lt;p&gt;为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。&lt;/p&gt;
&lt;p&gt;注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 &lt;code&gt;down(mutex)&lt;/code&gt; 再执行 &lt;code&gt;down(empty)&lt;/code&gt;。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 &lt;code&gt;down(empty)&lt;/code&gt; 操作，发现 &lt;code&gt;empty = 0&lt;/code&gt;，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 &lt;code&gt;up(empty)&lt;/code&gt; 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        // produce_item
        down(empty);
        // 临界区开始
        down(mutex);
        // insert item to 缓冲区（临界资源）
        up(mutex);
        // 临界区结束
        up(full);
    }
}

void consumer() {
    while(TRUE) {
        down(full);
        // 临界区开始
        down(mutex);
        // get item from 缓冲区（临界资源）
        // consume_item
        up(mutex);
        // 临界区结束
        up(empty);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用 管程 实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-pascal&#34;&gt;// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        // produce_item
        ProducerConsumer.insert();
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        ProducerConsumer.remove();
        // consume_item
    end
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;哲学家进餐问题&#34;&gt;哲学家进餐问题&lt;/h6&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误解法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;信号量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了防止死锁的发生，可以设置两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须同时拿起左右两根筷子；&lt;/li&gt;
&lt;li&gt;只有在两个邻居都没有进餐的情况下才允许进餐。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码的讲解，建议搭配代码一起看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过 mutex 保证临界资源 state 数组同一时刻只有一个进程可以访问&lt;/li&gt;
&lt;li&gt;在这个前提下，就可以根据 state 数组的状态来进行后续的操作&lt;/li&gt;
&lt;li&gt;对于每个哲学家，在 eat() 之前都需要 down()，而在 down() 之前会判断左右两边的 state 数组
&lt;ul&gt;
&lt;li&gt;如果左右两边的哲学家都不是 EATING 的状态，则会 up() 并将自身状态设置成 EATING&lt;/li&gt;
&lt;li&gt;如果左右两边的哲学家存在 EATING 的状态，则不会进行任何操作，在 down() 时等待身边的哲学家吃完&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define N 5
typedef int semaphore;

int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界资源是 state 数组，对其修改需要互斥

semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        // think
        take_two(i);
        // eat
        put_two(i);
    }
}

void take_two(int i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = HUNGRY;
    check(i);
    up(mutex);
    // state 的临界区 结束
    down(s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = THINKING;
    // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(LEFT);
    check(RIGHT);
    up(mutex);
    // state 的临界区 结束
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(s[i])，使得 down(s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;amp;&amp;amp; state[LEFT] != EATING &amp;amp;&amp;amp; state[RIGHT] != EATING) {
        state[i] = EATING;
        up(s[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;读者-写者问题&#34;&gt;读者-写者问题&lt;/h6&gt;
&lt;p&gt;问题描述：允许多个进程同时对数据进行读操作，但是不允许 读和写 以及 写和写 操作同时发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用信号量实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef int semaphore;
semaphore count_mutex = 1;
int count = 0;

semaphore data_mutex = 1;

void reader() {
    while(TRUE) {
        down(count_mutex);
        count++;
        if(count == 1) down(data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(count_mutex);
        // read
        down(count_mutex);
        count--;
        if(count == 0) up(data_mutex);
        up(count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(data_mutex);
        // write
        up(data_mutex);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;进程通信-ipc&#34;&gt;进程通信 IPC&lt;/h4&gt;
&lt;p&gt;进程通信 与 进程同步 之间的关系，可以见上文“互斥、同步与通信”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管道是通过调用 pipe 函数创建的，filedes[0] 用于读，filedes[1] 用于写。&lt;/p&gt;
&lt;p&gt;由 pipe 函数为 filedes 数组进行赋值，之后，可以通过 read write 函数进行读写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;unistd.h&amp;gt;

int filedes[2];
pipe( filedes );

read( filedes[0], buf, sizeof(buf) );
write( filedes[1], s, sizeof(s) );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只支持半双工通信（单向交替传输）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只能在父子进程或者兄弟进程中使用&lt;/p&gt;
  &lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;FIFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也称为命名管道，去除了管道只能在父子进程中使用的限制。&lt;/p&gt;
&lt;p&gt;之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。&lt;/p&gt;
&lt;p&gt;FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png&#34; alt=&#34;img&#34; style=&#34;zoom:65%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比于 FIFO，消息队列具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；&lt;/li&gt;
&lt;li&gt;避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；&lt;/li&gt;
&lt;li&gt;读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是一个计数器，用于为多个进程提供对共享数据对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。&lt;/p&gt;
&lt;p&gt;需要使用信号量用来同步对共享存储的访问。&lt;/p&gt;
&lt;p&gt;多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。&lt;/p&gt;
&lt;p&gt;共享内存使用的不是文件，而是内存的匿名段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;套接字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其它通信机制不同的是，它可用于不同机器间的进程通信&lt;/p&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;h4 id=&#34;必要条件&#34;&gt;必要条件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;互斥：每个资源要么已经分配给了一个进程，要么就是可用的。&lt;/li&gt;
&lt;li&gt;占有和等待：已经得到了某个资源的进程可以再请求新的资源。&lt;/li&gt;
&lt;li&gt;不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。&lt;/li&gt;
&lt;li&gt;环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;处理方法&#34;&gt;处理方法&lt;/h4&gt;
&lt;h5 id=&#34;鸵鸟策略&#34;&gt;鸵鸟策略&lt;/h5&gt;
&lt;p&gt;方法：把头埋在沙子里，假装根本没发生问题。&lt;/p&gt;
&lt;p&gt;原理：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。&lt;/p&gt;
&lt;p&gt;适用场景：当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。&lt;/p&gt;
&lt;p&gt;大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。&lt;/p&gt;
&lt;h5 id=&#34;死锁检测与死锁恢复&#34;&gt;死锁检测与死锁恢复&lt;/h5&gt;
&lt;p&gt;不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每种类型的资源只有一个的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即，对于每种类型的资源，被使用了，别的进程就不能再使用了&lt;/p&gt;
&lt;p&gt;有向图判环：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b1fa0453-a4b0-4eae-a352-48acca8fff74.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。&lt;/p&gt;
&lt;p&gt;图 a 可以抽取出环，如图 b 所示，它满足了环路等待条件，因此会发生死锁。&lt;/p&gt;
&lt;p&gt;该死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每种类型的资源有多个的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即，对于每种类型的资源，存在多个，被进程 A 使用了 1 个后，还有其他实例可以供其他进程使用&lt;/p&gt;
&lt;p&gt;银行家算法：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;上图中，有 3 个进程 4 个资源，每个数据代表的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E 向量：资源总量&lt;/li&gt;
&lt;li&gt;A 向量：资源剩余量&lt;/li&gt;
&lt;li&gt;C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量&lt;/li&gt;
&lt;li&gt;R 矩阵：每个进程请求的资源数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。&lt;/p&gt;
&lt;p&gt;算法总结如下：&lt;/p&gt;
&lt;p&gt;每个进程最开始时都不被标记，算法执行过程对进程进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。&lt;/li&gt;
&lt;li&gt;如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。&lt;/li&gt;
&lt;li&gt;如果没有这样一个进程，算法终止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;死锁恢复&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用抢占恢复&lt;/li&gt;
&lt;li&gt;利用回滚恢复
&lt;ul&gt;
&lt;li&gt;假设进程 A 等待资源，进程 B 占用该资源，则对进程 B 进行回滚并将资源分配给进程 A，从而实现死锁恢复。参考：https://blog.csdn.net/zhangxiaojiakele/article/details/106034016&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过杀死进程恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;死锁预防&#34;&gt;死锁预防&lt;/h5&gt;
&lt;p&gt;在程序运行之前预防发生死锁&lt;/p&gt;
&lt;p&gt;破坏 死锁 发生的必要条件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏互斥条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，“假脱机打印机技术”允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏占有和等待条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种实现方式是，规定所有进程在开始执行前请求所需要的全部资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏不可抢占条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;破坏环路等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给资源统一编号，进程只能按编号顺序来请求资源&lt;/p&gt;
&lt;h5 id=&#34;死锁避免&#34;&gt;死锁避免&lt;/h5&gt;
&lt;p&gt;在程序运行时避免发生死锁&lt;/p&gt;
&lt;p&gt;在为进程分配资源前进行检查，如果发现此次资源分配将导致死锁，则拒绝给该进程分配资源&lt;/p&gt;
&lt;p&gt;安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/ed523051-608f-4c3f-b343-383e2d194470.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。&lt;/p&gt;
&lt;p&gt;死锁避免，就是避免进入不安全状态。&lt;/p&gt;
&lt;p&gt;使用 银行家算法 判断某状态是否为 安全状态&lt;/p&gt;
&lt;h5 id=&#34;检测-vs-预防-vs-避免&#34;&gt;检测 VS 预防 VS 避免&lt;/h5&gt;
&lt;p&gt;检测，是判断当前状态是否发生了死锁&lt;/p&gt;
&lt;p&gt;预防，是不给死锁发生的机会&lt;/p&gt;
&lt;p&gt;避免，是死锁可能发生，但是避免其发生，例如，避免进入不安全状态。&lt;/p&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理&lt;/h3&gt;
&lt;h4 id=&#34;分页机制&#34;&gt;分页机制&lt;/h4&gt;
&lt;p&gt;通过 分页机制 可以实现 虚拟内存&lt;/p&gt;
&lt;p&gt;虚拟内存的目的是为了将物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存&lt;/p&gt;
&lt;p&gt;为了更好的管理内存，操作系统将内存抽象成若干地址空间。同时，地址空间又被分割成多个块，每一块称为一页，因此每页中都包含若干地址空间。&lt;/p&gt;
&lt;p&gt;这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的操作，将缺失的部分装入物理内存并重新执行失败的指令。&lt;/p&gt;
&lt;p&gt;从上面的描述中可以看出，虚拟内存允许操作系统不用将地址空间中的每一页都映射到物理内存，也就是说一个程序所使用的所有页不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7b281b1e-0595-402b-ae35-8c91084c33c1.png&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;例如，有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，因此，通过 虚拟内存技术 便可以在该计算机运行一个 64K 大小的程序。&lt;/p&gt;
&lt;p&gt;分页内存管理机制，对于程序来说是透明的，对于程序来说，它只知道地址空间是 0~64K，但其实物理内存空间只有 32KB，在运行过程中，是通过操作系统进行控制的，使得程序感觉上就像在 64KB 的物理内存上运行。&lt;/p&gt;
&lt;h5 id=&#34;分页系统的地址映射&#34;&gt;分页系统的地址映射&lt;/h5&gt;
&lt;p&gt;内存管理单元（MMU）管理着地址空间和物理内存的转换，其中，页表存储着页（地址空间）和页框（物理内存）的映射表。&lt;/p&gt;
&lt;p&gt;一个虚拟地址空间分成两个部分，一部分存储页面号，一部分存储偏移量。&lt;/p&gt;
&lt;p&gt;根据页面号，可以定位到页表中的特定行，然后从该行中获取物理内存地址前缀，与偏移量合并，得到物理内存地址。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;上图的页表存放着 16 个页（16行），这 16 个页需要用 4 个比特位来进行索引定位（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^4=16&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;例如，对于虚拟地址（0010 000000000100）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据前 4 位（0010）得知页面号为2，从页表第 2 行读取内容：110 1，其中，前 3 位为物理内存地址前缀，第 4 位表示是否存在于内存中，1 表示存在。&lt;/li&gt;
&lt;li&gt;后 12 位存储偏移量，结合刚才的物理内存地址前缀（110），这个页对应的页框的地址为 （110 000000000100）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h5&gt;
&lt;p&gt;在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。&lt;/p&gt;
&lt;p&gt;页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。&lt;/p&gt;
&lt;p&gt;页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳 OPT Optimal replacement algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择最长时间不再被访问的页面，将其置换。因为是最长时间不被访问的页面，所以可以保证获得最低的缺页率&lt;/p&gt;
&lt;p&gt;这是一种理论算法，无法实现，因为无法获知哪个页面在未来最长时间不被访问&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;系统为某进程分配了三个物理块，并有如下页面引用序列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为站在上帝视角，我们知道页面 7 再次被访问的时间最长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近最久未使用 LRU Least Recently Used&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然无法知道未来页面的使用情况，但是可以知道过去页面的使用情况。&lt;/p&gt;
&lt;p&gt;LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的。&lt;/p&gt;
&lt;p&gt;因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近未使用 NRU Not Recently Used&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。&lt;/p&gt;
&lt;p&gt;其中 R 位会定时被清零。&lt;/p&gt;
&lt;p&gt;将页面分成以下四&lt;strong&gt;类&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：R=0，M=0&lt;/li&gt;
&lt;li&gt;1：R=0，M=1&lt;/li&gt;
&lt;li&gt;2：R=1，M=0&lt;/li&gt;
&lt;li&gt;3：R=1，M=1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发生缺页中断时，NRU 算法随机地从&lt;strong&gt;类&lt;/strong&gt;编号最小的非空类中挑选一个页面将它换出。&lt;/p&gt;
&lt;p&gt;NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先进先出 FIFO First In First Out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择换出的页面是最先进入的页面。&lt;/p&gt;
&lt;p&gt;该算法会将那些经常被访问的页面换出，导致缺页率升高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次机会算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改。&lt;/p&gt;
&lt;p&gt;当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时钟 Clock&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;分段机制&#34;&gt;分段机制&lt;/h4&gt;
&lt;p&gt;现在，请先忘掉分页机制，分段机制是一种独立的机制，和分页机制无关。&lt;/p&gt;
&lt;p&gt;分段机制的设计思想是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护&lt;/p&gt;
&lt;p&gt;一般情况下，程序在运行时都会在内存中存储程序代码和数据，存储程序代码是为了能让程序执行下去（总要把下一行要执行的代码放到内存中吧，不然系统哪知道应该做什么）&lt;/p&gt;
&lt;p&gt;基于这个现象，操作系统内存管理分段机制允许程序拥有多个段，在不同段中存储不同类型的数据，且段的大小是可变的。程序无需知道段在物理内存中的位置，只需要使用段偏移量进行访问即可，在程序运行时，操作系统会把段映射到实际的内存空间中。例如，段偏移量是 0000~0100，那么程序实际运行时，会把段映射到 xxxx0000~xxxx0100&lt;/p&gt;
&lt;p&gt;因此，分段机制中是不涉及虚拟内存的&lt;/p&gt;
&lt;h4 id=&#34;分页-vs-分段&#34;&gt;分页 VS 分段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;空间大小是否可变：分页机制不可变；分段机制可变
&lt;ul&gt;
&lt;li&gt;分页存在覆盖问题：假设页的长度是100，那么程序在访问到 xxx101 时就会出错（xxx为页面号；为了方便，用的是十进制），因为根据地址映射，会把页面号进行替换，得到物理内存地址，但是因为页的长度是 100，所以其实本质上已经访问到下一页了，就会出现覆盖问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透明性：分页对程序是透明的，分段是不透明的&lt;/li&gt;
&lt;li&gt;目的：
&lt;ul&gt;
&lt;li&gt;分页主要用于实现虚拟内存，从而获得更大的地址空间&lt;/li&gt;
&lt;li&gt;分段主要为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;段页式&#34;&gt;段页式&lt;/h4&gt;
&lt;p&gt;程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2019040522291138.png&#34; alt=&#34;img&#34; style=&#34;zoom:100%;&#34; /&gt;
&lt;p&gt;根据段号和段表，获取页表，根据页号和页表，获取物理内存空间前缀，最后根据页内偏移计算出物理地址。&lt;/p&gt;
&lt;p&gt;一个程序拥有多个段，每个段包含多个页，每个页会被映射到物理内存&lt;/p&gt;
&lt;h3 id=&#34;磁盘&#34;&gt;磁盘&lt;/h3&gt;
&lt;h4 id=&#34;磁盘结构&#34;&gt;磁盘结构&lt;/h4&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/014fbc4d-d873-4a12-b160-867ddaed9807.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;盘面（Platter）：一个磁盘有多个盘面；&lt;/li&gt;
&lt;li&gt;磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；&lt;/li&gt;
&lt;li&gt;扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；&lt;/li&gt;
&lt;li&gt;磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；&lt;/li&gt;
&lt;li&gt;制动手臂（Actuator arm）：用于在磁道之间移动磁头；&lt;/li&gt;
&lt;li&gt;主轴（Spindle）：使整个盘面转动。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;磁盘调度算法&#34;&gt;磁盘调度算法&lt;/h4&gt;
&lt;p&gt;读写一个磁盘块的时间的影响因素有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旋转时间：主轴转动盘面，使得磁头移动到适当的扇区上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寻道时间&lt;/strong&gt;：制动手臂移动，使得磁头移动到适当的磁道上&lt;/li&gt;
&lt;li&gt;实际的数据传输时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，&lt;strong&gt;寻道时间&lt;/strong&gt;最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先来先服务 FCFS First Come First Served&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照磁盘请求的顺序进行调度。&lt;/p&gt;
&lt;p&gt;优点是公平和简单。&lt;/p&gt;
&lt;p&gt;缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短寻道时间优先 SSTF Shortest Seek Time First&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优先调度与当前磁头所在磁道距离最近的磁道。&lt;/p&gt;
&lt;p&gt;虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/4e2485e4-34bd-4967-9f02-0c093b797aaa.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;电梯算法 SCAN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。&lt;/p&gt;
&lt;p&gt;电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。&lt;/p&gt;
&lt;p&gt;因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/271ce08f-c124-475f-b490-be44fedc6d2e.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;
&lt;h4 id=&#34;链接系统&#34;&gt;链接系统&lt;/h4&gt;
&lt;p&gt;以下是一个 hello.c 程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
    printf(&amp;quot;hello, world\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Unix 系统上，由编译器把源文件转换为目标文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -o hello hello.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个过程大致如下：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：处理以 # 开头的预处理命令；&lt;/li&gt;
&lt;li&gt;编译阶段：翻译成汇编文件；&lt;/li&gt;
&lt;li&gt;汇编阶段：将汇编文件翻译成可重定位目标文件；&lt;/li&gt;
&lt;li&gt;链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可执行目标文件：可以直接在内存中执行；&lt;/li&gt;
&lt;li&gt;可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；&lt;/li&gt;
&lt;li&gt;共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;静态链接&#34;&gt;静态链接&lt;/h4&gt;
&lt;p&gt;静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。&lt;/li&gt;
&lt;li&gt;重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h4 id=&#34;动态链接&#34;&gt;动态链接&lt;/h4&gt;
&lt;p&gt;静态库有以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当静态库更新时那么整个程序都要重新进行链接；&lt;/li&gt;
&lt;li&gt;对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；&lt;/li&gt;
&lt;li&gt;在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;面试重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令：cat（文件）、grep（查找指令）、cut（管道指令）
&lt;ul&gt;
&lt;li&gt;括号中标出来这些指令所在的章节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件：实体链接与符号链接&lt;/li&gt;
&lt;li&gt;进程管理：SIGCHLD、僵尸进程与孤儿进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用指令&#34;&gt;常用指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;快捷键&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tab：命令和文件名补全；&lt;/li&gt;
&lt;li&gt;Ctrl+C：中断正在运行的程序；&lt;/li&gt;
&lt;li&gt;Ctrl+D：结束键盘输入（End Of File，EOF）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询指令用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/usr/share/doc 目录中存放着大部分软件的一整套说明文件&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145459251.png&#34; alt=&#34;image-20220104145459251&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;code&gt;--help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指令的基本用法与选项介绍&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;man 是 manual 的缩写，将指令的具体信息显示出来&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145001620.png&#34; alt=&#34;image-20220104145001620&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型&lt;/p&gt;
&lt;p&gt;常用的数字及其类型如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代号&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;用户在 shell 环境中可以操作的指令或者可执行文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td&gt;配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td&gt;系统管理员可以使用的管理指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;info&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;who&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在关机前需要先使用 who 命令查看有没有其它用户在线&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;环境变量 PATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在环境变量 PATH 中声明可执行文件的路径&lt;/p&gt;
&lt;p&gt;路径之间用 &lt;code&gt;:&lt;/code&gt; 分隔&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sudo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo 允许一般用户使用 root 可执行的命令&lt;/p&gt;
&lt;p&gt;不过只有在 &lt;code&gt;/etc/sudoers&lt;/code&gt; 配置文件中添加的用户才能使用该指令&lt;/p&gt;
&lt;h3 id=&#34;vim-的三个模式&#34;&gt;Vim 的三个模式&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191209002818626.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;一般指令模式：VIM 的默认模式，可以用于移动游标查看内容；&lt;/li&gt;
&lt;li&gt;编辑模式：按下 &amp;quot;i&amp;quot; 等按键之后进入，可以对文本进行编辑；&lt;/li&gt;
&lt;li&gt;指令列模式：按下 &amp;quot;:&amp;quot; 按键之后进入，用于保存退出等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 指令列模式 下，有以下命令用于离开或者保存文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写入磁盘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:w!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:q&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;离开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:q!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;强制离开不保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:wq&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写入磁盘后离开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:wq!&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;强制写入磁盘后离开&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;文件系统理论部分&#34;&gt;文件系统（理论部分）&lt;/h3&gt;
&lt;h4 id=&#34;组成&#34;&gt;组成&lt;/h4&gt;
&lt;p&gt;最主要的几个组成部分如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；&lt;/li&gt;
&lt;li&gt;block：记录文件的内容，文件太大时，会占用多个 block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外还包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;block bitmap：记录 block 是否被使用的位图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件读取&#34;&gt;文件读取&lt;/h4&gt;
&lt;p&gt;对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h4 id=&#34;磁盘碎片&#34;&gt;磁盘碎片&lt;/h4&gt;
&lt;p&gt;指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。&lt;/p&gt;
&lt;h4 id=&#34;block&#34;&gt;block&lt;/h4&gt;
&lt;p&gt;在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1KB&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2KB&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4KB&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最大单一文件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16GB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;256GB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2TB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最大文件系统&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16TB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。&lt;/p&gt;
&lt;h4 id=&#34;inode&#34;&gt;inode&lt;/h4&gt;
&lt;p&gt;inode 具体包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权限 (read/write/excute)；&lt;/li&gt;
&lt;li&gt;拥有者与群组 (owner/group)；&lt;/li&gt;
&lt;li&gt;容量；&lt;/li&gt;
&lt;li&gt;建立或状态改变的时间 (ctime)；&lt;/li&gt;
&lt;li&gt;最近读取时间 (atime)；&lt;/li&gt;
&lt;li&gt;最近修改时间 (mtime)；&lt;/li&gt;
&lt;li&gt;定义文件特性的旗标 (flag)，如 SetUID...；&lt;/li&gt;
&lt;li&gt;该文件真正内容的指向 (pointer)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inode 具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 inode 大小均固定为 128 bytes&lt;/li&gt;
&lt;li&gt;每个文件都仅会占用一个 inode。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。&lt;/p&gt;
&lt;h4 id=&#34;目录&#34;&gt;目录&lt;/h4&gt;
&lt;p&gt;目录，也可以理解成文件夹&lt;/p&gt;
&lt;p&gt;建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。&lt;/p&gt;
&lt;p&gt;可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。&lt;/p&gt;
&lt;p&gt;为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/ (root)：根目录&lt;/li&gt;
&lt;li&gt;/usr (unix software resource)：所有系统默认软件都会安装到这个目录&lt;/li&gt;
&lt;li&gt;/var (variable)：存放系统或程序运行过程中的数据文件&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/linux-filesystem.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h3 id=&#34;文件实践部分&#34;&gt;文件（实践部分）&lt;/h3&gt;
&lt;h4 id=&#34;文件属性&#34;&gt;文件属性&lt;/h4&gt;
&lt;p&gt;用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。&lt;/p&gt;
&lt;p&gt;使用 ls 查看一个文件时，会显示一个文件的信息，例如 &lt;code&gt;drwxr-xr-x 3 root root 17 May 6 00:14 .config&lt;/code&gt;，对这个信息的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段&lt;/li&gt;
&lt;li&gt;3：链接数&lt;/li&gt;
&lt;li&gt;root：文件拥有者&lt;/li&gt;
&lt;li&gt;root：所属群组&lt;/li&gt;
&lt;li&gt;17：文件大小&lt;/li&gt;
&lt;li&gt;May 6 00:14：文件最后被修改的时间&lt;/li&gt;
&lt;li&gt;.config：文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的文件类型及其含义有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d：目录&lt;/li&gt;
&lt;li&gt;-：文件&lt;/li&gt;
&lt;li&gt;l：链接文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。&lt;/p&gt;
&lt;p&gt;文件时间可使用 stat 指令查看&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220104155901036.png&#34; alt=&#34;image-20220104155901036&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;三种文件时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modification time (mtime)：文件的内容更新就会更新；&lt;/li&gt;
&lt;li&gt;status time (ctime)：文件的状态（权限、属性）更新就会更新；&lt;/li&gt;
&lt;li&gt;access time (atime)：读取文件时就会更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件与目录的基本操作指令&#34;&gt;文件与目录的基本操作指令&lt;/h4&gt;
&lt;p&gt;本节主要列出了 8 个基本操作指令，已经掌握的同学可直接跳过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. ls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出文件或者目录的信息，目录的信息就是其中包含的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. cd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更换当前目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;cd [相对路径或绝对路径]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. mkdir&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. rmdir&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除目录，目录必须为空。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;rmdir [-p] 目录名称
-p ：递归删除目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. touch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新文件时间或者建立新文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&amp;quot;日期或时间&amp;quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6. cp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7. rm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## rm [-fir] 文件或目录
-r ：递归删除
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8. mv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;移动文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;权限&#34;&gt;权限&lt;/h4&gt;
&lt;h5 id=&#34;修改权限&#34;&gt;修改权限&lt;/h5&gt;
&lt;p&gt;可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod [-R] xyz dirname/filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod 754 .bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用符号来设定权限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：为 .bashrc 文件的所有用户添加写权限。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## chmod a+w .bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;默认权限&#34;&gt;默认权限&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。&lt;/li&gt;
&lt;li&gt;目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。&lt;/p&gt;
&lt;h5 id=&#34;目录的权限&#34;&gt;目录的权限&lt;/h5&gt;
&lt;p&gt;文件名不是存储在一个文件的内容中，而是存储在该文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。&lt;/p&gt;
&lt;p&gt;目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。&lt;/p&gt;
&lt;h4 id=&#34;实体链接-vs-符号链接&#34;&gt;实体链接 VS 符号链接&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实体链接，也叫，硬链接&lt;/p&gt;
&lt;p&gt;符号链接，也叫，软连接&lt;/p&gt;
&lt;p&gt;两者关系如图：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;如果不理解，可继续看下面的解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。&lt;/p&gt;
&lt;p&gt;删除任意一个条目，文件还是存在，只要引用数量不为 0。&lt;/p&gt;
&lt;p&gt;有以下限制：不能跨越文件系统、不能对目录进行链接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为什么不能对目录创建实体链接&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;因为，目录是支持 &lt;code&gt;cd ../&lt;/code&gt; 操作的，因此，如果像文件那样，只是在目录中添加 inode 编号，那么带来的问题就是，在实体链接目录 /d1/d2 中执行 &lt;code&gt;cd ../&lt;/code&gt; 可能会跳转到 /d3 中，也就是说，会发现目录错位的现象。为了解决这个问题，那就需要真正创建一个目录，并在目录中为每个文件创建实体链接，但是这样的成本太高了，因此 操作系统禁止用户这么做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举例来说，如果你要将 /etc 使用硬链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下的所有文件名同时都与 /etc 下面的文件名要创建硬链接的，而不是仅仅连接到 /etc 和 /etc_hd 而已。并且，将来如果需要在 /etc_hd 目录下创建新文件时，连带的，/etc 下面的数据又得要创建一次硬链接。因此造成环境相当大的复杂度，所以是不支持链接目录的。&lt;/p&gt;
&lt;p&gt;by 鸟哥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实，Linux 中是存在目录的实体链接的，比如，&lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt;，但是 Linux 不允许用户创建实体链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;符号链接保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。&lt;/p&gt;
&lt;p&gt;当源文件被删除了，链接文件就打不开了。&lt;/p&gt;
&lt;p&gt;因为记录的是路径，所以可以为目录建立符号链接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&amp;gt; /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-个获取文件内容指令&#34;&gt;7 个获取文件内容指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. cat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取得文件内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. tac&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 cat 的反向操作，从最后一行开始打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. more&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. less&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和 more 类似，但是多了一个向前翻页的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. head&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取得文件前几行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## head [-n number] filename
-n ：后面接数字，代表显示几行的意思
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6. tail&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 head 的反向操作，只是取得是后几行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. od&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以字符或者十六进制的形式显示二进制文件。&lt;/p&gt;
&lt;h4 id=&#34;4-个搜索指令&#34;&gt;4 个搜索指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. which&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指令搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## which [-a] command
-a ：将所有指令列出，而不是只列第一个
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. whereis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。速度比较快，因为它只搜索几个特定的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## whereis [-bmsu] dirname/filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. locate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。可以用关键字或者正则表达式进行搜索。&lt;/p&gt;
&lt;p&gt;locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## locate [-ir] keyword
-r：正则表达式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. find&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件搜索。可以使用文件的属性和权限进行搜索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;## find [basedir] [option]
example: find . -name &amp;quot;shadow*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;① 与时间有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;+4、4 和 -4 的指示的时间范围如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/658fc5e7-79c0-4247-9445-d69bf194c539.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;② 与文件拥有者和所属群组有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;③ 与文件权限和名称有关的选项&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;压缩与打包&#34;&gt;压缩与打包&lt;/h3&gt;
&lt;h4 id=&#34;压缩文件名&#34;&gt;压缩文件名&lt;/h4&gt;
&lt;p&gt;Linux 底下有很多压缩文件名，常见的如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;扩展名&lt;/th&gt;
&lt;th&gt;压缩程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*.Z&lt;/td&gt;
&lt;td&gt;compress&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.zip&lt;/td&gt;
&lt;td&gt;zip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.gz&lt;/td&gt;
&lt;td&gt;gzip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.bz2&lt;/td&gt;
&lt;td&gt;bzip2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.xz&lt;/td&gt;
&lt;td&gt;xz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar&lt;/td&gt;
&lt;td&gt;tar 程序打包的数据，没有经过压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.gz&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 gzip 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.bz2&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 bzip2 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.tar.xz&lt;/td&gt;
&lt;td&gt;tar 程序打包的文件，经过 xz 的压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;3-个压缩指令&#34;&gt;3 个压缩指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. gzip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。&lt;/p&gt;
&lt;p&gt;经过 gzip 压缩过，源文件就不存在了。&lt;/p&gt;
&lt;p&gt;有 9 个不同的压缩等级可以使用。&lt;/p&gt;
&lt;p&gt;可以使用 zcat、zmore、zless 来读取压缩文件的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. bzip2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供比 gzip 更高的压缩比。&lt;/p&gt;
&lt;p&gt;查看命令：bzcat、bzmore、bzless、bzgrep。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ bzip2 [-cdkzv#] filename
-k ：保留源文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. xz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供比 bzip2 更佳的压缩比。&lt;/p&gt;
&lt;p&gt;可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。&lt;/p&gt;
&lt;p&gt;查看命令：xzcat、xzmore、xzless、xzgrep。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ xz [-dtlkc#] filename
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;打包指令&#34;&gt;打包指令&lt;/h4&gt;
&lt;p&gt;压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;使用方式&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打包压缩&lt;/td&gt;
&lt;td&gt;tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;查 看&lt;/td&gt;
&lt;td&gt;tar -jtv -f filename.tar.bz2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;解压缩&lt;/td&gt;
&lt;td&gt;tar -jxv -f filename.tar.bz2 -C 要解压缩的目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;bash&#34;&gt;Bash&lt;/h3&gt;
&lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;p&gt;Bash 是 Shell 的一种&lt;/p&gt;
&lt;p&gt;Shell 指的是一类程序，通过 Shell 程序，可以把我们的命令传递给内核，从而调用计算机硬件执行相关的操作，之后再把执行结果翻译成自然语言，呈现在我们面前。&lt;/p&gt;
&lt;p&gt;Bash 是当前大多数 Linux 发行版的默认Shell&lt;/p&gt;
&lt;h4 id=&#34;特性&#34;&gt;特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;命令历史：记录使用过的命令&lt;/li&gt;
&lt;li&gt;命令与文件补全：快捷键：tab&lt;/li&gt;
&lt;li&gt;命名别名：例如 ll 是 ls -al 的别名&lt;/li&gt;
&lt;li&gt;shell scripts&lt;/li&gt;
&lt;li&gt;通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;变量操作&#34;&gt;变量操作&lt;/h4&gt;
&lt;p&gt;对一个变量赋值直接使用 =。&lt;/p&gt;
&lt;p&gt;对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；&lt;/p&gt;
&lt;p&gt;输出变量使用 echo 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ x=abc
$ echo $x
$ echo ${x}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量内容如果有空格，必须使用双引号或者单引号。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号内的特殊字符可以保留原本特性，例如 x=&amp;quot;lang is $LANG&amp;quot;，则 x 的值为 lang is zh_TW.UTF-8；&lt;/li&gt;
&lt;li&gt;单引号内的特殊字符就是特殊字符本身，例如 x=&#39;lang is $LANG&#39;，则 x 的值为 lang is $LANG。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。&lt;/p&gt;
&lt;p&gt;可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。&lt;/p&gt;
&lt;p&gt;Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 [ ] 来对数组进行索引操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;指令搜索顺序&#34;&gt;指令搜索顺序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；&lt;/li&gt;
&lt;li&gt;由别名找到该指令来执行；&lt;/li&gt;
&lt;li&gt;由 Bash 内置的指令来执行；&lt;/li&gt;
&lt;li&gt;按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据流重定向&#34;&gt;数据流重定向&lt;/h4&gt;
&lt;p&gt;重定向指的是使用文件代替标准输入、标准输出和标准错误输出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;运算符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准输入 (stdin)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt; 或 &amp;lt;&amp;lt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准输出 (stdout)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;gt; 或 &amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标准错误输出 (stderr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&amp;gt; 或 2&amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，有一个箭头的表示以覆盖的方式重定向，而 有两个箭头的表示以追加的方式重定向。&lt;/p&gt;
&lt;p&gt;可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。&lt;/p&gt;
&lt;p&gt;如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&amp;gt;&amp;amp;1 表示将标准错误输出转换为标准输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ find /home -name .bashrc &amp;gt; list 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;管道指令&#34;&gt;管道指令&lt;/h3&gt;
&lt;p&gt;管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。&lt;/p&gt;
&lt;p&gt;在命令之间使用 | 分隔各个管道命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -al /etc | less
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提取指令 cut&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cut 对数据进行切分，取出想要的部分。&lt;/p&gt;
&lt;p&gt;切分过程一行一行地进行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 1：last 显示登入者的信息，取出用户名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d &#39; &#39; -f 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ export
declare -x HISTCONTROL=&amp;quot;ignoredups&amp;quot;
declare -x HISTSIZE=&amp;quot;1000&amp;quot;
declare -x HOME=&amp;quot;/home/dmtsai&amp;quot;
declare -x HOSTNAME=&amp;quot;study.centos.vbird&amp;quot;
.....(其他省略).....

$ export | cut -c 12-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;排序指令 sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort 用于排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ cat /etc/passwd | sort -t &#39;:&#39; -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;去重指令 uniq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uniq 可以将重复的数据只取一个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：取得每个人的登录总次数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last | cut -d &#39; &#39; -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;双向输出重定向指令 tee&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出重定向会将输出内容重定向到文件中，而 &lt;strong&gt;tee&lt;/strong&gt; 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tee [-a] file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5 个字符转换指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tr&lt;/code&gt; 用来删除一行中的字符，或者对字符进行替换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例，将 last 输出的信息所有小写转换为大写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last | tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;col&lt;/code&gt; 将 tab 字符转为空格字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;expand&lt;/code&gt; 将 tab 转换一定数量的空格，默认是 8 个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ expand [-t] file
-t ：tab 转为空格的数量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;join&lt;/code&gt; 将有相同数据的那一行合并在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;paste&lt;/code&gt; 直接将两行粘贴在一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分区指令 split&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;split 将一个文件划分成多个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找指令-grep&#34;&gt;查找指令 grep&lt;/h3&gt;
&lt;p&gt;g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep -n &#39;the&#39; regular_express.txt
8:I can&#39;t finish the test.
12:the symbol &#39;*&#39; is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &amp;quot;glad&amp;quot;.
18:google is the best tools for search keyword
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ grep -n &#39;a\{2,5\}&#39; regular_express.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-个格式化输出指令&#34;&gt;2 个格式化输出指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;printf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ printf &#39;%10s %5i %5i %5i %8.2f \n&#39; $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。&lt;/p&gt;
&lt;p&gt;awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。&lt;/p&gt;
&lt;p&gt;示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
$ last -n 5 | awk &#39;{print $1 &amp;quot;\t&amp;quot; $3}&#39;
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ awk &#39;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cat /etc/passwd | awk &#39;BEGIN {FS=&amp;quot;:&amp;quot;} $3 &amp;lt; 10 {print $1 &amp;quot;\t &amp;quot; $3}&#39;
root 0
bin 1
daemon 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk 变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;变量名称&lt;/th&gt;
&lt;th&gt;代表意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NF&lt;/td&gt;
&lt;td&gt;每一行拥有的字段总数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NR&lt;/td&gt;
&lt;td&gt;目前所处理的是第几行数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FS&lt;/td&gt;
&lt;td&gt;目前的分隔字符，默认是空格键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;示例：显示正在处理的行号以及每一行有多少字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ last -n 5 | awk &#39;{print $1 &amp;quot;\t lines: &amp;quot; NR &amp;quot;\t columns: &amp;quot; NF}&#39;
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;进程管理-2&#34;&gt;进程管理&lt;/h3&gt;
&lt;h4 id=&#34;4-个查看进程指令&#34;&gt;4 个查看进程指令&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. ps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看某个时间点的进程信息。&lt;/p&gt;
&lt;p&gt;示例：查看自己的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：查看系统所有进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps aux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：查看特定的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## ps aux | grep threadx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. pstree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看进程树。&lt;/p&gt;
&lt;p&gt;示例：查看所有进程树&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## pstree -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. top&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实时显示进程信息。&lt;/p&gt;
&lt;p&gt;示例：两秒钟刷新一次&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## top -d 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. netstat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看占用端口的进程&lt;/p&gt;
&lt;p&gt;示例：查看特定端口的进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;## netstat -anp | grep port
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;进程状态-2&#34;&gt;进程状态&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;R&lt;/td&gt;
&lt;td&gt;running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;D&lt;/td&gt;
&lt;td&gt;uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;S&lt;/td&gt;
&lt;td&gt;interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Z&lt;/td&gt;
&lt;td&gt;zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;T&lt;/td&gt;
&lt;td&gt;stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2bab4127-3e7d-48cc-914e-436be859fb05.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;h4 id=&#34;子进程的-sigchld-信号&#34;&gt;子进程的 SIGCHLD 信号&lt;/h4&gt;
&lt;p&gt;当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;得到 SIGCHLD 信号；&lt;/li&gt;
&lt;li&gt;waitpid() 或者 wait() 调用会返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。&lt;/p&gt;
&lt;p&gt;在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pid_t wait(int *status)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。&lt;/p&gt;
&lt;p&gt;如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。&lt;/p&gt;
&lt;p&gt;参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;waitpid()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pid_t waitpid(pid_t pid, int *status, int options)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。&lt;/p&gt;
&lt;p&gt;pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。&lt;/p&gt;
&lt;p&gt;options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。&lt;/p&gt;
&lt;h4 id=&#34;孤儿进程&#34;&gt;孤儿进程&lt;/h4&gt;
&lt;p&gt;一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。&lt;/p&gt;
&lt;p&gt;孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。&lt;/p&gt;
&lt;p&gt;由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。&lt;/p&gt;
&lt;h4 id=&#34;僵尸进程&#34;&gt;僵尸进程&lt;/h4&gt;
&lt;p&gt;一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。&lt;/p&gt;
&lt;p&gt;僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。&lt;/p&gt;
&lt;p&gt;系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。&lt;/p&gt;
&lt;p&gt;要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。&lt;/p&gt;
&lt;h2 id=&#34;关系型数据库&#34;&gt;关系型数据库&lt;/h2&gt;
&lt;p&gt;SQL 相关语法可以参考 &lt;a href=&#34;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E8%AF%AD%E6%B3%95.html&#34;&gt;cyc 大佬的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQL 相关练习可以参考 &lt;a href=&#34;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E7%BB%83%E4%B9%A0.html#description-15&#34;&gt;cyc 大佬的博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;sql-语法&#34;&gt;SQL 语法&lt;/h3&gt;
&lt;h4 id=&#34;内连接-自然连接-外连接&#34;&gt;内连接、自然连接、外连接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;内连接（INNER JOIN）：只显示符合 on 条件的行
&lt;ul&gt;
&lt;li&gt;自连接：自身与自身的内连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自然连接（NATURAL JOIN）：自动对同名列进行比对，不能使用 on 语句&lt;/li&gt;
&lt;li&gt;外连接（OUTER JOIN）：对于不符合 on 条件的行，对应列用 NULL 展示。分为左外连接、右外连接、全外连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符集&#34;&gt;字符集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符集（CHARACTER SET）：用于定义编号指代的字符，如，unicode、ascII、gb2312&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码：全称为编码格式，指的是具体字符集在传输和存储过程中的格式，如，utf-8、utf-16 是 unicode 的编码格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;unicode则是为了让全球能用上统一的字符集而发明的，有6万多个字符，每个字符占2个字节，比如英文a，ascII是97、unicode则是0097（示意的说法）。中文只收录最常用的6000多个汉字。unicode虽然是大一统的标准，但是在表示英文时浪费空间，并且许多古老的程序只支持ascII，unicode从标准设计上来说是不兼容ascII。正因如此在实际使用中unicode会以utf-8，utf-16等编码方式存储是传输。utf-8保持和ascII一致，英文使用1个字节，其他字符使用2-6个字节，比如中文多数是3个字节。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/liuliqiang/p/8258716.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校对字符（COLLATE）：即排序规则，用于指定字符间如何进行比较，主要用于排序和分组。例如，utf8_unicode_ci，ci 表示 Case Insensitive，即大小写无关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;什么是事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务是属于数据库中的一个概念，本质上指的是一系列的操作，但是这些操作会满足一些性质，ACID。&lt;/p&gt;
&lt;p&gt;事务可以通过 Commit 提交，也可以使用 Rollback 进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性 Atomicity：所有操作，要么全部提交，要么全部回滚。
&lt;ul&gt;
&lt;li&gt;回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; Consistency：强调数据库在逻辑上的一致性状态，依赖于原子性。比如，转账操作，要求多账户余额总和保持一致；扣款操作，要求账户余额变化与扣款金额一致。&lt;/li&gt;
&lt;li&gt;隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。&lt;/li&gt;
&lt;li&gt;持久性 Durability：当事务提交后，该事务中的一系列操作需要能被持久化到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
&lt;ul&gt;
&lt;li&gt;系统发生崩溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实，在 ACID 中，最重要的就是一致性，通过一致性，可以保证数据库时刻保持一致性的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;何为一致性状态？它指的是数据处于一种有意义的状态，这种状态是语义上的，而不是语法上的。最常见的例子就是转账，从账户 A 转一笔钱到账户 B，如果账户 A 上的钱减少了，但账户 B 上的钱没有增加，那么就认为此时数据处于不一致的状态。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/stone94/p/10409669.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在无并发的情况下，原子性 可以保证一致性&lt;/li&gt;
&lt;li&gt;在有并发的情况下，原子性+隔离性 可以保证一致性&lt;/li&gt;
&lt;li&gt;在系统发生崩溃时，持久性 可以保证一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207210437023.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;保留点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务处理中设置的临时占位符，如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;autocommit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 默认采用自动提交模式。也就是说，如果不显式使用 &lt;code&gt;START TRANSACTION&lt;/code&gt; 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。&lt;/p&gt;
&lt;p&gt;设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。&lt;/p&gt;
&lt;h4 id=&#34;并发中存在的一致性问题&#34;&gt;并发中存在的一致性问题&lt;/h4&gt;
&lt;p&gt;在并发环境下，如果事务的隔离性没有得到保证，则会出现很多一致性问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改丢失&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221744244.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;修改丢失，指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读脏数据&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221920368.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222102010.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222134306.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发控制可以通过&lt;strong&gt;封锁&lt;/strong&gt;来实现，但是封锁操作需要用户自己控制，相当复杂。&lt;/li&gt;
&lt;li&gt;数据库管理系统提供了事务的&lt;strong&gt;隔离级别&lt;/strong&gt;，让用户以一种更轻松的方式处理并发一致性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;锁&#34;&gt;锁&lt;/h4&gt;
&lt;h5 id=&#34;锁粒度&#34;&gt;&lt;strong&gt;锁粒度&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;MySQL 中提供了两种锁粒度：行级锁 以及 表级锁。&lt;/p&gt;
&lt;p&gt;应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的&lt;strong&gt;并发程度&lt;/strong&gt;就越高。&lt;/p&gt;
&lt;p&gt;但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统&lt;strong&gt;开销&lt;/strong&gt;就越大。&lt;/p&gt;
&lt;p&gt;在选择锁粒度时，需要在 锁开销 和 并发程度 之间做一个权衡。&lt;/p&gt;
&lt;h5 id=&#34;锁类型&#34;&gt;&lt;strong&gt;锁类型&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;读写锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁（E&lt;strong&gt;x&lt;/strong&gt;clusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（&lt;strong&gt;S&lt;/strong&gt;hared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有以下两个规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207213523777.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;意向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度锁。&lt;/p&gt;
&lt;p&gt;在存在 行级锁 和 表级锁 的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。&lt;/p&gt;
&lt;p&gt;意向锁在原来的 X/S 锁之上添加了 IX/IS，IX/IS 都是&lt;strong&gt;表锁&lt;/strong&gt;，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207214442687.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；&lt;/li&gt;
&lt;li&gt;这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;封锁协议&#34;&gt;封锁协议&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;三级封锁协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220440451.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。&lt;/p&gt;
&lt;p&gt;可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220831843.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。&lt;/p&gt;
&lt;p&gt;可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;三级&lt;/em&gt;&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221313819.png&#34; alt=&#34;img&#34; style=&#34;zoom:35%;&#34; /&gt;
&lt;p&gt;在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。&lt;/p&gt;
&lt;p&gt;可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段锁协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加锁和解锁分为两个阶段进行。先进行加锁阶段，然后进行解锁阶段。事务进行过程中的所有加锁行为都需要在加锁阶段内完成，解锁同理。&lt;/p&gt;
&lt;p&gt;事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。&lt;/p&gt;
&lt;p&gt;可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。&lt;/p&gt;
&lt;p&gt;充分条件：例如，以下操作满足两段锁协议，因此它是可串行化调度的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非必要条件：例如，以下操作不满足两段锁协议，但它还是可串行化调度的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;innodb-的隐式-显式加锁&#34;&gt;InnoDB 的隐式、显式加锁&lt;/h5&gt;
&lt;p&gt;MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候&lt;strong&gt;自动&lt;/strong&gt;加锁，并且所有的锁都是在同一时刻被释放，这被称为&lt;strong&gt;隐式&lt;/strong&gt;加锁。&lt;/p&gt;
&lt;p&gt;InnoDB 也可以使用特定的语句进行&lt;strong&gt;显式&lt;/strong&gt;加锁，即&lt;strong&gt;手动&lt;/strong&gt;加锁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;格式：
SELECT ... LOCK In SHARE MODE; -- 加 X 锁
SELECT ... FOR UPDATE; -- 加 S 锁
例子：
SELECT * FROM table1 WHERE name=&#39;张三&#39; LOCK In SHARE MODE;
SELECT * F table1 WHERE name=&#39;张三&#39; FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED (未提交读，也叫脏读）：
&lt;ul&gt;
&lt;li&gt;事务未提交时，依旧可以读取到其所做的修改&lt;/li&gt;
&lt;li&gt;该隔离级别在性能上并不会比其他的好太多，但却缺乏其他隔离级别所拥有的好处，因此在实际应用中，一般不使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;READ COMMITTED (提交读，也叫不可重复读）
&lt;ul&gt;
&lt;li&gt;大部分数据库系统默认的隔离级别，但 MySQL 不是&lt;/li&gt;
&lt;li&gt;一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。&lt;/li&gt;
&lt;li&gt;又被称为“不可重复读”，因为同样的查询，在事务提交前和提交后，读取到的数据可能不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;REPEATABLE READ (可重复读）
&lt;ul&gt;
&lt;li&gt;MySQL 默认的隔离级别&lt;/li&gt;
&lt;li&gt;保证了在一个事务中的多次查询结果一致&lt;/li&gt;
&lt;li&gt;该隔离级别可通过 MVCC 实现，但是会存在幻读，即，在事务执行过程中，另一事务修改了数据，从而产生“幻行”，两次查询读取到的数据总行数不一样。&lt;/li&gt;
&lt;li&gt;InnoDB 和 XtraDB 存储引擎通过 MVCC + Next-Key Locks 解决了幻读的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SERIALIZABLE (可串行化）
&lt;ul&gt;
&lt;li&gt;最高级别的隔离级别&lt;/li&gt;
&lt;li&gt;强制事务串行执行，不存在并发，这样多个事务互不干扰，不会出现并发一致性问题&lt;/li&gt;
&lt;li&gt;具体实现：为读取的每一行数据加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191207223400787.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;mvcc-多版本并发控制&#34;&gt;MVCC 多版本并发控制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;M&lt;/strong&gt;ulti-&lt;strong&gt;V&lt;/strong&gt;ersion &lt;strong&gt;C&lt;/strong&gt;oncurrency &lt;strong&gt;C&lt;/strong&gt;ontrol&lt;/p&gt;
&lt;p&gt;MVCC 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了 读写锁 来避免不必要的加锁操作，例如，读和读没有互斥关系。但，读和写操作仍然是互斥的。&lt;/p&gt;
&lt;p&gt;而 MVCC 利用了多版本的思想，&lt;strong&gt;写&lt;/strong&gt;操作更新&lt;strong&gt;最新版本&lt;/strong&gt;的快照，而&lt;strong&gt;读&lt;/strong&gt;操作去读&lt;strong&gt;旧版本&lt;/strong&gt;的快照，没有互斥关系，这一点和 CopyOnWrite 类似。&lt;/p&gt;
&lt;p&gt;在 MVCC 中，事务的每次修改操作（DELETE、INSERT、UPDATE）都会为&lt;strong&gt;数据行&lt;/strong&gt;新增一个版本快照。&lt;/p&gt;
&lt;p&gt;脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。&lt;/p&gt;
&lt;p&gt;多版本并发控制，每个 数据行快照版本 对应一个事务 id，当事务执行修改操作时，会生成对应的版本，多个 数据行快照版本 之间构成链表，从最新的版本开始寻找，直到找到满足要求的版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。&lt;/li&gt;
&lt;li&gt;事务版本号 TRX_ID ：事务开始时的系统版本号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Undo 日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。&lt;/p&gt;
&lt;p&gt;例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO t(id, x) VALUES(1, &amp;quot;a&amp;quot;);
UPDATE t SET x=&amp;quot;b&amp;quot; WHERE id=1;
UPDATE t SET x=&amp;quot;c&amp;quot; WHERE id=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为没有使用 &lt;code&gt;START TRANSACTION&lt;/code&gt; 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20191208164808217.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReadView&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有个多版本后，MVCC 该如何使用它呢？&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20220106103143882.png&#34; alt=&#34;image-20220106103143882&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;MVCC 维护了一个 ReadView 结构，主要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;m_ids：当前系统未提交的事务列表 {TRX_ID_1, TRX_ID_2, ...}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;min_trx_id：m_ids 中的最小值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;max_trx_id：当前系统的版本号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，但是，max_trx_id 的值是 4。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/jmliao/p/13204946.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;creator_trx_id：当前事务的 ID&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进行 SELECT 操作时，根据&lt;strong&gt;数据行&lt;/strong&gt;快照的 TRX_ID 与 min_trx_id 和 max_trx_id 之间的关系，从而判断数据行快照是否可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TRX_ID &amp;lt; min_trx_id，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。&lt;/li&gt;
&lt;li&gt;TRX_ID &amp;gt;= max_trx_id，表示该数据行快照是在事务启动之后被更改的，因此不可使用。&lt;/li&gt;
&lt;li&gt;TRX_ID_MIN &amp;lt;= TRX_ID &amp;lt; TRX_ID_MAX，需要根据隔离级别再进行判断：
&lt;ul&gt;
&lt;li&gt;提交读：如果 TRX_ID 在 m_ids 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。&lt;/li&gt;
&lt;li&gt;可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。&lt;/p&gt;
&lt;p&gt;对于提交读，ReadView 会在每次执行查询语句时生成一次，对于可重复读，只在第一次查询时生成，之后每次查询，复用第一次生成的 ReadView。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照读与当前读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVCC 只会在执行 SELECT 语句时发挥作用，在执行修改操作（INSERT、UPDATE、DELETE）时，依旧会对最新数据进行加锁，这是为了避免发生“修改丢失”。&lt;/p&gt;
&lt;p&gt;对于 SELECT 操作，会去多版本快照中读取数据，称为 快照读，快照读不会进行加锁操作&lt;/p&gt;
&lt;p&gt;对于其他修改操作，会对需要修改的数据进行加锁，确保修改的是最新的数据，这被称为 当前读。以下操作都是当前读：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT;
UPDATE;
DELETE;
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;幻读问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVCC 可以解决 快照读 的幻读问题，因为通过版本控制，只会读到旧版本中的数据，不会发生幻读问题&lt;/li&gt;
&lt;li&gt;但是无法解决 当前读 的幻读问题，因为当前读获取的是最新的数据
&lt;ul&gt;
&lt;li&gt;举个例子：&lt;/li&gt;
&lt;li&gt;事务1 select *&lt;/li&gt;
&lt;li&gt;事务2 insert&lt;/li&gt;
&lt;li&gt;事务1 select *，此时没问题，因为是快照读，不会读到事务2的insert&lt;/li&gt;
&lt;li&gt;事务1 update，因为 update 是当前读，会读到事务 2 的 insert，所以会把这条数据的版本号改成事务1，此时事务 1 再 select，就会出现幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;next-key-locks&#34;&gt;Next-Key Locks&lt;/h4&gt;
&lt;p&gt;Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。&lt;/p&gt;
&lt;p&gt;MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Record Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁定一个记录上的索引，而不是记录本身。&lt;/p&gt;
&lt;p&gt;如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gap Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Next-Key Locks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定的范围都是前开后闭的区间。&lt;/p&gt;
&lt;p&gt;例如，一个索引包含以下值：10, 11, 13, and 20，那么可能被锁住的区间有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体加锁规则为：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/50ff45e7d6f7826867bdc9c4197cf4c6.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;看了这结论，应该可以解答一大部分问题，不过有一句非常非常重点的话需要关注：&lt;/p&gt;
&lt;p&gt;MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列&amp;lt;=5.7.24，8.0 系列 &amp;lt;=8.0.13&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_36535538/article/details/117623068&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mysql&#34;&gt;MySQL&lt;/h3&gt;
&lt;h4 id=&#34;索引&#34;&gt;索引&lt;/h4&gt;
&lt;p&gt;索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。&lt;/p&gt;
&lt;h5 id=&#34;索引类型&#34;&gt;索引类型&lt;/h5&gt;
&lt;h6 id=&#34;b-tree-索引&#34;&gt;B+ Tree 索引&lt;/h6&gt;
&lt;p&gt;大多数 MySQL 存储引擎的默认索引类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。&lt;/p&gt;
&lt;p&gt;B+ Tree 是 B Tree 的升级版，在 B Tree 的基础上做了改良：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了叶子结点顺序访问指针&lt;/li&gt;
&lt;li&gt;将数据全部保存在叶子结点上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相较于 B Tree，B+ Tree 具有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保留了 B Tree 的平衡性&lt;/li&gt;
&lt;li&gt;可通过顺序访问指针提高区间查询的性能（B Tree中，需要使用中序遍历）&lt;/li&gt;
&lt;li&gt;将数据保存在叶子结点上，使得非叶子结点可以存储更多 key，进一步降低树高&lt;/li&gt;
&lt;li&gt;每次都会查到叶子结点才结束，因此查询时间较稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i+1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，且不为 null，则该指针指向节点的所有 key 大于等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 且小于等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;key_{i+1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.902771em;vertical-align:-0.208331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/33576849-9275-47bb-ada7-8ded5f5e7c73.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;当需要进行查找操作时&lt;/p&gt;
&lt;p&gt;首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。&lt;/p&gt;
&lt;p&gt;插入、删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VS 红黑树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。&lt;/p&gt;
&lt;p&gt;（一）B+ 树有更低的&lt;strong&gt;树高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。&lt;/p&gt;
&lt;p&gt;（二）磁盘访问原理&lt;/p&gt;
&lt;p&gt;操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。&lt;/p&gt;
&lt;p&gt;如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与&lt;strong&gt;树高&lt;/strong&gt;成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。&lt;/p&gt;
&lt;p&gt;（三）磁盘预读特性&lt;/p&gt;
&lt;p&gt;为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（不用红黑树的根本原因还是因为树高！）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。&lt;/li&gt;
&lt;li&gt;因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。&lt;/li&gt;
&lt;li&gt;可以指定多个列作为索引列，多个索引列共同组成键。&lt;/li&gt;
&lt;li&gt;适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InnoDB 中的 B+ Tree 索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个&lt;strong&gt;聚簇索引&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/45016e98-6879-4709-8569-262b2d6d60b9.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7c349b91-050b-4d72-a7f8-ec86320307ea.png&#34; alt=&#34;img&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;h6 id=&#34;其他索引&#34;&gt;其他索引&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希索引能以 O(1) 时间进行查找，但是失去了有序性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法用于排序与分组；&lt;/li&gt;
&lt;li&gt;只支持精确查找，无法用于部分查找和范围查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，这样就让 B+ Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM 存储引擎支持全文索引，&lt;strong&gt;用于查找文本中的关键词&lt;/strong&gt;，而不是直接比较是否相等。&lt;/p&gt;
&lt;p&gt;查找条件使用 MATCH AGAINST，而不是普通的 WHERE。&lt;/p&gt;
&lt;p&gt;全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间数据索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。&lt;/p&gt;
&lt;p&gt;必须使用 GIS 相关的函数来维护数据。&lt;/p&gt;
&lt;h5 id=&#34;如何高效使用索引&#34;&gt;如何高效使用索引&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;独立的列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。&lt;/p&gt;
&lt;p&gt;例如下面的查询不能使用 actor_id 列的索引：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多列索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引列的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让选择性最强的索引列放在前面。&lt;/p&gt;
&lt;p&gt;索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。&lt;/p&gt;
&lt;p&gt;例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;前缀索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。&lt;/p&gt;
&lt;p&gt;前缀长度的选取需要根据索引选择性来确定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;覆盖索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引包含所有需要查询的字段的值。&lt;/p&gt;
&lt;p&gt;具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。&lt;/li&gt;
&lt;li&gt;一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。&lt;/li&gt;
&lt;li&gt;对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;索引的优点与使用条件&#34;&gt;索引的优点与使用条件&lt;/h5&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大大减少了服务器需要扫描的数据行数。&lt;/li&gt;
&lt;li&gt;帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。&lt;/li&gt;
&lt;li&gt;将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；&lt;/li&gt;
&lt;li&gt;对于中到大型的表，索引就非常有效；&lt;/li&gt;
&lt;li&gt;但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。&lt;/p&gt;
&lt;p&gt;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。&lt;/p&gt;
&lt;p&gt;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。&lt;/p&gt;
&lt;p&gt;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。&lt;/p&gt;
&lt;p&gt;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。&lt;/p&gt;
&lt;p&gt;提供了大量的特性，包括压缩表、空间数据索引等。&lt;/p&gt;
&lt;p&gt;不支持事务。&lt;/p&gt;
&lt;p&gt;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。&lt;/p&gt;
&lt;p&gt;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。&lt;/p&gt;
&lt;p&gt;如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。&lt;/li&gt;
&lt;li&gt;并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。&lt;/li&gt;
&lt;li&gt;外键：InnoDB 支持外键。&lt;/li&gt;
&lt;li&gt;备份：InnoDB 支持在线热备份。&lt;/li&gt;
&lt;li&gt;崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。&lt;/li&gt;
&lt;li&gt;其它特性：MyISAM 支持压缩表和空间数据索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;整型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。&lt;/p&gt;
&lt;p&gt;INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。&lt;/p&gt;
&lt;p&gt;FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。&lt;/p&gt;
&lt;p&gt;VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。&lt;/p&gt;
&lt;p&gt;在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间和日期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DATETIME&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。&lt;/p&gt;
&lt;p&gt;它与时区无关。&lt;/p&gt;
&lt;p&gt;默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TIMESTAMP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。&lt;/p&gt;
&lt;p&gt;它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。&lt;/p&gt;
&lt;p&gt;MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。&lt;/p&gt;
&lt;p&gt;默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查询性能优化&#34;&gt;查询性能优化&lt;/h3&gt;
&lt;h4 id=&#34;使用-explain-进行分析&#34;&gt;使用 Explain 进行分析&lt;/h4&gt;
&lt;p&gt;Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。&lt;/p&gt;
&lt;p&gt;各字段含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样&lt;/li&gt;
&lt;li&gt;select_type : 查询类型，有简单查询、联合查询、子查询等&lt;/li&gt;
&lt;li&gt;type：针对单表的查询方式
&lt;ul&gt;
&lt;li&gt;all、index、range、ref、eq_ref、const，从左到右效率依次提升&lt;/li&gt;
&lt;li&gt;all：全表扫描&lt;/li&gt;
&lt;li&gt;index：根据索引的顺序全表扫描&lt;/li&gt;
&lt;li&gt;range：索引范围查询，between、&amp;gt;、&amp;lt;、in&lt;/li&gt;
&lt;li&gt;ref：查询条件使用索引，但不是唯一索引&lt;/li&gt;
&lt;li&gt;eq_ref：查询条件使用唯一索引&lt;/li&gt;
&lt;li&gt;const：查询条件使用主键，优化器会把查询优化为一个常量&lt;/li&gt;
&lt;li&gt;by https://blog.csdn.net/dennis211/article/details/78170079&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys：可能用到的索引&lt;/li&gt;
&lt;li&gt;key : 实际用到的索引&lt;/li&gt;
&lt;li&gt;rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）&lt;/li&gt;
&lt;li&gt;Extra：
&lt;ul&gt;
&lt;li&gt;Impossible where：查询条件为false&lt;/li&gt;
&lt;li&gt;Using where：顺序扫描，where 条件查询&lt;/li&gt;
&lt;li&gt;Using index：覆盖索引&lt;/li&gt;
&lt;li&gt;Using index condition：索引下推
&lt;ul&gt;
&lt;li&gt;根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表&lt;/li&gt;
&lt;li&gt;在表上建立联合索引（name, age）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table1 where name like &amp;quot;张%&amp;quot; and age = 23;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表&lt;/li&gt;
&lt;li&gt;by https://zhuanlan.zhihu.com/p/121084592&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化数据访问&#34;&gt;优化数据访问&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;减少请求的数据量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只返回必要的列：最好不要使用 SELECT * 语句。&lt;/li&gt;
&lt;li&gt;只返回必要的行：使用 LIMIT 语句来限制返回的数据。&lt;/li&gt;
&lt;li&gt;缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;减少服务器端扫描的行数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最有效的方式是使用覆盖索引进行查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重构查询方式&#34;&gt;重构查询方式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 切分大查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/p&gt;
&lt;p&gt;大查询：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM messages WHERE create &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;rows_affected = 0
do {
    rows_affected = do_query(
    &amp;quot;DELETE FROM messages WHERE create  &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&amp;quot;)
} while rows_affected &amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 分解大连接查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。&lt;/li&gt;
&lt;li&gt;分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。&lt;/li&gt;
&lt;li&gt;减少锁竞争；&lt;/li&gt;
&lt;li&gt;在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。&lt;/li&gt;
&lt;li&gt;查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag=&#39;mysql&#39;;
SELECT * FROM tag WHERE tag=&#39;mysql&#39;;
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切分&#34;&gt;切分&lt;/h3&gt;
&lt;h4 id=&#34;水平切分-sharding&#34;&gt;水平切分 Sharding&lt;/h4&gt;
&lt;p&gt;水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。&lt;/p&gt;
&lt;p&gt;当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;p&gt;策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希取模：hash(key) % N；&lt;/li&gt;
&lt;li&gt;范围：可以是 ID 范围也可以是时间范围；&lt;/li&gt;
&lt;li&gt;映射表：使用单独的一个数据库来存储映射关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务问题：使用分布式事务来解决，比如 XA 接口。&lt;/li&gt;
&lt;li&gt;连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。&lt;/li&gt;
&lt;li&gt;ID 唯一性：
&lt;ul&gt;
&lt;li&gt;使用全局唯一 ID（GUID）&lt;/li&gt;
&lt;li&gt;为每个分片指定一个 ID 范围&lt;/li&gt;
&lt;li&gt;分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;垂直切分&#34;&gt;垂直切分&lt;/h4&gt;
&lt;p&gt;垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。&lt;/p&gt;
&lt;p&gt;在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg&#34; alt=&#34;img&#34; style=&#34;zoom:90%;&#34; /&gt;
&lt;h3 id=&#34;分布式&#34;&gt;分布式&lt;/h3&gt;
&lt;h4 id=&#34;主从复制&#34;&gt;主从复制&lt;/h4&gt;
&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;binlog 线程&lt;/strong&gt; ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O 线程&lt;/strong&gt; ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 线程&lt;/strong&gt; ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;读写分离&#34;&gt;读写分离&lt;/h4&gt;
&lt;p&gt;主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。&lt;/p&gt;
&lt;p&gt;读写分离能提高性能的原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从服务器负责各自的读和写，极大程度缓解了锁的争用；&lt;/li&gt;
&lt;li&gt;从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；&lt;/li&gt;
&lt;li&gt;增加冗余，提高可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。&lt;/p&gt;
&lt;h3 id=&#34;关系型数据库-设计理论&#34;&gt;关系型数据库 设计理论&lt;/h3&gt;
&lt;p&gt;函数依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是函数依赖&lt;/li&gt;
&lt;li&gt;什么是键码、完全函数依赖、传递函数依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冗余数据&lt;/li&gt;
&lt;li&gt;修改异常&lt;/li&gt;
&lt;li&gt;删除异常&lt;/li&gt;
&lt;li&gt;插入异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式 1NF&lt;/li&gt;
&lt;li&gt;第二范式 2NF&lt;/li&gt;
&lt;li&gt;第三范式 3NF&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;er-图&#34;&gt;ER 图&lt;/h3&gt;
&lt;p&gt;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%85%AB%E3%80%81er-%E5%9B%BE&lt;/p&gt;
&lt;h2 id=&#34;非关系型数据库-redis&#34;&gt;非关系型数据库 Redis&lt;/h2&gt;
&lt;h3 id=&#34;概述-5&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。&lt;/p&gt;
&lt;p&gt;键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。&lt;/p&gt;
&lt;p&gt;Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。&lt;/p&gt;
&lt;h3 id=&#34;数据类型-2&#34;&gt;数据类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;可以存储的值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;STRING&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符串、整数或者浮点数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt;对整数和浮点数执行自增或者自减操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LIST&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从两端压入或者弹出元素 &lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无序集合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HASH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;包含键值对的无序散列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ZSET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有序集合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;使用方法&#34;&gt;使用方法&lt;/h4&gt;
&lt;p&gt;STRING&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; set hello world
OK
&amp;gt; get hello
&amp;quot;world&amp;quot;
&amp;gt; del hello
(integer) 1
&amp;gt; get hello
(nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LIST&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; rpush list-key item
(integer) 1
&amp;gt; rpush list-key item2
(integer) 2
&amp;gt; rpush list-key item
(integer) 3

&amp;gt; lrange list-key 0 -1
1) &amp;quot;item&amp;quot;
2) &amp;quot;item2&amp;quot;
3) &amp;quot;item&amp;quot;

&amp;gt; lindex list-key 1
&amp;quot;item2&amp;quot;

&amp;gt; lpop list-key
&amp;quot;item&amp;quot;

&amp;gt; lrange list-key 0 -1
1) &amp;quot;item2&amp;quot;
2) &amp;quot;item&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SET&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sadd set-key item
(integer) 1
&amp;gt; sadd set-key item2
(integer) 1
&amp;gt; sadd set-key item3
(integer) 1
&amp;gt; sadd set-key item
(integer) 0

&amp;gt; smembers set-key
1) &amp;quot;item&amp;quot;
2) &amp;quot;item2&amp;quot;
3) &amp;quot;item3&amp;quot;

&amp;gt; sismember set-key item4
(integer) 0
&amp;gt; sismember set-key item
(integer) 1

&amp;gt; srem set-key item2
(integer) 1
&amp;gt; srem set-key item2
(integer) 0

&amp;gt; smembers set-key
1) &amp;quot;item&amp;quot;
2) &amp;quot;item3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HASH&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; hset hash-key sub-key1 value1
(integer) 1
&amp;gt; hset hash-key sub-key2 value2
(integer) 1
&amp;gt; hset hash-key sub-key1 value1
(integer) 0

&amp;gt; hgetall hash-key
1) &amp;quot;sub-key1&amp;quot;
2) &amp;quot;value1&amp;quot;
3) &amp;quot;sub-key2&amp;quot;
4) &amp;quot;value2&amp;quot;

&amp;gt; hdel hash-key sub-key2
(integer) 1
&amp;gt; hdel hash-key sub-key2
(integer) 0

&amp;gt; hget hash-key sub-key1
&amp;quot;value1&amp;quot;

&amp;gt; hgetall hash-key
1) &amp;quot;sub-key1&amp;quot;
2) &amp;quot;value1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ZSET&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; zadd zset-key 728 member1
(integer) 1
&amp;gt; zadd zset-key 982 member0
(integer) 1
&amp;gt; zadd zset-key 982 member0
(integer) 0

&amp;gt; zrange zset-key 0 -1 withscores
1) &amp;quot;member1&amp;quot;
2) &amp;quot;728&amp;quot;
3) &amp;quot;member0&amp;quot;
4) &amp;quot;982&amp;quot;

&amp;gt; zrangebyscore zset-key 0 800 withscores
1) &amp;quot;member1&amp;quot;
2) &amp;quot;728&amp;quot;

&amp;gt; zrem zset-key member1
(integer) 1
&amp;gt; zrem zset-key member1
(integer) 0

&amp;gt; zrange zset-key 0 -1 withscores
1) &amp;quot;member0&amp;quot;
2) &amp;quot;982&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;存储结构&#34;&gt;存储结构&lt;/h4&gt;
&lt;p&gt;在 redis 中有 对象 和 存储结构 的概念，redis 对象利用不同的存储结构进行存储。例如，String 对象可以用 int 结构进行存储，也可以用 SDS 结构进行存储。&lt;/p&gt;
&lt;p&gt;对不同类型的对象，内部存储结构不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int 存储结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDS 存储结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;embstr：小于等于 44 字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png&#34; alt=&#34;image-20210528141323986&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw：大于 44 字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png&#34; alt=&#34;image-20210528141338577&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;embstr与raw的区别是，embstr只会申请一次内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hash 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png&#34; alt=&#34;image-20210525101358367&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表：空间占用大，查找快&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：数据数量较少或所占空间较少时，使用压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链表：空间占用更多，但添加、删除元素时，效率高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速列表：Redis 3.2 之后，用 快速列表 代替 压缩列表和链表&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png&#34; alt=&#34;image-20210528150649602&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set 对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数集合&lt;/li&gt;
&lt;li&gt;字典
&lt;ul&gt;
&lt;li&gt;字典中包含两个哈希表，哈希表使用 拉链法 解决哈希冲突&lt;/li&gt;
&lt;li&gt;之所以包含两个哈希表，是为了方便进行 rehash 操作。在扩容时，将其中一个 哈希表 上的键值对 rehash 到另一个 哈希表 上，完成之后释放空间并交换两个 哈希表 的角色。&lt;/li&gt;
&lt;li&gt;rehash 操作：
&lt;ul&gt;
&lt;li&gt;rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。&lt;/li&gt;
&lt;li&gt;渐进式 rehash 通过记录 字典 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 哈希表0 rehash 到 哈希表1，这一次会把 哈希表0 上 table[rehashidx] 的键值对 rehash 到 哈希表1 上，哈希表0 的 table[rehashidx] 指向 null，并令 rehashidx++。&lt;/li&gt;
&lt;li&gt;在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。&lt;/li&gt;
&lt;li&gt;采用渐进式 rehash 会导致字典中的数据分散在两个 哈希表 上，因此对字典的查找操作也需要到对应的 哈希表 上去执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet 对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳表：查找快，但更占空间且更新性能低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相较于 红黑树 的优势：&lt;/li&gt;
&lt;li&gt;插入速度非常快速，因为不需要进行旋转等操作来维护平衡性&lt;/li&gt;
&lt;li&gt;更容易实现&lt;/li&gt;
&lt;li&gt;支持无锁操作&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png&#34; alt=&#34;image-20210524163213876&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当元素个数超过 &lt;code&gt;zset-max-ziplist-entries&lt;/code&gt;，切换成跳表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用场景&#34;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以对 String 进行自增自减运算，从而实现计数器功能。&lt;/p&gt;
&lt;p&gt;Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如 DNS 记录就很适合使用 Redis 进行存储。&lt;/p&gt;
&lt;p&gt;查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息&lt;/p&gt;
&lt;p&gt;不过最好使用 Kafka、RabbitMQ 等消息中间件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 Redis 来统一存储多台应用服务器的会话信息。&lt;/p&gt;
&lt;p&gt;当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式锁实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。&lt;/p&gt;
&lt;p&gt;可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其它&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Set 可以实现交集、并集等操作，从而实现共同好友等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet 可以实现有序性操作，从而实现排行榜等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单值缓存&lt;/li&gt;
&lt;li&gt;对象缓存：JSON字符串&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;计数器&lt;/li&gt;
&lt;li&gt;分布式系统全局序列号
&lt;ul&gt;
&lt;li&gt;分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象缓存
&lt;ul&gt;
&lt;li&gt;与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现栈、队列、拥塞队列&lt;/li&gt;
&lt;li&gt;消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽奖功能：因为set有srandmember、spop方法&lt;/li&gt;
&lt;li&gt;点赞功能：频繁添加、删除、比较元素，用set效率比list好&lt;/li&gt;
&lt;li&gt;关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZSet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;性能高的原因&#34;&gt;性能高的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象在不同情况下使用不同的存储结构&lt;/li&gt;
&lt;li&gt;基于内存&lt;/li&gt;
&lt;li&gt;多路复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vs-memcached&#34;&gt;VS Memcached&lt;/h3&gt;
&lt;p&gt;http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html#%E4%BA%94%E3%80%81redis-%E4%B8%8E-memcached&lt;/p&gt;
&lt;h3 id=&#34;键的过期时间&#34;&gt;键的过期时间&lt;/h3&gt;
&lt;p&gt;Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。&lt;/p&gt;
&lt;p&gt;对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。&lt;/p&gt;
&lt;h3 id=&#34;数据淘汰策略&#34;&gt;数据淘汰策略&lt;/h3&gt;
&lt;p&gt;可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。&lt;/p&gt;
&lt;p&gt;Redis 具体有 6 种淘汰策略：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;策略&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-lru&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中挑选最近最少使用的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-ttl&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中挑选将要过期的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;volatile-random&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从已设置过期时间的数据集中任意选择数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allkeys-lru&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从所有数据集中挑选最近最少使用的数据淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allkeys-random&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从所有数据集中任意选择数据进行淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;noeviction&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;禁止驱逐数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。&lt;/p&gt;
&lt;p&gt;使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。&lt;/p&gt;
&lt;h3 id=&#34;持久化&#34;&gt;持久化&lt;/h3&gt;
&lt;p&gt;Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB 持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将某个时间点的所有数据都存放到硬盘上。&lt;/p&gt;
&lt;p&gt;可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。&lt;/p&gt;
&lt;p&gt;如果系统发生故障，将会丢失最后一次创建快照之后的数据。&lt;/p&gt;
&lt;p&gt;如果数据量很大，保存快照的时间会很长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF 持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将写命令添加到 AOF 文件（Append Only File）的末尾。&lt;/p&gt;
&lt;p&gt;使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;同步频率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;always&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每个写命令都同步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;everysec&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;每秒同步一次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;no&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;让操作系统来决定何时同步&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;always 选项会严重减低服务器的性能；&lt;/li&gt;
&lt;li&gt;everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；&lt;/li&gt;
&lt;li&gt;no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。&lt;/p&gt;
&lt;h3 id=&#34;事务-2&#34;&gt;事务&lt;/h3&gt;
&lt;p&gt;一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。&lt;/p&gt;
&lt;p&gt;事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。&lt;/p&gt;
&lt;p&gt;Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。&lt;/p&gt;
&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;
&lt;p&gt;Redis 服务器是一个事件驱动程序。&lt;/p&gt;
&lt;h4 id=&#34;文件事件&#34;&gt;文件事件&lt;/h4&gt;
&lt;p&gt;服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。&lt;/p&gt;
&lt;p&gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;h4 id=&#34;时间事件&#34;&gt;时间事件&lt;/h4&gt;
&lt;p&gt;服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。&lt;/p&gt;
&lt;p&gt;时间事件又分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时事件：是让一段程序在指定的时间之内执行一次；&lt;/li&gt;
&lt;li&gt;周期性事件：是让一段程序每隔指定时间就执行一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。&lt;/p&gt;
&lt;h4 id=&#34;事件的调度与执行&#34;&gt;事件的调度与执行&lt;/h4&gt;
&lt;p&gt;服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。&lt;/p&gt;
&lt;p&gt;事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &amp;lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从事件处理的角度来看，服务器运行流程如下：&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;主从复制-2&#34;&gt;主从复制&lt;/h3&gt;
&lt;p&gt;通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。&lt;/p&gt;
&lt;p&gt;一个从服务器只能有一个主服务器，并且不支持主主复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；&lt;/li&gt;
&lt;li&gt;从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；&lt;/li&gt;
&lt;li&gt;主服务器每执行一次写命令，就向从服务器发送相同的写命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;主从链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h3 id=&#34;sentinel-哨兵&#34;&gt;Sentinel 哨兵&lt;/h3&gt;
&lt;p&gt;Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。&lt;/p&gt;
&lt;h3 id=&#34;分片&#34;&gt;分片&lt;/h3&gt;
&lt;p&gt;分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。&lt;/p&gt;
&lt;p&gt;假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。&lt;/li&gt;
&lt;li&gt;还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据执行分片的位置，可以分为三种分片方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。&lt;/li&gt;
&lt;li&gt;代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。&lt;/li&gt;
&lt;li&gt;服务器分片：Redis Cluster。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;论坛系统实践&#34;&gt;论坛系统实践&lt;/h3&gt;
&lt;p&gt;该论坛系统功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以发布文章；&lt;/li&gt;
&lt;li&gt;可以对文章进行点赞；&lt;/li&gt;
&lt;li&gt;在首页可以按文章的发布时间或者文章的点赞数进行排序显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。&lt;/p&gt;
&lt;p&gt;Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/7c54de21-e2ff-402e-bc42-4037de1c1592.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;点赞功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。&lt;/p&gt;
&lt;p&gt;为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/485fdf34-ccf8-4185-97c6-17374ee719a0.png&#34; alt=&#34;img&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;对文章进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合或一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间或点赞数，而是根据时间或点赞数间接计算出来的）&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;四种常规实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒汉式-线程不安全&lt;/li&gt;
&lt;li&gt;饿汉式-线程安全&lt;/li&gt;
&lt;li&gt;懒汉式-线程安全&lt;/li&gt;
&lt;li&gt;双重校验锁-线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双重校验锁中，为什么需要用 volatile？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uniqueInstance 采用 volatile 关键字修饰也是很有必要的， &lt;code&gt;uniqueInstance = new Singleton();&lt;/code&gt; 这段代码其实是分为三步执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 uniqueInstance 分配内存空间&lt;/li&gt;
&lt;li&gt;初始化 uniqueInstance&lt;/li&gt;
&lt;li&gt;将 uniqueInstance 指向分配的内存地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&amp;gt;3&amp;gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。&lt;/p&gt;
&lt;p&gt;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种非常规实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内部类实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 &lt;code&gt;getUniqueInstance()&lt;/code&gt; 方法从而触发 &lt;code&gt;SingletonHolder.INSTANCE&lt;/code&gt; 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。&lt;/p&gt;
&lt;p&gt;这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JVM 如何保证 INSTANCE 只实例化一次？&lt;/p&gt;
&lt;p&gt;首先，对于类，无论静态类还是非静态类，只有被使用时，类才会被加载&lt;/p&gt;
&lt;p&gt;其次，对于成员变量：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用了static修饰的成员变量，会在类初始化的过程中被收集进类构造器，即&amp;lt; clinit&amp;gt;方法中，在多线程场景下，JVM会保证只有一个线程能执行该类的&amp;lt; clinit&amp;gt;方法，其他线程将会被阻塞等待，等到唯一的一次&amp;lt; cliint&amp;gt;方法执行完成，其他线程将不会再执行&amp;lt; clinit&amp;gt;方法，转而执行自己的代码。也就是说，static修饰的成员变量，在多线程的情况下能保证只实例化一次。&lt;/p&gt;
&lt;p&gt;ps:&lt;br&gt;
&amp;lt; init&amp;gt;:是instance实例构造器，对非静态变量进行初始化。&lt;br&gt;
&amp;lt; clinit&amp;gt;:是class类构造器，对静态变量、静态代码块进行初始化。&lt;br&gt;
————————————————&lt;br&gt;
原文链接：https://blog.csdn.net/weixin_43871678/article/details/107634599&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;枚举实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName(&amp;quot;firstName&amp;quot;);
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName(&amp;quot;secondName&amp;quot;);
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;firstName
secondName
secondName
secondName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。&lt;/li&gt;
&lt;li&gt;该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工厂相关的-3-个模式&#34;&gt;工厂相关的 3 个模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简单工厂模式：由工厂类的 create() 方法负责实例化对象
&lt;ul&gt;
&lt;li&gt;小米工厂负责生产手机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工厂方法模式：工厂类包含抽象方法，工厂子类继承工厂类并实现抽象方法
&lt;ul&gt;
&lt;li&gt;小米子工厂 A 负责生产手机 A，子工厂 B 负责生产手机 B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抽象工厂：在工厂方法模式的基础上，增加抽象方法的个数，从而实现对象家族的创建
&lt;ul&gt;
&lt;li&gt;小米子工厂 A 负责生产手机 A 和 投影仪 A，子工厂 B 负责生产手机 B 和投影仪 B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成器建造者&#34;&gt;生成器（建造者）&lt;/h3&gt;
&lt;p&gt;具体包含两个类：Director、Builder&lt;/p&gt;
&lt;p&gt;由 Director 负责控制流程，由 Builder 负责每一步具体的实现&lt;/p&gt;
&lt;p&gt;Director 依靠 Builder，并最终构造出对象&lt;/p&gt;
&lt;h3 id=&#34;观察者&#34;&gt;观察者&lt;/h3&gt;
&lt;p&gt;定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。&lt;/p&gt;
&lt;p&gt;主题（Subject）是被观察的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加、移除观察者&lt;/li&gt;
&lt;li&gt;通知观察者：notify()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而其所有依赖者（Observer）称为观察者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到通知后的操作：update()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许一个对象再创建另外一个可定制的对象，调用者无需知道任何创建的细节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;责任链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于请求，当前类无法处理，则抛给上一层&lt;/p&gt;
&lt;p&gt;通过组合构成责任链&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Handler {

    protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }

    protected abstract void handleRequest(Request request);
}

public class ConcreteHandler1 extends Handler {

    public ConcreteHandler1(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + &amp;quot; is handle by ConcreteHandler1&amp;quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command：命令（开灯操作、关灯操作）&lt;/li&gt;
&lt;li&gt;Receiver：命令接收者，也就是命令真正的执行者（灯）&lt;/li&gt;
&lt;li&gt;Invoker：通过它来调用命令（遥控器）&lt;/li&gt;
&lt;li&gt;Client：可以设置命令与命令的接收者（人）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没懂，暂时不管了，面经遇到再说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A 与 B 要通信，A 告诉中介者，由中介者通知 B&lt;/p&gt;
&lt;p&gt;优势：对象之间的通信可集中管理，让 A 与 B 解耦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备忘录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Originator：原始对象&lt;/li&gt;
&lt;li&gt;Caretaker：负责保存好备忘录&lt;/li&gt;
&lt;li&gt;Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/50678f34-694f-45a4-91c6-34d985c83fee.png&#34; alt=&#34;img&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类&lt;/p&gt;
&lt;p&gt;实现：将状态抽象成类，并将相应的行为放在该类中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一系列算法，封装每个算法，并使它们可以互换。&lt;/p&gt;
&lt;p&gt;策略模式可以让算法独立于使用它的客户端。&lt;/p&gt;
&lt;p&gt;与 状态模式 的比较：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。&lt;/li&gt;
&lt;li&gt;状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模板方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义算法框架，并将一些步骤的实现延迟到子类。&lt;/p&gt;
&lt;p&gt;通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不懂，暂时跳过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 什么都不做 的空对象来代替 NULL。&lt;/p&gt;
&lt;p&gt;一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把一个类接口转换成另一个用户需要的接口&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Duck {
    void quack();
}
public interface Turkey {
    void gobble();
}

public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&amp;quot;gobble!&amp;quot;);
    }
}
public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}

public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将抽象与实现分离开来，使它们可以独立变化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstraction：定义抽象类的接口&lt;/li&gt;
&lt;li&gt;Implementor：定义实现类接口&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;具体应用：https://blog.csdn.net/MY9526/article/details/108738263&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png&#34; alt=&#34;img&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。&lt;/p&gt;
&lt;p&gt;组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装饰者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为对象动态添加功能&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png&#34; alt=&#34;img&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;外观&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。&lt;/p&gt;
&lt;p&gt;观看电影需要操作很多电器，使用外观模式实现一键看电影功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;享元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象&lt;/p&gt;
&lt;p&gt;主要用于减少创建对象的数量，以减少内存占用和提高性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制对其它对象的访问&lt;/p&gt;
&lt;p&gt;代理有以下四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。&lt;/li&gt;
&lt;li&gt;虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。&lt;/li&gt;
&lt;li&gt;保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。&lt;/li&gt;
&lt;li&gt;智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计原则&#34;&gt;设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少（外观模式）&lt;/li&gt;
&lt;li&gt;类应该对扩展开放、对修改关闭：也就是添加新功能时不需要修改代码。不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方（装饰者模式）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://javaguide.cn/&#34;&gt;JavaGuide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cyc2018.xyz/&#34;&gt;CyC2018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;过往内容&#34;&gt;过往内容&lt;/h2&gt;
&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;h3 id=&#34;事务-3&#34;&gt;事务&lt;/h3&gt;
&lt;h3 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h3&gt;
&lt;h4 id=&#34;两阶段提交与三阶段提交&#34;&gt;两阶段提交与三阶段提交&lt;/h4&gt;
&lt;p&gt;待看：https://zhuanlan.zhihu.com/p/163864897&lt;/p&gt;
&lt;p&gt;两阶段提交：角色包括事务管理器和本地资源管理器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：事务管理器询问各个本地资源管理器是否提交就绪，如果任意一个本地资源管理器为no，则回滚&lt;/li&gt;
&lt;li&gt;第二阶段：事务管理器向本地资源管理器发送commit或roolback消息，本地资源管理器收到消息后进行提交或回滚操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两阶段提交存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步阻塞：资源管理器A占用某资源，资源管理器B也需要该资源&lt;/li&gt;
&lt;li&gt;单点故障：事务管理器挂了&lt;/li&gt;
&lt;li&gt;数据不一致：不能保证所有资源管理器都提交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三阶段提交（TCC）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：和两阶段提交的第一阶段相同&lt;/li&gt;
&lt;li&gt;第二阶段（缓冲阶段）：precommit 预提交，保证各节点状态相同&lt;/li&gt;
&lt;li&gt;第三阶段：和两阶段提交的第二阶段相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三阶段提交（TCC）的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入超时机制，减少阻塞：如果超时，默认abort，但如果是第三阶段，超时则自动提交，两阶段提交无法这么做，因为不存在缓冲阶段&lt;/li&gt;
&lt;li&gt;事务管理器集群：幂等操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;h4 id=&#34;3种集群模式主从-哨兵-集群&#34;&gt;3种集群模式：主从、哨兵、集群&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主从模式：
&lt;ul&gt;
&lt;li&gt;1个主节点，N个从节点&lt;/li&gt;
&lt;li&gt;主节点负责写操作，从节点负责读操作&lt;/li&gt;
&lt;li&gt;数据同步&lt;/li&gt;
&lt;li&gt;一旦主节点挂了，集群就丧失写功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哨兵模式
&lt;ul&gt;
&lt;li&gt;主从模式的升级版，添加哨兵&lt;/li&gt;
&lt;li&gt;哨兵本质上是一个进程，sentinel进程，负责监控节点状态，如果主节点挂了，会从从节点总竞选得到新的主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集群模式
&lt;ul&gt;
&lt;li&gt;主从模式+分区&lt;/li&gt;
&lt;li&gt;每个主从集群负责一部分哈希槽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发&#34;&gt;并发&lt;/h2&gt;
&lt;h3 id=&#34;synchronized-和-reentrantlock-的实现及区别&#34;&gt;synchronized 和 Reentrantlock 的实现及区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sychronized 是一个关键字，ReentrantLock 是一个类&lt;/li&gt;
&lt;li&gt;sychronized 会自动的加锁与释放锁，ReentrantLock 需要程序员手动加锁与释放锁，因此更灵活，可以根据业务场景进行相应操作&lt;/li&gt;
&lt;li&gt;sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁&lt;/li&gt;
&lt;li&gt;sychronized底层有一个锁升级的过程
&lt;ul&gt;
&lt;li&gt;偏向锁：偏向第一次持有锁的线程，该线程无需进行同步操作&lt;/li&gt;
&lt;li&gt;轻量级锁：自旋，CAS&lt;/li&gt;
&lt;li&gt;重量级锁：线程阻塞时，需要将用户态转到内核态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;synchronized：锁的是对象，锁信息保存在对象头中，可以是实例对象也可以是类对象&lt;br&gt;
6. 对象：使用汇编指令monitorenter和monitorexit&lt;br&gt;
6. 方法：使用ACC_SYNCHRONIZED标识符，本质上也是monitor的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;ReentrantLock：通过代码中的state标识来标识锁的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cas的缺点&#34;&gt;CAS的缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ABA问题、CPU空转问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程池实现机制-配置参数-使用注意点&#34;&gt;线程池实现机制、配置参数、使用注意点&lt;/h3&gt;
&lt;p&gt;线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建&lt;br&gt;
新的线程来处理被添加的任务。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入&lt;br&gt;
缓冲队列。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。&lt;/li&gt;
&lt;li&gt;如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等&lt;br&gt;
于maximumPoolSize，那么通过handler所指定的策略来处理此任务。&lt;/li&gt;
&lt;li&gt;当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：目的是更有效地利用CPU资源
&lt;ul&gt;
&lt;li&gt;CPU密集型：CPU核数+1，之所以+1，是为了更优的利用率&lt;/li&gt;
&lt;li&gt;IO密集型：CPU 核心数 * (1 + IO 耗时/ CPU 耗时)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MaximumPoolSize、workQueueSize、handler拒绝策略、keepAliveTime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程池预热方法：prestartAllCoreThreads()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何防止超卖现象&#34;&gt;如何防止超卖现象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;redis缓存和mysql同步更新&lt;/li&gt;
&lt;li&gt;减库存排队，使用窗口进行合并&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm&#34;&gt;JVM&lt;/h2&gt;
&lt;h3 id=&#34;gc&#34;&gt;GC&lt;/h3&gt;
&lt;h4 id=&#34;cms-g1的优缺点&#34;&gt;CMS、G1的优缺点&lt;/h4&gt;
&lt;p&gt;CMS是老年代的垃圾回收器，用的是标记清除算法，所以会产生内存碎片，但是因为它的回收原理是并发回收，因此STW时间较短。&lt;/p&gt;
&lt;p&gt;G1是面向整个堆的垃圾回收器，同时将分区的思想与分代相结合，每次回收时，都会去挑选需要回收的分区，使用的算法是标记整理算法，是jdk9默认的收集器，同时G1可以控制STW的时间，如果到达指定的STW时间，对于剩下的分区，就不进行回收，从而可以控制STW的时间。&lt;/p&gt;
&lt;h3 id=&#34;如何处理线上的oom&#34;&gt;如何处理线上的OOM&lt;/h3&gt;
&lt;p&gt;-Xms表示初始堆内存大小，memory startup&lt;/p&gt;
&lt;p&gt;-XmX表示最大堆内存大小，memory maximum&lt;/p&gt;
&lt;p&gt;-Xmn表示新生代内存大小，包括初始值和最大值，memory nursery/new&lt;/p&gt;
&lt;p&gt;示例：-Xms16m -Xmx32m&lt;/p&gt;
&lt;p&gt;通过参数配置，让java进程在OOM时自动产生dump文件，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp&lt;/p&gt;
&lt;p&gt;通过命令行导出dump文件，jmap -dump:live, file=jmap.hprof [PID]&lt;/p&gt;
&lt;p&gt;通过jvisualvm分析dump文件，分析哪些对象比较占内存&lt;/p&gt;
&lt;p&gt;两种可能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象确实太大了&lt;/li&gt;
&lt;li&gt;内存泄漏：各种连接，如果不手动关闭，则会被GC认为是不可回收的对象，导致内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络编程&#34;&gt;网络编程&lt;/h2&gt;
&lt;h3 id=&#34;netty&#34;&gt;Netty&lt;/h3&gt;
&lt;h4 id=&#34;了解reactor模型吗&#34;&gt;了解Reactor模型吗？&lt;/h4&gt;
&lt;p&gt;问题拆解：与Netty是什么关系，有几种类型，各自的优势是什么&lt;/p&gt;
&lt;p&gt;Netty 是一个广泛使用的 Java 网络编程框架&lt;/p&gt;
&lt;p&gt;Reactor是1995年由道格拉斯提出的一种高性能网络编程模式，一共有3种形式，单线程Reactor、多线程Reactor和主从多线程Reactor。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单线程Reactor：由一个线程处理连接请求、读写操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程Reactor：由一个线程处理连接请求，由线程池处理读写操作。但一个线程依旧可以处理多个读写操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6463324-1f7a2d77cfa17720.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从Reactor：由一个线程池处理连接请求，并将连接好的请求发送给读写线程池进行处理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6463324-a94066924053c037.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优势：不同形式适应不同的场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bytebuf实现原理&#34;&gt;ByteBuf实现原理&lt;/h4&gt;
&lt;p&gt;在java nio中提供了ByteBuffer作为字节容器，包括4个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark：调用mark()方法时，将position的值赋值给mark；调用reset()方法时，将mark的值赋值给position&lt;/li&gt;
&lt;li&gt;position：下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新&lt;/li&gt;
&lt;li&gt;limit：缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量&lt;/li&gt;
&lt;li&gt;capacity：缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变&lt;/li&gt;
&lt;li&gt;读写模式切换：flip()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;netty提供了ByteBuf作为字节容器，包括3个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;readIndex、writerIndex、capacity：字面意思&lt;/li&gt;
&lt;li&gt;discardReadBytes()：清空已读部分，利用System.arraycopy()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rpc&#34;&gt;RPC&lt;/h2&gt;
&lt;h3 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h3&gt;
&lt;h4 id=&#34;spi机制了解吗&#34;&gt;SPI机制了解吗&lt;/h4&gt;
&lt;p&gt;Java SPI：全称 Service Provider Interface，为接口指定实现类，放在 META-INF/services/ 目录里&lt;/p&gt;
&lt;p&gt;Java SPI的缺点：无法按需加载实现类，只能逐个进行加载，可能存在某个实现类，很耗资源，但又用不上&lt;/p&gt;
&lt;p&gt;Dubbo SPI的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以根据名称，按需加载。原理：在配置文件中由用户提供 名称-类全限定名 的键值对&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;负载均衡算法&#34;&gt;负载均衡算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;权重随机算法：获取随机数，然后依次减去每个invorker的权重，直到小于0；如果权重相同，则直接随机&lt;/li&gt;
&lt;li&gt;权重轮询算法：每次增加当前权重，选出大于当前权重的invorkers，然后从中按顺序选择&lt;/li&gt;
&lt;li&gt;最少活跃调用数算法：每次选出最小活跃的invorker，活跃数为invorker正在处理的请求数，如果不止一个，则对于这些invorkers，使用权重随机算法。&lt;/li&gt;
&lt;li&gt;一致性Hash算法：环形Hash空间，虚拟节点，对象迁移，寻找最近节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计思想&#34;&gt;设计思想&lt;/h2&gt;
&lt;h3 id=&#34;api的设计原则&#34;&gt;API的设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单一原则&lt;/li&gt;
&lt;li&gt;升级兼容性&lt;/li&gt;
&lt;li&gt;幂等设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;领域建模&#34;&gt;领域建模&lt;/h3&gt;
&lt;p&gt;DDD 领域驱动设计&lt;/p&gt;
&lt;p&gt;建模：对业务的抽象&lt;/p&gt;
&lt;p&gt;领域建模：将建模过程划分成4层：UI 层、应用层、领域层、基建层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI层：负责展示&lt;/li&gt;
&lt;li&gt;基建层：负责存储&lt;/li&gt;
&lt;li&gt;领域层：负责存储过程中的业务逻辑，只关心是否合法，不管是否合理，例如下订单的操作，设计创建订单和减库存，应该在领域层，而不是应用层&lt;/li&gt;
&lt;li&gt;应用层：负责核心业务逻辑，例如，黑名单的业务，应该在应用层，而不应该在领域层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：https://www.zhihu.com/question/25089273&lt;/p&gt;
&lt;h2 id=&#34;实战&#34;&gt;实战&lt;/h2&gt;
&lt;h3 id=&#34;做的项目遇到什么问题如何解决&#34;&gt;做的项目，遇到什么问题，如何解决&lt;/h3&gt;
&lt;h2 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaomi-info.github.io/2020/01/02/distributed-transaction/&#34;&gt;分布式事务，这一篇就够了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/paddix/p/5367116.html&#34;&gt;Java并发编程：Synchronized及其实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/kusedexingfu/article/details/103744202&#34;&gt;JVM的GC 参数为什么要这么命名：xms、xss、xmn和xmn?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1578846&#34;&gt;未关闭的文件流会引起内存泄露么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/duanxz/p/3696849.html&#34;&gt;Netty中的三种Reactor（反应堆）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/3930150bf7f0&#34;&gt;Netty系列-一分钟了解ByteBuffer和ByteBuf结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35190492/article/details/108256452&#34;&gt;阿里面试真题：Dubbo的SPI机制 敖丙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60c10eabdfaf&#34;&gt;Dubbo负载均衡算法实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/twoheads/p/10135896.html&#34;&gt;一致性哈希算法(consistent hashing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Lq4y1S7Rc?p=1&amp;amp;share_medium=android&amp;amp;share_plat=android&amp;amp;share_source=COPY&amp;amp;share_tag=s_i&amp;amp;timestamp=1632973331&amp;amp;unique_k=BEotpJ&#34;&gt;朋友投稿！与面试官死磕中间件与库存设计！顺利斩获大厂Offer！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">JavaHan</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习限流算法过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;计数器&#34;&gt;计数器&lt;/h2&gt;
&lt;p&gt;设置一个计数器counter，其有效时间为1分钟（即每分钟计数器会被重置为0）&lt;/p&gt;
&lt;p&gt;存在临界问题&lt;/p&gt;
&lt;h2 id=&#34;漏桶-leaky-bucket&#34;&gt;漏桶 Leaky Bucket&lt;/h2&gt;
&lt;p&gt;漏桶算法思路很简单，水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，而当入小于出的情况下，漏桶不起任何作用。&lt;/p&gt;
&lt;p&gt;流入：以任意速率往桶中放入水滴。&lt;br&gt;
流出：以固定速率从桶中流出水滴。&lt;/p&gt;
&lt;p&gt;存在效率较低的问题&lt;/p&gt;
&lt;h2 id=&#34;令牌桶-token-bucket&#34;&gt;令牌桶 Token Bucket&lt;/h2&gt;
&lt;p&gt;系统会按恒定 1/QPS 时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水)，如果桶已经满了，令牌就溢出了。如果桶未满，令牌可以积累。新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。&lt;/p&gt;
&lt;p&gt;流入：以固定速率从桶中流入水滴&lt;br&gt;
流出：按照任意速率从桶中流出水滴&lt;/p&gt;
&lt;h2 id=&#34;滑动窗口-rolling-window&#34;&gt;滑动窗口 Rolling Window&lt;/h2&gt;
&lt;p&gt;滑动窗口代表一段时间，将滑动窗口段划分成多个小格，通过统计滑动窗口中的总请求数，判断是否触发限流。每过一段时间，都将窗口往前移动。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/v2-b2fca280cb01069bc3b30c8b55f9d973_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/duanxz/p/4123068.html&#34;&gt;常见限流算法介绍（漏桶算法、令牌桶算法）及实现--待整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/122431276&#34;&gt;精度不够，滑动时间来凑「限流算法第二把法器：滑动时间窗口算法」- 第301篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">限流算法学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习JVM垃圾回收过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1T34y1X7xx?p=2&amp;amp;spm_id_from=pageDriver&#34;&gt;一节课掌握ZGC垃圾回收器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;手动回收的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄漏&lt;/li&gt;
&lt;li&gt;重复回收（多线程）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用计数的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;循环引用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923134958252.png&#34; alt=&#34;image-20210923134958252&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc工作原理&#34;&gt;GC工作原理&lt;/h2&gt;
&lt;h3 id=&#34;minor-gc新生代gc&#34;&gt;Minor GC（新生代GC）&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png&#34; alt=&#34;image-20210727152911187&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等&lt;/li&gt;
&lt;li&gt;根可达算法：将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为&lt;strong&gt;非垃圾对象&lt;/strong&gt;，其余未标记的对象都是垃圾对象。&lt;/li&gt;
&lt;li&gt;每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。&lt;/li&gt;
&lt;li&gt;如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minor-gc-vs-full-gc&#34;&gt;Minor GC VS Full GC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。&lt;/li&gt;
&lt;li&gt;Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短&lt;/li&gt;
&lt;li&gt;算法不同：
&lt;ul&gt;
&lt;li&gt;Mnior GC用空间换时间，需要两个内存空间，直接Copy&lt;/li&gt;
&lt;li&gt;Full GC用时间换空间，需要Mark+Compact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zgc垃圾回收器&#34;&gt;ZGC垃圾回收器&lt;/h2&gt;
&lt;p&gt;将堆划分成3部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小页面（2M）：对象小于256KB&lt;/li&gt;
&lt;li&gt;中页面（32M）：对象在256KM~4MB&lt;/li&gt;
&lt;li&gt;大页面（&amp;gt;32M）：对象大于4M&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指针着色：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png&#34; alt=&#34;image-20210923143727759&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。&lt;/li&gt;
&lt;li&gt;并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）&lt;/li&gt;
&lt;li&gt;再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。&lt;/li&gt;
&lt;li&gt;并发转移准备：筛选需要转移的分区&lt;/li&gt;
&lt;li&gt;初始转移：转移与GC Roots直接关联的对象&lt;/li&gt;
&lt;li&gt;并发转移：转发表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么初始标记阶段，不标记所有对象？&lt;/p&gt;
&lt;p&gt;因为耗时少！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么不直接进行并发标记？即，初始标记的意义是什么？&lt;/p&gt;
&lt;p&gt;初始标记的意义：找根对象&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png&#34; alt=&#34;image-20210924093232733&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;z的含义&#34;&gt;Z的含义&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可能大伙还惦记这标题吧？&lt;strong&gt;ZGC 的 Z 是什么意思？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实没啥意思，就是个名字而已。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/yessimida/article/details/109763732&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;其他垃圾回收器&#34;&gt;其他垃圾回收器&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png&#34; alt=&#34;image-20210923142511010&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新生代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial：标记-复制算法&lt;/li&gt;
&lt;li&gt;ParNew：标记-复制算法+多线程+STW尽量短&lt;/li&gt;
&lt;li&gt;Parallel Scavenge：标记-复制算法+多线程+吞吐量可控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代垃圾回收器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial Old：标记-整理算法&lt;/li&gt;
&lt;li&gt;Parallel Old：标记-整理算法+多线程&lt;/li&gt;
&lt;li&gt;CMS：标记-清除算法+STW尽量短
&lt;ul&gt;
&lt;li&gt;初始标记、并发标记、重新标记、并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jdk9 默认的收集器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记-整理算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区+分代&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/aef0f4765098&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZGC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STW极短&lt;/li&gt;
&lt;li&gt;分区思想&lt;/li&gt;
&lt;li&gt;染色指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/kevin7234/p/10644654.html&#34;&gt;jvm minor gc 为什么比 full gc 快很多&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/35172533&#34;&gt;为什么minor gc比full gc/major gc快？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Java垃圾回收（GC）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习Zookeeper过程中的笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1av411w7hp?from=search&amp;amp;seid=1946340734056821588&amp;amp;spm_id_from=333.337.0.0&#34;&gt;分布式架构Zookeeper入门实战到底层原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一致性&#34;&gt;一致性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。
&lt;ul&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。&lt;/li&gt;
&lt;li&gt;弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;zookeeper只保证最终一致性&lt;/p&gt;
&lt;h2 id=&#34;zookeeper-最终一致性-实现原理&#34;&gt;zookeeper 最终一致性 实现原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210916135047212.png&#34; alt=&#34;image-20210916135047212&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Zab协议
&lt;ul&gt;
&lt;li&gt;领导者选举机制
&lt;ul&gt;
&lt;li&gt;比较两个节点谁的数据更&lt;strong&gt;新&lt;/strong&gt; (zxid)，如果zxid相等，则比较myid，myid越大越好。zxid为请求id，对应每一个请求，且越靠后的请求，zxid越大。myid对应node节点，每个节点都有一个互不相等的myid，由配置文件指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过半机制&lt;/li&gt;
&lt;li&gt;两阶段提交机制
&lt;ul&gt;
&lt;li&gt;预提交&lt;/li&gt;
&lt;li&gt;ACK（过半机制）&lt;/li&gt;
&lt;li&gt;提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Zab协议的问题：
&lt;ul&gt;
&lt;li&gt;节点越多，写请求处理越慢，因为需要等待半数节点返回ACK&lt;/li&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;新增观察者，不参与两阶段提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/546b9dd86c91&#34;&gt;弱一致性、强一致性、最终一致性、顺序一致性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Zookeeper学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录如何实现一个秒杀系统，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1CE411s7xN?p=2&amp;amp;spm_id_from=pageDriver&#34;&gt;1小时带你用Redis轻松实现秒杀系统（附秒杀系统优化实战）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是秒杀系统&#34;&gt;什么是秒杀系统&lt;/h2&gt;
&lt;p&gt;其实主要的业务流程就是下订单、减库存，只是，该业务流程是在高并发、大流量的场景下进行的。&lt;/p&gt;
&lt;h2 id=&#34;并发量&#34;&gt;并发量&lt;/h2&gt;
&lt;p&gt;一般秒杀系统的并发量是万级别的，几万、几十万、几百万。&lt;/p&gt;
&lt;p&gt;单机MySQL的并发量一般为几百，最多一千。&lt;/p&gt;
&lt;p&gt;单机Tomcat的并发量一般也为几百。&lt;/p&gt;
&lt;p&gt;单机Redis的并发量一般为几万。&lt;/p&gt;
&lt;h2 id=&#34;优化前&#34;&gt;优化前&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://gitee.com/Bule-Zst/picture/raw/master/Seckill-%E4%BC%98%E5%8C%96%E5%89%8D.jpg&#34;&gt;项目下载&lt;/a&gt;（为了省事，我把文件后缀改成jpg了，这样直接用图床帮我存到云端）&lt;/p&gt;
&lt;p&gt;就是一个简单的购物系统，先下单之后再减库存，这个系统在业务逻辑上是没有bug的，最主要的问题就是性能差。&lt;/p&gt;
&lt;p&gt;需要注意的是，在系统里用到了事务，从而保证下单和减库存是原子操作，这里补充说一下Springboot事务失效的两个常见原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部调用：事务基于AOP，会对事务对象包装一个代理对象，因此不能直接调用事务对象的方法，应该使用Springboot的依赖注入，使用注入对象的方法。&lt;/li&gt;
&lt;li&gt;数据库存储引擎不支持：MyISAM是不支持事务的，所以可以检查一下数据库表的存储引擎，如果是MyISAM，需要改成InnoDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;吞吐量为130/s&lt;/p&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;h3 id=&#34;redis缓存&#34;&gt;Redis缓存&lt;/h3&gt;
&lt;p&gt;使用redis做缓存&lt;/p&gt;
&lt;p&gt;在秒杀之前，把商品库存信息放到redis中&lt;/p&gt;
&lt;p&gt;在秒杀时，先对redis中的库存执行decrement方法，之后判断返回结果是否小于0，如果返回结果大于等于0，则进行秒杀业务，否则说明库存为零。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;吞吐量为1400/s&lt;/p&gt;
&lt;h4 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h4&gt;
&lt;p&gt;缓存不一致问题：一旦秒杀业务过程中发生错误导致事务回滚，那么redis中的库存信息就和数据库中的不一致了。&lt;/p&gt;
&lt;p&gt;解决方案：如果事务中出现报错，就在catch语句中让库存加一。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jvm缓存&#34;&gt;JVM缓存&lt;/h3&gt;
&lt;p&gt;使用ConcurrentHashMap在JVM级别做缓存，当发现redis中库存为零后，使用ConcurrentHashMap标记当前商品为False。&lt;/p&gt;
&lt;p&gt;当收到秒杀请求时，首先判断ConcurrentHashMap中当前商品是否被标记，如果被标记了，说明库存为零，直接return。&lt;/p&gt;
&lt;p&gt;使用JVM级别的缓存能更好地提高系统性能，因为redis缓存是需要和redis服务做交互的，伴随网络请求，因此性能没有JVM级别快。&lt;/p&gt;
&lt;p&gt;吞吐量为：1815/s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if( concurrentHashMap.get(id) != null ) {
    return &amp;quot;fail&amp;quot;;
}

Long stock = stringRedisTemplate.opsForValue().decrement( id+&amp;quot;&amp;quot; );
if( stock &amp;lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    concurrentHashMap.put( id, true );
    return &amp;quot;fail&amp;quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;存在的问题-2&#34;&gt;存在的问题&lt;/h4&gt;
&lt;p&gt;JVM级缓存与redis缓存不一致，主要有两种场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当秒杀业务中存在异常时，会对redis和concurrentHashMap进行恢复，对redis中的缓存进行increment操作，对ConcurrentHashMap进行remove操作，但此时，redis中的库存很可能是负数的情况，因为在高并发情况下，大量请求被接受，所以redis会执行大量的decrement操作，虽然后续会执行increment操作进行恢复，但是有概率在新的请求被处理时，increment操作还未执行，当新的请求进来后，会发现redis中库存为负数，从而在concurrentHashMap进行标记。所以最终，redis中的库存数可能不为0，而concurrentHashMap中对应的商品却被标记了。&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210914163636067.png&#34; alt=&#34;image-20210914163636067&#34; style=&#34;zoom:63%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在分布式场景下，不同JVM中的concurrentHashMap很难保证同步，可能在某个JVM中对hashMap进行了恢复，但是别的JVM中，hashMap并没有进行恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是分布式导致的不一致问题，可以使用zookeeper解决。当zookeeper中节点的数据发生改变后，zookeeper会主动通知监听该节点的进程，从而实现分布式下JVM级的缓存同步。之所以使用zookeeper，是因为zookeeper是CP的模型，能较好保证各节点之间的一致性。&lt;/li&gt;
&lt;li&gt;如果是单机不一致问题，则借助lua脚本，让redis的减一操作和恢复操作原子化，因为之前出问题的原因就是decr和incr二者之间不具有原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;修复-lua&#34;&gt;修复-lua&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if( concurrentHashMap.get(id) != null ) {
    return &amp;quot;fail&amp;quot;;
}

String RELEASE_LOCK_LUA_SCRIPT = &amp;quot;if redis.call(&#39;decr&#39;, KEYS[1]) == -1 then redis.call(&#39;incr&#39;, KEYS[1]) return &#39;-1&#39; else return redis.call(&#39;get&#39;, KEYS[1]) end&amp;quot;;
DefaultRedisScript&amp;lt;String&amp;gt; redisScript = new DefaultRedisScript&amp;lt;&amp;gt;(RELEASE_LOCK_LUA_SCRIPT,String.class);
String result = stringRedisTemplate.execute(redisScript, Collections.singletonList(id+&amp;quot;&amp;quot;) );
if( result.equals(&amp;quot;-1&amp;quot;) ) {
    concurrentHashMap.put( id, true );
    return &amp;quot;fail&amp;quot;;
}

try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&amp;quot;&amp;quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
return &amp;quot;ok&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;吞吐量：1700/s&lt;/p&gt;
&lt;h3 id=&#34;其他优化手段&#34;&gt;其他优化手段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限流降级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis集群：提高redis并发量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微服务架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步下单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端优化：静态页面、CDN&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">秒杀系统-实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/"" data-c="
          &lt;p&gt;这篇文章主要用于记录优化MySQL慢查询的完整过程以及心得体会。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数据准备&#34;&gt;数据准备&lt;/h2&gt;
&lt;p&gt;随机生成了50w条数据，具体步骤可以参考这篇博客：&lt;a href=&#34;https://blog.csdn.net/qq_36994788/article/details/73216961&#34;&gt;mysql插入千万条随机数据&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;
&lt;p&gt;Explain语句结果中各个字段分表表示什么：&lt;/p&gt;
&lt;p&gt;各字段含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样&lt;/li&gt;
&lt;li&gt;select_type : 查询类型，有简单查询、联合查询、子查询等&lt;/li&gt;
&lt;li&gt;type：针对单表的查询方式
&lt;ul&gt;
&lt;li&gt;all、index、range、ref、eq_ref、const，从左到右效率依次提升&lt;/li&gt;
&lt;li&gt;all：全表扫描&lt;/li&gt;
&lt;li&gt;index：根据索引的顺序全表扫描&lt;/li&gt;
&lt;li&gt;range：索引范围查询，between、&amp;gt;、&amp;lt;、in&lt;/li&gt;
&lt;li&gt;ref：查询条件使用索引，但不是唯一索引&lt;/li&gt;
&lt;li&gt;eq_ref：查询条件使用唯一索引&lt;/li&gt;
&lt;li&gt;const：查询条件使用主键，优化器会把查询优化为一个常量&lt;/li&gt;
&lt;li&gt;by https://blog.csdn.net/dennis211/article/details/78170079&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys：可能用到的索引&lt;/li&gt;
&lt;li&gt;key : 实际用到的索引&lt;/li&gt;
&lt;li&gt;rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）&lt;/li&gt;
&lt;li&gt;Extra：
&lt;ul&gt;
&lt;li&gt;Impossible where：查询条件为false&lt;/li&gt;
&lt;li&gt;Using where：顺序扫描，where 条件查询&lt;/li&gt;
&lt;li&gt;Using index：覆盖索引&lt;/li&gt;
&lt;li&gt;Using index condition：索引下推
&lt;ul&gt;
&lt;li&gt;根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表&lt;/li&gt;
&lt;li&gt;在表上建立联合索引（name, age）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table1 where name like &amp;quot;张%&amp;quot; and age = 23;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102404385.png&#34; alt=&#34;image-20210913102404385&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913125829371.png&#34; alt=&#34;image-20210913125829371&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;优化前统计&#34;&gt;优化前统计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select * from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.55s&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开始优化&#34;&gt;开始优化&lt;/h2&gt;
&lt;h3 id=&#34;是否走了索引&#34;&gt;是否走了索引&lt;/h3&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102307124.png&#34; alt=&#34;image-20210913102307124&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;结果分析：&lt;/p&gt;
&lt;p&gt;Extra中为Using where，表示未使用索引，根据where条件顺序扫描&lt;/p&gt;
&lt;p&gt;解决方案：对deptno列建立索引&lt;/p&gt;
&lt;p&gt;建立索引后，Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105003822.png&#34; alt=&#34;image-20210913105003822&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;时间: 3.636s&lt;/p&gt;
&lt;p&gt;结果分析：时间反而变长了，猜测，可能是发生了回表操作。&lt;/p&gt;
&lt;p&gt;验证：&lt;/p&gt;
&lt;p&gt;尝试只select deptno，从而使用覆盖索引。&lt;/p&gt;
&lt;p&gt;select deptno from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.095s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110312538.png&#34; alt=&#34;image-20210913110312538&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意到Extra出现Using index，表示使用了覆盖索引。&lt;/p&gt;
&lt;p&gt;尝试select ename，在这种情况下，会发生回表操作&lt;/p&gt;
&lt;p&gt;select ename from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 3.189s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110337524.png&#34; alt=&#34;image-20210913110337524&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;未使用覆盖索引&lt;/p&gt;
&lt;p&gt;建立联合索引，(deptno, ename)&lt;/p&gt;
&lt;p&gt;select ename from emp where deptno = 101;&lt;/p&gt;
&lt;p&gt;时间: 0.033s&lt;/p&gt;
&lt;p&gt;Explain结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105937845.png&#34; alt=&#34;image-20210913105937845&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用了覆盖索引&lt;/p&gt;
&lt;p&gt;验证结束&lt;/p&gt;
&lt;h3 id=&#34;是否是最优索引&#34;&gt;是否是最优索引&lt;/h3&gt;
&lt;p&gt;where条件只对deptno进行了约束，因此是最优索引&lt;/p&gt;
&lt;h3 id=&#34;是否查询了过多字段&#34;&gt;是否查询了过多字段&lt;/h3&gt;
&lt;p&gt;select *，查询字段过多，应根据实际业务需要，减少查询字段，例如只查询ename和deptno，这样就可以使用联合索引进行优化。&lt;/p&gt;
&lt;h3 id=&#34;是否应该进行分库分表&#34;&gt;是否应该进行分库分表&lt;/h3&gt;
&lt;p&gt;暂时不考虑分库分表&lt;/p&gt;
&lt;h3 id=&#34;是否数据库服务所在机器性能过低&#34;&gt;是否数据库服务所在机器性能过低&lt;/h3&gt;
&lt;p&gt;暂时不考虑机器性能&lt;/p&gt;
">MySQL慢查询优化-实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习ConcurrentHashMap过程中的学习笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/4dTDHcwa7M9&#34;&gt;ConcurrentHashMap底层原理与源码分析深入详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;非线程安全&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210901135831288.png&#34; alt=&#34;image-20210901135831288&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;hashtable&#34;&gt;Hashtable&lt;/h2&gt;
&lt;p&gt;线程安全：对put方法加synchronized锁&lt;/p&gt;
&lt;p&gt;缺点：性能差&lt;/p&gt;
&lt;h2 id=&#34;concurrenthashmap-jdk17&#34;&gt;ConcurrentHashMap jdk1.7&lt;/h2&gt;
&lt;p&gt;class Segment extends Reentralock&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210901141125962.png&#34; alt=&#34;image-20210901141125962&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;segments数组长度为2的幂，为什么？因为计算下标时需要 &lt;code&gt;h &amp;amp; (length-1)&lt;/code&gt;，因此，必须是2的幂。&lt;/p&gt;
&lt;p&gt;同时，Segment对象内部的数组，长度也是2的幂，大小为 &lt;code&gt;initialCapacity / concurrencyLevel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据initialCapacity、loadFactor和concurrencyLevel，计算segments数组的大小、segment对象内部table的大小和threshold&lt;/li&gt;
&lt;li&gt;然后，初始化Segment对象，并放到segments[0]&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    while (ssize &amp;lt; concurrencyLevel) {
        ++sshift;
        ssize &amp;lt;&amp;lt;= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &amp;lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &amp;lt; c)
        cap &amp;lt;&amp;lt;= 1;
    // create segments and segments[0]
    Segment&amp;lt;K,V&amp;gt; s0 =
        new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
    Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;put&#34;&gt;put&lt;/h3&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key获取Segment对象，如果不存在，则初始化，使用CAS赋值给segments数组&lt;/li&gt;
&lt;li&gt;尝试对Segment对象进行加锁
&lt;ul&gt;
&lt;li&gt;如果加锁失败，则边尝试加锁，边遍历table[key]&lt;/li&gt;
&lt;li&gt;如果遍历过程中，找到了对应的entry对象，则&lt;strong&gt;停止遍历&lt;/strong&gt;。如果遍历完，依旧没有找到entry对象，则新建entry对象，然后&lt;strong&gt;停止遍历&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;停止遍历后
&lt;ul&gt;
&lt;li&gt;继续尝试加锁，如果尝试次数超过 &lt;code&gt;MAX_SCAN_RETRIES&lt;/code&gt;，则调用lock方法，阻塞加锁&lt;/li&gt;
&lt;li&gt;如果在尝试加锁过程中，发现table[key]被修改（first != table[key]），则重新开始遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只有当新建entry对象时，才会在加锁后获取到entry对象，其余情况下，获取到的都为null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加锁成功后，开始遍历table[key]
&lt;ul&gt;
&lt;li&gt;如果找到对应entry对象，则修改其value值&lt;/li&gt;
&lt;li&gt;如果没有找到entry对象，则判断之前是否已经新建过entry对象，如果没有，则新建。将新建的entry对象加入到table[key]的头结点之前，然后判断是否需要进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public V put(K key, V value) {
    Segment&amp;lt;K,V&amp;gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        int index = (tab.length - 1) &amp;amp; hash;
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}

private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value) {
    HashEntry&amp;lt;K,V&amp;gt; first = entryForHash(this, hash);
    HashEntry&amp;lt;K,V&amp;gt; e = first;
    HashEntry&amp;lt;K,V&amp;gt; node = null;
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        HashEntry&amp;lt;K,V&amp;gt; f; // to recheck first below
        if (retries &amp;lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries &amp;gt; MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries &amp;amp; 1) == 0 &amp;amp;&amp;amp;
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;扩容&#34;&gt;扩容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先，segment数组的长度是不会变的，与并发级别（concurrencyLevel）相同，扩容只在segment对象内部进行&lt;/li&gt;
&lt;li&gt;在put方法中，若segment中元素个数超过threshold，则进行rehash。
&lt;ul&gt;
&lt;li&gt;将table大小扩展一倍，并对所有元素放到新table中，同时根据比例因子更新threshold&lt;/li&gt;
&lt;li&gt;这里有一个需要说明的地方，在转移中，会去寻找最后一节不需要改动的链表，然后将其整个移动到新table中。怎么理解呢？因为在移动过程中，需要重复创建Entry，比较耗费资源，所以能尽量不创建就不创建。因此，转移过程中，会先找到 lastRun 节点，该节点后面的节点对应的hash值和该节点都一样，所以可以一起移动到新table中。然后再对lastRun节点之前的节点一个一个进行转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//扩容，Segment中，只对Segment中的HashEntry[]扩容
@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
private void rehash(HashEntry&amp;lt;K,V&amp;gt; node) {
	HashEntry&amp;lt;K,V&amp;gt;[] oldTable = table;//保存老的HashEntry[]
	int oldCapacity = oldTable.length;
	int newCapacity = oldCapacity &amp;lt;&amp;lt; 1;//扩容为原来的2倍
	threshold = (int)(newCapacity * loadFactor);//计算新的阈值
	HashEntry&amp;lt;K,V&amp;gt;[] newTable =
		(HashEntry&amp;lt;K,V&amp;gt;[]) new HashEntry[newCapacity];//创建新的HashEntry[]
	int sizeMask = newCapacity - 1;
	for (int i = 0; i &amp;lt; oldCapacity ; i++) {//循环移动老的数组中的元素
		HashEntry&amp;lt;K,V&amp;gt; e = oldTable[i];
		if (e != null) {
			HashEntry&amp;lt;K,V&amp;gt; next = e.next;
			int idx = e.hash &amp;amp; sizeMask;//计算在HashEntry[]中存放的位置
			if (next == null)   //当前节点的下一个节点为null，说明当前链表就一个节点
				newTable[idx] = e;//直接赋值
			else { //存在链表
				HashEntry&amp;lt;K,V&amp;gt; lastRun = e;
				int lastIdx = idx;
				//循环找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
				for (HashEntry&amp;lt;K,V&amp;gt; last = next;
					 last != null;
					 last = last.next) {
					int k = last.hash &amp;amp; sizeMask;
					if (k != lastIdx) {
						lastIdx = k;
						lastRun = last;
					}
				}
				newTable[lastIdx] = lastRun;//复制链表
				//处理lastRun之前的节点，这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
				for (HashEntry&amp;lt;K,V&amp;gt; p = e; p != lastRun; p = p.next) {
					V v = p.value;
					int h = p.hash;
					int k = h &amp;amp; sizeMask;
					HashEntry&amp;lt;K,V&amp;gt; n = newTable[k];
					newTable[k] = new HashEntry&amp;lt;K,V&amp;gt;(h, p.key, v, n);
				}
			}
		}
	}
	 // 将新加的 node 放到新数组中刚刚的两个链表之一的头部
	int nodeIndex = node.hash &amp;amp; sizeMask;
	node.setNext(newTable[nodeIndex]);
	newTable[nodeIndex] = node;
	table = newTable;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;concurrenthashmap-jdk18&#34;&gt;ConcurrentHashMap jdk1.8&lt;/h2&gt;
&lt;h3 id=&#34;sizectl&#34;&gt;sizeCtl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-1：正在初始化&lt;/li&gt;
&lt;li&gt;0：未进行初始化&lt;/li&gt;
&lt;li&gt;&amp;gt;0：
&lt;ul&gt;
&lt;li&gt;若还未进行初始化，则为初始化时 &lt;code&gt;tabel&lt;/code&gt; 的容量&lt;/li&gt;
&lt;li&gt;else，为触发下一次扩容的阈值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果sizeCtl小于0，则说明正在进行初始化，通过 &lt;code&gt;Thread.yield()&lt;/code&gt; 让出CPU时间&lt;/li&gt;
&lt;li&gt;else
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;sizeCtl&lt;/code&gt; 的值赋值为 &lt;code&gt;sc&lt;/code&gt;，作为备份，然后将sizeCtl赋值为-1
&lt;ul&gt;
&lt;li&gt;如果sc大于0，初始化长度为sc的table&lt;/li&gt;
&lt;li&gt;else，初始化长度为 &lt;code&gt;DEFAULT_CAPACITY&lt;/code&gt; 的table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;n-(n&amp;gt;&amp;gt;&amp;gt;2)&lt;/code&gt; 的值赋值给sizeCtl，&lt;code&gt;n-(n&amp;gt;&amp;gt;&amp;gt;2)&lt;/code&gt; 表示 &lt;code&gt;0.75*n&lt;/code&gt; ，所以sizeCtl为触发下一次扩容的阈值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final Node&amp;lt;K,V&amp;gt;[] initTable() {
    Node&amp;lt;K,V&amp;gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &amp;lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                    table = tab = nt;
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;put-2&#34;&gt;put&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;for循环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果table为空，则初始化table，然后重新循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为空，则初始化node节点，然后放到table[i]中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果“放”操作成功，则结束循环&lt;/li&gt;
&lt;li&gt;因为存在并发，“放”的操作可能失败，如果失败，则重新循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]的状态是MOVED，说明当前正在扩容，则帮忙一起扩容，扩容结束后，重新循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以上3个条件都不满足，则对table[i]加锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为链表，则遍历链表，并维护binCount变量，寻找key是否存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在，则更新value，结束遍历&lt;/li&gt;
&lt;li&gt;如果不存在，利用尾插法，插入新的node节点，结束遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果table[i]为红黑树，则向红黑树中插入node节点，将binCount设为2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入完成后，如果binCount大于等于TREEIFY_THRESHOLD（默认为8），则将table[i]由链表转换成红黑树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;退出循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果key在原先链表、红黑树中不存在（即，需要插入新节点），则调用 &lt;code&gt;addCount(1L, binCount)&lt;/code&gt; 将count加1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;链表转红黑树&#34;&gt;链表转红黑树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据链表，生成新的TreeNode类型的双向链表，hd为头结点&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;TreeBin(TreeNode&amp;lt;K,V&amp;gt; b)&lt;/code&gt; 构造函数，由双向链表转成红黑树&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int index) {
    Node&amp;lt;K,V&amp;gt; b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            tryPresize(n &amp;lt;&amp;lt; 1);
        else if ((b = tabAt(tab, index)) != null &amp;amp;&amp;amp; b.hash &amp;gt;= 0) {
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
                    for (Node&amp;lt;K,V&amp;gt; e = b; e != null; e = e.next) {
                        TreeNode&amp;lt;K,V&amp;gt; p =
                            new TreeNode&amp;lt;K,V&amp;gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin&amp;lt;K,V&amp;gt;(hd));
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;treebin与treenode&#34;&gt;TreeBin与TreeNode&lt;/h6&gt;
&lt;p&gt;在jdk1.8的HashMap中，没有使用TreeBin，为什么ConcurrentHashMap中使用了TreeBin？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免红黑树头结点发生变化：
&lt;ul&gt;
&lt;li&gt;在节点插入到红黑树的过程中，头结点可能会因为左移而改变，但是在ConcurrentHashMap中，是需要对头结点进行加锁操作的，一旦头结点发生改变，那么别的线程，就不会受到锁的限制，从而造成错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;addcount&#34;&gt;addCount&lt;/h4&gt;
&lt;p&gt;功能梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让ConcurrentHashMap的size加x&lt;/li&gt;
&lt;li&gt;在满足一定条件的情况下，对ConcurrentHashMap进行扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流程梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加x部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对ConcurrentHashMap的size进行加x操作有两种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对counterCells加x（可以先看size方法，加深对counterCells的理解）&lt;/li&gt;
&lt;li&gt;对baseCount加x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先判断counterCells是否为空，如果不为空，则进入if内部，对counterCells加x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果counterCells为空，则尝试对baseCount进行加x操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果成功，则结束，进入后续扩容部分&lt;/li&gt;
&lt;li&gt;如果失败，则同样进入if内部，对counterCells加x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对counterCells加x的操作流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果counterCells为空，则①&lt;/li&gt;
&lt;li&gt;如果counterCells不为空，但是length小于等于0，则①
&lt;ul&gt;
&lt;li&gt;这里补充一点，代码里的写法是 &lt;code&gt;(m = as.length - 1) &amp;lt; 0&lt;/code&gt; ，为什么要这么做呢，因为后续需要使用m进行与操作获取数组下标位置，与的时候是需要用 &lt;code&gt;length-1&lt;/code&gt; 的，所以直接在上面的判断中进行赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果counterCells不为空，且length也大于0，则判断对应下标位置的元素 &lt;code&gt;as[ThreadLocalRandom.getProbe() &amp;amp; m]&lt;/code&gt; 是否为空，如果为空，则①&lt;/li&gt;
&lt;li&gt;如果对应下标位置的元素也不为空，则尝试直接对该元素进行加x操作，如果失败，则①&lt;/li&gt;
&lt;li&gt;①：调用 &lt;code&gt;fullAddCount(x, uncontended)&lt;/code&gt; 对counterCells加x，addCount方法结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩容部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不进行扩容的情况
&lt;ul&gt;
&lt;li&gt;check小于0&lt;/li&gt;
&lt;li&gt;对counterCells进行加x操作，并且check小于等于1&lt;/li&gt;
&lt;li&gt;调用fullAddCount对counterCells进行加x操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &amp;lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
        if (check &amp;lt;= 1)
            return;
        s = sumCount();
    }
    if (check &amp;gt;= 0) {
        Node&amp;lt;K,V&amp;gt;[] tab, nt; int n, sc;
        while (s &amp;gt;= (long)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != null &amp;amp;&amp;amp;
               (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc &amp;lt; 0) {
                if ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &amp;lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;fulladdcount&#34;&gt;fullAddCount&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;使用线程的探针值对h进行赋值&lt;/li&gt;
&lt;li&gt;for循环
&lt;ul&gt;
&lt;li&gt;如果counterCells不为空，且长度等于0
&lt;ul&gt;
&lt;li&gt;如果counterCells数组对应下标位置元素为空
&lt;ul&gt;
&lt;li&gt;将collide赋值为false&lt;/li&gt;
&lt;li&gt;如果counterCells未被其他线程占用，则尝试使用x为对应位置进行初始化，如果初始化成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果wasUncontended为false，则将wasUncontended改为true。
&lt;ul&gt;
&lt;li&gt;wasUncontended：表示上一次没有冲突&lt;/li&gt;
&lt;li&gt;如果为false，则说明有冲突，所以直接跳到最后一条语句，更新h的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尝试使用CAS对数组对应下标位置的元素加x
&lt;ul&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;更新h的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;else，如果cellsBusy为0（说明counterCells没有被其他线程占用）
&lt;ul&gt;
&lt;li&gt;则对counterCells进行初始化，初始化为长度为2的数组，并将x的值添加到数组中&lt;/li&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;else，尝试对baseCount进行加x操作
&lt;ul&gt;
&lt;li&gt;如果成功，则退出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final void fullAddCount(long x, boolean wasUncontended) {
    int h;
    if ((h = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit();      // force initialization
        h = ThreadLocalRandom.getProbe();
        wasUncontended = true;
    }
    
    boolean collide = false;                // True if last slot nonempty
    for (;;) {
        CounterCell[] as; CounterCell a; int n; long v;
        if ((as = counterCells) != null &amp;amp;&amp;amp; (n = as.length) &amp;gt; 0) {
            if ((a = as[(n - 1) &amp;amp; h]) == null) {
                if (cellsBusy == 0) {            // Try to attach new Cell
                    CounterCell r = new CounterCell(x); // Optimistic create
                    if (cellsBusy == 0 &amp;amp;&amp;amp;
                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                        boolean created = false;
                        try {               // Recheck under lock
                            CounterCell[] rs; int m, j;
                            if ((rs = counterCells) != null &amp;amp;&amp;amp;
                                (m = rs.length) &amp;gt; 0 &amp;amp;&amp;amp;
                                rs[j = (m - 1) &amp;amp; h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                break;
            else if (counterCells != as || n &amp;gt;= NCPU)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 &amp;amp;&amp;amp;
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                try {
                    if (counterCells == as) {// Expand table unless stale
                        CounterCell[] rs = new CounterCell[n &amp;lt;&amp;lt; 1];
                        for (int i = 0; i &amp;lt; n; ++i)
                            rs[i] = as[i];
                        counterCells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = ThreadLocalRandom.advanceProbe(h);
        }
        else if (cellsBusy == 0 &amp;amp;&amp;amp; counterCells == as &amp;amp;&amp;amp;
                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
            boolean init = false;
            try {                           // Initialize table
                if (counterCells == as) {
                    CounterCell[] rs = new CounterCell[2];
                    rs[h &amp;amp; 1] = new CounterCell(x);
                    counterCells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
            break;                          // Fall back on using base
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;size&#34;&gt;size&lt;/h3&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36625757/article/details/90074355&#34;&gt;JDK1.7&amp;amp;1.8中ConcurrentHashMap解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1H64y1X7yM?p=6&#34;&gt;我敢说这是B站最详细的hashmap及ConcurrentHashMap底层原理解析，16个小时带你吃透所有知识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">ConcurrentHashMap详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-28-微服务架构与Spring Cloud Alibaba框架学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习微服务架构与Spring Cloud Alibaba框架过程中的学习笔记，学习资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/bJKCoGeUWY7&#34;&gt;微服务Spring Cloud Alibaba三高架构实战视频.mp4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/1TgXEyrFN2p&#34;&gt;阿里微服务架构Spring Cloud Alibaba源码深度剖析视频.mp4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;微服务架构的优势劣势&#34;&gt;微服务架构的优势劣势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;单一服务崩溃，不会影响其他服务的正常运行&lt;/li&gt;
&lt;li&gt;方便大型团队的开发和管理&lt;/li&gt;
&lt;li&gt;方便对特定服务的扩容&lt;/li&gt;
&lt;li&gt;不同服务使用不同的数据库，便于数据库的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;增加运维难度&lt;/li&gt;
&lt;li&gt;引发分布式事务问题&lt;/li&gt;
&lt;li&gt;bug定位困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务扩容方案&#34;&gt;服务扩容方案&lt;/h2&gt;
&lt;h3 id=&#34;nginx负载均衡&#34;&gt;nginx负载均衡&lt;/h3&gt;
&lt;p&gt;需要手动修改nginx配置，对运维要求较高&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-alibaba&#34;&gt;Spring Cloud Alibaba&lt;/h3&gt;
&lt;p&gt;使用注册中心组件-nacos&lt;/p&gt;
&lt;h4 id=&#34;实现原理&#34;&gt;实现原理&lt;/h4&gt;
&lt;p&gt;客户端：默认集成Ribbon，Ribbon定时从Nacos上拉取相关信息。当客户端通过rest调用服务时，会被Ribbon拦截，Ribbon会根据本地的服务信息替换链接。Ribbon默认使用的是轮询负载均衡。&lt;/p&gt;
&lt;p&gt;服务端：服务端启动后，会向Nacos注册服务，并开启心跳任务，定时向Nacos发送消息以证明自身存活。&lt;/p&gt;
&lt;h2 id=&#34;高可用&#34;&gt;高可用&lt;/h2&gt;
&lt;p&gt;核心链路中，某些服务未调用成功，则触发服务降级。服务降级可通过 sentinel组件 实现。&lt;/p&gt;
&lt;p&gt;sentinel组件还可以帮我们实现限流、熔断功能。&lt;/p&gt;
&lt;p&gt;限流：限制访问量。&lt;/p&gt;
&lt;p&gt;熔断：对于大概率失败的请求调用，直接调用降级服务。&lt;/p&gt;
&lt;h3 id=&#34;限流算法&#34;&gt;限流算法&lt;/h3&gt;
&lt;p&gt;滑动时间窗、漏桶、令牌桶&lt;/p&gt;
&lt;h2 id=&#34;高并发&#34;&gt;高并发&lt;/h2&gt;
&lt;h3 id=&#34;nacos&#34;&gt;nacos&lt;/h3&gt;
&lt;p&gt;如何解决读写冲突问题：读写分离，在副本上进行写，写完之后再覆盖掉原有数据。&lt;/p&gt;
&lt;h2 id=&#34;高扩展&#34;&gt;高扩展&lt;/h2&gt;
&lt;h3 id=&#34;nacos-2&#34;&gt;nacos&lt;/h3&gt;
&lt;p&gt;namespace -&amp;gt; group -&amp;gt; cluster -&amp;gt; instance&lt;/p&gt;
&lt;p&gt;namespace: test, dev...&lt;/p&gt;
&lt;p&gt;group: 交易微服务分组、仓储微服务分组&lt;/p&gt;
&lt;p&gt;cluster: 多地部署，深圳、杭州、北京、成都&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082845291.png&#34; alt=&#34;image-20210830082845291&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082920845.png&#34; alt=&#34;image-20210830082920845&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h2&gt;
&lt;p&gt;借助 seata组件 完成&lt;/p&gt;
">微服务架构与Spring Cloud Alibaba框架学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-26-HashMap详解/"" data-c="
          &lt;p&gt;这篇文章主要用于记录学习 HashMap 过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;扩容机制&#34;&gt;扩容机制&lt;/h2&gt;
&lt;p&gt;首先要了解 HashMap 的底层结构，如图所示，数组+单向链表（红黑树）。&lt;/p&gt;
&lt;p&gt;当单链表长度大于8时，~~数组长度达到64时，~~会由链表转换成红黑树。（依据：源码）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &amp;amp;&amp;amp;
        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
        break;
    p = e;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210826131403378.png&#34; alt=&#34;image-20210826131403378&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;初始时，数组长度为16，当数组中超过16*0.75=12个位置被使用后，数组会被扩容到32，之后会扩容到64。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，必须是数组中12个位置被使用过，并不是说HashMap中存放12个元素，这里容易混淆。&lt;/p&gt;
&lt;p&gt;同样，附上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (++size &amp;gt; threshold)
    resize();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比例因子：&lt;/p&gt;
&lt;p&gt;默认为0.75，也就是说，虽然数组长度为16，但只能存放16*0.75=12个元素。&lt;/p&gt;
&lt;h2 id=&#34;看源码梳理put方法逻辑&#34;&gt;看源码，梳理put方法逻辑&lt;/h2&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;首先根据key计算hash值&lt;/li&gt;
&lt;li&gt;根据hash值，从table中取出node
&lt;ul&gt;
&lt;li&gt;如果node为空，则根据key-value构造node，放到table相应位置中，并将size++，如果size超过阈值（容量*比例因子），则会进行扩容操作。&lt;/li&gt;
&lt;li&gt;如果node不为空
&lt;ul&gt;
&lt;li&gt;如果node为红黑树，则会调用putTreeVal，向树中添加元素&lt;/li&gt;
&lt;li&gt;如果node为单链表，则会遍历单链表
&lt;ul&gt;
&lt;li&gt;如果找到与key-value相等的元素，则直接返回。&lt;/li&gt;
&lt;li&gt;如果没找到，则在尾部新建节点。新建后，如果发现链表长度大于TREEIFY_THRESHOLD（默认为8），则会将单链表转为红黑树。&lt;/li&gt;
&lt;li&gt;分支逻辑：在转换过程中，如果发现当前table数组的大小小于MIN_TREEIFY_CAPACITY（默认为64），则不会进行转换，而是进行扩容操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xpsallwell/article/details/88071038&#34;&gt;ConcurrentHashMap扩容原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zuokaopuqingnian/article/details/79508730&#34;&gt;ArrayList HashMap ConcurrentHashMap扩容机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">HashMap详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-23-AQS、CAS学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习AQS、CAS过程中的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cas的应用&#34;&gt;CAS的应用&lt;/h2&gt;
&lt;p&gt;保证原子性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面我们了解了cas是什么了，那么它能解决什么问题呢？它可以解决多线程并发安全的问题，以前我们对一些多线程操作的代码都是使用synchronize关键字，来保证线程安全的问题；现在我们将cas放入到多线程环境里我们看一下它是怎么解决的，我们假设有A、B两个线程同时执行一个int值value自增的代码，并且同时获取了当前的value，我们还要假设线程B比A快了那么0.00000001s，所以B先执行，线程B执行了cas操作之后，发现当前值和预期值相符，就执行了自增操作，此时这个value = value + 1;然后A开始执行，A也执行了cas操作，但是此时value的值和它当时取到的值已经不一样了，所以此次操作失败，重新取值然后比较成功，然后将value值更新，这样两个线程进入，value值自增了两次，符合我们的预期。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ln_6am/article/details/85642853&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mulinsen77/article/details/84583716&#34;&gt;AQS详解（面试）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/40025595&#34;&gt;AQS 如何使用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011506543/article/details/82392338&#34;&gt;JAVA CAS实现原理与使用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">AQS、CAS学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-08-10-Spring中Bean、AOP、事务学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Spring Bean、AOP、事务过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/JBxJZYEJADm&#34;&gt;Spring之IOC、AOP、事务底层原理详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;bean&#34;&gt;Bean&lt;/h2&gt;
&lt;p&gt;Bean对象默认为单例Bean，即根据Bean的name获取对象，相同name对应相同的对象。如果是独立Bean，就算name相同，也依旧是不同的对象。&lt;/p&gt;
&lt;h3 id=&#34;bean-vs-对象&#34;&gt;Bean VS 对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：Bean一定是对象，但对象不一定是Bean，只有被Spring管理的对象才是Bean对象。&lt;/li&gt;
&lt;li&gt;特性：Bean对象中的Bean&lt;strong&gt;子&lt;/strong&gt;对象，会被Spring自动注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean创建流程&#34;&gt;Bean创建流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;实例化（无参构造方法）&lt;/li&gt;
&lt;li&gt;依赖注入
&lt;ol&gt;
&lt;li&gt;初始化前：@PostConstruct&lt;/li&gt;
&lt;li&gt;初始化：InitializingBean&lt;/li&gt;
&lt;li&gt;初始化后：AOP，生成代理对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring容器&#34;&gt;Spring容器&lt;/h2&gt;
&lt;p&gt;本质上是Map，先根据.class进行寻找，如果找到的结果不唯一，则继续根据name进行寻找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService2 ) {
	不报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	不报错
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP&lt;/h2&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;p&gt;具有事务的对象为代理对象，切面逻辑为“开启事务”。&lt;/p&gt;
&lt;h3 id=&#34;事务失效&#34;&gt;事务失效&lt;/h3&gt;
&lt;h4 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;MySQL默认存储引擎是MyISAM，该存储引擎不知道事务，需要切换成InnoDB。&lt;/p&gt;
&lt;h4 id=&#34;内部调用&#34;&gt;内部调用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional
public void test() {
	jdbcTemplate.execute(&amp;quot;insert t1 values(1,1,1)&amp;quot;);
	a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码不会报错，原因是：&lt;/p&gt;
&lt;p&gt;事务开启的逻辑是在代理对象中进行的，上述代码中a()方法的调用是在target对象中进行的，因此在调用a()方法时，不会触发事务相关的逻辑，因此事务失效。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private UserService userService;

@Transactional
public void test() {
	jdbcTemplate.execute(&amp;quot;insert t1 values(1,1,1)&amp;quot;);
	userService.a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Bean初始化，为什么有了initializingBean，还要PostConstructor&lt;/li&gt;
&lt;/ul&gt;
">Spring中Bean、AOP、事务学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-28-JMM学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习JMM过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/B67o2UcNvG8&#34;&gt;深入理解并发内存模型JMM与内存屏障&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java内存模型&#34;&gt;Java内存模型&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210728151840865.png&#34; alt=&#34;image-20210728151840865&#34; style=&#34;zoom:60%;&#34; /&gt;
&lt;p&gt;对于静态变量，每个线程中会存储变量副本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要不影响到变量的值、变量不参与运算，则不会从主内存中拉取，比如while、if、赋值给其他变量、作为方法参数等&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ren421259121/article/details/90447853&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下程序会死循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static boolean exit = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread() {
            @Override
            public void run() {
                while( !exit ) {

                }
                System.out.println( &amp;quot;end&amp;quot; );
            }
        }.start();
        Thread.sleep(2000);
        exit = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jmm的原子操作&#34;&gt;JMM的原子操作&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210729144205406.png&#34; alt=&#34;image-20210729144205406&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;h2 id=&#34;volatile&#34;&gt;volatile&lt;/h2&gt;
&lt;p&gt;作用：保证多线程间共享变量的可见性、有序性。不保证原子性，原子性需通过synchronized保证。&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM级：禁止JVM优化：指令重排、使用寄存器&lt;/li&gt;
&lt;li&gt;CPU级：利用CPU lock指令为总线加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可见性&#34;&gt;可见性&lt;/h3&gt;
&lt;h4 id=&#34;缓存一致性协议-vs-volatile&#34;&gt;缓存一致性协议 VS volatile&lt;/h4&gt;
&lt;h5 id=&#34;缓存一致性协议mesi&#34;&gt;缓存一致性协议（MESI）&lt;/h5&gt;
&lt;p&gt;四种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M（Modified）：在缓存行中被标记为Modified的值，与主存中的值不同，这个值将会在它被读取之前写入内存，并且状态置为Shared。&lt;/li&gt;
&lt;li&gt;E（Exclusive）：在缓存行中被标记为Exclusive的值与主存中的值一致，被读取时置为Shared状态，被写时置为Modified状态。&lt;/li&gt;
&lt;li&gt;S（Shared）：值也可能存在于其他缓存中，但是它的值和主存中的值一致。&lt;/li&gt;
&lt;li&gt;I（Invalid）：缓存行无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于状态之间的转换以及更详细介绍MESI的内容，可以看这篇博客：https://www.cnblogs.com/igoodful/p/9493156.html&lt;/p&gt;
&lt;p&gt;做个总结，MESI协议，保证了各CPU缓存之间的一致性。&lt;/p&gt;
&lt;h5 id=&#34;volatile是否多余&#34;&gt;volatile是否多余&lt;/h5&gt;
&lt;p&gt;既然MESI协议可以保证各CPU缓存之间数据的一致性（可见性），那么为什么还需要volatile关键词来保证各线程之间数据的一致性（可见性）呢？volatile关键字是否多余？&lt;/p&gt;
&lt;p&gt;答：不多余&lt;/p&gt;
&lt;p&gt;理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;出发点不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MESI协议保证了主内存和各CPU缓存的一致，而volatile保证了java进程中各线程之间的一致性。如果没有MESI，那么各线程之间一定是不一致的，但只有MESI，也不能完全保证各线程间的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现的功能不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MESI的功能上文已经说过了，即，保证了各CPU缓存之间的一致性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;防止JVM优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止数据从CPU cache以外的地方读取，这里做一下说明，MESI只能保证主内存和CPU缓存（CPU cache）的一致性，但CPU中还有很多额外的组件用于数据存储，这些组件可以提高CPU数据读写的效率，而这些组件的一致性MESI是不保证的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 MESI只是保证了多核cpu的独占cache之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。有些arm和power架构的cpu还可能有load buffer或者invalid queue等等。&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/296949412&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证多个变量的顺序一致，即，consistency。因为volatile会对总线加锁，且防止指令重排，所以可以保证用volatile修饰的多个变量之间的操作顺序。而MESI只能保证单个变量的操作顺序，即coherence。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coherence deals with maintaining a global order in which writes to a single location or single variable are seen by all processors.&lt;/p&gt;
&lt;p&gt;Consistency deals with the ordering of operations to multiple locations with respect to all processors.&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/296949412&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;s&gt;### CPU lock指令&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;CPU lock指令会将对应缓存行的状态改成E，并立即修改主内存中的数据。其他CPU通过总线嗅探机制，监听到数据的修改，将自己工作内存中的缓存行状态改成I。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;如果不使用volatile关键字，JVM则不会使用lock指令，此时，对变量的修改会导致缓存行的状态变成M，并不会修改主内存的数据，因此会导致不同线程中共享变量数据不一致。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;之所以不修改主内存，是因为对主内存的操作相对于CPU操作来说过于耗时，因此不会频繁操作主内存。&lt;/s&gt;&lt;/p&gt;
&lt;h4 id=&#34;reference&#34;&gt;Reference&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xrq730/p/7048693.html&#34;&gt;就是要你懂Java中volatile关键字实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/63120810&#34;&gt;java多线程在单核CPU上，还是需要volatile synchronized吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序性&#34;&gt;有序性&lt;/h3&gt;
&lt;h4 id=&#34;重排序原则&#34;&gt;重排序原则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;as-if-serial：不管怎么重排序 (编译器和处理器为了提高并行度)，(单线程) 程序的执行结果不能被改变。&lt;/li&gt;
&lt;li&gt;happens-before：本质上其实和第一点类似，就是保证单线程程序的语义不被改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试题：单例模式下对象半初始化问题&lt;/p&gt;
&lt;h4 id=&#34;内存屏障&#34;&gt;内存屏障&lt;/h4&gt;
&lt;p&gt;JVM内存屏障指令：LoadLoad, LoadStore, StoreLoad, StoreStore&lt;/p&gt;
&lt;p&gt;对于volatile修饰的变量，在JVM级，会在该操作前后添加内存屏障指令，在CPU级，会通过lock指令实现内存屏障。&lt;/p&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;volatile有什么特点和synchornized相比有什么区别&#34;&gt;volatile有什么特点，和synchornized相比有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;volatile的特点：保证可见性和有序性，不保证原子性&lt;/li&gt;
&lt;li&gt;volatile VS synchronized
&lt;ul&gt;
&lt;li&gt;修饰对象不同：volatile修饰变量，synchronized修饰方法和代码块&lt;/li&gt;
&lt;li&gt;原子性：volatile不保证，synchronized保证&lt;/li&gt;
&lt;li&gt;是否造成阻塞：volatile不会，synchronized会&lt;/li&gt;
&lt;li&gt;volatile为轻量级锁，synchronized为重量级锁&lt;/li&gt;
&lt;li&gt;都保证原子性和有序性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">JMM学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习K8S-Scheduler过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;amp;seid=1977024601217253447&#34;&gt;阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;调度器功能：负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。&lt;/p&gt;
&lt;p&gt;什么是Pod：Pod是K8S中最小的调度单元，Pod和docker容器的关系就相当于docker容器和进程，在目前的技术环境下，往往一个服务依赖于多个docker容器，因此，k8s中提出了Pod的概念，使用Pod对docker容器进行打包，统一进行调度。&lt;/p&gt;
&lt;h2 id=&#34;对pod进行自定义排序&#34;&gt;对Pod进行自定义排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按名称排序：kubectl get pods --sort-by=.metadata.name&lt;/li&gt;
&lt;li&gt;按创建时间进行排序：kubectl get pods --sort-by=.metadata.creationTimestamp&lt;/li&gt;
&lt;li&gt;按启动时间进行排序：kubectl get pods --sort-by=.status.startTime&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/m0_50434960/article/details/114851074&#34;&gt;k8s:Kubernetes 调度器介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/bfaa566f17fe&#34;&gt;细说kubernetes - 为什么是pod？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/yangyuliufeng/p/14257928.html&#34;&gt;k8s调度器扩展机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;amp;seid=1977024601217253447&#34;&gt;阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">K8S-Scheduler学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习JVM性能调优过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/mmv27Dfr291&#34;&gt;双十一亿级电商系统JVM性能调优实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java虚拟机组成&#34;&gt;Java虚拟机组成&lt;/h2&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png&#34; alt=&#34;image-20210727153842086&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;类装载子系统&lt;/li&gt;
&lt;li&gt;字节码执行引擎&lt;/li&gt;
&lt;li&gt;运行时数据区（内存模型）
&lt;ul&gt;
&lt;li&gt;栈（线程）
&lt;ul&gt;
&lt;li&gt;存放程序运行过程中的数据&lt;/li&gt;
&lt;li&gt;栈 -&amp;gt; 线程 -&amp;gt; 方法
&lt;ul&gt;
&lt;li&gt;从栈中划分一块区域给线程，再从这块区域中划分一块给方法&lt;/li&gt;
&lt;li&gt;方法中的局部变量就存在对应区域内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序计数器：记录每个线程当前运行的代码在方法区中的位置&lt;/li&gt;
&lt;li&gt;堆：存放程序运行过程中产生的对象&lt;/li&gt;
&lt;li&gt;方法区（元空间）：常量+静态变量+类信息&lt;/li&gt;
&lt;li&gt;本地方法栈：和上文的栈类似，只是，这里存放的是本地（native）方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc工作原理&#34;&gt;GC工作原理&lt;/h2&gt;
&lt;h3 id=&#34;minor-gc新生代gc&#34;&gt;Minor GC（新生代GC）&lt;/h3&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png&#34; alt=&#34;image-20210727152911187&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等&lt;/li&gt;
&lt;li&gt;将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为&lt;strong&gt;非垃圾对象&lt;/strong&gt;，其余未标记的对象都是垃圾对象。&lt;/li&gt;
&lt;li&gt;每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。&lt;/li&gt;
&lt;li&gt;如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minor-gc-vs-full-gc&#34;&gt;Minor GC VS Full GC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。&lt;/li&gt;
&lt;li&gt;Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短&lt;/li&gt;
&lt;li&gt;算法不同：
&lt;ul&gt;
&lt;li&gt;Mnior GC用空间换时间，需要两个内存空间，直接Copy&lt;/li&gt;
&lt;li&gt;Full GC用时间换空间，需要Mark+Compact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/kevin7234/p/10644654.html&#34;&gt;jvm minor gc 为什么比 full gc 快很多&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/35172533&#34;&gt;为什么minor gc比full gc/major gc快？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arthas工具&#34;&gt;Arthas工具&lt;/h2&gt;
&lt;p&gt;阿里JVM性能调优工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dashboard：显示监控仪表盘&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155106380.png&#34; alt=&#34;image-20210727155106380&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;thread thread_id：显示占用CPU较多的代码行数&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155209073.png&#34; alt=&#34;image-20210727155209073&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jad：反编译运行中的代码&lt;/p&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155320962.png&#34; alt=&#34;image-20210727155320962&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能调优&#34;&gt;性能调优&lt;/h2&gt;
&lt;p&gt;目的：减少 STW 的次数。&lt;/p&gt;
&lt;p&gt;STW: Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。&lt;/p&gt;
&lt;p&gt;Full GC的SWT时间远大于Minor GC。&lt;/p&gt;
&lt;p&gt;调优方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。&lt;/li&gt;
&lt;li&gt;对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。&lt;/li&gt;
&lt;li&gt;使用不同的垃圾收集器，不同收集器，适用于不同的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png&#34; alt=&#34;image-20210727162355407&#34; style=&#34;zoom:55%;&#34; /&gt;
">JVM性能调优学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-19-非对称加密的应用/"" data-c="
          &lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;稍微提一下原理&lt;/p&gt;
&lt;p&gt;主要原理是，用一定的数学方法生成一对密钥对（公钥+私钥），公钥加密后，私钥可以解密，同时，私钥加密后，公钥也可以解密。&lt;/p&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;h3 id=&#34;数据传输&#34;&gt;数据传输&lt;/h3&gt;
&lt;p&gt;1、A生成一对密钥对，把公钥发给B。&lt;/p&gt;
&lt;p&gt;2、B把需要传输的数据用公钥进行加密，然后发给A。&lt;/p&gt;
&lt;p&gt;3、A收到后，用私钥进行解密，即可获取数据。&lt;/p&gt;
&lt;h4 id=&#34;如何防截获&#34;&gt;如何防截获&lt;/h4&gt;
&lt;p&gt;使用报文摘要算法&lt;/p&gt;
&lt;p&gt;接上文&lt;/p&gt;
&lt;p&gt;B在第2步传数据时，使用报文摘要算法对所发数据进行摘要生成，之后，用自己的私钥对摘要进行加密，然后伴随数据一起发给A。&lt;/p&gt;
&lt;p&gt;A在收到后，对自己的私钥对数据进行解密，从而获取数据，之后再用B的公钥对摘要进行解密，然后比对收到的数据和摘要是否匹配，从而验证数据是否被篡改。&lt;/p&gt;
&lt;h3 id=&#34;身份验证&#34;&gt;身份验证&lt;/h3&gt;
&lt;p&gt;A要证明自己的身份&lt;/p&gt;
&lt;p&gt;B向A发送一段数据&lt;/p&gt;
&lt;p&gt;A用自己的私钥进行加密，然后发回给B，B用A的公钥进行解密，比对数据是否为自己发给A的数据，从而验证A的身份。&lt;/p&gt;
">非对称加密的应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-15-在Docker容器内创建新的Docker容器/"" data-c="
          &lt;h2 id=&#34;要解决的问题&#34;&gt;要解决的问题&lt;/h2&gt;
&lt;p&gt;这篇文章主要解决的问题如标题所述：如何在Docker容器内创建新的Docker容器。受限于标题长度，没法详细描述要解决的问题，因此，第一节首先讲一下问题场景。&lt;/p&gt;
&lt;p&gt;随着Docker技术以及微服务结构的普及，现在越来越多的应用被打包放在Docker容器中，并且，为了采用微服务的架构，应用通常是需要拆分成多个Docker容器的。&lt;/p&gt;
&lt;p&gt;那么，这就带来了一个问题，如何在一个Docker容器内去控制别的Docker容器。这里需要啰嗦一句，我想表达的意思并不是在一个Docker容器的内部创建新的Docker容器，而是说，在一个Docker容器内部，控制宿主机，让其创建新的Docker容器。&lt;/p&gt;
&lt;p&gt;问题描述讲完了，接下来说一下如何实现。&lt;/p&gt;
&lt;h2 id=&#34;如何解决&#34;&gt;如何解决&lt;/h2&gt;
&lt;p&gt;解决这个问题，就需要涉及到Docker的通信机制。&lt;/p&gt;
&lt;p&gt;Docker分为服务端和客户端。当服务端启动后，会在/var/run/文件夹中创建docker.sock这个文件，并且会持续监听这个文件。当有请求被写到docker.sock文件时，Docker服务端就会执行相应的操作。&lt;/p&gt;
&lt;p&gt;以往我们使用docker run等命令时，其实本质上也是往docker.sock文件中写请求。&lt;/p&gt;
&lt;p&gt;了解到这一点后，我们在创建Docker容器时，就可以把宿主机的docker.sock文件挂载到容器内部，这样，便可以在容器内部控制宿主机对容器的操作了。&lt;/p&gt;
&lt;p&gt;一共有两种方式，第一种是，在容器内部安装docker客户端，然后便可以像在宿主机中一样，使用docker命令，不同的地方时，docker命令控制的并不是容器内部的Docker服务端，而是宿主机中的Docker服务端。&lt;/p&gt;
&lt;p&gt;可以使用如下命令进行容器的创建&lt;code&gt;curl -XPOST --unix-socket /var/run/docker.sock -d &#39;{&amp;quot;Image&amp;quot;:&amp;quot;centos&amp;quot;}&#39; -H &#39;Content-Type: application/json&#39; http://localhost/containers/create&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二种方法是，使用docker-java，通过java api操作宿主机中的Docker服务端。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/dd0c814680ba&#34;&gt;解析 /var/run/docker.sock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/94224305&#34;&gt;Docker客户端连接远程Docker服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">在Docker容器内创建新的Docker容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-07-02-Leetcode 169. 多数元素/"" data-c="
          &lt;p&gt;题目链接：&lt;a href=&#34;https://leetcode-cn.com/problems/majority-element/&#34;&gt;169. 多数元素&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;题目&#34;&gt;题目&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210702100456543.png&#34; alt=&#34;image-20210702100456543&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;h3 id=&#34;哈希表&#34;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        unordered_map&amp;lt;int, int&amp;gt; counts;
        int majority = 0, cnt = 0;
        for (int num: nums) {
            ++counts[num];
            if (counts[num] &amp;gt; cnt) {
                majority = num;
                cnt = counts[num];
            }
        }
        return majority;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分治&#34;&gt;分治&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(logn)&lt;/p&gt;
&lt;p&gt;思路：如果数 &lt;code&gt;a&lt;/code&gt; 是数组 &lt;code&gt;nums&lt;/code&gt; 的众数，如果我们将 &lt;code&gt;nums&lt;/code&gt; 分成两部分，那么 &lt;code&gt;a&lt;/code&gt; 必定是至少一部分的众数（&lt;/p&gt;
&lt;h4 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h4&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;​&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T(n)=2T({n\over2})+2n​
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主定理：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msup&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T(n)=aT({n\over b})+O(n^d) \\
T(n) = \left\{ \begin{array}{lr} 
O(n^d) &amp;amp; d &amp;gt; log_ba \\
O(n^dlogn) &amp;amp; d = log_ba \\
O(b^{log_ba}) &amp;amp; d &amp;lt; log_ba
\end{array} \right.
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.7935600000000003em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.10756em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.149108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.6273239999999998em;vertical-align:-1.5636619999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.05002em;&#34;&gt;&lt;span style=&#34;top:-2.49999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎩&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.15001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.30002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.55002em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-l&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.063662em;&#34;&gt;&lt;span style=&#34;top:-4.214554em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0054459999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.7963380000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3448em;&#34;&gt;&lt;span style=&#34;top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15122857142857138em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5636619999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-r&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.063662em;&#34;&gt;&lt;span style=&#34;top:-4.214554em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0054459999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.7963380000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.5636619999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
    int count_in_range(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int lo, int hi) {
        int count = 0;
        for (int i = lo; i &amp;lt;= hi; ++i)
            if (nums[i] == target)
                ++count;
        return count;
    }
    int majority_element_rec(vector&amp;lt;int&amp;gt;&amp;amp; nums, int lo, int hi) {
        if (lo == hi)
            return nums[lo];
        int mid = (lo + hi) / 2;
        int left_majority = majority_element_rec(nums, lo, mid);
        int right_majority = majority_element_rec(nums, mid + 1, hi);
        if (count_in_range(nums, left_majority, lo, hi) &amp;gt; (hi - lo + 1) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, lo, hi) &amp;gt; (hi - lo + 1) / 2)
            return right_majority;
        return -1;
    }
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;
&lt;h4 id=&#34;快速排序&#34;&gt;快速排序&lt;/h4&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(logn) 栈空间&lt;/p&gt;
&lt;h4 id=&#34;堆排序&#34;&gt;堆排序&lt;/h4&gt;
&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;随机化&#34;&gt;随机化&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;p&gt;思路：随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。&lt;/p&gt;
&lt;p&gt;期望：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∞&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;msubsup&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E=lim_{n\to+\infty}\sum_{i=1}^n i * {1\over 2^i}=2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.104002em;vertical-align:-0.29971000000000003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.25833100000000003em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;→&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;∞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;&lt;span class=&#34;mop op-symbol small-op&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.804292em;&#34;&gt;&lt;span style=&#34;top:-2.40029em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.2029em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.29971000000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7570857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.786em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        while (true) {
            int candidate = nums[rand() % nums.size()];
            int count = 0;
            for (int num : nums)
                if (num == candidate)
                    ++count;
            if (count &amp;gt; nums.size() / 2)
                return candidate;
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多数投票算法&#34;&gt;多数投票算法&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nums:      [#, 7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:     7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      0  1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
               7  7  7  7  7  7   7  7   7  7  7  7   7  7  7  7
value:      0  1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测count是否为0，如果为0，就用当前数组的元素值更新candidate。&lt;/li&gt;
&lt;li&gt;如果当前数组的元素值和candidate相同，那么，count++，否则，count--。&lt;/li&gt;
&lt;li&gt;当数组遍历完时，当前的candidate，就是我们要的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count永远不为负数。&lt;/li&gt;
&lt;li&gt;当candidate和最终答案不相同时，count和value呈相反数；如果candidate和最终答案相同，count和value是相等的。&lt;/li&gt;
&lt;li&gt;value的最终值等于：7的个数-非7的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多数投票算法证明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果候选人不是7，则7会和其他&lt;strong&gt;非&lt;/strong&gt;候选人一起反对候选人，所以候选人一定会下台(count==0时发生换届选举)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果候选人是7，则 7 会支持自己，其他候选人会反对，但因为 7 票数超过一半，所以 7 一定会成功当选&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count &amp;lt; 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">Leetcode 169. 多数元素</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-29-Jmeter ThreadGroup LoopController各参数含义梳理/"" data-c="
          &lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ThreadGroup guiclass=&amp;quot;ThreadGroupGui&amp;quot; testclass=&amp;quot;ThreadGroup&amp;quot; testname=&amp;quot;线程组&amp;quot; enabled=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.on_sample_error&amp;quot;&amp;gt;continue&amp;lt;/stringProp&amp;gt;
	&amp;lt;elementProp name=&amp;quot;ThreadGroup.main_controller&amp;quot; elementType=&amp;quot;LoopController&amp;quot; guiclass=&amp;quot;LoopControlPanel&amp;quot; testclass=&amp;quot;LoopController&amp;quot; testname=&amp;quot;循环控制器&amp;quot; enabled=&amp;quot;true&amp;quot;&amp;gt;
		&amp;lt;boolProp name=&amp;quot;LoopController.continue_forever&amp;quot;&amp;gt;false&amp;lt;/boolProp&amp;gt;
		&amp;lt;intProp name=&amp;quot;LoopController.loops&amp;quot;&amp;gt;-1&amp;lt;/intProp&amp;gt;
	&amp;lt;/elementProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.num_threads&amp;quot;&amp;gt;20&amp;lt;/stringProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.ramp_time&amp;quot;&amp;gt;1&amp;lt;/stringProp&amp;gt;
	&amp;lt;boolProp name=&amp;quot;ThreadGroup.scheduler&amp;quot;&amp;gt;true&amp;lt;/boolProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.duration&amp;quot;&amp;gt;600&amp;lt;/stringProp&amp;gt;
	&amp;lt;stringProp name=&amp;quot;ThreadGroup.delay&amp;quot;&amp;gt;&amp;lt;/stringProp&amp;gt;
	&amp;lt;boolProp name=&amp;quot;ThreadGroup.same_user_on_next_iteration&amp;quot;&amp;gt;true&amp;lt;/boolProp&amp;gt;
&amp;lt;/ThreadGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数说明&#34;&gt;参数说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ThreadGroup.num_threads：并发线程数&lt;/li&gt;
&lt;li&gt;LoopController.loops：每个线程的循环次数，-1表示无限循环。&lt;/li&gt;
&lt;li&gt;压测的总请求数：ThreadGroup.num_threads * LoopController.loops&lt;/li&gt;
&lt;li&gt;调度器配置
&lt;ul&gt;
&lt;li&gt;ThreadGroup.duration：线程组的持续时间&lt;/li&gt;
&lt;li&gt;ThreadGroup.delay：启动延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ThreadGroup.scheduler：调度器是否生效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;压测是否结束&#34;&gt;压测是否结束&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果调度器不生效，则线程组达到循环次数后，压测结束。&lt;/li&gt;
&lt;li&gt;如果调度器生效，则每次循环结束后，都会检查持续时间，如果大于ThreadGroup.duration，则压测结束。在此过程中，如果线程组达到循环次数，也会结束压测。&lt;/li&gt;
&lt;/ul&gt;
">Jmeter ThreadGroup LoopController各参数含义梳理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-25-OpenResty学习笔记/"" data-c="
          &lt;h2 id=&#34;是什么-能做什么&#34;&gt;是什么、能做什么&lt;/h2&gt;
&lt;p&gt;OpenResty 是一个基于 Nginx 的 Web 平台。Web开发人员可以使用 OpenResty 搭建 Web 平台。借助于OpenResty，开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种由 C 语言实现的功能模块，从而实现特定的Web 业务需求。&lt;/p&gt;
&lt;p&gt;OpenResty 本质上是集成了 Lua 组件的 Nginx，是Nginx Plus。&lt;/p&gt;
&lt;h2 id=&#34;优点-缺点是什么&#34;&gt;优点、缺点是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;高并发
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相较于apache（200-300）、tomcat（1000），Nginx可以支持几万的并发量，因此，我们常常使用Nginx做负载均衡，OpenResty的出现，使得开发人员可以依托 Lua 脚本在 Nginx 的内部添加业务代码，充分利用Nginx高并发的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高性能的原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多线程+IO多路复用。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_30764137/article/details/98058884&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;暂未发现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://www.runoob.com/w3cnote/openresty-intro.html&lt;/li&gt;
&lt;li&gt;https://www.zhihu.com/question/266535644?sort=created&lt;/li&gt;
&lt;/ul&gt;
">OpenResty学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-24-跳表/"" data-c="
          &lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树（AVL）媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。&lt;/p&gt;
&lt;p&gt;https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624182132534.png&#34; alt=&#34;image-20210624182132534&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624191004554.png&#34; alt=&#34;image-20210624191004554&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;学过数据结构的都知道，在单链表中查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过2分的方式缩减时间复杂度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205210928206&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211105653&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。&lt;/p&gt;
&lt;p&gt;那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211246498&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？&lt;/p&gt;
&lt;p&gt;如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。&lt;/p&gt;
&lt;p&gt;至此为止，我们引入了最理想的跳跃表，但是如果想要在上图中插入或者删除一个元素呢？比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。我们知道，平衡二叉树的调整是一件令人头痛的事情，左旋右旋左右旋……一般人还真记不住，而调整一个理想的跳跃表将是一个比调整平衡二叉树还复杂的操作。幸运的是，我们并不需要通过复杂的操作调整连接来维护这样完美的跳跃表。有一种基于概率统计的插入算法，也能得到时间复杂度为O(logn)的查询效率，这种跳跃表才是我们真正要实现的。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;h3 id=&#34;抛硬币&#34;&gt;抛硬币&lt;/h3&gt;
&lt;p&gt;先讨论插入，我们先看理想的跳跃表结构，L2层的元素个数是L1层元素个数的1/2，L3层的元素个数是L2层的元素个数的1/2，以此类推。从这里，我们可以想到，只要在插入时尽量保证上一层的元素个数是下一层元素的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么样才能在插入时保证上一层元素个数是下一层元素个数的1/2呢？很简单，抛硬币就能解决了！假设元素X要插入跳跃表，很显然，L1层肯定要插入X。那么L2层要不要插入X呢？我们希望上层元素个数是下层元素个数的1/2，所以我们有1/2的概率希望X插入L2层，那么抛一下硬币吧，正面就插入，反面就不插入。那么L3到底要不要插入X呢？相对于L2层，我们还是希望1/2的概率插入，那么继续抛硬币吧！以此类推，元素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。&lt;/p&gt;
&lt;p&gt;在此还是以上图为例：跳跃表的初试状态如下图，表中没有一个元素：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212059243&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果我们要插入元素2，首先是在底部插入元素2，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212313963&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我们抛硬币，结果是正面，那么我们要将2插入到L2层，如下图:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212409123&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;继续抛硬币，结果是反面，那么元素2的插入操作就停止了，插入后的表结构就是上图所示。接下来，我们插入元素33，跟元素2的插入一样，现在L1层插入33，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212458264&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后抛硬币，结果是反面，那么元素33的插入操作就结束了，插入后的表结构就是上图所示。接下来，我们插入元素55，首先在L1插入55，插入后如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212553339&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后抛硬币，结果是正面，那么L2层需要插入55，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212659309&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;继续抛硬币，结果又是正面，那么L3层需要插入55，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205212712590&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以此类推，我们插入剩余的元素。当然因为规模小，结果很可能不是一个理想的跳跃表。但是如果元素个数n的规模很大，学过概率论的同学都知道，最终的表结构肯定非常接近于理想跳跃表。&lt;/p&gt;
&lt;p&gt;当然，这样的分析在感性上是很直接的，但是时间复杂度的证明实在复杂，在此我就不深究了，感兴趣的可以去看关于跳跃表的paper。再讨论删除，删除操作没什么讲的，直接删除元素，然后调整一下删除元素后的指针即可。跟普通的链表删除操作完全一样。再来讨论一下时间复杂度，插入和删除的时间复杂度就是查询元素插入位置的时间复杂度，这不难理解，所以是O(logn)。&lt;/p&gt;
&lt;h3 id=&#34;随机数&#34;&gt;随机数&lt;/h3&gt;
&lt;p&gt;在上一节中，我们采用抛硬币的方式来决定新元素插入的最高层数，这当然不能在程序中实现。代码中，我们采用随机数生成的方式来获取新元素插入的最高层数。我们先估摸一下n的规模，然后定义跳跃表的最大层数maxLevel，那么底层，也就是第0层，元素是一定要插入的，概率为1；最高层，也就是maxLevel层，元素插入的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.099108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们先随机生成一个范围为0~&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel}-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.932438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一个整数r。那么元素r小于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8491079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的概率为1/2，r小于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{maxLevel-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8491079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的概率为1/4，……，r小于2的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0991079999999998em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，r小于1的概率为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/2^{maxLevel}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.099108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举例，假设maxLevel为4，那么r的范围为0~15，则r小于8的概率为1/2，r小于4的概率为1/4，r小于2的概率为1/8，r小于1的概率为1/16。1/16正好是maxLevel层插入元素的概率，以此类推。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210624193459656.png&#34; alt=&#34;image-20210624193459656&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以上分析是随机数算法的关键。算法跟实现跟语言无关，以下贴一下C++语言的代码实现。&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Node* next;&lt;/p&gt;
&lt;p&gt;Node* next[MAXL];&lt;/p&gt;
&lt;p&gt;next[2] = null;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct SkipListNode {
    int val;
    vector&amp;lt;SkipListNode *&amp;gt; level;
    SkipListNode (int _val, int sz=32) : val(_val), level(sz, nullptr) {}
};

class Skiplist {
public:
    SkipListNode *head, *tail;
    int level, length;
    static int MAXL = 32;

    Skiplist() {
        level = length = 0;
        tail = new SkipListNode(INT_MAX, 0);
        head = new SkipListNode(-INT_MAX);
        for (int i = 0; i &amp;lt; MAXL; ++i) {
            head-&amp;gt;level[i] = tail;
        }
    }

    SkipListNode* find(int val) {
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
        }
        p = p-&amp;gt;level[0];
        return p;
    }

    bool search(int target) {
        SkipListNode *p = find(target);
        return p-&amp;gt;val == target;
    }

    void add(int val) {
        vector&amp;lt;SkipListNode *&amp;gt; update(MAXL);
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
            update[i] = p;
        }
        int lv = randomLevel();
        if (lv &amp;gt; level) {
            lv = ++level;
            update[lv - 1] = head;
        }
        SkipListNode *newNode = new SkipListNode(val, lv);
        for (int i = lv - 1; i &amp;gt;= 0; --i) {
            p = update[i];
            newNode-&amp;gt;level[i] = p-&amp;gt;level[i];
            p-&amp;gt;level[i] = newNode;
        }
        ++length;
    }

    bool erase(int val) {
        vector&amp;lt;SkipListNode *&amp;gt; update(MAXL + 1);
        SkipListNode *p = head;
        for (int i = level - 1; i &amp;gt;= 0; --i) {
            while (p-&amp;gt;level[i] &amp;amp;&amp;amp; p-&amp;gt;level[i]-&amp;gt;val &amp;lt; val) {
                p = p-&amp;gt;level[i];
            }
            update[i] = p;
        }
        p = p-&amp;gt;level[0];
        if (p-&amp;gt;val != val) return false;
        for (int i = 0; i &amp;lt; level; ++i) {
            if (update[i]-&amp;gt;level[i] != p) {
                break;
            }
            update[i]-&amp;gt;level[i] = p-&amp;gt;level[i];
        }
        while (level &amp;gt; 0 &amp;amp;&amp;amp; head-&amp;gt;level[level - 1] == tail)
            --level;
        --length;
        return true;
    }

    int randomLevel() {
        int level, r = rand(), target = INT_MAX/2;
        level = 0;
        for (int i = 1; i &amp;lt; MAXL; i++)
            if( r &amp;gt; INT_MAX-target ) {
                level = i;
                target /= 2;
            } else {
                break;
            }
        return level+1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习&#34;&gt;练习&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/design-skiplist/&#34;&gt;1206. 设计跳表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u013709270/article/details/53470428&lt;/li&gt;
&lt;/ul&gt;
">跳表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-06-09-Kafka学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Kafka过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coding.imooc.com/class/434.html&#34;&gt;Kafka多维度系统精讲，从入门到熟练掌握&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;课程大纲：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210609101437740.png&#34; alt=&#34;image-20210609101437740&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;partition&#34;&gt;Partition&lt;/h2&gt;
&lt;p&gt;Partition 在 Kafka 中是分区的意思。&lt;/p&gt;
&lt;p&gt;Kafka 中每个 Topic 可以划分多个分区，同一个 Topic 下的不同分区包含的消息是不同的。&lt;/p&gt;
&lt;p&gt;Kafka 通过 offset 可以保证消息在分区中的顺序性，但是跨分区是无序的，即 Kafka 只保证在同一个分区内的消息是有序的。&lt;/p&gt;
&lt;p&gt;每一条消息发送到 broker 的时候，会根据 Partition 的分区规则计算，然后选择将该消息存储到哪一个 Partition。&lt;/p&gt;
&lt;p&gt;参考资料：https://blog.csdn.net/lzb348110175/article/details/100764105&lt;/p&gt;
&lt;p&gt;Partition和Consumer的关系不能是1对多，即，一个Partition由多个Comsumer进行消费。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是由Consumer的消费机制决定的，Consumer在拿到消息后，需要在处理完后向Kafka提交处理结果，即，告诉Kafka这批消息已经处理好了（可以以自动的方式进行提交，也可以手动提交）。而在Kafka中，最小颗粒度的数据存储就是Partition，那么，如果有两个Consumer同时消费一个Partiton，就会导致线程不安全，即，两个Consumer同时拿到数据，然后导致数据冲突。&lt;/li&gt;
&lt;li&gt;如果是多个Consumer对应多个Partition，则不会出现这个情况，因为不同Partition之间是不会相互影响的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解读源码&#34;&gt;解读源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Producer在创建时，会新建发送线程，该线程会定时批量发送所有的消息。因此，Kafka是批量发送，不是调用一次send就发送一次，所以效率较高。&lt;/li&gt;
&lt;li&gt;当调用send后，会将消息存储在batch（批次）中，当达到一定阈值时，发送线程会自动进行消息的批量发送。因此，严格意义上，消息发送不是由send实现的。&lt;/li&gt;
&lt;li&gt;Kafka是线程安全的，可以多线程复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Producer
&lt;ul&gt;
&lt;li&gt;ACKS_CONFIG：消息传递保障&lt;/li&gt;
&lt;li&gt;RETRIES_CONFIG：发送失败后重试次数&lt;/li&gt;
&lt;li&gt;BATCH_SIZE_CONFIG：最大批次容量&lt;/li&gt;
&lt;li&gt;LINGER_MS_CONFIG：批量发送间隔时间&lt;/li&gt;
&lt;li&gt;BUFFER_MEMORY_CONFIG：缓存大小&lt;/li&gt;
&lt;li&gt;BATCH_SIZE &lt;strong&gt;VS&lt;/strong&gt; BUFFER_MEMORY
&lt;ul&gt;
&lt;li&gt;参考资料：https://blog.csdn.net/u010711495/article/details/113250402&lt;/li&gt;
&lt;li&gt;Kafka的所有信息都会存在缓存中，包括配置信息、消息等，一旦缓存满了，Kafka就会禁止用户再发送消息；而对于最大批次容量，当批次实际大小达到最大批次容量时，就会触发发送线程的发送；因此，一般缓存大小都是大于最大批次容量的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;KEY_SERIALIZER_CLASS_CONFIG：key序列化类&lt;/li&gt;
&lt;li&gt;VALUE_SERIALIZER_CLASS_CONFIG：value序列化类&lt;/li&gt;
&lt;li&gt;PARTITIONER_CLASS_CONFIG：自定义partition选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息传递保障&#34;&gt;消息传递保障&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最多一次：发了就不管了&lt;/li&gt;
&lt;li&gt;最少一次：一直发，直到收到响应&lt;/li&gt;
&lt;li&gt;正好一次：一直发，直到收到响应，但是接收方需要去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;key的作用&#34;&gt;Key的作用&lt;/h2&gt;
&lt;p&gt;Kafka的消息是一对键值对，Key在Kafka中的主要作用是选择分区，若用户没有指定分区，则Kafka会根据key的hash决定分区的选择。&lt;/p&gt;
&lt;p&gt;Kafka在设计时使用键值对的形式，可以为使用者提供功能上的扩展，例如可以自定义分区规则，将相同key的消息放在同一个分区中。&lt;/p&gt;
&lt;p&gt;当然，如果某些业务场景下对key没有特殊要求，这个字段也是可以不填的。&lt;/p&gt;
&lt;h2 id=&#34;kafka-vs-redis&#34;&gt;Kafka VS Redis&lt;/h2&gt;
&lt;p&gt;Redis List的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持重复消费：消息一旦被消费，就会从 Redis 中删除，无法再被其他消费者消费。&lt;/li&gt;
&lt;li&gt;消息丢失：消费者获取消息后，若发生异常宕机，则消息就会丢失。&lt;/li&gt;
&lt;li&gt;当List达到最大长度，则无法继续添加新的消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis Pub/Sub的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息丢失
&lt;ul&gt;
&lt;li&gt;消费者下线&lt;/li&gt;
&lt;li&gt;Redis 宕机&lt;/li&gt;
&lt;li&gt;消息堆积：当消息超过消费者缓冲区大小，Redis 会强制消费者下线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考资料：https://www.jianshu.com/p/c37368c867f8&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lzb348110175/category_9309572.html&#34;&gt;CSDN kafka-扛麻袋的少年&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Kafka学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-27-NIO与epoll模型学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习BIO NIO AIO、epoll模型、Netty框架过程中的笔记，学习资料为文档及视频，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/aLXiPUwmRs4&#34;&gt;深入Hotspot源码与Linux内核理解NIO与Netty线程模型-预习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/hyVcrKK9xHF&#34;&gt;深入Hotspot源码与Linux内核理解NIO与Netty线程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/5nSfgiayKS5&#34;&gt;高性能网络通信框架Netty从入门到核心源码剖析-预习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/H5MPxB4cCcd&#34;&gt;高性能网络通信框架Netty从入门到核心源码剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;bio-blocking-io&#34;&gt;BIO-Blocking IO&lt;/h2&gt;
&lt;h3 id=&#34;基本写法&#34;&gt;基本写法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    BufferedReader reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
    System.out.println( reader.readLine() );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：并发量为1&lt;/p&gt;
&lt;h3 id=&#34;优化1使用多线程进行优化&#34;&gt;优化1：使用多线程进行优化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    new Thread() {
        @Override
        public void run() {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
                System.out.println( reader.readLine() );
            } catch (IOException e) {
                e.printStackTrace();
            }
            
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：存在C10K问题，当并发量过大时，因为开的线程太多，会被内存挤爆。&lt;/p&gt;
&lt;h3 id=&#34;优化2使用线程池进行优化&#34;&gt;优化2：使用线程池进行优化&lt;/h3&gt;
&lt;p&gt;缺点：并发数会受到线程池中线程数的约束&lt;/p&gt;
&lt;h3 id=&#34;共同问题&#34;&gt;共同问题&lt;/h3&gt;
&lt;p&gt;可能会存在建立连接后不发数据的情况，导致该线程阻塞，降低系统性能&lt;/p&gt;
&lt;h2 id=&#34;nio-non-blocking-io&#34;&gt;NIO-Non-blocking IO&lt;/h2&gt;
&lt;h3 id=&#34;基本写法-2&#34;&gt;基本写法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
List&amp;lt;SocketChannel&amp;gt; socketChannelList = new ArrayList&amp;lt;&amp;gt;();
while( true ) {
    SocketChannel socketChannel = serverChannel.accept();
    if( socketChannel != null ) {
        socketChannel.configureBlocking( false );
        socketChannelList.add( socketChannel );
    }
    Iterator&amp;lt;SocketChannel&amp;gt; iterator = socketChannelList.iterator();
    while( iterator.hasNext() ) {
        SocketChannel socketChannel1 = iterator.next();
        ByteBuffer byteBuffer = ByteBuffer.allocate(128);
        int len = socketChannel1.read( byteBuffer );
        if( len &amp;gt; 0 ) {
            System.out.println( new String(byteBuffer.array()));
        } else if( len == -1 ) {
            iterator.remove();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对所有连接进行轮询，判断是否发送数据，但可能大部分连接都没有发送数据（空轮询）&lt;/li&gt;
&lt;li&gt;C10K问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优化使用selector进行优化&#34;&gt;优化：使用selector进行优化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
Selector selector = Selector.open();
serverChannel.register( selector, SelectionKey.OP_ACCEPT );
while( true ) {
    selector.select();
    Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
    Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
    while( iterator.hasNext() ) {
        SelectionKey selectionKey = iterator.next();
        if( selectionKey.isAcceptable() ) {
            ServerSocketChannel serverChannel1 = (ServerSocketChannel) selectionKey.channel();
            SocketChannel socketChannel = serverChannel1.accept();
            socketChannel.register( selector, SelectionKey.OP_READ );
        } else if( selectionKey.isReadable() ) {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(128);
            int len = socketChannel.read( byteBuffer );
            if( len &amp;gt; 0 ) {
                System.out.println( new String(byteBuffer.array()));
            } else if( len == -1 ) {
                iterator.remove();
            }
        }
        iterator.remove();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;selector原理&#34;&gt;Selector原理&lt;/h3&gt;
&lt;p&gt;在linux环境下，selector基于epoll实现（在windows环境下，不基于epoll）。&lt;/p&gt;
&lt;p&gt;使用epoll_create创建epoll对象，使用epoll_ctl进行注册，使用epoll_wait进行阻塞监听。&lt;/p&gt;
&lt;p&gt;Java调用操作系统的内核函数来创建Socket，获取到Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符，将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知。&lt;/p&gt;
&lt;p&gt;epoll基于“回调”实现监听。&lt;/p&gt;
&lt;p&gt;在Selector中，连接建立、数据读取都依赖于系统函数，例如，连接建立依赖于accept函数。因此，Selector可以使用epoll监听系统函数的调用，从而实现对连接建立、数据读取的监听。&lt;/p&gt;
&lt;p&gt;本质上，epoll监听的是文件描述符的状态（可读、可写）&lt;/p&gt;
&lt;h3 id=&#34;对selector的理解&#34;&gt;对Selector的理解&lt;/h3&gt;
&lt;p&gt;在Selector的实现中，看似是存在阻塞的（&lt;code&gt;selector.select()&lt;/code&gt;），但Selector依旧属于同步非阻塞IO的范畴，这是因为，这里所谓的阻塞，指的是当有多个连接希望建立时，因为正在处理某个连接的建立，导致其他连接无法被处理（连接被阻塞了），因此，这里所谓的阻塞，面向的对象是连接，当然，也可以是数据的读取，而不是程序的阻塞。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;selector.select()&lt;/code&gt;方法，当没有连接希望建立时，会阻塞，一旦有连接希望建立，则会立刻结束阻塞，且当有多个连接希望建立时，多个连接之间也不会有相互影响（即，因为线程A的建立，导致线程B建立请求的阻塞）。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;selector.select()&lt;/code&gt;方法的内部，其实调用的是&lt;code&gt;epoll_wait&lt;/code&gt;方法，这个方法是异步非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;对epoll的理解&#34;&gt;对epoll的理解&lt;/h3&gt;
&lt;p&gt;epoll本质上还是属于NIO的，虽然它的内部实现是基于“回调”的。&lt;/p&gt;
&lt;p&gt;这句话怎么理解？&lt;/p&gt;
&lt;p&gt;在epoll中，会有一个就绪队列，当监听的fd（文件描述符）完成某个操作（完成连接、读取数据完成等）时，内核会触发epoll的回调函数，回调函数会把该fd放入就绪队列里。&lt;code&gt;epoll_wait&lt;/code&gt; 会监听就绪队列，当就绪队列中存在fd时，则会返回。&lt;/p&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/h2604396739/article/details/82534253&#34;&gt;BIO\NIO\AIO再理解，nio轮询方式与epoll&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nio与aio-asynchronous-io-的区别&#34;&gt;NIO与AIO (Asynchronous IO) 的区别&lt;/h2&gt;
&lt;p&gt;NIO为同步非阻塞IO，会在程序中进行轮询，当发现有事件发生后，会对事件进行处理。&lt;/p&gt;
&lt;p&gt;AIO为异步非阻塞IO，预先写好处理逻辑，当有事件发生后，处理函数会被调用，用于处理事件（观察者模式）。&lt;/p&gt;
&lt;h2 id=&#34;对io多路复用的理解&#34;&gt;对IO多路复用的理解&lt;/h2&gt;
&lt;p&gt;如果不使用IO多路复用技术，那么对于每一个请求，都需要一个线程去进行管理，而如果使用了IO多路复用技术，则可以使用一个线程去管理多个请求，这里所谓的复用，指的是线程的复用。&lt;/p&gt;
&lt;p&gt;对于select和poll，使用的是轮询，即，在一个线程中，遍历所有的请求。而epoll，使用的是回调，即，当收到内核的通知后，将请求放到就绪队列中，同时，用 &lt;code&gt;epoll_wait&lt;/code&gt; 监听就绪队列。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210813163540811.png&#34; alt=&#34;image-20210813163540811&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/32163005&#34;&gt;IO 多路复用是什么意思？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty&#34;&gt;Netty&lt;/h2&gt;
&lt;h3 id=&#34;零拷贝机制&#34;&gt;零拷贝机制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210824140232560.png&#34; alt=&#34;image-20210824140232560&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">BIO NIO AIO、epoll模型、Netty框架学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-14-RESTHeart学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Zabbix过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://restheart.org/docs/try/&#34;&gt;Try RESTHeart Online&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/rongfengliang/p/9584470.html&#34;&gt;restheart 基本使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;PS：在RESTHeart中，如果要更新的item不存在，则会自动进行创建。&lt;/p&gt;
&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;h3 id=&#34;创建文档&#34;&gt;创建文档&lt;/h3&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;获取&#34;&gt;获取&lt;/h2&gt;
&lt;h3 id=&#34;获取集合中所有文档&#34;&gt;获取集合中所有文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;获取特定文档&#34;&gt;获取特定文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;指定过滤条件获取集合中的部分文档&#34;&gt;指定过滤条件，获取集合中的部分文档&lt;/h3&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id?filter={&#39;from&#39;:&#39;you&#39;}&amp;amp;pagesize=2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;
&lt;h3 id=&#34;更新数据库&#34;&gt;更新数据库&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新集合&#34;&gt;更新集合&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新整个文档&#34;&gt;更新整个文档&lt;/h3&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更新文档中的部分内容&#34;&gt;更新文档中的部分内容&lt;/h3&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;p&gt;&lt;code&gt;host_url/db_id/collection_id/document_id -d &amp;quot;{&#39;from&#39;:&#39;you&#39;,&#39;message&#39;:&#39;create document&#39;}&amp;quot;&lt;/code&gt;&lt;/p&gt;
">RESTHeart学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-14-Zabbix学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Zabbix过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zsythink.net/archives/790&#34;&gt;zabbix从放弃到入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
">Zabbix学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-13-Celery学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习Celery过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/22304455&#34;&gt;使用Celery-小明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210513101505012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Celery学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-12-MongoDB学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习MongoDB过程中的笔记&lt;/p&gt;
&lt;p&gt;学习资料来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xiaohuiduan/p/11403891.html&#34;&gt;Mongodb最基础入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/64352&#34;&gt;什么场景应该用 MongoDB ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/32071167&#34;&gt;MongoDB 应用场景?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mongodb使用场景&#34;&gt;MongoDB使用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用方便
&lt;ul&gt;
&lt;li&gt;增加字段不用改表结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可进行地理位置查询&lt;/li&gt;
&lt;li&gt;方便扩展&lt;/li&gt;
&lt;/ul&gt;
">MongoDB学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-08-redis学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习redis过程中的笔记，学习资料为视频及pdf，链接如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/2Fg2Arj1Doe&#34;&gt;双十一秒杀系统后端Redis高并发架构实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/N7WiV8Wgjm9&#34;&gt;亿级流量新浪微博与微信Redis架构实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/e1jtR4D15kz&#34;&gt;Redis常见面试题汇总.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/CprZdykwNd2&#34;&gt;Redis持久化、主从与哨兵架构详解.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/s/1HdqGt4krK1&#34;&gt;Redis命令参考手册完整版.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分布式&#34;&gt;分布式&lt;/h2&gt;
&lt;h3 id=&#34;分布式并发场景中可能存在的问题&#34;&gt;分布式并发场景中可能存在的问题&lt;/h3&gt;
&lt;p&gt;使用synchronized对代码块加锁，但因为是分布式，多个应用同时访问redis，依旧无法解决并发冲突问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508160113749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;redis实现分布式锁&#34;&gt;Redis实现分布式锁&lt;/h3&gt;
&lt;p&gt;使用SETNX实现分布式锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存在的问题：因为某些原因，锁在用完后没有成功释放，如，功能代码块抛异常、系统宕机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加过期时间：&lt;/li&gt;
&lt;li&gt;存在的问题：
&lt;ul&gt;
&lt;li&gt;实际业务执行时间可能会大于过期时间：进程A执行过慢，导致锁自动被释放，之后进程B进行加锁，开始处理业务，然后进程A执行完，释放B的锁，又导致进程C进行加锁，无限循环，最终导致锁永久失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：自己的锁只有自己可以释放（或者过期自动释放）
&lt;ul&gt;
&lt;li&gt;存在的问题：
&lt;ul&gt;
&lt;li&gt;还是&lt;strong&gt;过期时间&lt;/strong&gt;的锅：当进程A需要释放锁的时候，从redis获取锁的value，发现是自己加的锁，但随后，锁因为过期时间，自动失效，进程B随即进行加锁，然后进程A释放锁，就导致会把进程B的锁释放掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;锁续命：另开一个线程，持续进行加锁操作，例如过期时间是30s，则每10s加一次锁，保证业务执行过程中，锁不会自动失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式锁的性能问题&#34;&gt;分布式锁的性能问题&lt;/h3&gt;
&lt;p&gt;使用分布式锁，本质上是让所有web请求串行化执行，执行效率较低。&lt;/p&gt;
&lt;p&gt;解决方案：分段加锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例：秒杀场景下，为了防止超卖，需要使用分布式锁，例如商品数量为200个，那么可以划分成10分，分别进行加锁，这样可以提高约10倍的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存-数据库双写不一致问题&#34;&gt;缓存、数据库双写不一致问题&lt;/h2&gt;
&lt;p&gt;场景1：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213252468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;场景2：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213547682.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;不一致&lt;/strong&gt;：数据库里数据为6，缓存为10&lt;/p&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;比较不推荐的做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟双删&lt;/li&gt;
&lt;li&gt;内存队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读多写少
&lt;ul&gt;
&lt;li&gt;分布式锁：通过读写锁进行优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读多写多，对一致性要求不高
&lt;ul&gt;
&lt;li&gt;给缓存设置过期时间，保证双写不一致的最大时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读多写多，对一致性要求高
&lt;ul&gt;
&lt;li&gt;不要用缓存：因为缓存更新后，可能过了几秒，就又要进行更新。这种情况下，不如不用缓存。&lt;/li&gt;
&lt;li&gt;使用canal中间件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;p&gt;全称：Remote Dictionary Server&lt;/p&gt;
&lt;h3 id=&#34;为什么性能高&#34;&gt;为什么性能高&lt;/h3&gt;
&lt;p&gt;对性能的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消极
&lt;ul&gt;
&lt;li&gt;单线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;积极
&lt;ul&gt;
&lt;li&gt;内存操作&lt;/li&gt;
&lt;li&gt;基于epoll的多路复用模型&lt;/li&gt;
&lt;li&gt;高效的数据存储结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据存储结构&#34;&gt;数据存储结构&lt;/h4&gt;
&lt;p&gt;redis使用哈希表存储key-value对&lt;/p&gt;
&lt;p&gt;在redis中有对象和数据结构的概念，redis对象利用不同的数据结构进行存储，例如，String对象可以用int数据结构进行存储，也可以用SDS数据结构进行存储。&lt;/p&gt;
&lt;p&gt;对不同类型的对象，内部存储逻辑不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDS数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;embstr：小于等于44字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png&#34; alt=&#34;image-20210528141323986&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw：大于44字节&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png&#34; alt=&#34;image-20210528141338577&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;embstr与raw的区别是，embstr只会申请一次内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hash对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png&#34; alt=&#34;image-20210525101358367&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表：空间占用大，查找快&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表：数据数量较少或所占空间较少时，使用压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链表：空间占用更多，但添加、删除元素时，效率高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速列表：Redis3.2之后，用快速列表代替压缩列表和链表&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png&#34; alt=&#34;image-20210528150649602&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数集合&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSet对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;压缩列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳表：查找快，但更占空间且更新性能低&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png&#34; alt=&#34;image-20210524163213876&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当元素个数超过&lt;code&gt;zset-max-ziplist-entries&lt;/code&gt;，切换成跳表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;epoll多路复用模型&#34;&gt;epoll多路复用模型&lt;/h4&gt;
&lt;h5 id=&#34;redis为什么要用epollredis为什么采用单线程&#34;&gt;redis为什么要用epoll（redis为什么采用单线程）&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;redis是单线程的：redis是内存操作，虽然内存的速度比CPU慢，但依旧很快，CPU的利用率较高，无需使用多线程提高CPU的利用率。在正常程序中，因为包含大量IO操作，CPU使用率不高，此时，使用多线程可以提高CPU利用率，优化性能。&lt;/li&gt;
&lt;li&gt;对于单线程的应用，当用户进行网络请求后，该线程会被阻塞，等待用户输入。线程被阻塞，也就意味着整个进程、整个redis被阻塞。若等待用户输入时间较长，则在高并发场景下，会极大影响redis性能。&lt;/li&gt;
&lt;li&gt;因此，redis需要将等待用户输入这一操作委托给系统去完成，即，redis基于系统提供的epoll实现了多路复用模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;epoll的实现原理&#34;&gt;epoll的实现原理&lt;/h5&gt;
&lt;h5 id=&#34;redis如何使用epoll&#34;&gt;redis如何使用epoll&lt;/h5&gt;
&lt;p&gt;epoll_create&lt;/p&gt;
&lt;p&gt;epoll_ctl&lt;/p&gt;
&lt;p&gt;epoll_wait&lt;/p&gt;
&lt;h3 id=&#34;不同数据类型的适用场景&#34;&gt;不同数据类型的适用场景&lt;/h3&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单值缓存&lt;/li&gt;
&lt;li&gt;对象缓存：JSON字符串&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;计数器&lt;/li&gt;
&lt;li&gt;分布式系统全局序列号
&lt;ul&gt;
&lt;li&gt;分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象缓存
&lt;ul&gt;
&lt;li&gt;与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现栈、队列、拥塞队列&lt;/li&gt;
&lt;li&gt;消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽奖功能：因为set有srandmember、spop方法&lt;/li&gt;
&lt;li&gt;点赞功能：频繁添加、删除、比较元素，用set效率比list好&lt;/li&gt;
&lt;li&gt;关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZSet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排行榜&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备份策略&#34;&gt;备份策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份&lt;/li&gt;
&lt;li&gt;每天都保留一份当日的数据备份到一个目录中去，保留最近1个月的备份&lt;/li&gt;
&lt;li&gt;每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主从架构&#34;&gt;主从架构&lt;/h3&gt;
&lt;p&gt;防止单点redis宕机，对业务造成影响&lt;/p&gt;
&lt;p&gt;使用主从架构，子节点同步父节点信息，当父节点宕机后，用子节点代替父节点继续提供服务&lt;/p&gt;
&lt;p&gt;主从节点切换导致锁丢失：使用zookeeper代替redis&lt;/p&gt;
&lt;p&gt;redis vs zookeeper：redis性能更好；zookeeper一致性更好。&lt;/p&gt;
&lt;h3 id=&#34;哨兵机制&#34;&gt;哨兵机制&lt;/h3&gt;
&lt;p&gt;1、故障节点主观下线&lt;/p&gt;
&lt;p&gt;2、故障节点客观下线&lt;/p&gt;
&lt;p&gt;3、Sentinel集群选举Leader&lt;/p&gt;
&lt;p&gt;4、Sentinel Leader决定新主节点&lt;/p&gt;
&lt;p&gt;详细资料：&lt;a href=&#34;https://blog.csdn.net/weixin_28871885/article/details/113315639&#34;&gt;redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;lua脚本&#34;&gt;Lua脚本&lt;/h3&gt;
&lt;p&gt;Lua脚本可以植入redis内部进行运行&lt;/p&gt;
&lt;p&gt;Lua脚本的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少网络开销：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。&lt;/li&gt;
&lt;li&gt;原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。&lt;/li&gt;
&lt;li&gt;替代redis的事务功能：redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐如果要使用redis的事务功能可以用redis lua替代。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-vs-kafka&#34;&gt;Redis vs Kafka&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112907568&#34;&gt;花5min就能搞清楚redis和zookeeper分布式锁的区别，太有必要读一下了&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;面试&#34;&gt;面试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA&#34;&gt;整理好了，Redis面试题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hunternet/p/11306690.html&#34;&gt;Redis数据结构——压缩列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_45401061/article/details/107382276&#34;&gt;面试官：Redis 为什么这么快？除了基于内存操作还有其他原因吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u011663149/article/details/85307615&#34;&gt;Redis为什么是单线程、及高并发快的大原因详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yyoc97/article/details/85804654&#34;&gt;从redis为什么单线程还那么快到epoll的设计原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_28871885/article/details/113315639&#34;&gt;redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">redis学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-05-07-docker学习笔记/"" data-c="
          &lt;p&gt;这篇文章主要记录了学习docker过程中的笔记，学习资料为视频，链接如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ke.qq.com/course/3385294?taid=11066554472179662&#34;&gt;Docker部署微服务实战&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 设置yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# 安装docker
yum -y install docker-ce # ce为社区版
# 启动docker
service docker start
# 验证
docker version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;h3 id=&#34;镜像相关&#34;&gt;镜像相关&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 搜索镜像
docker search java
# 下载镜像
docker pull java:8
docker pull nginx:1.14
# 列出本地镜像
docker images
# 删除镜像
docker rmi java:8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;容器相关&#34;&gt;容器相关&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 新建并启动容器
docker run -d -p 91:80 -net=bridge(default)/host nginx
# 列出容器
docker ps
# 启动/停止容器
docker start/stop container_id
# 查看容器信息
docker inspect container_id
# 进入容器
docker container exec -it container_id /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;好处&#34;&gt;好处&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将主流的中间件打包成docker，可实现快速部署。因为docker的使用，如启动和关闭，命令都是相同的，所以可以使用脚本实现自动化的部署。而如果不使用docker，不同的中间件都有一套对应的运维命令，运维工作的效率将会降低很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker技术提供了一种管理机制，可以对各种制品进行统一管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 的镜像机制提供了一种更高级的通用的应用制品（artifact）包，也就是大家说的集装箱能力。原来各种操作系统或编程语言都有各自己的制品机制，Ubuntu 的 deb，RedHat 的 RPM，Java 的 JAR、WAR，各自的依赖管理，制品库都不相同。应用从源码打包，分发到制品库，再部署到服务器，很难抽象出一种通用的流程和机制。而有了 Docker 的镜像以及镜像仓库标准之后，这个流程终于可以标准化了。于是雨后春笋般冒出很多镜像管理仓库，这在以前的制品管理领域是很难想象的，以前貌似也就 Java 领域的 nexus 和 artifactory 略完备些。&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;amp;mid=2653548284&amp;amp;idx=1&amp;amp;sn=9243449fac7e86342f84da3a6a87453c&amp;amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;amp;scene=21#wechat_redirect&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 指定基础镜像
FROM nginx
# 执行命令
RUN echo &amp;quot;hello, world!&amp;quot; &amp;gt; hello.html
# 复制文件到容器
ADD a.jar /app.jar
# 声明需要暴露的端口
EXPOSE 8761
# 配置容器启动后执行的命令
ENTRYPOINT[&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]

docker build -t nginx:hello .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;virtual-machines-vs-docker&#34;&gt;Virtual Machines VS Docker&lt;/h2&gt;
&lt;p&gt;OS：虚拟机有实实在在的操作系统；Docker通过引擎虚拟操作系统&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210507193822675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">docker学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-25-NOJ优化-PHP-Laravel/"" data-c="
          &lt;p&gt;这篇文章，主要介绍一下NOJ的部署。&lt;/p&gt;
&lt;p&gt;主要参考这篇文章：https://njuptaaa.github.io/docs/#/noj/guide/deploy&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;
&lt;h3 id=&#34;安装环境&#34;&gt;安装环境&lt;/h3&gt;
&lt;p&gt;需要安装的环境有：Apache、PHP、Composer、MySQL、Redis&lt;/p&gt;
&lt;p&gt;Apache和MySQL在我本地已经有了，直接跳过。&lt;/p&gt;
&lt;p&gt;对于PHP和Composer，直接在官网下载，需要注意的是，对于Composer，直接下载可执行的安装包就行；对于PHP，需要下载的是zip，而不是source code，如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175552450.png&#34; alt=&#34;image-20210425175552450&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;PHP压缩包下载完，解压到任意文件夹中，然后运行Composer的安装程序，在安装过程中，需要指定php的路径，选择解压后文件夹中的php.exe：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175722912.png&#34; alt=&#34;image-20210425175722912&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;git-clone&#34;&gt;git-clone&lt;/h3&gt;
&lt;p&gt;在这一步，需要注意的是，需要把noj项目克隆到apache或者nginx的文件夹下，并将其中的public文件夹设置成根目录。&lt;/p&gt;
&lt;h3 id=&#34;composer-install&#34;&gt;composer install&lt;/h3&gt;
&lt;h4 id=&#34;your-lock-file-does-not-contain-a-compatible-set-of-packages-please-run-composer-update&#34;&gt;Your lock file does not contain a compatible set of packages. Please run composer update.&lt;/h4&gt;
&lt;p&gt;环境配置好后，就可以开始安装项目了，使用&lt;code&gt;composer install&lt;/code&gt;进行安装，但我本地报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;E:\NOJ&amp;gt;composer install
Installing dependencies from lock file (including require-dev)
Verifying lock file contents can be installed on current platform.
Your lock file does not contain a compatible set of packages. Please run composer update.

  Problem 1
    - grubersjoe/bing-daily-photo is locked to version v2.0.0 and an update of this package was not requested.
    - grubersjoe/bing-daily-photo v2.0.0 requires ext-intl * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s intl extension.
  Problem 2
    - intervention/image is locked to version 2.5.1 and an update of this package was not requested.
    - intervention/image 2.5.1 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 3
    - league/flysystem is locked to version 1.1.3 and an update of this package was not requested.
    - league/flysystem 1.1.3 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 4
    - league/mime-type-detection is locked to version 1.5.1 and an update of this package was not requested.
    - league/mime-type-detection 1.5.1 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 5
    - phpoffice/phpspreadsheet is locked to version 1.15.0 and an update of this package was not requested.
    - phpoffice/phpspreadsheet 1.15.0 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
  Problem 6
    - league/flysystem 1.1.3 requires ext-fileinfo * -&amp;gt; it is missing from your system. Install or enable PHP&#39;s fileinfo extension.
    - spatie/laravel-backup 6.13.1 requires league/flysystem ^1.0.49 -&amp;gt; satisfiable by league/flysystem[1.1.3].
    - spatie/laravel-backup is locked to version 6.13.1 and an update of this package was not requested.

To enable extensions, verify that they are enabled in your .ini files:
    - E:\environment\php\php-7.3.27-nts-Win32-VC15-x64\php.ini
You can also run `php --ini` inside terminal to see which files are used by PHP in CLI mode.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;composer install --ignore-platform-reqs&lt;/code&gt;就不会报错了。&lt;/p&gt;
&lt;h4 id=&#34;the-process-class-relies-on-proc_open-which-is-not-available-on-your-php-installation&#34;&gt;The Process class relies on proc_open, which is not available on your PHP installation.&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lw545034502/article/details/96450335&#34;&gt;（亲测可用）The Process class relies on proc_open, which is not available on your PHP installation.解决方案！&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;php-routes的使用&#34;&gt;php routes的使用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/yaoliuyang/p/12298780.html&#34;&gt;thinkphp中路由的基本使用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;nginx配置&#34;&gt;nginx配置&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/96149578&#34;&gt;PHP]深度解析Nginx下的PHP框架路由实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目信息&#34;&gt;项目信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;submit：提交到后台&lt;/li&gt;
&lt;li&gt;pedding：队列中准备提交&lt;/li&gt;
&lt;li&gt;waiting：已提交，等待结果&lt;/li&gt;
&lt;li&gt;submitting -&amp;gt; pedding -&amp;gt; waiting -&amp;gt; accept&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;p&gt;01:08开始&lt;/p&gt;
&lt;p&gt;前面，主要是介绍项目&lt;/p&gt;
&lt;h3 id=&#34;优化1实时更新榜单&#34;&gt;优化1：实时更新榜单&lt;/h3&gt;
&lt;p&gt;06:00&lt;/p&gt;
&lt;p&gt;目前是一分钟更新一次，从数据库读取到redis中&lt;/p&gt;
&lt;p&gt;优化思路：1、使用增量更新，当有新的AC事件发生时，更新内存中的redis缓存；2、客户端，对于提交记录，循环查询结果，查询操作为异步，循环间隔为5s，使用内存锁避免查询冲突&lt;/p&gt;
&lt;p&gt;目前的问题：对于每个提交记录，被更新了10几次。&lt;/p&gt;
&lt;h3 id=&#34;优化2容器化&#34;&gt;优化2：容器化&lt;/h3&gt;
&lt;p&gt;将各个功能点封装成docker容器&lt;/p&gt;
&lt;h3 id=&#34;优化3管理功能界面&#34;&gt;优化3：管理功能界面&lt;/h3&gt;
&lt;p&gt;74:28&lt;/p&gt;
&lt;h2 id=&#34;phpstore&#34;&gt;PhpStore&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/ljh101/article/details/112549860&#34;&gt;composer require --dev barryvdh/laravel-ide-helper报错解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[&lt;a href=&#34;https://my.oschina.net/anziguoer/blog/647367&#34;&gt;Phpstorm 安装 laravel扩展，laravel代码提示插件&lt;/a&gt;](https://my.oschina.net/anziguoer/blog/647367)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后台参考这里的代码https://github.com/ZsgsDesign/HASAAOSE/tree/main/app/Admin&lt;/p&gt;
">NOJ优化-PHP-Laravel</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/"" data-c="
          &lt;p&gt;本文主要是对 &lt;a href=&#34;https://wym0120.github.io/2021/04/12/cmmi/&#34;&gt;[课堂笔记] 软件过程改进 &lt;/a&gt;这篇文章的一些个人补充&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;过程的定义&#34;&gt;过程的定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IEEE: Sequence of steps performed for a given purpose.
&lt;ul&gt;
&lt;li&gt;为给定目的执行的步骤顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a SP ecified end result.
&lt;ul&gt;
&lt;li&gt;人员、材料、能源、设备和程序 在工作活动中的逻辑组织，旨在产生SP（特定实践）确认的最终结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMMI GLOSSARY: A set of interrelated activities, which transform inputs into outputs, to achieve a given purpose (These activities can be mapped to one or more practices in CMMI process areas to allow a model to be useful for process improvement and process appraisal.)
&lt;ul&gt;
&lt;li&gt;一组相互关联的活动，这些活动将输入转化为输出，以实现给定的目的（这些活动可以映射到CMMI过程域中的一个或多个实践，以使模型可用于流程改进和流程评估。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过程和过程域的关系&#34;&gt;过程和过程域的关系&lt;/h2&gt;
&lt;p&gt;过程域中包含若干过程。&lt;/p&gt;
&lt;h2 id=&#34;连续式表示法与阶段式表示法&#34;&gt;连续式表示法与阶段式表示法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;连续式表示法：选择一个特定的过程域进行改进。&lt;/li&gt;
&lt;li&gt;阶段式表示法：选择某一成熟度级别下的多个过程域进行改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等价阶段式定级&#34;&gt;等价阶段式定级&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CL：capability level 能力等级&lt;/li&gt;
&lt;li&gt;ML：maturity level 成熟度级别&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;过程模型&#34;&gt;过程模型&lt;/h2&gt;
&lt;p&gt;过程模型是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。&lt;/p&gt;
&lt;p&gt;CMMI 开发模型就是一种过程模型。&lt;/p&gt;
&lt;h2 id=&#34;cmmi来源于哪三个模型-研究机构&#34;&gt;CMMI来源于哪三个模型 ，研究机构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;软件工程 sw-cmm&lt;/li&gt;
&lt;li&gt;系统工程 EIA/IS&lt;/li&gt;
&lt;li&gt;集成化产品和过程开发 IPD-CMM&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210416144801516.png&#34; alt=&#34;image-20210416144801516&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;已管理和已定义的区别&#34;&gt;已管理和已定义的区别&lt;/h2&gt;
&lt;p&gt;已管理：标准、过程描述与规程在过程的每个特定实例中（如在某一特定项目中）都可能有很大的不同。&lt;/p&gt;
&lt;p&gt;已定义：项目的标准、过程描述与规程是从组织的标准过程集中裁剪得来，以适应特定的项目或组织级单位，因而就更为一致，除非是裁剪指南所允许的差别。&lt;/p&gt;
&lt;h2 id=&#34;过程域&#34;&gt;过程域&lt;/h2&gt;
&lt;h3 id=&#34;工程类&#34;&gt;工程类&lt;/h3&gt;
&lt;h4 id=&#34;确认与验证的区别&#34;&gt;确认与验证的区别&lt;/h4&gt;
&lt;p&gt;确认：确认产品实际的用途是否符合其预期的用途；做了正确的事。&lt;/p&gt;
&lt;p&gt;验证：验证工作产品（or 产品）的功能是否符合需求；正确地做了事。&lt;/p&gt;
&lt;h3 id=&#34;支持类&#34;&gt;支持类&lt;/h3&gt;
&lt;h4 id=&#34;度量与分析-and-过程与产品质量保证&#34;&gt;度量与分析 and 过程与产品质量保证&lt;/h4&gt;
&lt;p&gt;PPQA专注于质量，而MA则是对一切过程提供度量与分析。当对质量进行度量与分析时，个人认为MA与PPQA是等价的，因此，MA的范围更广，而PPQA则专注于质量方面。&lt;/p&gt;
&lt;h2 id=&#34;ppt中问题整理&#34;&gt;PPT中问题整理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;requirements traceability：需求可追溯性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A to B and vice versa：A符合B，反之亦然&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Budget and funding：预算和资金&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Staff：职员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Facilities：设施&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;peer review meetings：同行评审会议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delinquent：拖欠的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;People are not meeting schedules.：人们没有遵守时间表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;likelihood：可能性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;motion sensors：运动传感器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;contract：合同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;COTS were used for the keypad; sensors were secured from suppliers; and the controller consists of re-used PASS in-house software.：键盘上使用了COTS； 传感器由供应商提供保护； 控制器由重复使用的PASS内部软件组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;incorporating experiences：整合经验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;appraisal metrics：评估指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align with：对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All PASS projects follow the standard process exactly as is.：所有PASS项目都完全按照标准流程进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trace：追溯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tailoring：裁剪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spiral lifecycle：螺旋生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简答题列表&#34;&gt;简答题列表&lt;/h2&gt;
&lt;h3 id=&#34;过程域相关&#34;&gt;过程域相关&lt;/h3&gt;
&lt;p&gt;Lv4组织级过程性能(OPP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x.y.z代表着什么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2项目监督与控制(PMC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目监控点选择的原则？原因&lt;/li&gt;
&lt;li&gt;SG2中的相关实践约定，需要采取纠偏措施的问题来源&lt;/li&gt;
&lt;li&gt;纠偏行动的先决条件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2项目计划(PP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PP过程域在项目中的作用域&lt;/li&gt;
&lt;li&gt;计划制定的原则？&lt;/li&gt;
&lt;li&gt;一般的估算方法有哪几个？区别&lt;/li&gt;
&lt;li&gt;什么是承诺管理？承诺的分类&lt;/li&gt;
&lt;li&gt;PP中“建立”和“维护”两个活动的解释？&lt;/li&gt;
&lt;li&gt;估算目标: 不是尽可能客观描述代码行/工作量（永远不可能实现估算），而是得到一个数字&lt;strong&gt;数字对不对不重要，重要的是大家认可&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2需求管理(REQM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(需求跟踪的方法) 需求跟踪矩阵的使用&lt;/li&gt;
&lt;li&gt;(获得需求承诺) 应该获得那些人的承诺&lt;/li&gt;
&lt;li&gt;识别需求不一致性的最有效方法&lt;/li&gt;
&lt;li&gt;敏捷对于需求的态度是拥抱变更，但这是不正确的，大部分开发人员还是希望能够close开发&lt;/li&gt;
&lt;li&gt;Scrum对于需求的态度是不响应一个SP rint中的需求变更(目标不变)，只是记录到backlog，可能会在下一个迭代响应变更&lt;/li&gt;
&lt;li&gt;理解双向可跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv4量化项目管理(QPM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OPP 和 QPM 的关联&lt;/li&gt;
&lt;li&gt;QPM SP1.2 和之前过程定义的区别 （和 IPM 的区别）&lt;/li&gt;
&lt;li&gt;QPM 和 OPM 的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3产品集成(PI)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设你是产品集成的负责人，拒绝那些不合格的产品组件。定义哪些验收标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3验证 (VER)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VAL 和 VER的关键区别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2度量与分析(MA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;度量分析的作用体现在哪些方面？(从项目和组织两个角度分析)&lt;/li&gt;
&lt;li&gt;度量的目的要支持质量的目标&lt;/li&gt;
&lt;li&gt;如何满足度量的可追踪性(哪些工作产品可以满足)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2配置管理(CM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个软件开发过程中会产生很多工作产品artifacts/work product，但是并不是所有产品都是值得管理的，要去掉一些不那么重要的产品，确保重要的（为了让交付有完整性的）工作产品被管理。其实就是为了减少工作量。&lt;/li&gt;
&lt;li&gt;CCB: Change Control Board&lt;/li&gt;
&lt;li&gt;配置管理员的主要职责&lt;/li&gt;
&lt;li&gt;配置项标示的规则，什么情况下改写Vx.y.z中的x和y？什么说情况下改写z？规则是怎样的&lt;/li&gt;
&lt;li&gt;配置管理系统的等级？三个概念库如何体现配置库的等级？配置库需要注意什么&lt;/li&gt;
&lt;li&gt;基线的定义和特点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv2过程与产品质量保证(PPQA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件项目质量的分类&lt;/li&gt;
&lt;li&gt;QA行使的角色&lt;/li&gt;
&lt;li&gt;解释 PPQA QA SQA NC QC&lt;/li&gt;
&lt;li&gt;QA 和 QC差别？&lt;/li&gt;
&lt;li&gt;执行PPQA的工具方法&lt;/li&gt;
&lt;li&gt;简述评审一般过程、审计一般过程&lt;/li&gt;
&lt;li&gt;QA人员以及PPQA过程的质量保证如何实现&lt;/li&gt;
&lt;li&gt;如何评价&amp;quot;测试驱动开发TDD可以显著提升质量&amp;quot;这一说法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv3决策分析与解决(DAR)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何评价 &amp;quot;CMMI 是官僚、重文档的&amp;quot;这一说法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lv5原因分析与解决(CAR)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAR 在本质上做的是什么&lt;/li&gt;
&lt;li&gt;CAR 一定是选坏的吗&lt;/li&gt;
&lt;li&gt;CAR 实际上是依赖于 OPM 进行执行的&lt;/li&gt;
&lt;li&gt;CAR 的理念是不犯错比犯了错再改正更好&lt;/li&gt;
&lt;li&gt;CAR 在4级和5级的不同&lt;/li&gt;
&lt;li&gt;CAR 为什么需要和 OPM 配合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ppt&#34;&gt;ppt&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Which of the following examples of requirements traceability are adequate?&lt;/li&gt;
&lt;li&gt;PASS is planning their resources. What project resources should be included?&lt;/li&gt;
&lt;li&gt;Project Management and Control&lt;/li&gt;
&lt;li&gt;Risk Management&lt;/li&gt;
&lt;li&gt;Supplier Agreement Management&lt;/li&gt;
&lt;li&gt;Which CM SPs could have prevented the problem?&lt;/li&gt;
&lt;li&gt;Which are process evaluations? Which are product evaluations?&lt;/li&gt;
&lt;li&gt;Which of the following are adequate for verification procedures and criteria?&lt;/li&gt;
&lt;li&gt;Which are verification and which are validation?&lt;/li&gt;
&lt;li&gt;Which of the following show incorporating experiences?&lt;/li&gt;
&lt;li&gt;Which PASS scenarios align with IPM?&lt;/li&gt;
&lt;li&gt;Organizational Process Definition&lt;/li&gt;
&lt;li&gt;Organizational Training&lt;/li&gt;
&lt;li&gt;VER SG2 SG3: SG3包含SG2&lt;/li&gt;
&lt;li&gt;持续集成 vs 大爆炸集成&lt;/li&gt;
&lt;/ul&gt;
">南京大学-软件过程改进-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/"" data-c="
          &lt;h2 id=&#34;b树-b树索引&#34;&gt;B树、B+树索引&lt;/h2&gt;
&lt;h3 id=&#34;阶的含义&#34;&gt;阶的含义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;上限：每个节点最多有 M 个子树&lt;/li&gt;
&lt;li&gt;下限：
&lt;ul&gt;
&lt;li&gt;根节点至少2个子树
&lt;ul&gt;
&lt;li&gt;非根节点至少有⌈M /2⌉个子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;画结构&#34;&gt;画结构&lt;/h3&gt;
&lt;p&gt;B+树&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415160910412.png&#34; alt=&#34;image-20210415160910412&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418174758526.png&#34; alt=&#34;image-20210418174758526&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418175351820.png&#34; alt=&#34;image-20210418175351820&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;b树使用场景&#34;&gt;B+树使用场景&lt;/h3&gt;
&lt;p&gt;能做的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全键值：Where x=123&lt;/li&gt;
&lt;li&gt;键值范围：Where 45&amp;lt;x&amp;lt;123&lt;/li&gt;
&lt;li&gt;键前缀查找：where x LIKE ‘J%’&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候能用，什么时候不能用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一般索引，都能用，除非查询优化器发现用了索引后，会导致性能降低，则不会使用索引，例如因为索引占用空间太大，导致IO操作耗时较高。&lt;/li&gt;
&lt;li&gt;对于复合索引，如果违反最左匹配原则，则不能用。例如，对(x,y)建立索引，但对y进行查询，则不能用。&lt;/li&gt;
&lt;li&gt;对于一个有索引的列作出函数查询，Select * from t where f(indexed_col) = value&lt;/li&gt;
&lt;li&gt;隐形函数查询，比如查询SQL中存在隐式类型转换，比如no为VARCHAR类型，但是查询时把该字段当做INT类型查询：SELECT * FROM T WHERE no = 2124&lt;/li&gt;
&lt;li&gt;没有正确的统计信息，造成查询优化器无法做出正确的选择&lt;/li&gt;
&lt;li&gt;含前导模糊查询的Like语法不能使用索引（”%XXX”）&lt;/li&gt;
&lt;li&gt;B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候应该用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅当要通过索引访问表中很少一部分行&lt;/li&gt;
&lt;li&gt;虽然查询行数比较多，但索引包含多个字段，而要访问的字段全部包含在索引中时，查找只需通过索引而不用访问全表时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候不应该用（没找到答案，自己的理解）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当需要查询的数据占表总数据的比重很大时，不应该使用索引，因为查询优化器会发现，使用索引的效率不如全表遍历。&lt;/li&gt;
&lt;li&gt;写密集型事务：频繁修改索引，增加开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分区&#34;&gt;分区&lt;/h2&gt;
&lt;h3 id=&#34;分区是干嘛用的&#34;&gt;分区是干嘛用的&lt;/h3&gt;
&lt;p&gt;分区就是将一个大表根据条件分割成若干个小表，是一种数据分组方式，能够提高并发性和并行性。对于多用户并发访问情况，查询效率可能较高。&lt;/p&gt;
&lt;p&gt;表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件）上&lt;/p&gt;
&lt;h3 id=&#34;根据分区键partition-key的类型分类分区有哪几种类型&#34;&gt;根据分区键（Partition Key）的类型分类，分区有哪几种类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希分区：对分区键进行哈希运算，根据运算结果进行分区。 &lt;s&gt;把不同的列随机平均的分布到不同的物理环境，达到备份和恢复（写 undo 和 redo文件）效率高，降低错误回滚压力（为了管理）。&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;范围分区：根据连续数据的范围对数据进行分区~~。把字段的值分布到一个物理范围~~，这个范围是你在创建分区时指定的分区键决定的。这种分区方式是最为常用的。&lt;/li&gt;
&lt;li&gt;列表分区：把不同的列存到不同的分区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何选择分区键-选择原则是什么&#34;&gt;如何选择分区键、选择原则是什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希分区：根据分区键，可以快速找到记录，但对范围检索没有任何帮助。更接近于非数据驱动的循环分区，用于负载均衡，提高并发的能力。&lt;/li&gt;
&lt;li&gt;范围分区：比较常用，非常适合处理历史数据。&lt;/li&gt;
&lt;li&gt;列表分区：查询时，通常只查询某几个字段，或者，某几个字段通常一起被查询。但，每个分区都必须有主键，因此会造成冗余。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;按什么字段进行分区要整体考虑，因为：更新分区键会引起移动数据，应该避免这么做。当数据分区键均匀分布时，分区表查询收益最大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;h3 id=&#34;处理模式操作模式批处理与实时系统&#34;&gt;处理模式（操作模式）：批处理与实时系统&lt;/h3&gt;
&lt;p&gt;9.2 为性能设计（下）.mp4，17:09&lt;/p&gt;
&lt;h4 id=&#34;基本逻辑&#34;&gt;基本逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异步处理模式：可以允许用户发出操作之后去做其他工作，数据库进行集中的批处理，当处理完毕后通知用户，但是实时性不好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步处理时模式：用户必须等待数据库操作并返回结果，期间不能做其它操作。适合数据库进行实时交易。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;好坏&#34;&gt;好坏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当操作过于复杂，需要横跨很多系统、物理环境，实时系统中不可控的因素就会变多，此时就需要采用异步处理模式。&lt;/li&gt;
&lt;li&gt;异步处理模式：健壮性、稳定性更强。&lt;/li&gt;
&lt;li&gt;同步处理模式：满足实时性的要求，在某些特定业务下，这是必须的，比如银行转账业务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;选择&#34;&gt;选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;由系统需求和所需处理的数据的物理结构决定的，大部分情况下，同步和异步是共存的，不能先入为主得认为业务必须同步。&lt;/li&gt;
&lt;li&gt;从性能的角度，如果对实时性没有要求，则可以考虑尝试使用批处理模式&lt;/li&gt;
&lt;li&gt;在批处理模式下，更容易暴露性能问题，因为批处理需要压榨硬件资源，而实时系统只有在高并发或大数据量的情况下才可能暴露性能问题，而当实时系统暴露出性能问题后，可能会极大影响正常业务的开展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储模式集中式与分布式&#34;&gt;存储模式：集中式与分布式&lt;/h3&gt;
&lt;p&gt;9.2 为性能设计（下）.mp4，11:31&lt;/p&gt;
&lt;h4 id=&#34;基本逻辑-2&#34;&gt;基本逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分布式数据存储：将数据分散存储在多台独立的设备上，一般情况下，多台设备在地理位置上相对分散。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中式数据存储：将数据集中存储在一台或多台设备上，一般情况下，存储设备在地理位置上相对集中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;好坏-2&#34;&gt;好坏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;分布式数据系统：
&lt;ul&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;复杂度高、健壮性低、管理成本高&lt;/li&gt;
&lt;li&gt;保密性不易控制&lt;/li&gt;
&lt;li&gt;多个副本的一致性难以保证&lt;/li&gt;
&lt;li&gt;不同数据源数据的结合极为困难
&lt;ul&gt;
&lt;li&gt;数据传输开销大&lt;/li&gt;
&lt;li&gt;脱离数据源的环境，数据源无法从数据规划中获益（物理结构、索引）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;单一节点的负担低&lt;/li&gt;
&lt;li&gt;具有更灵活的体系结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集中式
&lt;ul&gt;
&lt;li&gt;缺点：单点故障，会带来很大损失，因此常常需要热备份或灾难备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;选择-2&#34;&gt;选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;平衡、折中
&lt;ul&gt;
&lt;li&gt;全球性的数据，若集中存储，则跨大陆的访问速度将大幅降低（离数据越近，访问越快）；但从另一个角度看，因为集中式避免了分布式中的数据传输，并可以利用数据规划，因此查询速度快。&lt;/li&gt;
&lt;li&gt;集中式存储的访问吞吐量有上限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-查询优化器是如何工作的&#34;&gt;SQL-查询优化器是如何工作的&lt;/h2&gt;
&lt;p&gt;4.1 SQL优化.mp4，13:38&lt;/p&gt;
&lt;p&gt;优化是在数据处理的真正被执行的时候发生&lt;/p&gt;
&lt;p&gt;不同结果的关系表达式在实际环境下执行的效率千差万别&lt;/p&gt;
&lt;p&gt;查询优化器如何权衡哪种优化更好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于成本的优化器 CBO：综合考虑所有的情况。现在最常用的优化器类型。&lt;/li&gt;
&lt;li&gt;基于规则的优化器 RBO：根据预定义的规则进行优化，例如加减的权重是1，乘除的权重是2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SQL的执行顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL、语法语义检查、解析（软解析+硬解析）、执行计划、执行引擎、存储引擎、数据库&lt;/li&gt;
&lt;li&gt;解析是整个SQL优化最消耗资源的环节，其中硬解析是最重要的一部分。&lt;/li&gt;
&lt;li&gt;执行计划：Plan，二进制的执行代码&lt;/li&gt;
&lt;li&gt;解析+生成执行计划是查询优化器最重要的工作&lt;/li&gt;
&lt;li&gt;生成执行计划后，抛入执行引擎，从数据库中读取数据，然后返回。&lt;/li&gt;
&lt;li&gt;语法分析：判断一条SQL语句的语法是否符合SQL的规范，代价小&lt;/li&gt;
&lt;li&gt;语义分析：判断该SQL语句所访问的对象是否准确，且用户是否有相应的权限，代价小&lt;/li&gt;
&lt;li&gt;硬解析：对提交的sql完全重新从头进行解析(当在共享池中找不到已解析好的结果时将会进行此操作)&lt;/li&gt;
&lt;li&gt;软解析：如果在共享池中找到了与之完全相同的sql解析好的结果后，会跳过硬解析的后两步，代价小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化器只能对关系领域进行优化&lt;/p&gt;
&lt;p&gt;优化器的有效范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化器需要借助数据库中找到的信息&lt;/li&gt;
&lt;li&gt;能进行数学意义上的等价变换&lt;/li&gt;
&lt;li&gt;优化器考虑整体响应时间&lt;/li&gt;
&lt;li&gt;优化器改善的是独立的查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库设计-层次结构&#34;&gt;数据库设计-层次结构&lt;/h2&gt;
&lt;p&gt;6.1 处理层次结构.mp4，12:17&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邻接模型：id、pid&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兄弟节点是无序的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物化路径模型：1、1.1、1.1.2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兄弟节点是有序的&lt;/li&gt;
&lt;li&gt;方便扩展：3层结构扩展层4层&lt;/li&gt;
&lt;li&gt;查询语句编写简单，找出适当的记录并缩排显示比较容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嵌套集合模型：left_num、right_num，所有子节点都在left_num和right_num之间&lt;/p&gt;
&lt;p&gt;上述3种树状表结构设计都满足三范式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种查询方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下（Vandamme查询）
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;connect by current = &lt;em&gt;prior&lt;/em&gt; previous，非关系型查询方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103050088.png&#34; alt=&#34;image-20210420103050088&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用with as，首先定义起始点，之后对两个select语句进行union all，通过递归查询不断根据父记录生成子记录。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103019003.png&#34; alt=&#34;image-20210420103019003&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql不支持connect by，也不支持with as，因此只能事先知道树的深度，然后手动union&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算深度：path字符串长度 减去 去掉点之后的path字符串长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定需要查询的path前缀，之后使用模糊查询获取结果，然后对path进行排序，即可&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210420103422776.png&#34; alt=&#34;image-20210420103422776&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上（Hignland查询）
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;connect by previous = &lt;em&gt;prior&lt;/em&gt; current&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;指定需要查询的叶子结点，之后使用模糊查询获取父节点&lt;/li&gt;
&lt;li&gt;会存在重复记录，因此需要使用distinct&lt;/li&gt;
&lt;li&gt;排序问题：对distinct的结果进行select，并按path进行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下
&lt;ul&gt;
&lt;li&gt;邻接模型
&lt;ul&gt;
&lt;li&gt;性能最好，每秒返回的查询记录数最多，只需要处理数值关系，但性能会收到迭代操作的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化路径模型
&lt;ul&gt;
&lt;li&gt;中等，因为涉及到字符串操作&lt;/li&gt;
&lt;li&gt;计算深度、缩排函数 比较费时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上
&lt;ul&gt;
&lt;li&gt;和自顶向下类似，邻接最好，物化路径中等&lt;/li&gt;
&lt;li&gt;当不能用connect by和with as时，可以使用物化路径模型作为替代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">南京大学-高级数据库开发技术-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-13-南京大学-高级算法课程-复习笔记/"" data-c="
          &lt;h2 id=&#34;蛮力法&#34;&gt;蛮力法&lt;/h2&gt;
&lt;p&gt;算法思想：在不考虑时间、空间效率的情况下，寻求问题的解决方案&lt;/p&gt;
&lt;p&gt;DFS BFS 连通性、环路&lt;/p&gt;
&lt;h2 id=&#34;分治&#34;&gt;分治&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;思想：分而治之&lt;/p&gt;
&lt;p&gt;分(Divide): 递归解决较小的问题，直到终止层或者可以解决的时候停下来&lt;br&gt;
治(Conquer): 递归求解，如果问题够小直接求解&lt;br&gt;
合并(Combine): 用子问题的解合并构建父问题&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/zhang971105/article/details/115759963&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;归并排序合并排序&#34;&gt;归并排序（合并排序）&lt;/h3&gt;
&lt;p&gt;归并排序的主要缺点是该算法需要额外的线性空间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210418125331240.png&#34; alt=&#34;image-20210418125331240&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;减治&#34;&gt;减治&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用给定实例下问题的解和较小规模实例下相同问题的解之间的关系。&lt;/li&gt;
&lt;li&gt;可以从顶至下（递归地）也可以自底向上（非递归地）地运用该关系。&lt;/li&gt;
&lt;li&gt;与分治法不同，减治法只针对其部分子问题进行求解，同时也是采取划分后选择计算的思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减常量：插入排序、深度优先、广度优先遍历&lt;/li&gt;
&lt;li&gt;减常因子：折半查找、三份查找&lt;/li&gt;
&lt;li&gt;减可变规模：欧几里得最大公约数、选择问题、插值查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;减治法与分治法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二项查找规模减半的两个子问题只有一个问题需要解决，是减治法。分治求和，规模减半的两个子问题都需要求解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成组合对象&#34;&gt;生成组合对象&lt;/h3&gt;
&lt;h4 id=&#34;johnson-trotter算法&#34;&gt;Johnson-Trotter算法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419101235692.png&#34; alt=&#34;image-20210419101235692&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;减一法&#34;&gt;减一法&lt;/h4&gt;
&lt;p&gt;生成n-1个数的排列&lt;br&gt;
将第n个数依次插入n-1个数的每一个排列中&lt;br&gt;
缺点：记录所有中间结果，耗费存储空间&lt;/p&gt;
&lt;h3 id=&#34;插值查找&#34;&gt;插值查找&lt;/h3&gt;
&lt;p&gt;与折半查找类似，只是确定mid的方式有所改变：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415110033670.png&#34; alt=&#34;image-20210415110033670&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最坏情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要在[1,10]中查到2，但多数元素分布在[1,2]之前&lt;/li&gt;
&lt;li&gt;每次插值查找都只能减少1个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动机：在预测顺序数组是均匀排布的假设前提下，使用插值查找可以在时间复杂度O(log logn)的情况下比&lt;strong&gt;折半查找&lt;/strong&gt;O(logn)花费更少的查找次数。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/zhang971105/article/details/115760010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果在遍历的过程中，发现某个顶点有一条边指向已经访问过的顶点，且这个已访问过的顶点不是当前顶点的父节点（这里的父节点表示DFS遍历顺序中的父节点），则说明图包含环。&lt;/li&gt;
&lt;li&gt;判断连通性：若vis数组存在0值，则该节点未被访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhang971105/article/details/115760010&#34;&gt;【算法复习】减治算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变治&#34;&gt;变治&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个更简单的实例——&lt;strong&gt;实例化简&lt;/strong&gt;——预排序，将问题变为排序好的列表的问题：高斯消去法&lt;/li&gt;
&lt;li&gt;一个实例的不同表现——&lt;strong&gt;改变表现&lt;/strong&gt;——平衡查找树、堆——改变数据结构：霍纳法则&lt;/li&gt;
&lt;li&gt;变为另一个问题的实例——&lt;strong&gt;问题化简&lt;/strong&gt;——对NP难问题和NP完全问题的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高斯消去法-实例化简&#34;&gt;高斯消去法-实例化简&lt;/h3&gt;
&lt;p&gt;n元一次方程组求解&lt;/p&gt;
&lt;p&gt;将方程组系数变为一个下三角全部是0的矩阵&lt;/p&gt;
&lt;p&gt;思想：将n元一次方程组求解实例化简为一个容易求解的实例。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618454369592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;转换方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用第一个方程的一个倍数和第二个方程求差，将第二个方程中x1系数变为0；同样与其它方程求差，将所有x1系数变为0；&lt;/li&gt;
&lt;li&gt;再用第二个方程与其它方程作同样操作，将所有第二个方程后的所有x2系数变为0；&lt;/li&gt;
&lt;li&gt;最终得到下三角为0的系数矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419085806002.png&#34; alt=&#34;image-20210419085806002&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;霍纳法则-改变表现&#34;&gt;霍纳法则-改变表现&lt;/h3&gt;
&lt;p&gt;经过霍纳法则变换的多项式只需要执行 n 次乘法运算便可以得到 n 阶多项式的值，使得原本&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;复杂度的计算变为O(n)，加快运算速度。&lt;/p&gt;
&lt;p&gt;用于快速计算多项式的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415110131949.png&#34; alt=&#34;image-20210415110131949&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419090914753.png&#34; alt=&#34;image-20210419090914753&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;二进制幂&#34;&gt;二进制幂&lt;/h4&gt;
&lt;p&gt;基于改变表现的求幂的算法&lt;/p&gt;
&lt;p&gt;任何一个数，都可以变成&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.849108em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的累加和，例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1 = 2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5=2^2+2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;6=2^2+2^1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^n=a^{p(2)}=a^{\sum_{i=0}^n{b_i*2^i}}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.664392em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8879999999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8879999999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9944599999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9944599999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mop mtight&#34;&gt;&lt;span class=&#34;mop op-symbol small-op mtight&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7385428571428572em;&#34;&gt;&lt;span style=&#34;top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32143857142857146em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace mtight&#34; style=&#34;margin-right:0.19516666666666668em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9020857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x=2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的多项式，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;只能取0或者1。&lt;/p&gt;
&lt;p&gt;有两种计算方法，从左到右和从右到左。&lt;/p&gt;
&lt;p&gt;以&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^{13}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为例，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;13=1*2^3+1*2^2+0*2^1+1*2^0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&#34;从左到右&#34;&gt;从左到右&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415111446604.png&#34; alt=&#34;image-20210415111446604&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每一次，先平方，然后，如果n的二进制位为1，则乘上一个a。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419091410008.png&#34; alt=&#34;image-20210419091410008&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;从右到左&#34;&gt;从右到左&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415111618512.png&#34; alt=&#34;image-20210415111618512&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;预先准备好a的各个幂次的结果，如果n的二进制位为1，则将对应幂次运算结果乘到最终答案中。&lt;/p&gt;
&lt;p&gt;（话说，这不是快速幂吗？）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419091431205.png&#34; alt=&#34;image-20210419091431205&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;霍纳法则，也可以延伸到X进制的情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210415112335441.png&#34; alt=&#34;image-20210415112335441&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;参考资料-2&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/riasky/p/3509097.html&#34;&gt;霍纳法则和二进制幂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;时空权衡&#34;&gt;时空权衡&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入增强：对输入进行&lt;strong&gt;预处理&lt;/strong&gt;，存储&lt;strong&gt;额外信息&lt;/strong&gt;，以加速后续问题的求解。
&lt;ul&gt;
&lt;li&gt;计数排序（比较计数、分布计数）&lt;/li&gt;
&lt;li&gt;字符串匹配：Boyer-Moore算法和Horspool提出的简化版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预构造：使用&lt;strong&gt;额外的空间&lt;/strong&gt;存储输入（比简单存储更多的空间），以实现更快、更方便的存取。
&lt;ul&gt;
&lt;li&gt;散列法&lt;/li&gt;
&lt;li&gt;B树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计数排序&#34;&gt;计数排序&lt;/h3&gt;
&lt;p&gt;比较计数：对数组中的元素两两进行比较，计算Count数组。Count[i]表示比第i个数小的数的个数。&lt;/p&gt;
&lt;p&gt;分布计数：预先知道待排数组的范围，统计每个元素出现的次数。&lt;/p&gt;
&lt;h3 id=&#34;祖先问题&#34;&gt;祖先问题&lt;/h3&gt;
&lt;p&gt;要求在一棵给定的n顶点二叉树中，确定一个顶点u是否是顶点v的祖先。设计一个属于O(n)的输入增强算法，使我们可以在常量时间内获得树的每一对顶点的足够信息，来对问题求解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分析：一个顶点u是顶点v的祖先，当前仅当先序遍历u在v的前面，并且后序遍历u在v的后面。第一个条件，先序遍历u在v的前面，代表要么u是v的祖先，要么u在公共祖先的左子树中而v在公共祖先的右子树中；第二个条件，后序遍历u在v的后面，代表要么u是v的祖先，要么u在公共祖先的右子树中而v在公共祖先的左子树中。综合两个条件，我们可以知道确定一个顶点u是否是顶点v的祖先，其充分必要条件是先序遍历u在v的前面，并且后序遍历u在v的后面。&lt;/p&gt;
&lt;p&gt;解答：在O(n)时间对二叉树进行先序遍历和后序遍历，在常量时间内对需要比较的两个节点在先序和后序中比较次序，确定顶点u是否是顶点v的祖先。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_30432997/article/details/85282116&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;字符串匹配&#34;&gt;字符串匹配&lt;/h3&gt;
&lt;p&gt;要求在一个较长的n个字符的串（称为&lt;strong&gt;文本&lt;/strong&gt;）中，寻找一个给定的m个字符的串（称为&lt;strong&gt;模式&lt;/strong&gt;）&lt;/p&gt;
&lt;h4 id=&#34;蛮力法-2&#34;&gt;蛮力法&lt;/h4&gt;
&lt;p&gt;简单地&lt;strong&gt;从左到右&lt;/strong&gt;比较模式和文本中每一个对应的字符，如果不匹配，把模式向右移动一格，再进行下一轮尝试，&lt;strong&gt;最差效率为O(nm)&lt;/strong&gt;，随机文本的平均效率O(n+m)=O(n)&lt;/p&gt;
&lt;h4 id=&#34;horspool算法&#34;&gt;Horspool算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;先将文本与模式左对齐&lt;/li&gt;
&lt;li&gt;从模式的最后一个字符从后往前进行匹配。&lt;/li&gt;
&lt;li&gt;如果全部匹配成功，则结束。&lt;/li&gt;
&lt;li&gt;如果匹配失败，分情况讨论：
&lt;ul&gt;
&lt;li&gt;规定：文本中与模式最后一个字符对应的字符为c&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618387864255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;当模式的前m-1个字符中不存在c时，将模式右移m位。&lt;/li&gt;
&lt;li&gt;当模式的前m-1个字符中存在c时，将模式右移，使模式中的c与文本中的c对齐。&lt;/li&gt;
&lt;li&gt;回到第2步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时空权衡优化思路-输入增强：&lt;br&gt;
预先计算t数组，t[c]表示：当匹配失败，且文本中对应的字符为c时，模式需要右移的位数。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618388234611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;boyer-moore算法&#34;&gt;Boyer-Moore算法&lt;/h4&gt;
&lt;p&gt;Boyer-Moore算法是Horspool算法的升级版，同时运用了坏字符原则和好后缀原则。&lt;/p&gt;
&lt;p&gt;在我们进行匹配的时候，我们将第一次碰到的不匹配的字符称为坏字符，而将碰到坏字符之前所匹配到的字符串称为好后缀。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618390709878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;坏字符原则之前已经介绍过了，就是Horspool算法的核心。这里重点介绍一下好后缀原则。&lt;/p&gt;
&lt;p&gt;和坏字符原则一样，我们需要维护一个好后缀数组，那么好后缀数组的含义是什么呢？&lt;/p&gt;
&lt;p&gt;它的含义是，需要往前最少数几位，才能让后缀或者后缀的子串匹配上。&lt;/p&gt;
&lt;p&gt;我们用S数组表示好后缀数组。S[k]表示的是长度为k的后缀 ，即a[m-k, m-k+1 ... m-2, m-1]。&lt;/p&gt;
&lt;p&gt;我们以BAOBAB举例子。&lt;/p&gt;
&lt;p&gt;S[1] = 2：表示，B这个后缀，需要最少往前数2位，就能让其匹配上了。&lt;br&gt;
再详细说一下，对于BAOBAB，倒数第三个字符也是B，因此只需要往前数2位，就能让后缀B匹配上了。&lt;/p&gt;
&lt;p&gt;我们再来看S[2]，它对应的后缀是AB，但是AB无法匹配，因此我们取子后缀B，这里需要注意，因为我们取的是子后缀，因此如果是类似BB、CB的情况，是无法匹配的，因为原后缀是AB。因此，和子后缀B匹配的只有首位的B，因此S[2] = 5。&lt;/p&gt;
&lt;p&gt;这就是好后缀数组的含义。好后缀数组的意义在于，利用了已匹配的字符串的信息，增加了每次移动的位数。&lt;/p&gt;
&lt;p&gt;大家可以试一下，如果移动位数少于好后缀数组的值，那么一定是无法匹配上的。&lt;/p&gt;
&lt;p&gt;好后缀数组的计算过程可以参考这篇文章：&lt;a href=&#34;https://blog.csdn.net/qq_35423154/article/details/109137798&#34;&gt;字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于坏字符原则和好后缀原则，取最大值进行移动。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;参考资料-3&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35423154/article/details/109137798&#34;&gt;字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;思考题&#34;&gt;思考题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用字符串匹配算法匹配到一个相同字符串后，要查找下一个匹配子串，移动距离是多少？&lt;/li&gt;
&lt;li&gt;如果只用坏符号移动表或者好后缀移动表，BM算法能够正确工作吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;递归与动态规划的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都需要找到递推关系&lt;/li&gt;
&lt;li&gt;不同点：
&lt;ul&gt;
&lt;li&gt;动态规划是自底向上，从停止条件逐步计算出问题的解。&lt;/li&gt;
&lt;li&gt;递归是自顶向下，从问题出发，利用递推式逐步减小问题规模，当达到停止条件时，逐步返回，最终求出问题的解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分治法与动态规划的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分治方法&lt;/strong&gt;将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态规划&lt;/strong&gt;应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。这种情况下使用分治算法会重复求解那些子子问题而浪费时间。&lt;/li&gt;
&lt;li&gt;By: https://blog.csdn.net/zhang971105/article/details/115759889&lt;/li&gt;
&lt;li&gt;动态规划注重：与其对交叠的子问题一次一次求解，还不如对每个较小的子问题只求解一次并把结果记录在表中。&lt;/li&gt;
&lt;li&gt;By：https://jinzengnju.github.io/2018/05/22/leetcode高级算法/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最优二叉查找树&#34;&gt;最优二叉查找树&lt;/h3&gt;
&lt;p&gt;假设一次搜索的实际代价为检查的节点的个数，即所发现的节点的深度加1，一次搜索所花费的预期成本为：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/munderover&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E(T) = \sum_{i=1}^n {(depth(k_i)+1)*p_i}+\sum_{i=0}^n{(depth(d_i)+1)*q_i}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.929066em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.6513970000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.929066em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.6513970000000002em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最优二叉查找树：一次搜索所花费的预期成本最小。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e[i,j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示对于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_i,...,k_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和虚拟节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d_{i-1}, ..., d_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 最优 BST 的期望搜索成本。&lt;/p&gt;
&lt;p&gt;因此，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E(T) = e[1,n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w[i,j]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示对一棵关键字 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;k_i, ..., k_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子树，其概率总和：&lt;/p&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲
w[i,j] &amp;amp;= \sum…&#39;&gt;\begin{align*}
w[i,j] &amp;amp;= \sum_{k=i}^j p_k + \sum_{k=i-1}^jq_k \\
 &amp;amp; = p_r + w[i,r-1] + w[r+1,j] \\
 &amp;amp; = w[i,j-1] + p_j + q_j
 \end{align*}
&lt;/p&gt;
&lt;p&gt;综上所述：&lt;/p&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
e[i,j] &amp;amp; = p_r…&#39;&gt;\begin{align}
e[i,j] &amp;amp; = p_r + (e[i,r-1]+w[i,r-1])+(e[r+1,j]+w[r+1,j]) \\
&amp;amp; =e[i,r-1]+e[r+1,j]+w[i,j]
\end{align}
&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/image-20210419092052208.png&#34; alt=&#34;image-20210419092052208&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;参考资料-4&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xiajun07061225/article/details/8088784&#34;&gt;【算法学习】最优二叉查找树（动态规划）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/henuliulei/p/10074216.html&#34;&gt;最优二叉查找树_动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;背包问题&#34;&gt;背包问题&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# w[i]表示第i个物品的重量, v[i]表示第i个物品的价值, 下标从V开始
# S表示背包总空间, N表示总共多少个物品
Algorithm bag:
    # N+1行S+1列
    dp = [[0 for i in range(S + 1)] for j in range(N + 1)]
    for i in range(1, N+1):
        for j in range(1, S+1):
            if j &amp;gt;= w[i]: # 判断此时背包空间是否大于此时物品重量
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
            else:
            	dp[i][j] = dp[i-1][j]
                
    # 返回在空间为S时前N个物品的最大价值
    return dp[N][S] 

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料-5&#34;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhang971105/article/details/115759889&#34;&gt;【算法复习】动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;迭代改进&#34;&gt;迭代改进&lt;/h2&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;贪婪：采用每步最优策略，逐步构造问题的解。最终生成的解，不一定是最优解。&lt;/s&gt;（不考）&lt;/li&gt;
&lt;li&gt;迭代改进：先生成一个可行解，然后，不断通过小的、局部的改变对其进行优化，使目标函数更优。当目标函数无法再优化时，则为最优解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现过程中可能遇到的困难：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何生成可行解？&lt;/li&gt;
&lt;li&gt;如何判断是局部最优解？&lt;/li&gt;
&lt;li&gt;如何判断局部最优解是全局最优解？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法实例：遗传算法、蚁群算法、梯度下降算法。&lt;/p&gt;
&lt;h3 id=&#34;线性规划&#34;&gt;线性规划&lt;/h3&gt;
&lt;p&gt;线性规划问题：在一系列线性约束下，求一个包含若干变量的线性方程的最优解。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618313856251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;极值定理&#34;&gt;极值定理&lt;/h4&gt;
&lt;p&gt;极值定理：可行区域非空的任意线性规划问题有最优解，且最优解总能够在其可行区域的一个&lt;strong&gt;极点&lt;/strong&gt;上找到。&lt;/p&gt;
&lt;p&gt;利用极值定理解决线性规划问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成可行区域的所有极点&lt;/li&gt;
&lt;li&gt;计算所有极点对应的问题解，保留最优的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;极值定理存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法生成所有的极点&lt;/li&gt;
&lt;li&gt;无法遍历所有的极点（当问题规模变大，极点个数呈爆炸式增长，无法全部遍历）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单纯形法&#34;&gt;单纯形法&lt;/h4&gt;
&lt;p&gt;算法思想：先在可行区域中找到一个极点，然后检查在邻接极点处是否能够优化，如果能，则继续处理该邻接极点；如果不能，则当前极点即为最优解。&lt;/p&gt;
&lt;p&gt;局限性：&lt;br&gt;
- 只能解决最大化问题&lt;br&gt;
- 所有变量都非负&lt;br&gt;
- 除 非负约束 外，其余约束都必须为等式。&lt;/p&gt;
&lt;h5 id=&#34;线性规划问题的标准形式&#34;&gt;线性规划问题的标准形式&lt;/h5&gt;
&lt;p&gt;能够解决的线性规划问题的标准形式：m个等式约束、n个变量。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618377842782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如何转化为标准形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小化转为最大化——通过改变目标函数系数正负号&lt;/li&gt;
&lt;li&gt;不等问题转为相等问题——通过松弛变量，将松弛变量定义为&amp;gt;=0的新变量&lt;/li&gt;
&lt;li&gt;没有非负约束的变量添加约束——定义为 两个带非负约束的新变量的差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转化为标准形式的好处：可以用一种简单的方法确定可行区域的极点&lt;br&gt;
确定方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将约束中的n-m个非基本变量设置成0，利用m个等式求出剩余m个基本变量的解。&lt;/li&gt;
&lt;li&gt;如果能求出唯一解，则得到一个基本解。&lt;/li&gt;
&lt;li&gt;如果得到的基本解的所有值都非负，则为基本可行解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本解与区域内的交点一一对应。&lt;br&gt;
基本可行解与可行区域的极点一一对应。&lt;/p&gt;
&lt;h5 id=&#34;单纯形表&#34;&gt;单纯形表&lt;/h5&gt;
&lt;p&gt;单纯形&lt;strong&gt;表&lt;/strong&gt;：解决线性规划问题的一种方法、工具，其中，蕴含了单纯形法的思想。&lt;/p&gt;
&lt;p&gt;单纯形表的计算过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求得一个基本可行解，作为初始单纯形表。&lt;/li&gt;
&lt;li&gt;不断根据规则计算得到下一个单纯形表，每张单纯形表对应一个极点。&lt;/li&gt;
&lt;li&gt;对于每张单纯形表，判断是否是最优解或是否有界。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体讲解：&lt;a href=&#34;https://www.bilibili.com/video/BV16t411F7Zu?t=697&#34;&gt;十分钟带你学单纯形法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最优：目标行都为非负。&lt;br&gt;
无界：被选中的非基本变量对应的系数全部小于等于零，则无界，说明目标函数可以无限制增大。详解：&lt;a href=&#34;https://www.zhihu.com/question/24146260&#34;&gt;运筹学单纯形法无界解的判定原理是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何确定入基变量：（各教材不一样，本文以老师ppt为准）从非基本变量中选择，选择目标行系数最小的变量作为入基变量。&lt;br&gt;
如何确定出基变量：各行变量值除以入基变量所在列对应的系数，取最小。需要注意的是，需要忽略掉系数 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\le&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7719400000000001em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 0的那些行。&lt;/p&gt;
&lt;p&gt;单纯形表原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;线性规划之单纯形法【超详解+图解】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xvshu/article/details/23288787&#34;&gt;运筹学·单纯形法——原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;是否能够使用单纯形法解决背包问题如果能请给出解法过程并请指出这是不是一个解决该问题的好算法如果不能请说明原因&#34;&gt;是否能够使用单纯形法解决背包问题？如果能，请给出解法过程，并请指出这是不是一个解决该问题的好算法？如果不能，请说明原因。&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;解答：可以通过单纯形法解决背包问题的连续版本，因为它是一般线性规划问题的一个特例。然而，它不是解决这个问题的好方法，因为它可以通过基于贪婪法的更简单的算法更有效地解决。由于对问题变量施加的完整性（0-1）约束，单纯形法无法解决0-1版本的背包问题。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_30432997/article/details/85283898&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;为什么基本可行解与可行区域的极点一一对应&#34;&gt;为什么基本可行解与可行区域的极点一一对应？&lt;/h5&gt;
&lt;p&gt;我们从二维来理解这个问题，对于高维，也是同样的道理，只是二维比较好描述、且比较好理解。&lt;/p&gt;
&lt;p&gt;要解答这个问题，我们先尝试理解另一个问题，为什么基本解与图上的交点一一对应？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618367158808.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图，我们能看到很多的交点，在这些交点中，有一些是可行区域的极点，有一些不是。对于那些是可行区域极点的交点，它们对应了基本可行解；对于那些不是可行区域极点的交点，它们对应了基本非可行解，也就是除了基本可行解以外的那些基本解。&lt;/p&gt;
&lt;p&gt;我们回到线性规划问题，如下的线性约束一共有3个不等式，但其实本质上应该是4个，对于第三个不等式，可以拆成2个不等式，即&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1 \ge 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7859700000000001em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_2 \ge 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7859700000000001em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618367306612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们只有两个变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），那么从4个不等式中，任取两个，就会得到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的一组解。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;C_4^2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0622159999999998em;vertical-align:-0.24810799999999997em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的值为6，因此上图中一共有6个交点。&lt;/p&gt;
&lt;p&gt;用更一般的形式说明一下：&lt;/p&gt;
&lt;p&gt;原约束方程：&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618368676328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;标准化后的约束方程：&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618368705133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们用n表示所有变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2, x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数，m表示基本变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。在线性约束标准化的过程中，m也表示新加入的松弛变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_3, x_4&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。&lt;/p&gt;
&lt;p&gt;根据n和m的定义，我们可以得出，n-m表示原约束方程中变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的个数。因此，我们只需要确定n-m个方程，就可以求出原约束方程中变量（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x_1, x_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）的值，从而求出目标函数的值。&lt;/p&gt;
&lt;p&gt;那么如何将线性约束方程与单纯形表结合起来呢，如果看了之前&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;讲原理的博客&lt;/a&gt;，我们就会知道，每一张单纯形表，其实本质上都是将n-m个非基本变量的值设为0，然后算出原约束方程中n-m个变量的值，从而求出目标表达式的值。&lt;/p&gt;
&lt;p&gt;那么，我们将n-m个非基本变量的值设为0，其实就是选择了n-m个不等式。如上所述，当我们选择了n-m个不等式，就能确定原约束方程中n-m个变量的值，也就相当于确定了一个交点。&lt;/p&gt;
&lt;p&gt;如果这个交点又是可行区域内的交点，那么其就是可行区域的极点，在单纯形表中的体现就是，基本解的值非负。&lt;/p&gt;
&lt;h5 id=&#34;参考资料-6&#34;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html&#34;&gt;线性规划之单纯形法【超详解+图解】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV16t411F7Zu?t=697&#34;&gt;十分钟带你学单纯形法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xvshu/article/details/23288787&#34;&gt;运筹学·单纯形法——原理剖析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/39071505/answer/131945180&#34;&gt;怎么用简单的语言理解基变量与非基变量？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/26840528/answer/34257469&#34;&gt;如何理解线性规划中的单纯形法和单纯形表？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/24146260&#34;&gt;运筹学单纯形法无界解的判定原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他一些小知识点&#34;&gt;其他一些小知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2-3树是最简单的B-树结构，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树也是一种BST。&lt;/li&gt;
&lt;li&gt;堆
&lt;ul&gt;
&lt;li&gt;堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。&lt;/li&gt;
&lt;li&gt;使用数组实现堆。对于每一个非叶子节点的父母节点i，其子女将会位于2i与2i+1的位置。（达到这种效果必须要求数组实现时，索引位置为0的地方空出来）。&lt;/li&gt;
&lt;li&gt;堆总是满足下列性质：
&lt;ul&gt;
&lt;li&gt;堆中某个结点的值总是不大于或不小于其父结点的值&lt;/li&gt;
&lt;li&gt;堆总是一棵完全二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。&lt;/li&gt;
&lt;li&gt;从最后的父母节点开始，依次向上检查是否满足父母优势。如果不满足，把节点的键K值和它子女的最大键进行交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B树元素的插入：
&lt;ul&gt;
&lt;li&gt;如果要插入的节点已经没有空间，该叶子一分为2，把后面一半的记录放在一个新节点中。在这之后，新节点中最小的键K‘以及指向它的指针要插入到原来的叶子的父母中，递归该过程一直到根中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料-7&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jinzengnju.github.io/2018/05/22/leetcode%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/&#34;&gt;leetcode高级算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">南京大学-高级算法课程-复习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-04-10-使用码云（gitee）提升博客访问速度/"" data-c="
          &lt;p&gt;之前写过文章，通过Gridea+github搭建个人博客 &lt;a href=&#34;https://bule-zst.gitee.io/ji-yu-grideagithubcoding-da-jian-jing-tai-bo-ke/&#34;&gt;基于Gridea+github/coding搭建静态博客&lt;/a&gt;，但使用了一段时间后，发现加载速度实在是太慢了，而且cdn更新也不太稳定。&lt;/p&gt;
&lt;p&gt;今天突发奇想，可以使用码云部署自己的个人博客，说干就干。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gridea个人博客搭建的原理&#34;&gt;Gridea个人博客搭建的原理&lt;/h1&gt;
&lt;p&gt;首先，和大家讲一下Gridea个人博客的搭建原理，如果只想看操作步骤的话，可以跳过这一节。&lt;/p&gt;
&lt;p&gt;Github为我们提供了一个功能，叫github pages，可以用于展示&lt;strong&gt;静态&lt;/strong&gt;网页，Gridea正是利用了github pages这一功能来搭建博客的。&lt;/p&gt;
&lt;p&gt;我们在github上创建项目后，可以为项目开启github pages功能，开启后，访问对应的网址，就会加载项目中的静态网页，例如在项目根目录下放入index.html文件，当访问项目时，就会展示index.html中的内容。&lt;/p&gt;
&lt;p&gt;而，只要是git系列的产品，理论上都有pages的功能，码云也不例外，因此，我们可以将Gridea生成的博客项目推送到码云项目中，然后开启码云项目的pages功能，就可以利用码云来搭建博客了。&lt;/p&gt;
&lt;h1 id=&#34;具体操作步骤&#34;&gt;具体操作步骤&lt;/h1&gt;
&lt;h2 id=&#34;码云&#34;&gt;码云&lt;/h2&gt;
&lt;p&gt;首先，需要在码云上创建项目，并开启pages功能，具体可参考&lt;a href=&#34;https://gitee.com/help/articles/4136#article-header0&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里提一些容易忽略的细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，和github不一样，在码云中创建的项目的项目名，需要和用户名一样。&lt;/li&gt;
&lt;li&gt;第二，在创建完项目后，需要开启pages服务。&lt;/li&gt;
&lt;li&gt;第三，记得要往项目中添加index.html文件，这一步主要用于测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成参考文章中的步骤后，访问网址（用户名.gitee.io），看看能不能加载出内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618028959506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;修改gridea配置&#34;&gt;修改Gridea配置&lt;/h2&gt;
&lt;p&gt;第二步，需要修改Gridea中的配置&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029063220.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其余地方都不变，只需要修改图中红色框框出来的域名，改成码云对应的网址（用户名.gitee.io）&lt;/p&gt;
&lt;h2 id=&#34;推送项目到码云并更新pages服务&#34;&gt;推送项目到码云，并更新pages服务&lt;/h2&gt;
&lt;p&gt;第三步，需要将Gridea生成的个人博客项目推送到码云上，在这一步中，我用的是git可视化管理工具-gtikraken，如果git基本功比较好的，也可以在git bash中进行操作。&lt;/p&gt;
&lt;p&gt;首先用gitkraken打开本地个人博客项目，目录是：/个人博客项目根目录/output&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029373237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开后会发现，有一个remote，这个就是之前我们配置的github仓库&lt;/p&gt;
&lt;p&gt;我们将码云中创建的项目也添加到remote中&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029472492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后，点击Gridea中的同步，将本地博客项目同步到github项目中。&lt;/p&gt;
&lt;p&gt;之后点击push按钮，将本地项目推送到码云项目中。在点击push按钮后，可能会让我们选择需要推送的目标仓库，注意要选择码云中的项目。&lt;/p&gt;
&lt;p&gt;在推送完成后，回到码云项目中，点击Gitee Pages按钮，进入pages管理界面&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029658643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击更新按钮&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029730998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在更新完成后，访问博客网址（用户名.gitee.io），就能看到博客的内容了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1618029790776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
&lt;p&gt;最后还需要说一点，就是，每次推送博客更新到码云项目后，都需要点击pages中的更新按钮进行更新，这是因为对于免费版的码云，不支持pages的自动更新。&lt;/p&gt;
&lt;p&gt;虽然这样好像有点麻烦，对我觉得，相对于github的访问速度来说，我还是更偏向于码云一些。&lt;/p&gt;
">使用码云（gitee）提升博客访问速度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-03-31-MySQL性能优化/"" data-c="
          &lt;p&gt;from &lt;a href=&#34;https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web&#34;&gt;https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;MySQL慢查询 优化手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引：使用MySQL工具，如explain，看一下查询有没有走索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;p&gt;索引是帮助MySQL高效获取数据的&lt;strong&gt;排好序&lt;/strong&gt;的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据结构可视化网站：&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&#34;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;索引的常见数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树
&lt;ul&gt;
&lt;li&gt;二叉搜索树：
&lt;ul&gt;
&lt;li&gt;优化思路：使用二叉搜索树，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;缺点-退化。当数据递增或递减时，会退化成链表，如，1, 2, 3, 4, 5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉平衡树
&lt;ul&gt;
&lt;li&gt;优化思路：减少二叉树层数，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;红黑树：缺点-效率低。虽然会自平衡，但当数据量达到500w时，可能树的高度会达到20层，如果查询的数据在叶子结点，20次IO操作依旧很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多路平衡树
&lt;ul&gt;
&lt;li&gt;优化思路：扩展每个节点，使其包含多个索引元素，更进一步减少二叉树层数，降低IO操作次数。&lt;/li&gt;
&lt;li&gt;B Tree&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B+ Tree&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;目前MySQL索引采用的数据结构&lt;/li&gt;
&lt;li&gt;MySQL中，默认情况下，每个节点可占用的空间大小为16KB。3层B+Tree，约可以存放2000w个索引元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B-Tree与B+Tree的比较
&lt;ul&gt;
&lt;li&gt;把数据统一存放在叶子结点中，好处是，非叶子结点可以包含更多的索引元素，因此树的高度更低。&lt;/li&gt;
&lt;li&gt;叶子结点之前的连接：更好地支持范围查找。B-树如果要做范围查询，则需要定位到第一个元素后，进行中序遍历。&lt;/li&gt;
&lt;li&gt;B+树，每次都会查到叶子结点才结束，因此查询时间较稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash表
&lt;ul&gt;
&lt;li&gt;Hash表的效率很多情况下优于B+树&lt;/li&gt;
&lt;li&gt;不选择Hash表的原因：
&lt;ul&gt;
&lt;li&gt;Hash冲突（次要）：当存在大量Hash冲突时，会导致链表变长，降低效率。但当链表过长时，MySQL会进行ReHash操作，降低链表长度。&lt;/li&gt;
&lt;li&gt;不支持范围查询（主要）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从二叉搜索树到二叉平衡术再到多路平衡树，本质上是逐步降低了磁盘IO次数，那为什么不把所有索引元素都放到一个节点中？这样，只需要一次IO操作就行了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当数据量大的时候，太占内存了，并且有的时候，可能内存容量不允许这么做。&lt;/li&gt;
&lt;li&gt;当所有索引都读取到内存后，索引数量太多，可能500w，二分查找效率也会降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么主键推荐用整型，而不是UUID？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较效率。在索引中，会进行多次比较，整形比较速度更快。&lt;/li&gt;
&lt;li&gt;存储空间。UUID是字符串，更占空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么 MySQL 官方建议使用自增主键作为表的主键？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/39e5b433bbaf&#34;&gt;https://www.jianshu.com/p/39e5b433bbaf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;聚集索引：叶子结点包含完整的数据记录。例如，InnoDB的主键索引。对于每张表，聚集索引最多只有一个；对于InnoDB表，聚集索引有且仅有一个。&lt;br&gt;
非聚集索引：索引文件和数据文件是分离的。&lt;br&gt;
聚集索引效率高，因为非聚集索引拿到数据地址后，还需要一次IO操作，才能获取数据。&lt;/p&gt;
&lt;p&gt;联合索引：本质还是B+树，只是在比大小时，按字段顺序，依次进行比较&lt;/p&gt;
&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;p&gt;存储引擎是针对表的，不同表可以设置不同的存储引擎。&lt;/p&gt;
&lt;p&gt;数据库中存储的数据，默认放在安装目录下的data文件夹中。&lt;br&gt;
一个数据库，对应一个文件夹。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617329696374.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一个数据表，对应文件夹中的多个同名文件，不同存储引擎对应的文件结构不一样。&lt;br&gt;
&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617330056948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.frm：frame，表结构的相关信息&lt;/li&gt;
&lt;li&gt;InnoDB
&lt;ul&gt;
&lt;li&gt;.ibd：表中的数据及索引。InnoDB的数据和索引，是存储在一起的。&lt;/li&gt;
&lt;li&gt;主键索引：
&lt;ul&gt;
&lt;li&gt;索引用B+数的结构存储，数据存储在B+数的叶子结点上。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617331007626.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二级索引（普通索引）
&lt;ul&gt;
&lt;li&gt;索引用B+树存储，叶子结点存放&lt;strong&gt;主键&lt;/strong&gt;信息，获取到主键后，需要再次从主键索引中获取数据信息（回表操作）。&lt;/li&gt;
&lt;li&gt;二级索引存主键信息：
&lt;ul&gt;
&lt;li&gt;优点：因为表数据是存在索引中的，伴随索引节点的分裂，表数据的磁盘地址会发生改变，存主键信息避免了二级索引的维护工作。&lt;/li&gt;
&lt;li&gt;缺点：1、回表操作，比较耗时；2、存主键，导致二级索引更占空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617331631874.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若表中没有主键，存储引擎会先在表中寻找，看是否存在非空唯一索引，若存在，则对该列或该索引建立聚集索引，若不存在，则维护一个额外的隐藏列（6字节的rowid），用于建立聚集索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MyISAM
&lt;ul&gt;
&lt;li&gt;.MYD：MyISAM Data，表中的数据&lt;/li&gt;
&lt;li&gt;.MYI：MyISAM Index，索引的相关信息&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1617330872488.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引优化原则&#34;&gt;索引优化原则&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;最左前缀原则：对于联合索引，如果要用，那么必须按照建索引时字段的先后顺序去用，不能跳过任何一个字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;简历&#34;&gt;简历&lt;/h1&gt;
&lt;p&gt;不要光罗列会的技术，要深入地写，写技术细节。&lt;/p&gt;
&lt;h1 id=&#34;面试题&#34;&gt;面试题&lt;/h1&gt;
&lt;h2 id=&#34;说说建立索引的优势-负面影响和原则&#34;&gt;说说建立索引的优势、负面影响和原则?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;提高检索速度&lt;/li&gt;
&lt;li&gt;唯一性索引，保证数据的唯一性&lt;/li&gt;
&lt;li&gt;加速表与表之间的连接&lt;/li&gt;
&lt;li&gt;减少分组和排序的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负面影响：
&lt;ul&gt;
&lt;li&gt;耗时：创建和维护，都需要消耗时间，耗时随数据量增加而增加&lt;/li&gt;
&lt;li&gt;占空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原则：
&lt;ul&gt;
&lt;li&gt;什么时候该建
&lt;ul&gt;
&lt;li&gt;在最频繁使用的、用以缩小查询范围的字段上建立索引&lt;/li&gt;
&lt;li&gt;在最频繁使用的、需要排序的字段上建立索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么时候不该建
&lt;ul&gt;
&lt;li&gt;对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引&lt;/li&gt;
&lt;li&gt;对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)、uuid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;说说sql事务隔离级别&#34;&gt;说说SQL事务隔离级别?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;读未提交(read uncommitted）是指，一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读提交(read committed)是指，一个事务提交之后，它做的变更才会被其他事务看到。&lt;/li&gt;
&lt;li&gt;可重复读(repeatable read)是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。&lt;/li&gt;
&lt;li&gt;串行化 (serializable ) ，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/image-20210818155116207.png&#34; alt=&#34;image-20210818155116207&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;b树相对于b树的优势&#34;&gt;B+树相对于B树的优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把数据统一存放在叶子结点中，好处是，非叶子结点可以包含更多的索引元素，因此树的高度更低。&lt;/li&gt;
&lt;li&gt;叶子结点之前的连接：更好地支持范围查找。B-树如果要做范围查询，则需要定位到第一个元素后，进行中序遍历。&lt;/li&gt;
&lt;li&gt;B+树，每次都会查到叶子结点才结束，因此查询时间较稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/uyu0lKz2_N5BYgITKz71CQ&#34;&gt;什么是数据库的 “缓存池” ？（万字干货）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_16162981/article/details/70142166&#34;&gt;全文检索原理及实现方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">MySQL性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2021-01-06-Jetbrains系列产品重置试用方法/"" data-c="
          &lt;p&gt;本站惯例：本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。&lt;/p&gt;
&lt;p&gt;没错，jetbrains-agent这个项目停止了。市面上漫天飞的各种最新都是其他大神的魔改版本。&lt;br&gt;
我不是要专门写个博文来说明jetbrains-agent项目已经停止，然后缅怀感叹一番。这篇文章是想和大家聊聊另一种思路。&lt;/p&gt;
&lt;h1 id=&#34;0x0-项目背景&#34;&gt;0x0. 项目背景&lt;/h1&gt;
&lt;p&gt;Jetbrains家的产品有一个很良心的地方，他会允许你试用30天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。&lt;br&gt;
但很多时候会出现一种情况：IDE并不能按照我们实际的试用时间来计算。&lt;br&gt;
我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）&lt;br&gt;
发现了吗？你未能真的有30天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？&lt;/p&gt;
&lt;p&gt;事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。但切记不要无休止的一直试用，这并不是这个插件的本意！&lt;/p&gt;
&lt;h1 id=&#34;0x1-如何安装&#34;&gt;0x1. 如何安装&lt;/h1&gt;
&lt;h2 id=&#34;1-插件市场安装&#34;&gt;1). 插件市场安装：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在Settings/Preferences... -&amp;gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io&lt;/li&gt;
&lt;li&gt;搜索：&lt;code&gt;IDE Eval Reset&lt;/code&gt;插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？&lt;/li&gt;
&lt;li&gt;插件会提示安装成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-下载安装&#34;&gt;2). 下载安装：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;点击这个&lt;a href=&#34;https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip&#34;&gt;链接(v2.1.6)&lt;/a&gt;下载插件的zip包（macOS可能会自动解压，然后把zip包丢进回收站）&lt;/li&gt;
&lt;li&gt;通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&amp;gt; Plugins 里手动安装插件（Install Plugin From Disk...）&lt;/li&gt;
&lt;li&gt;插件会提示安装成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x2-如何使用&#34;&gt;0x2. 如何使用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）&lt;/li&gt;
&lt;li&gt;也可以手动唤出插件的主界面：
&lt;ul&gt;
&lt;li&gt;如果IDE没有打开项目，在Welcome界面点击菜单：Get Help -&amp;gt; Eval Reset&lt;/li&gt;
&lt;li&gt;如果IDE打开了项目，点击菜单：Help -&amp;gt; Eval Reset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：
&lt;ul&gt;
&lt;li&gt;按钮：Reload 用来刷新界面上的显示信息。&lt;/li&gt;
&lt;li&gt;按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（此为手动重置方式）&lt;/li&gt;
&lt;li&gt;勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x3-如何更新&#34;&gt;0x3. 如何更新&lt;/h1&gt;
&lt;h2 id=&#34;1-插件更新机制推荐&#34;&gt;1). 插件更新机制（推荐）：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。&lt;/li&gt;
&lt;li&gt;点击IDE的&lt;code&gt;Check for Updates...&lt;/code&gt;菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。&lt;/li&gt;
&lt;li&gt;插件更新可能会需要重启IDE。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-手动更新&#34;&gt;2). 手动更新：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从本页面下载最新的插件zip包安装更新。参考本文：&lt;code&gt;下载安装&lt;/code&gt;小节。&lt;/li&gt;
&lt;li&gt;插件更新需要重启IDE。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x4-一些说明&#34;&gt;0x4. 一些说明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本插件默认不会显示其主界面，如果你需要，参考本文：&lt;code&gt;如何使用&lt;/code&gt;小节。&lt;/li&gt;
&lt;li&gt;市场付费插件的试用信息也会一并重置。&lt;/li&gt;
&lt;li&gt;对于某些付费插件（如: Iedis 2, MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：
&lt;ul&gt;
&lt;li&gt;如果IDE没有打开项目，在Welcome界面点击菜单：Configure -&amp;gt; Edit Custom VM Options... -&amp;gt; 移除 -javaagent: 开头的行。&lt;/li&gt;
&lt;li&gt;如果IDE打开了项目，点击菜单：Help -&amp;gt; Edit Custom VM Options... -&amp;gt; 移除 -javaagent: 开头的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重置需要重启IDE生效！&lt;/li&gt;
&lt;li&gt;重置后并不弹出Licenses对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。&lt;/li&gt;
&lt;li&gt;如果长达25天不曾有任何重置动作，IDE会有通知询问你是否进行重置。&lt;/li&gt;
&lt;li&gt;如果勾选：Auto reset before per restart ，重置是静默无感知的。&lt;/li&gt;
&lt;li&gt;简单来说：勾选了Auto reset before per restart则无需再管，一劳永逸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x5-开源信息&#34;&gt;0x5. 开源信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;插件是学习研究项目，源代码是开放的。源码仓库地址：&lt;a href=&#34;https://gitee.com/pengzhile/ide-eval-resetter&#34;&gt;Gitee&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你有更好的想法，欢迎给我提Pull Request来共同研究完善。&lt;/li&gt;
&lt;li&gt;插件源码使用：GPL-2.0开源协议发布。&lt;/li&gt;
&lt;li&gt;插件使用PHP编写，毕竟PHP是世界上最好的编程语言！&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x6-支持的产品&#34;&gt;0x6. 支持的产品&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;AppCode&lt;/li&gt;
&lt;li&gt;CLion&lt;/li&gt;
&lt;li&gt;DataGrip&lt;/li&gt;
&lt;li&gt;GoLand&lt;/li&gt;
&lt;li&gt;PhpStorm&lt;/li&gt;
&lt;li&gt;PyCharm&lt;/li&gt;
&lt;li&gt;Rider&lt;/li&gt;
&lt;li&gt;RubyMine&lt;/li&gt;
&lt;li&gt;WebStorm&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://zhile.io/2020/11/18/jetbrains-eval-reset.html&#34;&gt;https://zhile.io/2020/11/18/jetbrains-eval-reset.html&lt;/a&gt;&lt;/p&gt;
">Jetbrains系列产品重置试用方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-30-LeetCode 410. 分割数组的最大值/"" data-c="
          &lt;h1 id=&#34;题意&#34;&gt;题意&lt;/h1&gt;
&lt;p&gt;给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。&lt;/p&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;解题思路&lt;/h1&gt;
&lt;h2 id=&#34;暴力搜索&#34;&gt;暴力搜索&lt;/h2&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msubsup&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/munderover&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M[n,k] = min^n_{j=1}\{max\{ \ M[j,k-1], \ \sum^{n-1}_{i=j}A_i\}\}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.133108em;vertical-align:-0.383108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.714392em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1130000000000004em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.383108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.2148900000000005em;vertical-align:-1.4137769999999998em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8011130000000006em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.3000050000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.4137769999999998em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，n表示数组长度，k表示数组分成几段。&lt;br&gt;
初始化条件：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;munderover&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/munderover&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M[1,k] = A_0 \\ M[n,1] = \sum^{n-1}_{i=0}A_i
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.0787820000000004em;vertical-align:-1.277669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8011130000000004em;&#34;&gt;&lt;span style=&#34;top:-1.872331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.050005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.300005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.277669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;递归算法拥有指数时间的复杂度，并且会重复计算一些M值。这类的算法一般可以使用动态规划进行优化。使用数组保存一些已经计算得到的值，采用自底向上进行计算&lt;/p&gt;
&lt;h2 id=&#34;二分查找&#34;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;此题可以想象成把数据按顺序装入桶中，m即是给定的桶数，问桶的容量至少应该为多少才能恰好把这些数装入k个桶中（按顺序装的）。&lt;/p&gt;
&lt;p&gt;首先我们可以知道，桶的容量最少不会小于数组中的最大值，即桶容量的最小值（小于的话，这个数没法装进任何桶中），假设只需要一个桶，那么其容量应该是数组所有元素的和，即桶容量的最大值；其次，桶数量越多，需要的桶的容量就可以越少，即随着桶容量的增加，需要的桶的数量非递增的（二分查找就是利用这点）；我们要求的就是在给定的桶数量m的时候，找最小的桶容量就可以把所有的数依次装入k个桶中。在二分查找的过程中，对于当前的桶容量，我们可以计算出需要的最少桶数requiredPainters，如果需要的桶数量大于给定的桶数量k，说明桶容量太小了，只需在后面找对应的最小容量使需要的桶数恰好等于k；如果计算需要的桶数量小于等于k，说明桶容量可能大了（也可能正好是要找的最小桶容量），不管怎样，该桶容量之后的桶容量肯定不用考虑了（肯定大于最小桶容量），这样再次缩小查找的范围，继续循环直到终止，终止时，当前的桶容量既是最小的桶容量。&lt;/p&gt;
&lt;p&gt;对于数组 1 2 3 4 5 6 7，假设k=3，最小桶容量为7（要5个桶），最大桶容量为28（一个桶）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1609316379450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一行表示桶容量，第二行表示需要的桶数，即要求桶数量恰为k的最小桶容量。&lt;/p&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool judge( vector&amp;lt;int&amp;gt;&amp;amp; nums, int capacity, int num ) {
        int curCapacity = capacity;
        for( int i = 0; i &amp;lt; nums.size(); ++i ) {
            if( curCapacity &amp;lt; nums[i] ) {
                num--;
                if( num == 0 ) {
                    return false;
                }
                curCapacity = capacity;
                i--;
            } else {
                curCapacity -= nums[i];
            }
        }
        return true;
    }
    int splitArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int m) {
        int max, min;
        int sum = 0;
        for( int i = 0; i &amp;lt; nums.size(); ++i ) {
            sum += nums[i];
        }
        max = sum; // 成功的情况
        min = 0; // 失败的情况
        while( min&amp;lt;max-1 ) { // 当两者相邻，就退出
            int mid = ( min+max ) / 2;
            if( judge(nums,mid,m) ) {
                max = mid;
            } else {
                min = mid;
            }
        }
        return max;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.cnblogs.com/ygh1229/p/10637504.html&#34;&gt;https://www.cnblogs.com/ygh1229/p/10637504.html&lt;/a&gt;&lt;/p&gt;
">LeetCode 410. 分割数组的最大值</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-29-Ubuntu下配置telnet环境/"" data-c="
          &lt;p&gt;1、首先查看telnet运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -a | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出为空，表示没有开启该服务&lt;/p&gt;
&lt;p&gt;2、安装openbsd-inetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install openbsd-inetd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果已经安装过了，会提示已经安装过了，直接执行下面的步骤就可以了。&lt;/p&gt;
&lt;p&gt;3、安装telnetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install telnetd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完之后，查看/etc/inetd.conf的内容会多了一行telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat /etc/inetd.conf | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出： telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd&lt;/p&gt;
&lt;p&gt;4、重启openbsd-inetd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/init.d/openbsd-inetd restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：* Restarting internet superserver inetd&lt;/p&gt;
&lt;p&gt;5、查看telnet运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat -a | grep telnet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：tcp　　0　　0 :telnet　　😗　　LISTEN&lt;/p&gt;
&lt;p&gt;此时表明已经开启了telnet服务。&lt;/p&gt;
&lt;p&gt;6、telnet登陆测试&lt;/p&gt;
&lt;p&gt;&lt;code&gt;telnet 127.0.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出： Trying 127.0.0.1… Connected to 127.0.0.1. Escape character is ‘^]’. （停在这里的时候要按Ctrl+] 然后回车）&lt;/p&gt;
&lt;p&gt;telnet&amp;gt; （表示登陆成功）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.cnblogs.com/taomylife/p/7552424.html&#34;&gt;https://www.cnblogs.com/taomylife/p/7552424.html&lt;/a&gt;&lt;/p&gt;
">Ubuntu下配置telnet环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-26-算法题精选/"" data-c="
          &lt;p&gt;本文档整理了笔者在刷题过程中遇到的、比较不错的题目，并进行了分类整理，供大家参考。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;打表&#34;&gt;打表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/UVA100&#34;&gt;UVA100 The 3n + 1 problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;并查集&#34;&gt;并查集&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1111&#34;&gt;P1111 修复公路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二分&#34;&gt;二分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/split-array-largest-sum/&#34;&gt;410. 分割数组的最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/magnetic-force-between-two-balls/&#34;&gt;1552. 两球之间的磁力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/63/description?_from=cat&#34;&gt;63 · 搜索旋转排序数组 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分治&#34;&gt;分治&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1257&#34;&gt;P1257 平面上的最接近点对&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/valid-parentheses/&#34;&gt;20. 有效的括号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/&#34;&gt;150. 逆波兰表达式求值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/tag-validator/&#34;&gt;591. 标签验证器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单调栈&#34;&gt;单调栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/daily-temperatures/&#34;&gt;739. 每日温度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/next-greater-element-i/&#34;&gt;496. 下一个更大元素 I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-k-digits/&#34;&gt;402. 移掉K位数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&#34;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water/&#34;&gt;42. 接雨水&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/&#34;&gt;84. 柱状图中最大的矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/maximal-rectangle/&#34;&gt;85. 最大矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/remove-duplicate-letters/&#34;&gt;316. 去除重复字母&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/online-stock-span/&#34;&gt;901. 股票价格跨度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;中缀转后缀&#34;&gt;中缀转后缀&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/basic-calculator/&#34;&gt;224. 基本计算器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/basic-calculator-ii/&#34;&gt;227. 基本计算器 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单调队列&#34;&gt;单调队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/sliding-window-maximum/&#34;&gt;239. 滑动窗口最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/137/&#34;&gt;135. 最大子序和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/subarrays-with-k-different-integers/&#34;&gt;992. K 个不同整数的子数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/insertion-sort-list/147/&#34;&gt;147. 对链表进行插入排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/1691/description?_from=cat&#34;&gt;1691 · 买卖股票的最佳时机 V&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;计算几何&#34;&gt;计算几何&lt;/h1&gt;
&lt;h2 id=&#34;凸包&#34;&gt;凸包&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/erect-the-fence/&#34;&gt;587. 安装栅栏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dp&#34;&gt;dp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364845&#34;&gt;ZOJ 1346 Comparing Your Heroes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/maximal-rectangle/&#34;&gt;85. 最大矩形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/trapping-rain-water/&#34;&gt;42. 接雨水&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/partition-equal-subset-sum/&#34;&gt;416. 分割等和子集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/longest-increasing-subsequence/&#34;&gt;300. 最长递增子序列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/interleaving-string/&#34;&gt;97. 交错字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers/&#34;&gt;1977. 划分数字的方案数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/cherry-pickup/&#34;&gt;741. 摘樱桃&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/232311&#34;&gt;Zet&#39;ubou Another&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;旅行商问题&#34;&gt;旅行商问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d&#34;&gt;毕业旅行问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模拟&#34;&gt;模拟&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/tag-validator/&#34;&gt;591. 标签验证器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;全排列生成算法&#34;&gt;全排列生成算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/permutations-ii/&#34;&gt;47. 全排列 II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;快速幂&#34;&gt;快速幂&lt;/h1&gt;
&lt;h2 id=&#34;矩阵快速幂&#34;&gt;矩阵快速幂&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1962&#34;&gt;P1962 斐波那契数列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;字符串&#34;&gt;字符串&lt;/h1&gt;
&lt;h2 id=&#34;kmp&#34;&gt;KMP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/implement-strstr/&#34;&gt;28. 实现 strStr()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩展kmp&#34;&gt;扩展KMP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=4763&#34;&gt;HDU 4763 Theme Section&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;图论&#34;&gt;图论&lt;/h1&gt;
&lt;h2 id=&#34;最短路&#34;&gt;最短路&lt;/h2&gt;
&lt;h3 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://practice.geeksforgeeks.org/problems/minimum-cost-path3833/1&#34;&gt;Minimum Cost Path&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;离散化&#34;&gt;离散化&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/232311&#34;&gt;Zet&#39;ubou Another&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;思维&#34;&gt;思维&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/pairs-with-same-manhattan-and-euclidean-distance/&#34;&gt;Pairs with same Manhattan and Euclidean distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://practice.geeksforgeeks.org/problems/geek-collects-the-balls5515/1&#34;&gt;Geek collects the balls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/&#34;&gt;581. 最短无序连续子数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/word-subsets/&#34;&gt;916. 单词子集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/iterator-for-combination/&#34;&gt;1286. 字母组合迭代器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lintcode.com/problem/797/description?_from=cat&#34;&gt;797 · 到达一个数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/snapshot-array/&#34;&gt;1146. 快照数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多数投票算法&#34;&gt;多数投票算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;随机化&#34;&gt;随机化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&#34;&gt;剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;搜索&#34;&gt;搜索&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/&#34;&gt;1263. 推箱子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">算法题精选</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-26-与技术相关的文章、博客、网站的汇总/"" data-c="
          &lt;p&gt;这篇文章主要收藏了一些与技术相关的文章、博客、网站，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平时工作学习中遇到的问题的解决方案&lt;/li&gt;
&lt;li&gt;学习资源网站&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://start.spring.io/&#34;&gt;快速创建SpringBoot项目-Spring Initializr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;windows子系统&#34;&gt;Windows子系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-6---install-your-linux-distribution-of-choice&#34;&gt;适用于 Linux 的 Windows 子系统安装指南 (Windows 10)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wulaa/p/7943550.html&#34;&gt;linux改变apt-get安装源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/stickmangod/article/details/85316142/&#34;&gt;E: Sub-process /usr/bin/dpkg returned an error code (1)解决办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/silno/article/details/107498696&#34;&gt;linux 修改ip后不能访问大网的问题解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/63c328ca208d&#34;&gt;Java Agent简介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;环境安装&#34;&gt;环境安装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/java/technologies/downloads/archive/&#34;&gt;Previous Java releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.codebaoku.com/jdk/jdk-oracle-account.html&#34;&gt;Oracle 共享账号 用于JDK下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;android&#34;&gt;Android&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/niuba123456/article/details/90450135#t4&#34;&gt;使用adb获取设备信息： failed to start daemon error: cannot connect to daemon&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;推荐使用换端口号的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lfd.uci.edu/~gohlke/pythonlibs/&#34;&gt;Python安装包大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45523851/article/details/110674141&#34;&gt;Could not build wheels for cryptography which use PEP 517 and cannot be installed directly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qm5132/article/details/105619531/&#34;&gt;python和Microsoft Visual C++ Build Tools版本安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/pyyong2011/article/details/105045883/&#34;&gt;python: cookies 解密问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;django&#34;&gt;Django&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/356405945&#34;&gt;手把手教你用Django实现RESTful接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qiyihan/article/details/105468754&#34;&gt;覃超五毒神掌步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分治&#34;&gt;分治&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33935895/article/details/103261211&#34;&gt;算法]分治法解最近对问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/q547550831/article/details/51541527&#34;&gt;分治法——棋盘覆盖问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;凸包&#34;&gt;凸包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/l1l1/p/9432876.html&#34;&gt;求凸包（安德鲁算法）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/peng0614/article/details/81193484&#34;&gt;【计算几何/凸包】安德鲁算法（Andrew&#39;s Algorithm）详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/21923021&#34;&gt;如何更好地理解和掌握 KMP 算法?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ethsonliu.com/2019/06/extended-kmp.html&#34;&gt;扩展 KMP 算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;学习网站&#34;&gt;学习网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/learning&#34;&gt;阿里云-开发者学院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ke.qq.com/&#34;&gt;腾讯课堂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fortify破解&#34;&gt;Fortify破解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.shungg.cn/tag/Fortify19.1.0%E7%A0%B4%E8%A7%A3%E7%89%88/&#34;&gt;标签 Fortify19.1.0破解版 下的文章&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aliyundrive.com/drive/folder/60d975363027965796944370938057922389184e&#34;&gt;Fortify SCA 20.1.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.52pojie.cn/thread-1085767-1-1.html&#34;&gt;fortify license 破解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计模式&#34;&gt;设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhonghuan1992/article/details/38358183&#34;&gt;迪米特法则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uml&#34;&gt;UML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wglla/article/details/52225571&#34;&gt;uml图六种箭头的含义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/mafeng/p/7909450.html&#34;&gt;位图（BitMap）索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/majunzhu/article/details/100163523&#34;&gt;数据库分库分表策略和分库分表后数据的查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kafka&#34;&gt;Kafka&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hunternet/p/11017000.html&#34;&gt;docker 安装kafka&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;悟空架构&#34;&gt;悟空架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451958620&amp;amp;idx=1&amp;amp;sn=2b68a7579fe43f185b9479e257f6b8ea&amp;amp;chksm=8d1c12c3ba6b9bd5d12b50b3685759053204d63e2fadf8989ad1c8cafde01f0791f37320612d&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0909GosYFr1BPWpDIiHTMimh&amp;amp;sharer_sharetime=1631186094285&amp;amp;sharer_shareid=909e580e119d7a6d472174ec4df35366#rd&#34;&gt;1 W 字+ | 硬刚 MySQL（典藏版）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451958264&amp;amp;idx=1&amp;amp;sn=f7c990e26332cb1b86256f0515b921fd&amp;amp;chksm=8d1c1067ba6b9971e0391682dd97edb2dda9e8fff55aa77aa1d15e5337edee69d10d0340bcd9&amp;amp;scene=178&amp;amp;cur_album_id=2006564214110224387#rd&#34;&gt;面试突击：多线程 | 水帘洞版（免费下载）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式&#34;&gt;分布式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaomi-info.github.io/2020/01/02/distributed-transaction/&#34;&gt;分布式事务，这一篇就够了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;科研&#34;&gt;科研&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/80767310&#34;&gt;学术邮箱命名指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33653203/article/details/111124871&#34;&gt;Yandex降低内存的做法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">与技术相关的文章、博客、网站的汇总</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/valine/"" data-c="
          &lt;p&gt;这篇文章主要用于让python脚本定时评论，唤醒Valine。&lt;/p&gt;
">Valine</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-21-NexT主题设置Valine评论系统邮件提醒/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天无意间看到很久之前写的一篇文章有新的评论，而评论时间呢也是10天以前的。这就有点伤了啊，别人兴致冲冲地提了疑惑，而我却10天后才看到。经过这一茬，意识到评论提醒功能的重要性。由于我使用的是hexo+NexT主题+Valine评论系统，自然而然地就去&lt;a href=&#34;https://valine.js.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valine官网&lt;/a&gt;看了看，没想到还真有提醒的功能「&lt;a href=&#34;https://valine.js.org/notify.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;邮件提醒&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;这里就给大家讲讲Valine中如何配置邮件提醒功能。&lt;/p&gt;
&lt;h2 id=&#34;Valine邮件提醒&#34;&gt;&lt;a href=&#34;#Valine邮件提醒&#34; class=&#34;headerlink&#34; title=&#34;Valine邮件提醒&#34;&gt;&lt;/a&gt;Valine邮件提醒&lt;/h2&gt;&lt;p&gt;Valine评论功能是基于&lt;a href=&#34;https://leancloud.cn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leancloud&lt;/a&gt;的，Valine评论功能还不能跑起来的可以看看我之前写的文章《&lt;a href=&#34;/2345860311#comment_system&#34;&gt;Hexo使用NexT主题及配置&lt;/a&gt;》，其中就有详细的使用说明，这里就不展开了。&lt;/p&gt;
&lt;p&gt;Valine官方提供的邮件提醒功能是基于&lt;code&gt;Leancloud的密码重置邮件提醒&lt;/code&gt;，操作步骤如下：&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Leancloud&lt;/code&gt;&amp;gt;选择你的评论所存放的&lt;code&gt;应用&lt;/code&gt;&amp;gt;&lt;code&gt;设置&lt;/code&gt;&amp;gt;&lt;code&gt;邮件模板&lt;/code&gt;，按下图设置好用于&lt;code&gt;重置密码&lt;/code&gt;的邮件主题&amp;gt;然后保存:&lt;/p&gt;
![](http://Bule-Zst.gitee.io/post-images/1608560201989.jpg)
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改邮件主题：&lt;code&gt;你在  的评论收到了新的评论&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改内容：将下面的代码复制到“内容”中，并将其中的&lt;code&gt;你的网址首页链接&lt;/code&gt;改为你的网址首页链接。&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Hi, {{username}}&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;你在 {{appname}} 的评论收到了新的回复，请点击查看：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;href&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;你的网址首页链接&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;style&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;马上查看&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击“保存”按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;span class=&#34;label label-info&#34;&gt;NexT主题配置文件&lt;/span&gt;，搜索&lt;code&gt;valine&lt;/code&gt;（快速定位），将其中的&lt;code&gt;notify&lt;/code&gt;改为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;# Valine.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# You can get your appid and appkey from https://leancloud.cn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# more info please open https://valine.js.org&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;valine:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  enable: true&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  appid:  gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  appkey: susRJyHS8Fq1SyKXg0r9ad65&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  notify: true # mail notifier , https://github.com/xCss/Valine/wiki&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  verify: false # Verification code&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  placeholder: 您的评论可以一针见血 (*^ω^*)~~ # comment box placeholder&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  avatar: mm # gravatar style&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  guest_info: nick,mail,link # custom comment header&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  pageSize: 10 # pagination size&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;&lt;a href=&#34;#注意事项&#34; class=&#34;headerlink&#34; title=&#34;注意事项&#34;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;发送次数过多，可能会暂时被Leancloud 屏蔽邮件发送功能  &lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;邮件提醒&lt;/code&gt;功能使用的&lt;code&gt;Leancloud的密码重置邮件提醒&lt;/code&gt;，只能传递&lt;code&gt;昵称&lt;/code&gt;、&lt;code&gt;邮箱&lt;/code&gt;两个属性，所以邮件提醒链接&lt;code&gt;无法直达指定文章页&lt;/code&gt;。&lt;strong&gt;请悉知&lt;/strong&gt;。  &lt;/li&gt;
&lt;li&gt;开启&lt;code&gt;邮件提醒&lt;/code&gt;会默认开启&lt;code&gt;验证码&lt;/code&gt;选项。  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;该功能目前还在测试阶段，谨慎使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前&lt;code&gt;邮件提醒&lt;/code&gt;正处于测试阶段，仅在&lt;code&gt;子级&lt;/code&gt;对存在邮件地址的&lt;code&gt;父级&lt;/code&gt;发表评论时发送邮件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三方支持&#34;&gt;&lt;a href=&#34;#第三方支持&#34; class=&#34;headerlink&#34; title=&#34;第三方支持&#34;&gt;&lt;/a&gt;第三方支持&lt;/h2&gt;&lt;p&gt;这里重点讲一下第三方&lt;code&gt;邮件提醒&lt;/code&gt;：&lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valine-Admin&lt;/a&gt; (by &lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@zhaojun1998&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;这也先需要将Valine的评论功能成功跑起来。&lt;/p&gt;
&lt;p&gt;然后进入 &lt;a href=&#34;https://leancloud.cn/dashboard/applist.html#/apps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leancloud&lt;/a&gt; 对应的 Valine 应用中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击 &lt;code&gt;云引擎 -&amp;gt; 设置&lt;/code&gt; 填写代码库并保存：&lt;code&gt;https://github.com/zhaojun1998/Valine-Admin&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560645315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;切换到部署标签页，分支使用 master，点击部署即可：&lt;br&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560340962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560360122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置云引擎的环境变量&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560540352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;必选参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SITE_NAME&lt;/code&gt; : 网站名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SITE_URL&lt;/code&gt; : 网站地址, &lt;strong&gt;最后不要加 &lt;code&gt;/&lt;/code&gt; 。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_USER&lt;/code&gt; : SMTP 服务用户名，一般为邮箱地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_PASS&lt;/code&gt; : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_SERVICE&lt;/code&gt; : 邮件服务提供商，支持 &lt;code&gt;QQ&lt;/code&gt;、&lt;code&gt;163&lt;/code&gt;、&lt;code&gt;126&lt;/code&gt;、&lt;code&gt;Gmail&lt;/code&gt;、&lt;code&gt;&#34;Yahoo&#34;&lt;/code&gt;、&lt;code&gt;......&lt;/code&gt;  ，全部支持请参考 : &lt;a href=&#34;https://nodemailer.com/smtp/well-known/#supported-services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nodemailer Supported services&lt;/a&gt;。 — &lt;em&gt;如这里没有你使用的邮件提供商，请查看&lt;a href=&#34;/高级配置.md#自定义邮件服务器&#34;&gt;自定义邮件服务器&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENDER_NAME&lt;/code&gt; : 寄件人名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于我使用的是我自己的企业邮箱，所以这边的&lt;code&gt;SMTP_SERVICE&lt;/code&gt;就不适用了，需要用这三个参数替换：&lt;code&gt;SMTP_HOST&lt;/code&gt;、&lt;code&gt;SMTP_PORT&lt;/code&gt;、&lt;code&gt;SMTP_SECURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;详细说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SMTP_HOST&lt;/code&gt; : 邮件服务提供商 SMTP 地址，如 qq : &lt;code&gt;smtp.qq.com&lt;/code&gt;，&lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_PORT&lt;/code&gt; : 邮件服务提供商 SMTP 端口, &lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTP_SECURE&lt;/code&gt; : 是否启用加密, 默认为 &lt;code&gt;true&lt;/code&gt;，一般不需要设置，如有特殊请自行配置。 &lt;em&gt;此项需要自行查询或询问其服务商&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果也同我一样使用阿里云企业邮箱，&lt;code&gt;SMTP_HOST&lt;/code&gt;、&lt;code&gt;SMTP_PORT&lt;/code&gt;、&lt;code&gt;SMTP_SECURE&lt;/code&gt;可以照我的写。&lt;/p&gt;
&lt;p&gt;可以看到上图中，我的自定义环境变量还多了2个，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TO_EMAIL&lt;/code&gt;：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到&lt;code&gt;SMTP_USER&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEMPLATE_NAME&lt;/code&gt;：设置提醒邮件的主题，目前内置了两款主题，分别为 &lt;code&gt;default&lt;/code&gt; 与 &lt;code&gt;rainbow&lt;/code&gt;。默认为 &lt;code&gt;default&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Web-评论管理&#34;&gt;&lt;a href=&#34;#Web-评论管理&#34; class=&#34;headerlink&#34; title=&#34;Web 评论管理&#34;&gt;&lt;/a&gt;Web 评论管理&lt;/h3&gt;&lt;p&gt;此项目还为 Valine 提供了更方便的评论管理功能，可以在 web 端对评论进行查看与删除操作。配置方式如下。&lt;/p&gt;
![](http://Bule-Zst.gitee.io/post-images/1608560421062.png)
&lt;p&gt;后台登录需要账号密码，需要在这里设置，只需要填写 &lt;code&gt;email&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;username&lt;/code&gt;，这三个字段即可, 使用  &lt;code&gt;email&lt;/code&gt; 作为账号登陆即可。（为了安全考虑，此 &lt;code&gt;email&lt;/code&gt; 必须为配置中的 &lt;code&gt;SMTP_USER&lt;/code&gt; 或 &lt;code&gt;TO_EMAIL&lt;/code&gt;， 否则不允许登录）&lt;br&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560447539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Web 后台目前仅有 &lt;code&gt;查看&lt;/code&gt; 与 &lt;code&gt;删除&lt;/code&gt; 功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;LeanCloud-休眠策略&#34;&gt;&lt;a href=&#34;#LeanCloud-休眠策略&#34; class=&#34;headerlink&#34; title=&#34;LeanCloud 休眠策略&#34;&gt;&lt;/a&gt;LeanCloud 休眠策略&lt;/h3&gt;&lt;p&gt;免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天必须休眠 6 个小时&lt;/li&gt;
&lt;li&gt;30 分钟内没有外部请求，则休眠。&lt;/li&gt;
&lt;li&gt;休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。&lt;/p&gt;
&lt;p&gt;附 &lt;code&gt;Linux crontab&lt;/code&gt; 定时器代码：&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注 : 此 &lt;code&gt;crontab&lt;/code&gt; 不是 &lt;code&gt;LeanCloud&lt;/code&gt; 后台的定时任务，如果你没有 &lt;code&gt;Linux&lt;/code&gt; 服务器来配置此定时器，那么可以在此 &lt;a href=&#34;https://github.com/zhaojun1998/Valine-Admin/issues/1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issues&lt;/a&gt; 中回复&lt;strong&gt;zhaojun1998&lt;/strong&gt;，让他帮你加上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注&#34;&gt;&lt;a href=&#34;#注&#34; class=&#34;headerlink&#34; title=&#34;注&#34;&gt;&lt;/a&gt;注&lt;/h3&gt;&lt;p&gt;&lt;strong class=&#34;lable-red&#34;&gt;更新新版本与更改环境变量均需要重启容器后生效。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;重启容器&#34;&gt;&lt;a href=&#34;#重启容器&#34; class=&#34;headerlink&#34; title=&#34;重启容器&#34;&gt;&lt;/a&gt;重启容器&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608560469789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.nhtzj.com/3315416634/&#34;&gt;https://www.nhtzj.com/3315416634/&lt;/a&gt;&lt;/p&gt;
">NexT主题设置Valine评论系统邮件提醒</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-20-防御式编程（Defensive Programming）/"" data-c="
          &lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;新的一年开始了，大家都立下了什么新年flag呢？好久没有更新简书了，最近在看《代码大全》对于第八章的防御式编程颇有感慨，正好最近又是在准备公司的技术分享，索性用&lt;code&gt;md&lt;/code&gt;写了篇博文，总结了一下又增加了一些我个人的理解，在这里跟各位分享一下。&lt;/p&gt;
&lt;h1 id=&#34;defensive-programming&#34;&gt;Defensive Programming&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456004690.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;防御式编程（Defensive Programming）&lt;/strong&gt;是提高软件质量技术的有益辅助手段&lt;/p&gt;
&lt;p&gt;怎么理解呢？防御式编程思想的理解可以参考防御式驾驶：&lt;/p&gt;
&lt;p&gt;在防御式驾驶中要建立这样一种思维，那就是你水远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456590306.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;防御式编程的主要思想是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更一般地说，其核心想法是要承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点来编程序，这种思想是将可能出现的错误造成的影响控制在有限的范围内。&lt;/p&gt;
&lt;h2 id=&#34;保护程序免遭非法输入数据的破坏&#34;&gt;保护程序免遭非法输入数据的破坏&lt;/h2&gt;
&lt;p&gt;计算机领域有着一句&lt;code&gt;GIGO(Garbage In Garbage Out)&lt;/code&gt;俗语，翻译过来就是&lt;code&gt;垃圾进，垃圾出&lt;/code&gt;，意思就是&lt;code&gt;有垃圾数据进来后，出来的也是垃圾数据&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456659523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而就目前而言，对于已经成型的产品可能单单是这种原则并不适用，而是应该做到&lt;code&gt;垃圾进，什么也不出&lt;/code&gt;、&lt;code&gt;垃圾进，出去的是错误提示&lt;/code&gt;、&lt;code&gt;垃圾进，经过筛选提取，出去的是有用信息&lt;/code&gt;或是&lt;code&gt;不许垃圾进来&lt;/code&gt;。换句话说，&lt;code&gt;GIGO&lt;/code&gt;于今天的标准看来已然是差劲程序的标志了。&lt;/p&gt;
&lt;p&gt;防御式编程针对垃圾进这种情况，有以下三种方法处理：&lt;/p&gt;
&lt;h4&gt; 1、检查所有来源于外部的数据&lt;/h4&gt;
&lt;p&gt;当从文件、用户、网络或其他外部接口中获取数据时，应检查所获得的数据值，以确保它在允许的范围内。&lt;/p&gt;
&lt;h4&gt; 2、检查子程序所有输入参数的值&lt;/h4&gt;
&lt;p&gt;检查子程序输入参数的值，事实上和检查来源于外部的数据一样，只不过数据来源于其他子程序而非外部接口。&lt;/p&gt;
&lt;h4&gt; 3、决定如何处理错误的输入数据&lt;/h4&gt;
&lt;p&gt;一旦检测到非法的参数，你该如何处理它呢？根据情况的不同，你可以选择适合你的&lt;code&gt;错误处理技术&lt;/code&gt;或&lt;code&gt;断言&lt;/code&gt;来处理。&lt;/p&gt;
&lt;p&gt;接下来我们将针对以上所说的情况讲解防御式编程中需要掌握的方式：&lt;/p&gt;
&lt;h2 id=&#34;断言&#34;&gt;断言&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456704145.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;断言是指在开发期间使用的、让程序在运行时进行自检的代码（通常为宏或一个子程序）。断言为真则程序正常运行，断言为假则意味着代码中发生了错误。&lt;/p&gt;
&lt;p&gt;举个例子：一份客户信息程序要求包含记录数不超过10，我们加一个断言。当记录数小于10，断言会默默无语两眼泪，当超过10，断言就会大声的说程序中存在一个错误！&lt;/p&gt;
&lt;p&gt;断言对于大型复杂程序或可靠性要求极高的程序来说尤为重要。通过使用断言，程序员能更快速排查出因修改代码或者别的原因，而弄进程序里不匹配的接口和错误等。&lt;/p&gt;
&lt;p&gt;OC中内置的断言：（&lt;strong&gt;iOS每个线程都可以指定断言处理器。想设置一个 NSAssertionHandler 的子类来处理失败的断言，在线程的 threadDictionary 对象中设置 NSAssertionHandlerKey 字段即可&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;对NSAssertionHandler有兴趣的童鞋请移步：&lt;a href=&#34;https://nshipster.cn/nsassertionhandler/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define NSAssert(condition, desc, ...)  \
    do {                \
    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
    if (__builtin_expect(!(condition), 0)) {        \
            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
            __assert_file__ = __assert_file__ ? __assert_file__ : @&amp;quot;&amp;lt;Unknown File&amp;gt;&amp;quot;; \
        [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
        object:self file:__assert_file__ \
            lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
    }               \
        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
    } while(0)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面将介绍一下断言使用时的建议：&lt;/p&gt;
&lt;h4&gt; 1、建立自己的断言机制&lt;/h4&gt;
&lt;p&gt;很多时候，系统自带的断言无法满足我们的需求，比如iOS断言在release模式下会失效，那么我们可以自定义断言来适应我们的项目&lt;/p&gt;
&lt;p&gt;下面是C++的断言宏示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#define ASSERT(condition, message) {    \
    if (!condition) {                   \
        Log(&amp;quot;ERROR &amp;quot;,condition,message);\
        exit( EXIT_FAILURE );           \
    }                                   \
}                                       \

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OC中示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define WYHAssert(condition, desc)  \
if (DEBUG) {                        \
   NSAssert(condition, desc);       \
}else {                             \
   NSString *app_build = [[NSBundle mainBundle].infoDictionary objectForKey:@&amp;quot;CFBundleVersion&amp;quot;]; \
NSLog(@&amp;quot;Assert Error condition:%@ (desc: %@) \n Occur in &amp;lt;%s&amp;gt;&amp;lt;第%d行&amp;gt; , AppBuildVersion:%@&amp;quot;,condition,desc,__FILE__,__LINE__,app_build); \
   [LogModule postLog];                            \
} \
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt; 2、用错误处理代码处理预期发生的状况，用断言去处理那些不可发生的错误！&lt;/h4&gt;
&lt;p&gt;断言和错误处理代码的区别：&lt;/p&gt;
&lt;p&gt;断言是用来检查永远不该发生的情况，而错误处理代码(error-handling code)是用来检查不太可能经常发生的情况，这些情况是能在写代码时被预料的，且在产品正式上线时也要处理这些情况，因而说错误处理通常用来检查有害的输入数据，而断言是用于检查代码中的bug ！&lt;/p&gt;
&lt;p&gt;有种方式可以让你更好理解断言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把断言看做是可执行的注解，你不能依赖它来让代码正常工作，但与编程语言中的注解相比，它更能主动地对程序中的假定做出说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt; 3、利用断言来注解前条件和后条件&lt;/h4&gt;
&lt;p&gt;前条件（先验条件）和后条件(后验条件)专有名词最初来自于&lt;a href=&#34;https://baike.baidu.com/item/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1/2180000?fr=aladdin&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;契约式设计(Design by Contract)(DbC)&lt;/a&gt;，使用契约式设计时，每个子程序或类与程序的其余部分都形成了一份契约。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很多语言都有对这种断言的支持。然而DbC认为这些契约对于软件的正确性至关重要，它们应当是设计过程的一部分。实际上，DbC提倡首先写断言。（百度百科）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前条件：子程序或类的调用方代码再调用子程序或实例化对象之前要确保为真的属性。前条件是调用方对其所调用的代码要承担的义务。&lt;/p&gt;
&lt;p&gt;后条件：子程序或类在执行结束后要确保为真的属性，后条件是子程序或类对调用方代码所承担的责任。&lt;/p&gt;
&lt;p&gt;而断言是用来说明前后条件的有利工具。&lt;/p&gt;
&lt;p&gt;下面举个例子说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/// 警报站坐标
private class EStationCoordinate: NSObject {

    var latitude: Float?
    
    var longitude: Float?
    
    var elevation: Float = 0.0
    
    init(_ latitude: Float,_ longitude: Float,_ elevation: Float) {
        super.init()
        
        self.latitude = latitude
        self.longitude = longitude
        self.elevation = elevation
    }
}


/// 取得报警站坐标
///
/// - Parameters:
///   - latitude: &amp;lt;#latitude description#&amp;gt;
///   - longitude: &amp;lt;#longitude description#&amp;gt;
///   - elevation: &amp;lt;#elevation description#&amp;gt;
/// - Returns: &amp;lt;#return value description#&amp;gt;
private func createEmergencyCoordinate(_ latitude: Float,_ longitude: Float,_ elevation: Float) -&amp;gt; EStationCoordinate {
    
    // precondition
    assert(-90 &amp;lt;= latitude &amp;amp;&amp;amp; latitude &amp;lt;= 90, &amp;quot;latitude must within range !&amp;quot;);
    
    assert(0 &amp;lt;= longitude &amp;amp;&amp;amp; longitude &amp;lt; 360, &amp;quot;longitude must within range !&amp;quot;);
    
    assert(100 &amp;lt;= elevation &amp;amp;&amp;amp; elevation &amp;lt; 500, &amp;quot;elevation must within range !&amp;quot;);
    
    // handle .... searching in local
    
    // postcondition
    assert(isContain, &amp;quot;local not contain this coordinate !&amp;quot;)
    
    var coordinate = EStationCoordinate(latitude,longitude,elevation)
    
    return coordinate
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果变量latitude、longitude和elevation都是来源于系统外部，那么就应该用错误处理代码来检查和处理非法的数值，而如果变量的值是源于可信的系统内部，并且这段程序是基于这些值不会超出合法范围的假定而设计，使用断言则是非常合适的。&lt;/p&gt;
&lt;h4&gt; 4、避免将需要执行的子程序放到断言中&lt;/h4&gt;
&lt;p&gt;如果把需要执行的子程序代码写在断言的codition条件里，那么当你关闭断言功能时，编译器很可能就把这些代码排除在外了，下面举一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)postFileToServer {
    
    // .... make file
    
    NSAssert([self compressFileToZip], @&amp;quot;File can&#39;t be compressed !&amp;quot;);
    
    // ... post to server 
}

- (BOOL)compressFileToZip {
    
    //... compress file and create a zip path !
    if (zipPath.length &amp;gt; 0) {
        
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样如果未编译断言，则condition语句的子程序也将不会执行，应修改为以下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)postFileToServer {
    
    // .... make file
    BOOL isCompressSuccess = [self compressFileToZip];
    
    NSAssert(isCompressSuccess, @&amp;quot;File can&#39;t be compressed !&amp;quot;);
    
    // ... post to server
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;错误处理技术&#34;&gt;错误处理技术&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456741675.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;前面我们提过了，断言是处理程序代码中那些不应发生的错误，那么又如何处理那些我们预料之内的可能发生的错误呢？&lt;/p&gt;
&lt;p&gt;首先我们要明确对于程序而言，处理错误最恰当的方式是要根据程序软件的类别而定，进而言之就是对于程序的两个概念：&lt;em&gt;健壮性与正确性&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt; 程序的健壮性 &lt;/h4&gt;&lt;/h4&gt;
&lt;p&gt;定义：健壮性具体指的是系统在不正常的输入或不正常的外部环境下仍能表现出正常的程度。&lt;/p&gt;
&lt;p&gt;健壮性的原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断尝试采取措施来包容错误的输入以此让程序正常运转（对自己的代码要保守，对用户的行为要开放）&lt;/li&gt;
&lt;li&gt;考虑各种各样的极端情况，没有impossible&lt;/li&gt;
&lt;li&gt;即使终止执行，也要准确/无歧义的向用户展示全面的错误信息&lt;/li&gt;
&lt;li&gt;错误信息有助于进行debug&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：视频游戏中的绘图子程序接收到了一个错误的颜色输入，那么在设计的时候可以针对这种情况，采用它的默认背景色或前景色继续绘制，而不是让程序崩溃或退出。&lt;/p&gt;
&lt;h4&gt; 程序的正确性&lt;/h4&gt;
&lt;p&gt;定义：正确性意味着程序永不返回不准确的结果，即使这样做会不返回结果或是直接退出程序。&lt;/p&gt;
&lt;p&gt;例如：在设计控制治疗癌症病人的放疗设备的软件时，当软件接收到错误的放射剂量，那么也许直接关闭程序就是最佳的选择，哪怕重启也比冒险施放错误的放射剂量要好的多。&lt;/p&gt;
&lt;p&gt;总结，两者之间的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确性：永不给用户错误的结果，哪怕是退出程序&lt;/li&gt;
&lt;li&gt;健壮性：尽可能的保持软件运行而不是总是退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了程序的健壮性与正确性，我们就可以采用以下几种手段，或结合起来使用错误处理技术：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、返回中立值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时，处理错误的最佳做法就是继续执行操作并简单的返回一个没有危害的值。&lt;/p&gt;
&lt;p&gt;比如，一个基于输入颜色的绘图子程序接收到了一个错误的颜色输入，它可以忽略这个错误的颜色，而是采用默认的底色或前景色继续进行绘制，而不是直接崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、换用下一个正确的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在处理轮询查询状态的子程序时，如果某次查询出的输出数据错误或有误，大可以忽略本次错误的数据，继续等待下一次轮询时读取正确的数据&lt;br&gt;
&lt;p&gt;（例如，如果你以每秒100次的速度读取体温计的数据，如果某一次得到的数据有误，我们可以再等上1/100秒后继续读取正确的数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、返回与前次相同的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是举上一个例子，如果体温计在1/100秒读取到的是一个错误数据，那么大可以返回上一次正确的数据，因为温度在1/100秒内变化不会太大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、换用最接近的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，当我们在编写一个滑块在规定区域内滑动的程序时，如果滑块超过规定区域，我们可以取最接近于超过区域的安全数值返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、把警告信息记录到日志文件中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在检测到错误数据时，可以选择在日志文件中记录一条警告信息，然后继续执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、返回一个错误状态码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以决定只让徐彤的某些部分处理错误，其他部分则不在局部处理错误，而是简单的返回一个错误码。&lt;/p&gt;
&lt;p&gt;比如在用户信息编辑页面有一个保存按钮，当某些信息填写错误时，这时只是记录一个错误码，当点击保存按钮时才去判断验证这个错误码是否存在，决定是否允许用户执行下一步操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、调用错误处理子程序或对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把错误处理都集中在一个全局的错误处理子程序或对象中，这种方法优点在于能把错误处理的职责集中到一起，从而让调试变得更简单。而代价则是整个程序都要知道这个集中点，并与之紧密耦合。&lt;/p&gt;
&lt;p&gt;什么意思呢？比如在一系列有上下文关系的请求中，针对所有的请求错误，我们只封装一个错误管理类来集中管理这些错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、当错误发生时显示出错消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法可以把错误处理的开销减到最小，然而你需要衡量此时的错误消息对于用户而言是否是友善的，相反对于攻击者而言，尽量不要让他们利用错误信息来发现如何攻击这个系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、关闭程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些更偏向于&lt;code&gt;正确性&lt;/code&gt;的程序，当检测到错误发生时，也许关闭程序是最佳的选择。&lt;/p&gt;
&lt;p&gt;如上面谈到的&lt;code&gt;癌症病人的放疗设备的软件&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456771734.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异常处理，英文名为exceptional handling, 是代替日渐衰落的error code方法的新法，提供error code 所未能具体的优势。异常处理分离了接收和处理错误代码。这个功能理清了编程者的思绪，也帮助代码增强了可读性，方便了维护者的阅读和理解。 异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理使用 try、catch 和 finally 关键字来尝试可能未成功的操作，处理失败，以及在事后清理资源。(百度百科)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在一个子程序中遇到了预料之外的情况，但并不知道如何处理的话，你就可以选择抛出一个异常。&lt;/p&gt;
&lt;p&gt;异常的基本结构是：子程序使用throw抛出一个异常对象，再被调用链上层其他子程序的try-catch语句捕获。(&lt;strong&gt;内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;我知道听到这，肯定有人懵逼了，我们来看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)tryFirstException {
    @try {
        // 1
        [self trySecondException];
        
    } @catch (NSException *exception) {
        //2
        NSLog(@&amp;quot;First reason:%@&amp;quot;,exception.reason);
        
    } @finally {
        //3
    }
    //4
}

+ (void)trySecondException {
    @try {
        //5
        [self tryThirldException];
        
    } @catch (NSException *exception) {
        //6
        @throw exception; //如果将这段代码注释后又会怎样？
        NSLog(@&amp;quot;Second reason:%@&amp;quot;,exception.reason);
    } @finally {
        //7
    }
    //8
}

+ (void)tryThirldException {
    //9
    @throw [NSException exceptionWithName:@&amp;quot;Exc&amp;quot; reason:@&amp;quot;no reason!&amp;quot; userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有人知道程序应该怎么执行吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;许多常见的程序设计语言，包括Actionscript，Ada，BlitzMax，C++，C#，D，ECMAScript，Eiffel，Java，ML，Object Pascal（如Delphi，Free Pascal等），Objective-C，Ocaml，PHP（version 5），PL/1，Prolog，Python，REALbasic，Ruby，Visual Prolog以及大多数.NET程序设计语言，内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止。一般在这个异常处理代码的搜索过程中逐级完成栈卷回（stack unwinding）。但Common Lisp是个例外，它不采取栈卷回，因此允许异常处理完后在抛出异常的代码处原地恢复执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面将给予一些使用异常的建议：&lt;/p&gt;
&lt;h4&gt; 1、用异常通知程序的其他部分，发生了不可忽略的错误&lt;/h4&gt;
&lt;p&gt;异常机制的优越之处，在于它能提供一种无法被忽略的错误通知机制。其他错误处理技术有可能会导致错误在不知不觉中向外扩散，而异常则消除了这种可能性。&lt;/p&gt;
&lt;h4&gt; 2、只在真正例外的情况下才抛出异常&lt;/h4&gt;
&lt;p&gt;仅在真正例外的情况下才使用异常————换句话说，就是仅在其他编码实践方法无法解决的情况下才使用异常。这种情况跟断言相似————都是用来处理那些不仅罕见甚至永远不该发生的情况。&lt;/p&gt;
&lt;h4&gt; 3、不能用异常来推卸责任&lt;/h4&gt;
&lt;p&gt;如果某种错误情况可以在局部处理，那就应该在局部处理它。不要把本可以处理的错误当成一个未被捕获的异常抛出去。&lt;/p&gt;
&lt;h4&gt; 4、避免在构造函数和析构函数中抛出异常，除非你在同一个地方把它们捕获&lt;/h4&gt;
&lt;p&gt;如果尝试在构造函数或析构函数中抛出异常，则处理异常将变得非常复杂。&lt;br&gt;
&lt;p&gt;比如在C++中，只有对象在完全构造之后才能调用析构函数，也就是说如果再构造函数中抛出异常，就不会调用析构函数，从而造成潜在的资源泄漏。&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt; 5、在恰当的抽象层次抛出异常&lt;/h4&gt;
&lt;p&gt;当你决定把一个异常传给调用方时，请确保异常的抽象层次与子程序的接口抽象层次一致。&lt;br&gt;
&lt;p&gt;（比如在A类的某一子程序中，有一个getDefenseId的方法，在方法中的某些步骤中，我们抛出了一个文件读写错误的异常，这本应由层次更低的内部类F专职去做的事，却错误的在A类中抛出异常，破坏了封装性，也暴露了一些私有的实现细节，这显然不是我们想要的）&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt; 6、在异常消息中加入关于导致异常发生的全部信息&lt;/h4&gt;
&lt;p&gt;比如因为一个索引值错误而抛出的，就应该在异常消息中包含索引的上下界限一级非法的索引下标值等信息。&lt;/p&gt;
&lt;h4&gt; 7、避免使用空的catch语句&lt;/h4&gt;
&lt;p&gt;不要视图敷衍一个不知该如何处理的异常&lt;/p&gt;
&lt;h4&gt; 8、考虑创建一个集中的异常报告机制&lt;/h4&gt;
&lt;p&gt;封装一个异常报告的子程序（或基类）专门快速方便的报告程序中需要主动抛出的异常（异常处理器），将对于异常的使用更加标准化&lt;/p&gt;
&lt;h4&gt; 9、考虑异常的替换机制&lt;/h4&gt;
&lt;p&gt;虽然一些编程语言对于异常的支持已有5~10年甚至更久的历史，但关于如何安全使用异常的经验仍然还是很少。&lt;/p&gt;
&lt;p&gt;拿iOS举例，&lt;code&gt;Apple.inc&lt;/code&gt;虽然同时提供了错误处理（&lt;code&gt;NSError&lt;/code&gt;）和异常处理（&lt;code&gt;Exception&lt;/code&gt;）两种机制，但是Apple不建议我们主动去使用Exception，更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Important: In many environments, use of exceptions is fairly commonplace. For example, you might throw an exception to signal that a routine could not execute normally—such as when a file is missing or data could not be parsed correctly. Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors. Instead you should use the return value of a method or function to indicate that an error has occurred, and provide information about the problem in an error object. For more information, see Error Handling Programming Guide.&lt;/p&gt;
&lt;p&gt;(developer.apple.com)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感兴趣的童鞋请移步苹果官网 &lt;a href=&#34;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多说一句，虽然apple不推荐我们经常主动使用Exception，但针对于crash的异常捕捉，iOS是可以通过&lt;code&gt;NSSetUncaughtExceptionHandler&lt;/code&gt;来捕获大部分crash的，但值得注意的是无法捕获那些由于&lt;code&gt;内存溢出&lt;/code&gt;、&lt;code&gt;野指针BAD_ACCESS&lt;/code&gt;导致的crash，比如&lt;code&gt;Flurry&lt;/code&gt;中对&lt;code&gt;crash&lt;/code&gt;处理就是这么运作的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - (void) uncaughtExceptionHandler(NSException *exception) 
    {
        [Flurry logError:@&amp;quot;Uncaught&amp;quot; message:@&amp;quot;Crash!&amp;quot; exception:exception];
    }
 
    - (void)applicationDidFinishLaunching:(UIApplication *)application
    {
        NSSetUncaughtExceptionHandler(&amp;amp;uncaughtExceptionHandler);
        [Flurry startSession:@&amp;quot;YOUR_API_KEY&amp;quot;];
        // ....
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;隔栏&#34;&gt;隔栏&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456801568.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;隔栏是防御式编程中的一种容损策略，举个例子，大家可以这样来理解：&lt;/p&gt;
&lt;p&gt;船体外壳上装备隔离舱，如果船只与冰山相撞导致船体破裂，隔离舱就会被封闭起来，从而保护船体的其余部分不会受到影响。&lt;br&gt;
&lt;p&gt;（&lt;code&gt;隔栏&lt;/code&gt;过去叫&lt;code&gt;防火墙&lt;/code&gt;，但现在&lt;code&gt;防火墙&lt;/code&gt;这一术语常用来代指阻止恶意网络攻击）&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456820092.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;5毛钱特效&lt;/code&gt;翻译过来就是：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608457186869.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;左侧外部接口数据假定是肮脏的不可信的，中间这些类（子程序）构成&lt;code&gt;隔栏&lt;/code&gt;，负责清理和验证数据并返回可信的数据，最右侧的类（子程序）全部在假定数据干净（安全）的基础上工作，这样可以让大部分的代码无须再担负检查错误数据的职责！&lt;/p&gt;
&lt;p&gt;这种策略可以拟一个比较生动的例子，可以看做是手术室里使用的一种策略。&lt;br&gt;
&lt;p&gt;任何东西在允许进入手术室之前都要经过消毒处理，因此手术室里的任何东西都可以认为是安全的。这其中最核心的设计决策是&lt;code&gt;规定什么可以进入手术室，什么不可以，还有把手术室的门设在哪里&lt;/code&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;在编程中也是如此，约定哪些子程序可认为是在安全区域里的，哪些又是在安全区域外的，哪些负责清理数据（完成这一工作最简单的方法是在得到外部数据时，立即进行清理，不过数据往往需要经过一层以上的清理，因此多层清理有时也是必须的）&lt;/p&gt;
&lt;p&gt;隔栏的应用：&lt;br&gt;
&lt;p&gt;隔栏的使用使断言和错误处理有了清晰的区分，隔栏外部的程序应该使用错误处理技术，在那里对数据做的任何处理假定都是不安全的。而隔栏内部的程序里就应该使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。如果隔栏内部的子程序检测到了错误的数据，那么应该是程序里的错误而不是程序外的错误。&lt;/p&gt;&lt;/p&gt;
&lt;h2 id=&#34;辅助调试代码&#34;&gt;辅助调试代码&lt;/h2&gt;
&lt;p&gt;防御式编程的另一重要方面就是使用调试助手（辅助调试代码），调试助手非常之强大👍，可以帮助我们快速检查错误。&lt;/p&gt;
&lt;p&gt;应用在开发期间应牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具。&lt;/p&gt;
&lt;h4&gt; 1、应尽早的引入辅助调试代码&lt;/h4&gt;
&lt;p&gt;越早进入辅助调试代码，它能够提供的帮助也越大。如果你经常遇到某些问题，尝试自己编写或引入一些&lt;code&gt;辅助调试代码&lt;/code&gt;，它就会自始至终在项目中帮助你。&lt;/p&gt;
&lt;h4&gt; 2、采用进攻式编程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://Bule-Zst.gitee.io/post-images/1608456836309.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;什么又是进攻式编程，其实这也是防御式编程中的一种习惯，其思想在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量让异常的情况在开发期间暴露出来，而在产品上线时自我恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如你有一段switch case语句用来处理事件，在开发期间应尽量考虑所有你能预料得到的情况并作出处理，另外在default case语句中，如果是开发阶段可以采用&lt;code&gt;进攻式编程处理&lt;/code&gt;，而在产品正式上线期间，针对default case应更稳妥一些，比如记录错误日志。&lt;/p&gt;
&lt;p&gt;下面列举一下进攻式编程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保断言语句使程序终止运行&lt;/li&gt;
&lt;li&gt;完全填充分配到的所有内存&lt;/li&gt;
&lt;li&gt;完全填充己分配到的所有文件或流&lt;/li&gt;
&lt;li&gt;确保每一个case 语句中的default分支或else 分支都能产生严重错误（如终止程序）&lt;/li&gt;
&lt;li&gt;在删除一个对象之前把它填满垃圾数据&lt;/li&gt;
&lt;li&gt;让程序将错误日志主动用电子邮件或推送发送给开发者（安防目前采用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt; 3、计划移除调试辅助的代码&lt;/h4&gt;
&lt;p&gt;如果是商用软件，调试用的代码有时会使软件的体积变大且速度变慢，从而给程序造成巨大的性能影响。要事先做好准备计划，避免调试用的代码和程序原代码纠缠不清，下面列举一些可以选择的移除方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用类似ant和make这样的版本控制工具&lt;/p&gt;
&lt;p&gt;（可以从同一套源码编译出不同版本的程序。在开发模式下，你可以让make工具把所有的调试代码都包含进来一起编译。而在产品上线期间，把那些调试代码排除在外。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用内置的预处理器（&lt;code&gt;C++ #字符为预处理器指令，包含#if、#warning、#include、#define等&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;（如果你所用的编程环境里有预处理器，你可以用预处理器来包含或排除调试的代码）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- (void)handleSomething {
    
#ifdef DEBUG
    
    [self debugF];//通常为一些debug用的耗时操作
#else
    
    [self releaseF];
#endif
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为应用增加调试模式的入口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的应用需要同时支持两种模式（发布和调试），那么我们可以自定义进入调试模式的入口，而不是针对编译层次的DEBUG，我们的调试代码的嵌入也依赖于这个调试模式是否开启，下面将演示安防app内定义的调试模式。&lt;/p&gt;
&lt;h2 id=&#34;对防御式编程采取防御的姿态&#34;&gt;对防御式编程采取防御的姿态&lt;/h2&gt;
&lt;p&gt;说了这么多，那么是不是防御式代码越多越好呢？&lt;/p&gt;
&lt;p&gt;其实也不是，多度的防御式编程也会引起问题，如果你在每一个能想到的地方都用每一种能想到的方法来检查参数、处理错误，那么你的程序会变得臃肿而缓慢，更糟的事，多度的防御式代码换来的是软件的复杂度。&lt;/p&gt;
&lt;p&gt;这说明，防御式编程引入的代码也并非不会有缺陷，和其他代码一样，你同样能轻而易举的在防御式编程添加的代码中找到错误，尤其是当你随手编写这些代时更是如此。&lt;/p&gt;
&lt;p&gt;因此，要考虑好什么地方需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序代码中对错误处理的方式远比&lt;code&gt;GIGO&lt;/code&gt;复杂的多。&lt;/li&gt;
&lt;li&gt;防御式编程技术可以让错误更容易发现问题、更容易修改，并减少错误对产品代码的破坏。&lt;/li&gt;
&lt;li&gt;遵从防御式编程的思想去开发，会让你在开发阶段就提前处理了许多问题，提高代码质量，降低测试周期，要做到主动去发现错误并做出处理（&lt;strong&gt;千万不要存侥幸心理，明明可以多考虑几种情况，偏偏却要忽略它们的可能性&lt;/strong&gt;），而不是等到bug隐式的出现所带来的未曾预料的灾难。&lt;/li&gt;
&lt;li&gt;错误处理技术更适用于暴露的接口程序或类，而断言则更强调不可允许的错误，多适用于不暴露在外的私有方法（或内部类）。&lt;/li&gt;
&lt;li&gt;处理错误最恰当的方式是要根据程序软件的类别而定，更倾向于&lt;strong&gt;正确性&lt;/strong&gt;还是&lt;strong&gt;健壮性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;异常提供了一种与代码正常流程角度不同的错误处理手段，但同时也应该在异常和其他错误处理手段之间进行权衡比较，比如iOS中就很少采用异常处理机制。&lt;/li&gt;
&lt;li&gt;合理的运用辅助调试代码，会让你不管是在开发还是发布阶段都能更快速定位问题，并从容地解决问题。（预处理器就是个很好的选择）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，我对于防御式编程的理解是，我认为程序的好坏与其健壮性（和正确性）有很大的联系，所有的程序开发人员都要对它有足够的重视，主动去迎战错误，从一点一滴开始做起，不要忽视任何的细节，不能盲目依赖测试去发现bug，而是以测试驱动编程，不断地思考可能发生的问题以进行预防，做一个聪明的程序员。这才是防御式编程所告诉我们的事 ！&lt;/p&gt;
&lt;h2 id=&#34;推荐&#34;&gt;推荐&lt;/h2&gt;
&lt;p&gt;最后列举一下文中出现的引用来源及一些推荐看的文章或书籍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《代码大全第2版》第八章防御式编程&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1yfmqkf84CJ6Zpbj4-_TlUQ&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;《Writing Solid Code》断言的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1DYNOJrl7AJLhlRCY4gCnDQ&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;《Object-Oriented Software Construction》中有关于契约式设计的前置条件、后置条件、不变式的权威概述。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nshipster.cn/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;苹果对于Exception Handling介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://www.jianshu.com/p/34f1dfa3aa8e&#34;&gt;https://www.jianshu.com/p/34f1dfa3aa8e&lt;/a&gt;&lt;/p&gt;
">防御式编程（Defensive Programming）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-18-完全小白教程：使用Coding Pages和Gridea搭建个人博客/"" data-c="
          &lt;div class=&#34;RichText ztext Post-RichText&#34;&gt;&lt;p&gt;2020/07/14更新&lt;/p&gt;&lt;p&gt;如果严格按照教程步骤操作了，还是出现远程连接失败的问题，可以尝试修改仓库名，例如我的仓库名叫myblog，在Gridea配置里，把仓库名设为myblog/myblog。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_b.png&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;778&#34; data-rawheight=&#34;85&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;778&#34; data-original=&#34;https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;hr&gt;&lt;p&gt;上一篇文章写了使用Github Pages和Gridea来搭建个人博客：&lt;/p&gt;&lt;a target=&#34;_blank&#34; href=&#34;https://zhuanlan.zhihu.com/p/165948546&#34; data-draft-node=&#34;block&#34; data-draft-type=&#34;link-card&#34; data-image=&#34;https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg&#34; data-image-width=&#34;1280&#34; data-image-height=&#34;720&#34; class=&#34;LinkCard LinkCard--hasImage&#34; data-za-detail-view-id=&#34;172&#34;&gt;&lt;span class=&#34;LinkCard-backdrop&#34; style=&#34;background-image:url(https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg)&#34;&gt;&lt;/span&gt;&lt;span class=&#34;LinkCard-content&#34;&gt;&lt;span class=&#34;LinkCard-text&#34;&gt;&lt;span class=&#34;LinkCard-title&#34; data-text=&#34;true&#34;&gt;海边的卡夫卡：完全小白教程：使用Github Pages和Gridea搭建个人博客&lt;/span&gt;&lt;span class=&#34;LinkCard-meta&#34;&gt;&lt;span style=&#34;display:inline-flex;align-items:center&#34;&gt;&amp;#8203;&lt;svg class=&#34;Zi Zi--InsertLink&#34; fill=&#34;currentColor&#34; viewBox=&#34;0 0 24 24&#34; width=&#34;17&#34; height=&#34;17&#34;&gt;&lt;path d=&#34;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/span&gt;zhuanlan.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;LinkCard-imageCell&#34;&gt;&lt;img class=&#34;LinkCard-image LinkCard-image--horizontal&#34; alt=&#34;图标&#34; src=&#34;https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;但Github毕竟是国外的服务器，访问速度很慢，如果你只是想要在国内访问你的博客，你完全可以使用国内的&lt;b&gt;Coding Pages&lt;/b&gt;来代替Github Pages。&lt;/p&gt;&lt;h2&gt;1 Coding Pages开通&lt;/h2&gt;&lt;h3&gt;1.1 Coding账号注册&lt;/h3&gt;&lt;p&gt;原来的Coding个人版合并到团队版了，所以这里我详细说下Coding的注册。&lt;/p&gt;&lt;p&gt;进入&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//e.coding.net/signup%3F_ga%3D2.238701378.316970461.1592676170-1921038398.1592620024&#34; class=&#34; wrap external&#34; target=&#34;_blank&#34; rel=&#34;nofollow noreferrer&#34;&gt;注册页面&lt;/a&gt;，创建新团队，这个团队名称要记住，后面要用到，然后创建用户，完成注册。&lt;/p&gt;&lt;h3&gt;1.2 创建项目&lt;/h3&gt;&lt;p&gt;登录后，点击项目，发现只有一个示例项目，我们新建一个项目。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;939&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_r.jpg&#34;/&gt;
&lt;/figure&gt;&lt;p&gt;选择第一个——代码托管项目。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1550&#34; data-rawheight=&#34;689&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1550&#34; data-original=&#34;https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;然后填写项目名称，往下拉点完成创建。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1049&#34; data-rawheight=&#34;766&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1049&#34; data-original=&#34;https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;创建后是这样的，点左下角的项目设置。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点功能开关，把&lt;b&gt;持续集成&lt;/b&gt;和&lt;b&gt;持续部署&lt;/b&gt;开关打开。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;进入代码仓库，如果还没有初始化，就先初始化仓库，勾选那个readme，就可以初始化了。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1917&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1917&#34; data-original=&#34;https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h3&gt;1.3 实名认证&lt;/h3&gt;&lt;p&gt;点网页左上角猴子的图标回主页，点左下角团队设置。团队所有者在【团队管理】-&amp;gt;【团队设置】-&amp;gt;【实名认证】，可进行团队实名认证。实名认证后，团队将可以使用 Pages 部署等产品功能。&lt;/p&gt;&lt;h3&gt;1.4 使用静态网站服务&lt;/h3&gt;&lt;p&gt;回到myblog项目，点【持续部署】-&amp;gt;【静态网站】-&amp;gt;【立即发布静态网站】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1916&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1916&#34; data-original=&#34;https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;名称还是叫myblog吧，保存。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1916&#34; data-rawheight=&#34;941&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1916&#34; data-original=&#34;https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;这里就是你的博客访问地址了（我的有两个，是因为我已经绑定域名了），不过现在点开，会显示404，别急嘛。点右上角的设置，来绑定域名，毕竟他给的这个网址好难记QAQ&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1920&#34; data-rawheight=&#34;940&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1920&#34; data-original=&#34;https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点了设置后，往下拉，绑定域名，保存修改。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1622&#34; data-rawheight=&#34;517&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1622&#34; data-original=&#34;https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h3&gt;1.5 生成令牌&lt;/h3&gt;&lt;p&gt;右上角头像点开，点【个人设置】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;458&#34; data-rawheight=&#34;347&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;458&#34; data-original=&#34;https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点【访问令牌】-&amp;gt;【新建令牌】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1403&#34; data-rawheight=&#34;625&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1403&#34; data-original=&#34;https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;你可以把权限都勾上，然后点【创建令牌】。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1237&#34; data-rawheight=&#34;910&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1237&#34; data-original=&#34;https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;p&gt;点这个图标复制令牌，另外你的令牌用户名也是后面要用到的。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1097&#34; data-rawheight=&#34;262&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1097&#34; data-original=&#34;https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;h2&gt;2 Gridea远程部署&lt;/h2&gt;&lt;p&gt;Gridea下载请参考我上一篇文章，运行Gridea，配置。&lt;/p&gt;&lt;figure data-size=&#34;normal&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_b.jpg&#34; data-caption=&#34;&#34; data-size=&#34;normal&#34; data-rawwidth=&#34;1484&#34; data-rawheight=&#34;992&#34; class=&#34;origin_image zh-lightbox-thumb&#34; width=&#34;1484&#34; data-original=&#34;https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_r.jpg&#34;/&gt;&lt;/figure&gt;&lt;blockquote&gt;如果你没有绑定域名，就填他提供给你的网址，CNAME就不填。&lt;br&gt;仓库用户名为你的&lt;b&gt;团队名&lt;/b&gt;。&lt;/blockquote&gt;&lt;p&gt;保存后，点检测远程连接，如果没有问题就可以同步了。&lt;/p&gt;&lt;p&gt;OK，可以正常访问了~&lt;/p&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://zhuanlan.zhihu.com/p/166114376&#34;&gt;https://zhuanlan.zhihu.com/p/166114376&lt;/a&gt;&lt;/p&gt;
">完全小白教程：使用Coding Pages和Gridea搭建个人博客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-12-18-基于Gridea+github搭建静态博客/"" data-c="
          &lt;div class=&#34;text &#34;&gt;
                &lt;h3 id=&#34;写在开头&#34;&gt;写在开头&lt;/h3&gt;
&lt;p&gt;为什么要写这篇博客呢，因为Gridea目前还处于未被发现的阶段，使用的用户很少。官方的文档里是使用视频进行介绍，配置过程中反复回调进度条比较麻烦，因此撰写该文章方便新加入的用户学习经验。同时将一些可能出现的问题总结在文章中，防止大家踩坑~&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;前提&#34;&gt;前提&lt;/h3&gt;
&lt;p&gt;拥有一个Github账号 / 拥有一个Coding账号（如果没有请前往注册）&lt;br&gt;
Github地址：https://github.com/&lt;br&gt;
Coding地址：https://coding.net/&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;1下载安装git工具&#34;&gt;1.下载安装Git工具&lt;/h3&gt;
&lt;p&gt;该工具的用处本文不作介绍，毕竟是个“程序员”都知道。&lt;br&gt;
下载地址：Git下载&lt;br&gt;
选择适合自己的电脑版本下载安装即可。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;2gridea下载安装&#34;&gt;2.Gridea下载安装&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/1.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
选择适合自己的版本下载安装即可。&lt;br&gt;
安装完后打开软件，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/2.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
PS：这也是我为啥放弃hexo转用Gridea的原因，颜值高，还有专门的桌面端软件配套使用。另外平心而论，Gridea配置起来比hexo简单很多。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;3github静态pages配置&#34;&gt;3.GitHub静态Pages配置&lt;/h3&gt;
&lt;p&gt;(1)进入Github新建一个仓库。&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/3.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
其中用户名尽量和Owner名字保持一致（不然可能会出现问题）&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
(2)新建完仓库后，访问 https:// + 你仓库的名字，如下图&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/4.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
如果访问404失败便是配置出现问题，请仔细查看自己的步骤。如果显示出来一个几乎空白的页面便是成功。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
(3)打开个人设置&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/5.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/6.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/7.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/8.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/8.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
接下来会生成一串密钥，请把它们保存到一个文档里（因为之后可能就会找不到了）&lt;br&gt;
接下来就基本OK啦，开始最终配置&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/9.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
当上方显示远程连接成功后，保存配置。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
然后点击左侧同步。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
接下来重新访问 用户名.github.io&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/10.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/10.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;4-coding静态页面配置&#34;&gt;4. Coding静态页面配置&lt;/h3&gt;
&lt;p&gt;为什么还需要配置Coding呢？&lt;br&gt;
答：Coding和Github属于两个托管平台。即以上步骤便已经算配置好你的个人博客了。那为什么还需要如下步骤呢？第一.存储在两个平台较为安全 第二.Github静态页面访问起来速度较慢，同时会被一些搜索引擎屏蔽掉，即你的博客无法被百度搜到，写的文章只能自娱自乐。&lt;br&gt;
ps:经过了以上步骤，这里我们快速讲解。大同小异。&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
首先在个人设置里修改自己的用户名（仅针对于刚刚注册的用户）&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/11.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/11.png&#34; style=&#34;&#34;&gt;&lt;br&gt;
由于Coding平台版本更新，曾经的配置方法部分失效。&lt;br&gt;
建议借鉴该文章：&lt;br&gt;
&lt;a href=&#34;http://liyuanbo.top/post/grideacoding-page-ge-ren-wang-zhan-da-jian/&#34;&gt;Gridea+Coding Page个人网站搭建&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;h3 id=&#34;可能出现的问题&#34;&gt;可能出现的问题&lt;/h3&gt;
&lt;p&gt;1.在点击检测远程连接时，总是失败，但是自己步骤都做了。&lt;br&gt;
答：检查自己是否成功安装Git。&lt;br&gt;
2.Gridea软件&lt;br&gt;
如果安装在其他文件夹时，请务必修改设置。&lt;br&gt;
&lt;img src=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/12.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; class=&#34;lazyload&#34; data-original=&#34;https://ericamblog.oss-cn-shanghai.aliyuncs.com/2019/12.png&#34; style=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from &lt;a href=&#34;https://ericam.top/post/ji-yu-grideagithubcoding-da-jian-ge-ren-jing-tai-bo-ke/&#34;&gt;https://ericam.top/post/ji-yu-grideagithubcoding-da-jian-ge-ren-jing-tai-bo-ke/&lt;/a&gt;&lt;/p&gt;
">基于Gridea+github搭建静态博客</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-11-09-论文转述 Design Pattern Implementation in Java and AspectJ/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/74c24bb20c5d42869f844b9f2f1e154c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;摘要&#34;&gt;摘要&lt;/h1&gt;
&lt;h1 id=&#34;二-既定挑战&#34;&gt;二、既定挑战&lt;/h1&gt;
&lt;p&gt;许多作者已经确定了当模式在特定的软件系统中具体化时会出现的挑战。其中，三个最重要的挑战与实现、文档和组合有关。&lt;/p&gt;
&lt;p&gt;设计模式的实现通常有许多不良的相关影响。因为模式影响系统结构，并且它们的实现也受到系统结构的影响，所以模式实现通常是根据使用情况定制的。这可能导致它们“消失在代码中”，并失去模块化。这使得很难区分模式、具体实例和涉及的对象模型。在系统中添加或移除模式通常是一种侵入性的、难以逆转的改变。&lt;strong&gt;因此，虽然设计模式是可重用的，但它的实现通常不是&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模式代码的侵入性，以及它与其他代码的分散和纠缠造成了文档问题。如果在一个系统中使用了多个模式，跟踪一个设计模式的特定实例会变得很困难，尤其是当类涉及到多个模式时(即，如果有模式覆盖/组合)。&lt;/p&gt;
&lt;p&gt;模式组合导致的不仅仅是文档问题。对包含相同类的多个模式的系统进行推理本来就很困难，因为这种组合会产生大量相互依赖的类。这是一个重要的主题，因为一些设计模式在他们的解决方案中显式地使用其他模式。&lt;/p&gt;
&lt;h1 id=&#34;三-研究格式&#34;&gt;三、研究格式&lt;/h1&gt;
&lt;p&gt;本文中的发现是基于对GoF设计模式的Java和AspectJ实现的比较分析。&lt;/p&gt;
&lt;p&gt;对于23种GoF模式中的每一种，我们都创建了一个利用该模式的小示例，并在Java和AspectJ中实现了该示例（&lt;a href=&#34;http://www.cs.ubc.ca/labs/spl/projects/aodps.html&#34;&gt;代码下载[已失效]&lt;/a&gt;）。Java实现对应于GoF书中的示例C++实现，并做了一些小的调整，以解决C++和Java之间的差异(缺乏多重继承等)。大多数模式都有许多实现变体和替代方案。如果一个模式提供了不止一个可能的实现，我们选择一个看起来最普遍适用的。&lt;/p&gt;
&lt;p&gt;AspectJ实现是迭代开发的。AspectJ结构允许许多不同的实现，通常有不同的权衡。我们的目标是充分研究每个模式的明确定义的实现的设计空间。我们最终总共创建了57个不同的实现，每个模式从1到7个不等。第4节讨论了一些权衡和设计决策。&lt;/p&gt;
&lt;h1 id=&#34;四-结果&#34;&gt;四、结果&lt;/h1&gt;
&lt;p&gt;本节介绍了GoF设计模式的具体实例的AspectJ和Java实现的比较。第4.1节详细讨论了观察者模式。我们使用这个讨论来呈现大多数AspectJ解决方案共有的属性。其余的模式是基于第4.1节中的概念提出的。&lt;/p&gt;
&lt;h2 id=&#34;41-例子-观察者模式&#34;&gt;4.1 例子: 观察者模式&lt;/h2&gt;
&lt;p&gt;观察者模式的意图是“在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有从属对象都会被自动通知和更新”。观察者模式的面向对象实现，比如GoF书(第300-303页)中的示例代码，通常向所有潜在的主题添加一个字段，存储对该特定主题感兴趣的观察者列表。当一个主体想要向它的观察者报告状态改变时，它调用它自己的通知方法，该方法又调用列表中所有观察者的更新方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/79c76dde9f844d689e4171f3532faffe~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;考虑一个简单图形包中观察者模式的具体例子，如图1所示。在这样的系统中，观察者模式将被用来使图形元素的突变操作更新屏幕。如图所示，实现这种模式的代码分布在各个类中。&lt;/p&gt;
&lt;p&gt;所有参与者(即点和线)必须知道他们在模式中的角色，并因此拥有模式代码。从类中添加或删除角色需要更改该类。改变通知机制(例如在推和拉模型之间切换[9])需要改变所有参与的类。&lt;/p&gt;
&lt;h3 id=&#34;411-抽象的观察者模式&#34;&gt;4.1.1 抽象的观察者模式&lt;/h3&gt;
&lt;p&gt;在观察者模式的结构中，一些部分是模式的所有潜在实例化所共有的，而其他部分是每个实例化所特有的。所有实例共有的部分是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主体和观察者角色的存在(即有些类作为观察者，有些作为主体)。&lt;/li&gt;
&lt;li&gt;维护从受试者到观察者的映射。&lt;/li&gt;
&lt;li&gt;一般更新逻辑:主题更改触发观察者更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;模式的每个实例化的特定部分是:&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;哪些课可以是主题，哪些可以是观察者。&lt;/li&gt;
&lt;li&gt;引发观察者更新的一组感兴趣的主题变化&lt;/li&gt;
&lt;li&gt;当更新逻辑需要时，更新每种观察者的具体方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/e973ed1a3bdd48dd86f594112908369f~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们开发了AspectJ代码，它反映了可重用部分和实例特定部分的分离。抽象方面封装了可概括的部分(1-3)，而模式的每个实例的方面的一个具体扩展填充了特定的部分(4-6)。图2显示了可重用的ObserverProtocol方面。&lt;/p&gt;
&lt;h4 id=&#34;4111-主体和观察者的角色&#34;&gt;4.1.1.1 主体和观察者的角色&lt;/h4&gt;
&lt;p&gt;角色被实现为名为主题和观察者的受保护的内部接口(图2，第3-4行)。它们的主要目的是允许在模式实现的上下文中正确地输入主题和观察者，比如在像addObserver这样的方法中。ObserverProtocol方面的具体扩展将角色分配给特定的类(见下文)。&lt;/p&gt;
&lt;p&gt;这些接口是受保护的，因为它们将只由ObserverProtocol及其具体扩展使用。方面和扩展之外的任何代码都不需要根据这些角色来处理对象。&lt;/p&gt;
&lt;p&gt;这些接口是空的，因为模式没有定义主题或观察者角色的方法。通常在主体和观察者上定义的方法是在方面本身上定义的(见下文)。&lt;/p&gt;
&lt;p&gt;对于可抽象的模式，我们必须决定将角色接口放在哪里。两个位置是可能的:要么作为抽象方面内部的私有接口，要么作为单独的公共接口。我们是根据角色接口是否引入了客户端访问的功能来做出这个决定的，即向客户端公开功能(如策略、迭代器等)或者不公开(如观察者的情况)。如果角色没有客户端可访问的功能，它将只在模式方面被引用。因为这个原因，我们把它放在抽象方面。在另一种情况下，我们将接口移动到一个单独的文件中，以便于引用。&lt;/p&gt;
&lt;h4 id=&#34;4112-主体-观察者映射&#34;&gt;4.1.1.2 主体-观察者映射&lt;/h4&gt;
&lt;p&gt;AspectJ代码中映射的实现被本地化为ObserverProtocol方面。它是通过使用链表的弱散列映射来存储每个主题的观察者来实现的(第6行)。由于每个模式实例都由ObserverProtocol的一个具体子方面表示，因此每个实例都有自己的映射。&lt;/p&gt;
&lt;p&gt;对主题-观察者映射的改变可以通过具体子方面继承的公共的添加观察者和移除观察者方法(第21-26行)来实现。为了让屏幕对象成为点对象的观察者，客户在适当的子方面调用这些方法(例如颜色观察者):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ColorObserving.aspectOf().addObserver(P, S); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私有的getObservers方法只在内部使用。它按需创建适当的二级数据结构(链表)(第8-19行)。请注意，在这个实现中，主题-观察者映射数据结构集中在每个具体的扩展中。对抽象模式方面进行子类化的所有具体方面都将自动拥有一个单独的字段副本。这遵循[9]中给出的结构。这在某些情况下会造成瓶颈。通过用一种使用更分散的数据结构的方法覆盖getObservers，可以在每个模式实例的基础上修复这些问题。&lt;/p&gt;
&lt;p&gt;一般来说，只要模式解决方案需要参与者之间的映射(即责任链中处理程序的后继字段)，并且模式实现是可抽象的，我们就可以在参与者上定义一个字段，或者将映射保留在抽象方面的中心数据结构中(如本例所示)。无论选择哪种方法，对数据结构的访问点都是特定于实例的方面，这样涉及相同参与者的模式的不同实例都是可能的，并且不会混淆。&lt;/p&gt;
&lt;h4 id=&#34;4113-更新逻辑&#34;&gt;4.1.1.3 更新逻辑&lt;/h4&gt;
&lt;p&gt;在可重用方面，更新逻辑实现了一个一般概念，即主题可以以需要更新所有观察者的方式进行更改。这个实现并没有精确地定义什么构成了一个改变，或者观察者应该如何被更新。一般更新逻辑由三部分组成:&lt;/p&gt;
&lt;p&gt;感兴趣的变化描述了概念操作，即程序执行中的一组点，在这些点上，主体应该更新其观察者(以通知他们其状态的变化)。在AspectJ中，这类点的集合用切入点构造来标识。在可重用方面，我们只知道有感兴趣的修改，但我们不知道它们是什么。因此，我们定义了一个名为subjectChange的抽象切入点，它将被实例特定的子方面具体化(第28-29行)。&lt;/p&gt;
&lt;p&gt;在可重用部分，我们只知道观察者必须在模式的上下文中更新，但是不能预测如何最好地实现。我们定义了一个抽象的更新方法updateObserver，它将为每个模式实例具体化(第31-32行)。这样，观察者模式的每个实例都可以选择自己的更新机制。&lt;/p&gt;
&lt;p&gt;最后，可重用方面根据上面提到的可推广的实现部分来实现更新逻辑。这个逻辑包含在后一条建议中(第34-39行)。这个建议是这样的:每当执行到达一个与主题匹配的连接点时，改变切入点，然后更新适当主题的所有观察者。&lt;/p&gt;
&lt;h3 id=&#34;412-特定于模式实例的具体方面&#34;&gt;4.1.2 特定于模式实例的具体方面&lt;/h3&gt;
&lt;p&gt;ObserverProtocol的每个具体子方面定义了一种特定的观察关系，换句话说就是一个模式实例。在这种关系中，可以有任意数量的主体，每个主体有任意数量的观察者。子方面定义了三件事:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扮演受试者和观察者角色的分类。这是通过使用declare parents构造来完成的，该构造将超类或超接口添加到类中，以分配抽象方面中定义的角色。&lt;/li&gt;
&lt;li&gt;需要更新观察者的关于该主题的概念性操作。这是通过具体化subjectChange切入点来实现的。&lt;/li&gt;
&lt;li&gt;如何更新观察者？这是通过具体化updateObserver来实现的。更新的推或拉模式之间的选择不再是必要的，因为此时我们可以访问主题和观察者，并且可以定制更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;declare parents构造是AspectJ开放类机制的一部分，它允许方面修改现有的类而不改变它们的代码。这种开放的类机制可以将字段、方法或者——在这种情况下——接口附加到现有的类上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/913640c699a8455988c17999d6cd7f25~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图3显示了观察者模式的两个不同实例，包括点、线和屏幕类。在这两种情况下，点和线扮演主体的角色，屏幕扮演观察者的角色。第一个观察颜色变化，第二个观察坐标变化。&lt;/p&gt;
&lt;p&gt;请注意，第13行和第31行中的类型转换预计会随着AspectJ对泛型的计划支持而消失。这样就有可能创建包含角色分配并且类型安全的参数化子方面。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/c5396bacab2a489f851b5925364d7ec6~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;特定的类可以在同一个模式实例或不同的模式实例中扮演一个或两个主体和观察者的角色。图4显示了第三个模式实例，其中屏幕同时充当主体和观察者。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/a123.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在AspectJ版本中，与观察者和主题之间的关系相关的所有代码都被移动到一个方面中，这改变了模块之间的依赖关系。图5显示了这种情况的结构。&lt;/p&gt;
&lt;h3 id=&#34;413-此实现的属性&#34;&gt;4.1.3 此实现的属性&lt;/h3&gt;
&lt;p&gt;观察者模式的这种实现具有以下密切相关的模块化属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部性——实现观察者模式的所有代码都在抽象和具体的观察者方面，没有一个在参与者类中。参与者类完全不受模式上下文的约束，因此参与者之间没有耦合。每个观察者模式实例的潜在变化被限制在一个地方。&lt;/li&gt;
&lt;li&gt;可重用性——核心模式代码是抽象的和可重用的。ObserverProtocol的实现概括了整个模式行为。抽象方面可以在多个观察者模式实例中重用和共享。对于每个模式实例，我们只需要定义一个具体的方面。&lt;/li&gt;
&lt;li&gt;合成透明性——因为模式参与者的实现与模式无关，如果一个主体或观察者参与多个观察关系，他们的代码不会变得更复杂，模式实例也不会混淆。该模式的每个实例都可以独立推理。&lt;/li&gt;
&lt;li&gt;(不)可插入性——因为主体和观察者不需要知道他们在任何模式实例中的角色，所以可以在系统中使用模式和不使用模式之间切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-其他模式&#34;&gt;4.2 其他模式&lt;/h2&gt;
&lt;p&gt;在下文中，我们将描述剩余的22种GoF模式，以及AspectJ实现与纯Java版本的不同之处。模式按共同特征分组，无论是模式结构还是它们的AspectJ实现。&lt;/p&gt;
&lt;h3 id=&#34;421-复合-命令-中介-责任链角色仅用于模式方面&#34;&gt;4.2.1 复合、命令、中介、责任链：角色仅用于模式方面&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/6777d81cba204229b0863e0bd56dbdd7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;类似于观察者模式，这些模式引入了&lt;strong&gt;不需要客户端可访问接口的角色&lt;/strong&gt;，并且只在模式中使用。在AspectJ中，这样的角色是用空的(受保护的)接口实现的。它们引入的类型在模式协议中使用。每个模式的一个抽象方面定义了角色，并在可能的情况下附加了默认实现(参见图6的部分抽象组合方面)。&lt;/p&gt;
&lt;p&gt;对于涉及特定概念操作的模式，抽象模式方面引入了一个抽象切入点(为模式的每个实例具体化)，它捕获应该触发重要事件的连接点(例如命令模式中命令的执行)。就像在观察者的例子中一样，建议(在之后、之前或周围)负责调用适当的方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/f8a70c3386784d638547cc4ba22ba0ff~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在复合情况下，为了允许遍历模式固有的树结构，我们定义了让访问者遍历和/或改变结构的工具。这些来访者是在具体方面定义的。有关如何从组合结构中收集统计数据的示例，请参见图7。在这个例子中，我们展示了一个为文件系统建模的复合模式的实例。目录是复合的，文件是叶。该示例显示了如何计算文件系统所需的磁盘空间，假设文件对象具有大小字段。同样，客户端使用方面的公共方法来访问新功能。参与者的适当方法是私下介绍的，只能通过方面看到。&lt;/p&gt;
&lt;h3 id=&#34;422-单例模式-原型模式-备忘录模式-迭代器模式-享元模式作为对象工厂的方面&#34;&gt;4.2.2 单例模式、原型模式、备忘录模式、迭代器模式、享元模式：作为对象工厂的方面&lt;/h3&gt;
&lt;p&gt;这些模式管理对特定对象实例的访问。它们都向客户提供工厂方法，并共享按需创建策略。模式在AspectJ中是抽象的(可重用的)，在Aspect中有工厂代码。&lt;/p&gt;
&lt;p&gt;在AspectJ实现中，工厂方法要么是抽象Aspect的参数化方法，要么附加到参与者的方法中。如果使用前一种方法，模式的多个实例透明地组成，即使所有的工厂方法都有相同的名称。&lt;strong&gt;单例&lt;/strong&gt;的情况很特殊，因为我们可以使用“环绕”建议将原始构造函数转换为工厂方法，并在所有构造函数调用中返回唯一的对象。&lt;/p&gt;
&lt;p&gt;参数化的工厂方法也可以根据诺德伯格的工厂示例[18]来实现：工厂方法为空(返回null或默认对象)。其他返回值由该方法的Advice提供。如果参数合适，Advice创建一个新的匹配对象；否则，它将继续正常执行。这使得我们可以在不改变代码的情况下扩展工厂(就新产品而言)。参与者不再需要有模式代码；原始对象和它的表示或访问器(纪念品，迭代器)之间的紧密耦合将从参与者中移除。&lt;/p&gt;
&lt;h3 id=&#34;423-适配器-装饰器-策略-访问者-代理语言结构&#34;&gt;4.2.3 适配器、装饰器、策略、访问者、代理：语言结构&lt;/h3&gt;
&lt;p&gt;使用AspectJ，一些模式的实现完全消失了，因为AspectJ语言构造直接实现了它们。这在不同程度上适用于这些模式。&lt;/p&gt;
&lt;p&gt;适配器和访问者模式可以通过扩展适配器的接口来实现(通过AspectJ的开放类机制)。装饰器、策略和代理有基于附加建议的替代实现(在[18]中为装饰器提到)。&lt;/p&gt;
&lt;p&gt;虽然更简单、更模块化，但这些方法有其固有的局限性。Decorator基于建议的实现失去了它的动态操作属性(Decorator的动态重新排序)，因此不太灵活。当我们想用另一个具有相同名称和参数但返回类型不同的方法替换现有方法时，适配器的接口扩展不能以这种方式实现。&lt;/p&gt;
&lt;p&gt;使用上述方法，保护或委托代理可以实现为可重用的，但是代理模式的一些应用程序要求代理和主体是两个不同的对象(例如远程代理和虚拟代理)。在这些情况下，Java和AspectJ实现是相同的。&lt;/p&gt;
&lt;h3 id=&#34;424-抽象工厂模式工厂方法模式模板模式建造者模式桥接模式多重继承&#34;&gt;4.2.4 抽象工厂模式，工厂方法模式，模板模式，建造者模式，桥接模式：多重继承&lt;/h3&gt;
&lt;p&gt;这些模式在结构上是相似的：继承用于区分不同但相关的实现。因为这已经在面向对象中很好地实现了，所以这些模式不能被给予更多可重用的实现。然而，使用AspectJ，可以用接口替换GoF解决方案中提到的抽象类，而不会失去将(默认)实现附加到它们的方法的能力。对于Java，如果我们想为模式代码中的方法定义一个默认实现，我们就不能使用接口。在这方面，AspectJ的开放类机制有效地提供了一种有限形式的多重继承。&lt;/p&gt;
&lt;p&gt;除此之外，建造者模式和桥接模式还有以下额外的实现注意事项。&lt;br&gt;
对于建造者模式，一个Aspect可以拦截对创建方法的调用，并使用Advice用替代实现来替换它们(参见上面的策略)。&lt;br&gt;
对于桥接模式，抽象和实现者的解耦可以通过使用诺德伯格建议的多态Advice来实现[24]。虽然这种方法减少了参与者之间的耦合，但是当涉及到动态改变实现者时，它就不那么灵活了。&lt;/p&gt;
&lt;h3 id=&#34;426-外观模式没有从aspectj中获益&#34;&gt;4.2.6 外观模式：没有从AspectJ中获益&lt;/h3&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;p&gt;对于这种模式，AspectJ方法在结构上与Java实现没有什么不同。Façade为子系统的一组接口提供了统一的接口，使子系统更易于使用。这个例子主要需要名字空间管理和良好的编码风格。&lt;/p&gt;
&lt;h1 id=&#34;五-分析&#34;&gt;五、分析&lt;/h1&gt;
&lt;p&gt;在这一节中，我们分析了之前观察到的用AspectJ实现模式的好处。分析分为三个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在许多模式重新实现中观察到的一般改进。&lt;/li&gt;
&lt;li&gt;与特定模式相关的具体改进。&lt;/li&gt;
&lt;li&gt;模式中横切结构的起源，以及观察到的改进与模式中横切结构的存在相关的演示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;51-总体改进&#34;&gt;5.1 总体改进&lt;/h2&gt;
&lt;p&gt;对于许多模式来说，AspectJ实现体现了几个密切相关的模块化好处:局部性、可重用性、依赖性反转、透明的可组合性和(不)可插入性。试图说哪一个是主要的是困难的，相反，我们简单地描述它们并讨论它们的一些相互关系。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/68d760a110a5407aa036ad77a1225b0d~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;23个GoF模式中的17个的AspectJ实现是本地化的。对于其中的12个，局部性使得实现的核心部分能够被抽象成可重用的代码。在17个中的14个中，我们观察到了模式实例的透明可组合性，因此多个模式可以有共享的参与者(见表1)。&lt;/p&gt;
&lt;p&gt;AspectJ实现的改进主要是由于颠倒了依赖性，因此模式代码依赖于参与者，而不是相反。这与局部性直接相关——模式和参与者之间的所有依赖都被本地化在模式代码中。&lt;/p&gt;
&lt;h2 id=&#34;52-具体改进&#34;&gt;5.2 具体改进&lt;/h2&gt;
&lt;h3 id=&#34;521-单例模式&#34;&gt;5.2.1 单例模式&lt;/h3&gt;
&lt;p&gt;模式实现的AspectJ版本打开了两个在Java中不可能的设计选项：&lt;br&gt;
第一，Singleton是继承属性，还是说，我们存在错误的继承？&lt;br&gt;
第二，我们是希望一个专门的工厂方法来提供单例模式的实例，还是希望构造函数在被调用时返回它？&lt;/p&gt;
&lt;p&gt;我们决定实现继承的Singleton属性，但是如果需要的话，我们提供了从Singleton保护中排除特定子类的工具。&lt;/p&gt;
&lt;p&gt;第二，我们认为使用构造函数而不是专用的工厂方法是有益的。如果需要，工厂可以直接在类中实现，或者作为一个透明组合的Aspect来实现。&lt;/p&gt;
&lt;h3 id=&#34;522-多重继承与java&#34;&gt;5.2.2 多重继承与Java&lt;/h3&gt;
&lt;p&gt;正如最初提出的，一些GoF模式在其实现中利用了多重继承，例如适配器模式的类版本。对于许多模式，参与者在模式中扮演的角色在Java中被实现为抽象类。参与者类从这些抽象类继承接口和默认实现。但是如果参与者类具有模式上下文之外的功能(比如作为观察者模式中的主体或观察者的图形用户界面小部件)，它们通常已经是继承层次的一部分。由于Java缺乏多重继承，在这些情况下的实现可能有些笨拙：在Java中，如果参与者必须继承其角色和其他功能，那么其中一个超类型必须实现为接口。不幸的是，Java中的接口不能包含代码，因此无法附加方法的默认实现。&lt;/p&gt;
&lt;p&gt;AspectJ中的开放类机制为我们提供了一种更灵活的方式来实现这些模式，因为它允许将接口和实现(代码)都附加到现有的类上。&lt;/p&gt;
&lt;h3 id=&#34;523-打破循环依赖&#34;&gt;5.2.3 打破循环依赖&lt;/h3&gt;
&lt;p&gt;一些设计模式管理对象集合之间复杂的交互。在面向对象的实现中，这些类紧密耦合并且相互依赖。引入循环依赖的设计模式的一个例子是中介器，它是在用户界面编程中经常使用的观察者模式的变体。在这里，对同事(如小部件)的更改会触发中介对象(如控制器)的更新。另一方面，作为对此的反应，调解人可能会更新一些或所有同事。&lt;/p&gt;
&lt;h2 id=&#34;53-设计模式的横切结构&#34;&gt;5.3 设计模式的横切结构&lt;/h2&gt;
&lt;p&gt;本节介绍了模式中横切结构的起源，并展示了在模式实现中使用AspectJ的观察到的好处与模式中的横切相关。角色定义了模式中参与者的行为和功能。这种角色的例子有:复合模式的组件、叶和复合，观察者模式的主题和观察者，或者抽象工厂模式的抽象和具体工厂。模式结构中的横切是由不同类型的角色及其与参与者类的交互引起的。&lt;/p&gt;
&lt;p&gt;在一些模式中，角色是定义的：参与者在模式之外没有功能。也就是角色完整的定义了参与者。例如，扮演门面角色的对象为子系统提供统一的接口，并且(通常)没有自己的其他行为。定义角色通常包括客户端可访问的界面。&lt;/p&gt;
&lt;p&gt;在其他模式中，角色是重叠的:它们被分配给在模式之外有功能和责任的类。例如，在观察者模式中，扮演主体和观察者的类不仅仅满足模式要求。例如，在图形用户界面环境中，主题可以是小部件。换句话说，在观察者模式上下文之外有行为的类。因此，主体角色只是现有类的扩充。叠加角色通常没有客户端可访问的界面。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，定义角色往往是通过子类化一个抽象超类来实现不同但相关的行为；叠加的角色通常是定义行为和责任的接口。&lt;/p&gt;
&lt;p&gt;Java中有一个不一致的地方，叠加角色上的方法可能只供模式使用，但是它们必须在接口上定义，这要求它们是公共的。&lt;/p&gt;
&lt;h3 id=&#34;531-角色和横切&#34;&gt;5.3.1 角色和横切&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/4e2f42fcd41c4494a60e89c4af6a5722~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;叠加的角色导致模式和参与者之间三种不同的横切:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;角色可以横切参与者类。即对于1个角色，可以有n个类，1个类可以有n个角色；即如图5所示的主题角色。&lt;/li&gt;
&lt;li&gt;感兴趣的概念操作可以横切一个或多个类中的方法。即一个概念操作可以有n个方法，n个概念操作中可以有1个方法；即触发观察者更新的主题变更操作，如图5所示。&lt;/li&gt;
&lt;li&gt;来自多个模式的角色可以在类和/或方法方面相互横切。也就是说，模式A认为是一个角色的一部分的两个类，模式B可能认为是一个以上的角色，反之亦然。概念操作也是如此；即主体角色和主体变更操作，如图9所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表1显示了模式引入的角色类型和AspectJ实现的观察到的好处之间的关系。设计模式可以分为三类:只有定义角色的，有两种角色的和只有叠加角色的。该表显示，虽然第一组中模式的AspectJ实现没有显示出任何改进，但最后一组中的模式显示出我们确定的所有模块化优势类别的改进。对于具有两种角色的模式，结果取决于特定的模式。&lt;/p&gt;
&lt;p&gt;鉴于AspectJ旨在模块化横切结构，这一结果并不奇怪。主要涉及横切结构的模式在AspectJ实现中被很好地模块化了。&lt;br&gt;
（请注意，AspectJ没有移除模式的横切，而是提供了模块化该结构的机制。）&lt;/p&gt;
&lt;h3 id=&#34;532-预测模型&#34;&gt;5.3.2 预测模型？&lt;/h3&gt;
&lt;p&gt;模式角色之间的紧密联系，模式引入的横切，以及观察到的AspectJ实现的好处，暗示了给定设计模式的AspectJ实现的好处的预测模型。&lt;/p&gt;
&lt;p&gt;通过定义角色，每个抽象单元(类)代表一个单一的概念，即一个类的功能对应于它在模式中的角色。继承用于区分相关但不同的实现。在这种情况下，透明性和可插入性并不是有用的属性，因为每个参与者本质上都只在一个特定的模式实例中有用。&lt;/p&gt;
&lt;p&gt;有叠加行为，情况就不一样了。参与者在模式环境之外有自己的责任和理由。如果我们强迫一个这样的类进入模式上下文，我们至少有两个由一个抽象模块(类)表示的关注点:原始功能和模式特定的行为。由于模块化受到损害，由此产生的混乱和代码重复经常会导致问题。对于这些模式和它们的实现，模式功能和参与者的原始功能的干净模块化是合乎需要的。在AspectJ实现中，通常可以模块化抽象的模式行为，并让每个模式实例有一个方面来分配角色、概念操作和填充实例特定的代码。因为参与者在模式上下文之外确实有一个意义，所以他们并不局限于一个角色或者一个模式实例。&lt;/p&gt;
&lt;p&gt;这个模型对于那些只有定义或只有叠加角色的GoF模式来说似乎是准确的。对其他人来说，预期的好处似乎取决于实现特定角色的参与者的数量。映射到多个参与者的叠加角色(例如，访问者中的元素、组合或组合中的叶)表明了模块化的潜力，即使模式也包括定义角色。&lt;/p&gt;
&lt;h1 id=&#34;七-总结&#34;&gt;七、总结&lt;/h1&gt;
&lt;p&gt;在模式实现中使用AspectJ的改进与模式中&lt;strong&gt;横切结构&lt;/strong&gt;的存在直接相关。这种横切结构出现在将行为叠加到参与者身上的模式中。在这种模式中，角色可以横切参与者类，概念操作可以横切方法(和构造函数)。就共享参与者而言，多个这样的模式也可以相互横切。&lt;/p&gt;
&lt;p&gt;这些改进表现为一组与模块化相关的属性。模式实现更加本地化，并且在很多情况下是可重用的。因为AspectJ解决方案更好地将代码中的依赖与解决方案结构中的依赖联系起来，所以模式的AspectJ实现有时也是可组合的。&lt;/p&gt;
&lt;p&gt;本地化模式实现提供了内在的代码可理解性优势——模式代码的单个命名单元的存在使得模式的存在和结构更加明确。此外，它还为改进代码文档提供了一个锚。&lt;/p&gt;
&lt;p&gt;我们的结果为进一步的实验提出了几个方向，包括将AspectJ应用于更多的模式，试图系统地使用我们的可重用模式实现，以及试图在已知受设计模式思维影响的遗留代码库中使用AspectJ。未来工作的另一个途径是将这些结果与其他定向技术的使用进行比较。&lt;/p&gt;
">论文转述 Design Pattern Implementation in Java and AspectJ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-09-06-SpringBoot jar包运行报错/"" data-c="
          &lt;p&gt;报错信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication
        at com.MainApplication.main(MainApplication.java:10)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 1 more
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;生成jar&#34;&gt;生成jar&lt;/h1&gt;
&lt;p&gt;首先，如果使用的是maven，那么直接执行package指令就可以生成jar包，如下图：&lt;br&gt;
&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/149a1061ed2c4c5e922605fd60aae2a2~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是，当我们使用&lt;code&gt;java -jar xx.jar&lt;/code&gt;运行时，会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication
        at com.MainApplication.main(MainApplication.java:10)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 1 more
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大概的意思就是缺少依赖。&lt;/p&gt;
&lt;h1 id=&#34;解决jar包依赖问题&#34;&gt;解决jar包依赖问题&lt;/h1&gt;
&lt;p&gt;通过修改pom文件，解决依赖问题。&lt;/p&gt;
&lt;p&gt;在pom文件中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重新打包(package)即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;，随着IDEA的升级，现在开始出现了一个新的标签&lt;code&gt;pluginManagement&lt;/code&gt;，在这个标签里，也同样有&lt;code&gt;plugins&lt;/code&gt;标签，但千万不要把&lt;code&gt;pluginManagement&lt;/code&gt;中的&lt;code&gt;plugins&lt;/code&gt;当成上文中出现的&lt;code&gt;plugins&lt;/code&gt;标签，即下面的写法是错误的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
	&amp;lt;pluginManagement&amp;gt;
	    &amp;lt;plugins&amp;gt;
	        &amp;lt;plugin&amp;gt;
	            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
	        &amp;lt;/plugin&amp;gt;
	    &amp;lt;/plugins&amp;gt;
	&amp;lt;/pluginManagement&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot jar包运行报错</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-07-28-Go cannot find package google.golang.orgprotobuf 解决办法/"" data-c="
          &lt;p&gt;使用Go语言开发时，出现访问Google有些包无法下载问题，解决方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Go的root目录，src下创建文件夹“src\google.golang.org”&lt;/li&gt;
&lt;li&gt;在google.golang.org文件夹中，执行如下代码&lt;code&gt;git clone https://github.com/protocolbuffers/protobuf-go.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将生成的文件夹重命名为protobuf，如下图&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/17394d7e05d34455&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Go cannot find package google.golang.orgprotobuf 解决办法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/2020-07-28-Go语言的反射/"" data-c="
          &lt;p&gt;反射是语言里面非常重要的一个特性，我们经常会看见这个词，但是对于反射没有一个很好的理解，主要是因为对于反射的使用场景不太熟悉。&lt;/p&gt;
&lt;h1 id=&#34;一-理解变量的内在机制&#34;&gt;一、理解变量的内在机制&lt;/h1&gt;
&lt;p&gt;1.类型信息，元信息，是预先定义好的，静态的。&lt;/p&gt;
&lt;p&gt;2.值信息，程序进行过程中，动态变化的。&lt;/p&gt;
&lt;h1 id=&#34;二-反射和空接口&#34;&gt;二、反射和空接口&lt;/h1&gt;
&lt;p&gt;1.空接口相当于一个容器，能接受任何东西。&lt;/p&gt;
&lt;p&gt;2.那怎么判断空接口变量存储的是什么类型呢？之前有使用过类型断言，这只是一个比较基础的方法&lt;/p&gt;
&lt;p&gt;3.如果想获取存储变量的类型信息和值信息就要使用反射机制，所以反射是什么？ 反射就是动态的获取变量类型信息和值信息的机制。&lt;/p&gt;
&lt;h1 id=&#34;三-怎么利用反射分析空接口里面的信息呢&#34;&gt;三、怎么利用反射分析空接口里面的信息呢？&lt;/h1&gt;
&lt;p&gt;①首先利用的是GO语言里面的Reflect包&lt;/p&gt;
&lt;p&gt;②利用包里的TypeOf方法可以获取变量的类型信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflect_typeof(a interface{}) {
    t := reflect.TypeOf(a)
    fmt.Printf(&amp;quot;type of a is:%v\n&amp;quot;, t)
 
    k := t.Kind()
    switch k {
    case reflect.Int64:
        fmt.Printf(&amp;quot;a is int64\n&amp;quot;)
    case reflect.String:
        fmt.Printf(&amp;quot;a is string\n&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用Kind() 可以获取t的类型，如代码所示，这里可以判断a是Int64还是string, 像下面一样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x int64 = 3
    reflect_example(x)
 
    var y string = &amp;quot;hello&amp;quot;
    reflect_example(y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type of a is:int64
a is int64
type of a is:string
a is string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③利用包里的ValueOf方法可以获取变量的值信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflect_value(a interface{}) {
    v := reflect.ValueOf(a)
    k := v.Kind()
    switch k {
    case reflect.Int64:
        fmt.Printf(&amp;quot;a is Int64, store value is:%d\n&amp;quot;, v.Int())
    case reflect.String:
        fmt.Printf(&amp;quot;a is String, store value is:%s\n&amp;quot;, v.String())
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用ValueOf方法可以得到变量的值信息,ValueOf返回的是一个Value结构体类型，有趣的是 可以使用 v.Type() 获取该变量的类型，和上面reflect.TypeOf() 获取的结果一样。&lt;/p&gt;
&lt;p&gt;此外，因为值信息是动态的，所以我们不仅仅可以获取这个变量的类型，还能取得这个变量里面存储的值，利用 v.Int() 、 v.String() 等等就能取得值。如上面的main，调用此函数返回的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a is Int64, store value is:3
a is String, store value is:hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里存在一个问题，如果传进去一个类型，使用了错误的解析，那么将会在运行的时候报错， 例如将  一个string类型强行的v.Int()。&lt;/p&gt;
&lt;p&gt;既然值类型是动态的，能取到保存的值，同样可以设置值。在反射里面有很多set的方法，例如SetFloat、SetInt()、SetString()等可以帮助我们设置值。&lt;/p&gt;
&lt;p&gt;① 下面的例子，我想把 x设置为 6.28，但是会报错！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(x)
    v.SetFloat(6.28)
    fmt.Printf(&amp;quot;After Set Value is %f&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;panic: reflect: reflect.Value.SetFloat using unaddressable value
......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果上说明是不可设置的，为什么呢？ 因为我们的x是一个值类型，而值类型的传递是拷贝了一个副本，当 v := reflect.ValueOf(x) 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 v = reflect.ValueOf(&amp;amp;x)。修改程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    v.SetFloat(6.28)
    fmt.Printf(&amp;quot;After Set Value is %f&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：依然报错！为什么传了地址还报错？因为&amp;amp;x是地址了，所以它的类型就变了，可以通过v.Type()，看下改变成了什么：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    fmt.Printf(&amp;quot;type of v is %v&amp;quot;, v.Type())   //打印的结果是：type of v is *float64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由程序可以知道，这个返回的是一个指针类型的。所以上面SetFloat才会失败，那怎么做？&lt;/p&gt;
&lt;p&gt;我们正常的赋值，如果是地址的话，例如下面：一般我们都会对*y进行赋值, *的意思就是往这个地址里面赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var y *float64 = new(float64)
*y = 10.12
fmt.Printf(&amp;quot;y = %v&amp;quot;, *y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的，我们在反射里面也可以取地址，需要通过 Elem() 方法进行取地址。再次修改程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x float64 = 3.14
    v := reflect.ValueOf(&amp;amp;x)
    fmt.Printf(&amp;quot;type of v is %v\n&amp;quot;, v.Type())
    v.Elem().SetFloat(6.28)
    fmt.Printf(&amp;quot;After set x is %v&amp;quot;, x)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type of v is *float64
After set x is 6.28
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-利用反射获取结构体里面的方法和调用&#34;&gt;四、利用反射获取结构体里面的方法和调用。&lt;/h1&gt;
&lt;h2 id=&#34;1获取结构体的字段&#34;&gt;1.获取结构体的字段&lt;/h2&gt;
&lt;p&gt;我们可以通过上面的方法判断一个变量是不是结构体。&lt;/p&gt;
&lt;p&gt;可以通过 NumField() 获取所有结构体字段的数目、进而遍历，通过Field()方法获取字段的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
    Name  string
    Sex   int
    Age   int
    Score float32
}
 
func main() {
    //创建一个结构体变量
    var s Student = Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(s)
    t := v.Type()
    kind := t.Kind()
     
    //分析s变量的类型，如果是结构体类型，那么遍历所有的字段
    switch kind {
    case reflect.Int64:
        fmt.Printf(&amp;quot;s is int64\n&amp;quot;)
    case reflect.Float32:
        fmt.Printf(&amp;quot;s is int64\n&amp;quot;)
    case reflect.Struct:
        fmt.Printf(&amp;quot;s is struct\n&amp;quot;)
        fmt.Printf(&amp;quot;field num of s is %d\n&amp;quot;, v.NumField())
        //NumFiled()获取字段数，v.Field(i)可以取得下标位置的字段信息，返回的是一个Value类型的值
        for i := 0; i &amp;lt; v.NumField(); i++ {
            field := v.Field(i)
            //打印字段的名称、类型以及值
            fmt.Printf(&amp;quot;name:%s type:%v value:%v\n&amp;quot;,
                t.Field(i).Name, field.Type().Kind(), field.Interface())
        }
    default:
        fmt.Printf(&amp;quot;default\n&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s is struct
field num of s is 4
name:Name type:string value:BigOrange
name:Sex type:int value:1
name:Age type:int value:10
name:Score type:float32 value:80.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要说明几个问题：&lt;/p&gt;
&lt;p&gt;①打印字段名称的时候，使用的是t.Field(i).Name ，Name是静态的，所以属于类型的信息&lt;/p&gt;
&lt;p&gt;②打印值的时候，这里将field.Interface()实际上相当于ValueOf的反操作（&lt;a href=&#34;https://www.cnblogs.com/baicaiyoudu/archive/2016/09/25/5905766.html&#34;&gt;可以参考这篇文章&lt;/a&gt;），所以才能把值打印出来&lt;/p&gt;
&lt;p&gt;③此外如果Student中的Name字段变为name（私有），那么则会报错，不能反射出私有变量 错误信息 &lt;code&gt;panic: reflect.Value.Interface: cannot return value obtained from unexported field or method&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2对结构体内的字段进行赋值操作&#34;&gt;2.对结构体内的字段进行赋值操作&lt;/h2&gt;
&lt;p&gt;参考下面的代码，对上面的Student进行赋值操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    fmt.Printf(&amp;quot;Name:%v, Sex:%v,Age:%v,Score:%v \n&amp;quot;, s.Name, s.Sex, s.Age, s.Score)
    v := reflect.ValueOf(&amp;amp;s)  //这里传的是地址！！！
 
    v.Elem().Field(0).SetString(&amp;quot;ChangeName&amp;quot;)
    v.Elem().FieldByName(&amp;quot;Score&amp;quot;).SetFloat(99.9)
 
    fmt.Printf(&amp;quot;Name:%v, Sex:%v,Age:%v,Score:%v \n&amp;quot;, s.Name, s.Sex, s.Age, s.Score)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name:BigOrange, Sex:1,Age:10,Score:80.1
Name:ChangeName, Sex:1,Age:10,Score:99.9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3获取结构体里面的方法&#34;&gt;3.获取结构体里面的方法&lt;/h2&gt;
&lt;p&gt;可以通过NumMethod()获得接头体里面的方法数量，然后遍历通过Method()获取方法的具体信息。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//新增-设置名称方法
func (s *Student) SetName(name string) {
     fmt.Printf(&amp;quot;有参数方法 通过反射进行调用:%v\n&amp;quot;, s)
     s.Name = name
}
//新增-打印信息方法
func (s *Student) PrintStudent() {
    fmt.Printf(&amp;quot;无参数方法 通过反射进行调用:%v\n&amp;quot;, s)
}
 
func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(&amp;amp;s)
    //取得Type信息
    t := v.Type()
     
    fmt.Printf(&amp;quot;struct student have %d methods\n&amp;quot;, t.NumMethod())
 
    for i := 0; i &amp;lt; t.NumMethod(); i++ {
        method := t.Method(i)
        fmt.Printf(&amp;quot;struct %d method, name:%s type:%v\n&amp;quot;, i, method.Name, method.Type)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct student have 2 methods
struct 0 method, name:PrintStudent type:func(*main.Student)
struct 1 method, name:SetName type:func(*main.Student, string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果中看到我们可以获取方法的名称以及签名信息，并且这个方法的输出顺序是按照字母排列的。&lt;/p&gt;
&lt;p&gt;并且输出结果可以看到一个有趣的现象：结构体的方法其实也是通过函数实现的例如 func(s Student) SetName(name string) 这个方法，反射之后的结果就是 func(main.Student , string) 实际上把Student当参数了。&lt;/p&gt;
&lt;p&gt;此外还可以通过反射来调用这些方法。想要通过反射调用结构体里面的方法，首先要知道方法调用时一个动态的，所以要先通过ValueOf获取值，然后通过获取的值进行方法的调用 ，通过 value里面的Method方法 返回一个方法，然后通过Call方法调用，Call是参数是一个切片，也就是参数的列表。以下是Call方法的定义：可以看到参数是一个Value的数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/Bule-Zst/picture/raw/master/31c638c8e4c94fb8b9ddea294a80f9a5~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如下代码展示了如何调用有参数的方法和无参数的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := Student{
        Name:  &amp;quot;BigOrange&amp;quot;,
        Sex:   1,
        Age:   10,
        Score: 80.1,
    }
 
    v := reflect.ValueOf(&amp;amp;s)
 
    //通过reflect.Value获取对应的方法并调用
    m1 := v.MethodByName(&amp;quot;PrintStudent&amp;quot;)
    var args []reflect.Value
    m1.Call(args)
 
    m2 := v.MethodByName(&amp;quot;SetName&amp;quot;)
    var args2 []reflect.Value
    name := &amp;quot;stu01&amp;quot;
    nameVal := reflect.ValueOf(name)
    args2 = append(args2, nameVal)
    m2.Call(args2)
    m1.Call(args)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;BigOrange&amp;quot;, Sex:1, Age:10, Score:80.1}
有参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;BigOrange&amp;quot;, Sex:1, Age:10, Score:80.1}
无参数方法 通过反射进行调用:&amp;amp;main.Student{Name:&amp;quot;stu01&amp;quot;, Sex:1, Age:10, Score:80.1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面格式打印：&lt;/p&gt;
&lt;p&gt;%v      相应值的默认格式。            Printf(&amp;quot;%v&amp;quot;, people)   {zhangsan}，&lt;/p&gt;
&lt;p&gt;%+v     打印结构体时，会添加字段名     Printf(&amp;quot;%+v&amp;quot;, people)  {Name:zhangsan}&lt;/p&gt;
&lt;p&gt;%#v     相应值的Go语法表示            Printf(&amp;quot;#v&amp;quot;, people)   main.Human{Name:&amp;quot;zhangsan&amp;quot;}&lt;/p&gt;
&lt;h1 id=&#34;五-怎么获取结构体里tag的信息&#34;&gt;五、怎么获取结构体里tag的信息。&lt;/h1&gt;
&lt;p&gt;有时候我们在类型上面定义一些tag，例如使用json和数据库的时候。Field()方法返回的StructField结构体中保存着Tag信息，并且Tag信息可以通过一个Get(Key)的方法获取出来，如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
    Name string `json:&amp;quot;jsName&amp;quot; db:&amp;quot;dbName&amp;quot;`
}
 
func main() {
    s := Student{
        Name: &amp;quot;BigOrange&amp;quot;,
    }
    v := reflect.ValueOf(&amp;amp;s)
    t := v.Type()
    field0 := t.Elem().Field(0)
    fmt.Printf(&amp;quot;tag json=%s\n&amp;quot;, field0.Tag.Get(&amp;quot;json&amp;quot;))
    fmt.Printf(&amp;quot;tag db=%s\n&amp;quot;, field0.Tag.Get(&amp;quot;db&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tag json=jsName
tag db=dbName
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-应用场景&#34;&gt;六、应用场景&lt;/h1&gt;
&lt;p&gt;1.序列化和反序列化，比如json, protobuf等各种数据协议&lt;/p&gt;
&lt;p&gt;2.各种数据库的ORM，比如gorm，sqlx等数据库中间件&lt;/p&gt;
&lt;p&gt;3.配置文件解析相关的库，比如yaml、ini等&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;from https://www.cnblogs.com/dcz2015/p/11199060.html&lt;/p&gt;
">Go语言的反射</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://Bule-Zst.gitee.io/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>




<script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script>

</html>