<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2021-04-18T10:14:39.208Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[南京大学-软件过程改进-复习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/">
        </link>
        <updated>2021-04-16T01:53:00.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要是对 <a href="https://wym0120.github.io/2021/04/12/cmmi/">[课堂笔记] 软件过程改进 </a>这篇文章的一些个人补充</p>
<hr>
<p>[TOC]</p>
<h2 id="过程的定义">过程的定义</h2>
<ul>
<li>IEEE: Sequence of steps performed for a given purpose.
<ul>
<li>为给定目的执行的步骤顺序。</li>
</ul>
</li>
<li>PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a SP ecified end result.
<ul>
<li>人员、材料、能源、设备和程序 在工作活动中的逻辑组织，旨在产生SP（特定实践）确认的最终结果。</li>
</ul>
</li>
<li>CMMI GLOSSARY: A set of interrelated activities, which transform inputs into outputs, to achieve a given purpose (These activities can be mapped to one or more practices in CMMI process areas to allow a model to be useful for process improvement and process appraisal.)
<ul>
<li>一组相互关联的活动，这些活动将输入转化为输出，以实现给定的目的（这些活动可以映射到CMMI过程域中的一个或多个实践，以使模型可用于流程改进和流程评估。）</li>
</ul>
</li>
</ul>
<h2 id="过程和过程域的关系">过程和过程域的关系</h2>
<p>过程域中包含若干过程。</p>
<h2 id="连续式表示法与阶段式表示法">连续式表示法与阶段式表示法</h2>
<ul>
<li>连续式表示法：选择一个特定的过程域进行改进。</li>
<li>阶段式表示法：选择某一成熟度级别下的多个过程域进行改进。</li>
</ul>
<h2 id="等价阶段式定级">等价阶段式定级</h2>
<ul>
<li>CL：capability level 能力等级</li>
<li>ML：maturity level 成熟度级别</li>
</ul>
<h2 id="过程模型">过程模型</h2>
<p>过程模型是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。</p>
<p>CMMI 开发模型就是一种过程模型。</p>
<h2 id="cmmi来源于哪三个模型-研究机构">CMMI来源于哪三个模型 ，研究机构</h2>
<ul>
<li>软件工程 sw-cmm</li>
<li>系统工程 EIA/IS</li>
<li>集成化产品和过程开发 IPD-CMM</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/image-20210416144801516.png" alt="image-20210416144801516" loading="lazy"></figure>
<h2 id="已管理和已定义的区别">已管理和已定义的区别</h2>
<p>已管理：标准、过程描述与规程在过程的每个特定实例中（如在某一特定项目中）都可能有很大的不同。</p>
<p>已定义：项目的标准、过程描述与规程是从组织的标准过程集中裁剪得来，以适应特定的项目或组织级单位，因而就更为一致，除非是裁剪指南所允许的差别。</p>
<h2 id="过程域">过程域</h2>
<h3 id="工程类">工程类</h3>
<h4 id="确认与验证的区别">确认与验证的区别</h4>
<p>确认：确认产品实际的用途是否符合其预期的用途；做了正确的事。</p>
<p>验证：验证工作产品（or 产品）的功能是否符合需求；正确地做了事。</p>
<h3 id="支持类">支持类</h3>
<h4 id="度量与分析-and-过程与产品质量保证">度量与分析 and 过程与产品质量保证</h4>
<p>PPQA专注于质量，而MA则是对一切过程提供度量与分析。当对质量进行度量与分析时，个人认为MA与PPQA是等价的，因此，MA的范围更广，而PPQA则专注于质量方面。</p>
<h2 id="ppt中问题整理">PPT中问题整理</h2>
<ul>
<li>
<p>requirements traceability：需求可追溯性</p>
</li>
<li>
<p>A to B and vice versa：A符合B，反之亦然</p>
</li>
<li>
<p>Budget and funding：预算和资金</p>
</li>
<li>
<p>Staff：职员</p>
</li>
<li>
<p>Facilities：设施</p>
</li>
<li>
<p>peer review meetings：同行评审会议</p>
</li>
<li>
<p>delinquent：拖欠的</p>
</li>
<li>
<p>People are not meeting schedules.：人们没有遵守时间表。</p>
</li>
<li>
<p>likelihood：可能性</p>
</li>
<li>
<p>motion sensors：运动传感器</p>
</li>
<li>
<p>contract：合同</p>
</li>
<li>
<p>COTS were used for the keypad; sensors were secured from suppliers; and the controller consists of re-used PASS in-house software.：键盘上使用了COTS； 传感器由供应商提供保护； 控制器由重复使用的PASS内部软件组成。</p>
</li>
<li>
<p>incorporating experiences：整合经验</p>
</li>
<li>
<p>appraisal metrics：评估指标</p>
</li>
<li>
<p>align with：对齐</p>
</li>
<li>
<p>All PASS projects follow the standard process exactly as is.：所有PASS项目都完全按照标准流程进行。</p>
</li>
<li>
<p>trace：追溯</p>
</li>
<li>
<p>tailoring：裁剪</p>
</li>
<li>
<p>Spiral lifecycle：螺旋生命周期</p>
</li>
</ul>
<h2 id="简答题列表">简答题列表</h2>
<h3 id="过程域相关">过程域相关</h3>
<p>Lv4组织级过程性能(OPP)</p>
<ul>
<li>x.y.z代表着什么</li>
</ul>
<p>Lv2项目监督与控制(PMC)</p>
<ul>
<li>项目监控点选择的原则？原因</li>
<li>SG2中的相关实践约定，需要采取纠偏措施的问题来源</li>
<li>纠偏行动的先决条件</li>
</ul>
<p>Lv2项目计划(PP)</p>
<ul>
<li>PP过程域在项目中的作用域</li>
<li>计划制定的原则？</li>
<li>一般的估算方法有哪几个？区别</li>
<li>什么是承诺管理？承诺的分类</li>
<li>PP中“建立”和“维护”两个活动的解释？</li>
<li>估算目标: 不是尽可能客观描述代码行/工作量（永远不可能实现估算），而是得到一个数字<strong>数字对不对不重要，重要的是大家认可</strong></li>
</ul>
<p>Lv2需求管理(REQM)</p>
<ul>
<li>(需求跟踪的方法) 需求跟踪矩阵的使用</li>
<li>(获得需求承诺) 应该获得那些人的承诺</li>
<li>识别需求不一致性的最有效方法</li>
<li>敏捷对于需求的态度是拥抱变更，但这是不正确的，大部分开发人员还是希望能够close开发</li>
<li>Scrum对于需求的态度是不响应一个SP rint中的需求变更(目标不变)，只是记录到backlog，可能会在下一个迭代响应变更</li>
<li>理解双向可跟踪</li>
</ul>
<p>Lv4量化项目管理(QPM)</p>
<ul>
<li>OPP 和 QPM 的关联</li>
<li>QPM SP1.2 和之前过程定义的区别 （和 IPM 的区别）</li>
<li>QPM 和 OPM 的关系</li>
</ul>
<p>Lv3产品集成(PI)</p>
<ul>
<li>假设你是产品集成的负责人，拒绝那些不合格的产品组件。定义哪些验收标准</li>
</ul>
<p>Lv3验证 (VER)</p>
<ul>
<li>VAL 和 VER的关键区别</li>
</ul>
<p>Lv2度量与分析(MA)</p>
<ul>
<li>度量分析的作用体现在哪些方面？(从项目和组织两个角度分析)</li>
<li>度量的目的要支持质量的目标</li>
<li>如何满足度量的可追踪性(哪些工作产品可以满足)</li>
</ul>
<p>Lv2配置管理(CM)</p>
<ul>
<li>一个软件开发过程中会产生很多工作产品artifacts/work product，但是并不是所有产品都是值得管理的，要去掉一些不那么重要的产品，确保重要的（为了让交付有完整性的）工作产品被管理。其实就是为了减少工作量。</li>
<li>CCB: Change Control Board</li>
<li>配置管理员的主要职责</li>
<li>配置项标示的规则，什么情况下改写Vx.y.z中的x和y？什么说情况下改写z？规则是怎样的</li>
<li>配置管理系统的等级？三个概念库如何体现配置库的等级？配置库需要注意什么</li>
<li>基线的定义和特点</li>
</ul>
<p>Lv2过程与产品质量保证(PPQA)</p>
<ul>
<li>软件项目质量的分类</li>
<li>QA行使的角色</li>
<li>解释 PPQA QA SQA NC QC</li>
<li>QA 和 QC差别？</li>
<li>执行PPQA的工具方法</li>
<li>简述评审一般过程、审计一般过程</li>
<li>QA人员以及PPQA过程的质量保证如何实现</li>
<li>如何评价&quot;测试驱动开发TDD可以显著提升质量&quot;这一说法</li>
</ul>
<p>Lv3决策分析与解决(DAR)</p>
<ul>
<li>如何评价 &quot;CMMI 是官僚、重文档的&quot;这一说法</li>
</ul>
<p>Lv5原因分析与解决(CAR)</p>
<ul>
<li>CAR 在本质上做的是什么</li>
<li>CAR 一定是选坏的吗</li>
<li>CAR 实际上是依赖于 OPM 进行执行的</li>
<li>CAR 的理念是不犯错比犯了错再改正更好</li>
<li>CAR 在4级和5级的不同</li>
<li>CAR 为什么需要和 OPM 配合</li>
</ul>
<h3 id="ppt">ppt</h3>
<ul>
<li>Which of the following examples of requirements traceability are adequate?</li>
<li>PASS is planning their resources. What project resources should be included?</li>
<li>Project Management and Control</li>
<li>Risk Management</li>
<li>Supplier Agreement Management</li>
<li>Which CM SPs could have prevented the problem?</li>
<li>Which are process evaluations? Which are product evaluations?</li>
<li>Which of the following are adequate for verification procedures and criteria?</li>
<li>Which are verification and which are validation?</li>
<li>Which of the following show incorporating experiences?</li>
<li>Which PASS scenarios align with IPM?</li>
<li>Organizational Process Definition</li>
<li>Organizational Training</li>
<li>VER SG2 SG3: SG3包含SG2</li>
<li>持续集成 vs 大爆炸集成</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[南京大学-高级数据库开发技术-复习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/">
        </link>
        <updated>2021-04-15T07:35:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="b树-b树索引">B树、B+树索引</h2>
<h3 id="阶的含义">阶的含义</h3>
<ul>
<li>上限：每个节点最多有 M 个子树</li>
<li>下限：
<ul>
<li>根节点至少2个子树</li>
<li>非根节点至少有⌈M /2⌉个子树</li>
</ul>
</li>
</ul>
<h3 id="画结构">画结构</h3>
<p>B+树</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415160910412.png" alt="image-20210415160910412" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://Bule-Zst.gitee.io/post-images/image-20210418174758526.png" alt="image-20210418174758526" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://Bule-Zst.gitee.io/post-images/image-20210418175351820.png" alt="image-20210418175351820" loading="lazy"></figure>
<h3 id="b树使用场景">B+树使用场景</h3>
<p>能做的：</p>
<ul>
<li>全键值：Where x=123</li>
<li>键值范围：Where 45&lt;x&lt;123</li>
<li>键前缀查找：where x LIKE ‘J%’</li>
</ul>
<p>什么时候能用，什么时候不能用：</p>
<ul>
<li>对于一般索引，都能用，除非查询优化器发现用了索引后，会导致性能降低，则不会使用索引，例如因为索引占用空间太大，导致IO操作耗时较高。</li>
<li>对于复合索引，如果违反最左匹配原则，则不能用。例如，对(x,y)建立索引，但对y进行查询，则不能用。</li>
<li>对于一个有索引的列作出函数查询，Select * from t where f(indexed_col) = value</li>
<li>隐形函数查询，比如查询SQL中存在隐式类型转换比如no为VARCHAR类型，但是查询时把该字段当做INT类型查询：SELECT * FROM T WHERE no = 2124</li>
<li>没有正确的统计信息，造成查询优化器无法做出正确的选择</li>
<li>含前导模糊查询的Like语法不能使用索引（”%XXX”）</li>
<li>B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引</li>
</ul>
<p>什么时候应该用：</p>
<ul>
<li>仅当要通过索引访问表中很少一部分行</li>
<li>虽然查询行数比较多，但索引包含多个字段，而要访问的字段全部包含在索引中时，查找只需通过索引而不用访问全表时</li>
</ul>
<p>什么时候不应该用（没找到答案，自己的理解）：</p>
<ul>
<li>当需要查询的数据占表总数据的比重很大时，不应该使用索引，因为查询优化器会发现，使用索引的效率不如全表遍历。</li>
<li>写密集型事务：频繁修改索引，增加开销</li>
</ul>
<h2 id="分区">分区</h2>
<h3 id="分区是干嘛用的">分区是干嘛用的</h3>
<p>分区就是将一个大表根据条件分割成若干个小表，是一种数据分组方式，能够提高并发性和并行性。对于多用户并发访问情况，查询效率可能较高。</p>
<p>表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件）上</p>
<h3 id="根据分区键partition-key的类型分类分区有哪几种类型">根据分区键（Partition Key）的类型分类，分区有哪几种类型？</h3>
<ul>
<li>哈希分区：把不同的列随机平均的分布到不同的物理环境，达到备份和恢复（写 undo 和 redo文件）效率高，降低错误回滚压力（为了管理）。</li>
<li>范围分区：把字段的值分布到一个物理范围，这个范围是你在创建分区时指定的分区键决定的。这种分区方式是最为常用的。</li>
<li>列表分区：把不同的列存到不同的分区中。</li>
</ul>
<h3 id="如何选择分区键-选择原则是什么">如何选择分区键、选择原则是什么</h3>
<ul>
<li>哈希分区：根据分区键，可以快速找到记录，但对范围检索没有任何帮助。更接近于非数据驱动的循环分区，用于负载均衡，提高并发的能力。</li>
<li>范围分区：比较常用，非常适合处理历史数据。</li>
<li>列表分区：查询时，通常只查询某几个字段，或者，某几个字段通常一起被查询。但，每个分区都必须有主键，因此会造成冗余。</li>
<li></li>
<li>按什么字段进行分区要整体考虑，因为：更新分区键会引起移动数据，应该避免这么做。当数据分区键均匀分布时，分区表查询收益最大。</li>
</ul>
<h2 id="设计原则">设计原则</h2>
<h3 id="处理模式操作模式批处理与实时系统">处理模式（操作模式）：批处理与实时系统</h3>
<p>9.2 为性能设计（下）.mp4，17:09</p>
<h4 id="基本逻辑">基本逻辑</h4>
<ul>
<li>
<p>异步处理模式：可以允许用户发出操作之后去做其他工作，数据库进行集中的批处理，当处理完毕后通知用户，但是实时性不好</p>
</li>
<li>
<p>同步处理时模式：用户必须等待数据库操作并返回结果，期间不能做其它操作。适合数据库进行实时交易。</p>
</li>
</ul>
<h4 id="好坏">好坏</h4>
<ul>
<li>当操作过于复杂，需要横跨很多系统、物理环境，实时系统中不可控的因素就会变多，此时就需要采用异步处理模式。</li>
<li>异步处理模式：健壮性、稳定性更强。</li>
<li>同步处理模式：满足实时性的要求，在某些特定业务下，这是必须的，比如银行转账业务。</li>
</ul>
<h4 id="选择">选择</h4>
<ul>
<li>由系统需求和所需处理的数据的物理结构决定的，大部分情况下，同步和异步是共存的，不能先入为主得认为业务必须同步。</li>
<li>从性能的角度，如果对实时性没有要求，则可以考虑尝试使用批处理模式</li>
<li>在批处理模式下，更容易暴露性能问题，因为批处理需要压榨硬件资源，而实时系统只有在高并发或大数据量的情况下才可能暴露性能问题，而当实时系统暴露出性能问题后，可能会极大影响正常业务的开展。</li>
</ul>
<h3 id="存储模式集中式与分布式">存储模式：集中式与分布式</h3>
<p>9.2 为性能设计（下）.mp4，11:31</p>
<h4 id="基本逻辑-2">基本逻辑</h4>
<ul>
<li>
<p>分布式数据存储：将数据分散存储在多台独立的设备上，一般情况下，多台设备在地理位置上相对分散。</p>
</li>
<li>
<p>集中式数据存储：将数据集中存储在一台或多台设备上，一般情况下，存储设备在地理位置上相对集中。</p>
</li>
</ul>
<h4 id="好坏-2">好坏</h4>
<ul>
<li>分布式数据系统：
<ul>
<li>缺点
<ul>
<li>复杂度高、健壮性低、管理成本高</li>
<li>保密性不易控制</li>
<li>多个副本的一致性难以保证</li>
<li>远程数据的透明访问代价高</li>
<li>不同数据源数据的结合极为困难
<ul>
<li>数据传输开销大</li>
<li>脱离数据源的环境，数据源无法从数据规划中获益（物理结构、索引）</li>
</ul>
</li>
</ul>
</li>
<li>优点
<ul>
<li>单一节点的负担低</li>
<li>具有更灵活的体系结构</li>
</ul>
</li>
</ul>
</li>
<li>集中式
<ul>
<li>缺点：单点故障，会带来很大损失，因此常常需要热备份或灾难备份</li>
</ul>
</li>
</ul>
<h4 id="选择-2">选择</h4>
<ul>
<li>平衡、折中
<ul>
<li>
<h2 id="全球性的数据若集中存储则跨大陆的访问速度将大幅降低离数据越近访问越快但从另一个角度看因为集中式避免了分布式中的数据传输并可以利用数据规划因此查询速度快">全球性的数据，若集中存储，则跨大陆的访问速度将大幅降低（离数据越近，访问越快）；但从另一个角度看，因为集中式避免了分布式中的数据传输，并可以利用数据规划，因此查询速度快。</h2>
</li>
<li>集中式存储的访问吞吐量有上限</li>
</ul>
</li>
</ul>
<h2 id="sql-查询优化器是如何工作的">SQL-查询优化器是如何工作的</h2>
<p>4.1 SQL优化.mp4，13:38</p>
<p>优化是在数据处理的真正被执行的时候发生</p>
<p>不同结果的关系表达式在实际环境下执行的效率千差万别</p>
<p>查询优化器如何权衡哪种优化更好</p>
<ul>
<li>基于成本的优化器 CBO：综合考虑所有的情况。现在最常用的优化器类型。</li>
<li>基于规则的优化器 RBO：根据预定义的规则进行优化，例如加减的权重是1，乘除的权重是2。</li>
</ul>
<p>SQL的执行顺序：</p>
<ul>
<li>SQL、语义语法检查、解析（软解析+硬解析）、执行计划、执行引擎、存储引擎、数据库</li>
<li>解析是整个SQL优化最消耗资源的环节，其中硬解析是最重要的一部分。</li>
<li>执行计划：Plan，二进制的执行代码</li>
<li>解析+生成执行计划是查询优化器最重要的工作</li>
<li>生成执行计划后，抛入执行引擎，从数据库中读取数据，然后返回。</li>
</ul>
<p>优化器只能对关系领域进行优化</p>
<p>优化器的有效范围：</p>
<ul>
<li>优化器需要借助数据库中找到的信息</li>
<li>能进行数学意义上的等价变换</li>
<li>优化器考虑整体响应时间</li>
<li>优化器改善的是独立的查询</li>
</ul>
<h2 id="数据库设计-层次结构">数据库设计-层次结构</h2>
<p>6.1 处理层次结构.mp4，12:17</p>
<ul>
<li>
<p>邻接模型：id、pid</p>
<ul>
<li>兄弟节点是无序的</li>
</ul>
</li>
<li>
<p>物化路径模型：1、1.1、1.1.2</p>
<ul>
<li>兄弟节点是有序的</li>
<li>方便扩展：3层结构扩展层4层</li>
<li>查询语句编写简单，找出适当的记录并缩排显示比较容易</li>
</ul>
</li>
<li>
<p>嵌套集合模型：left_num、right_num，所有子节点都在left_num和right_num之间</p>
<p>上述3种树状表结构设计都满足三范式</p>
</li>
</ul>
<p>两种查询方式：</p>
<ul>
<li>自顶向下（Vandamme查询）
<ul>
<li>邻接模型
<ul>
<li>connect by current = <em>prior</em> previous，非关系型查询方式</li>
<li>利用with as，首先定义起始点，之后对两个select语句进行union all，通过递归查询不断根据父记录生成子记录。</li>
<li>mysql不支持connect by，也不支持with as，因此只能事先知道树的深度，然后手动union</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>计算深度：path字符串长度 减去 去掉点之后的path字符串长度</li>
<li>指定需要查询的path前缀，之后使用模糊查询获取结果，然后对path进行排序，即可</li>
</ul>
</li>
</ul>
</li>
<li>自底向上（Hignland查询）
<ul>
<li>邻接模型
<ul>
<li>connect by previous = <em>prior</em> current</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>指定需要查询的叶子结点，之后使用模糊查询获取父节点</li>
<li>会存在重复记录，因此需要使用distinct</li>
<li>排序问题：对distinct的结果进行select，并按path进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>性能对比</p>
<ul>
<li>自顶向下
<ul>
<li>邻接模型
<ul>
<li>性能最好，每秒返回的查询记录数最多，只需要处理数值关系，但性能会收到迭代操作的影响</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>中等，因为涉及到字符串操作</li>
<li>计算深度、缩排函数 比较费时</li>
</ul>
</li>
</ul>
</li>
<li>自底向上
<ul>
<li>和自顶向下类似，邻接最好，物化路径中等</li>
<li>当不能用connect by和with as时，可以使用物化路径模型作为替代</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[南京大学-高级算法课程-复习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-13-南京大学-高级算法课程-复习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-13-南京大学-高级算法课程-复习笔记/">
        </link>
        <updated>2021-04-13T11:21:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="蛮力法">蛮力法</h2>
<p>算法思想：在不考虑时间、空间效率的情况下，寻求问题的解决方案</p>
<p>DFS BFS 连通性、环路</p>
<h2 id="分治">分治</h2>
<blockquote>
<p>思想：分而治之</p>
<p>分(Divide): 递归解决较小的问题，直到终止层或者可以解决的时候停下来<br>
治(Conquer): 递归求解，如果问题够小直接求解<br>
合并(Combine): 用子问题的解合并构建父问题</p>
<p>https://blog.csdn.net/zhang971105/article/details/115759963</p>
</blockquote>
<h3 id="归并排序">归并排序</h3>
<p>归并排序的主要缺点是该算法需要额外的线性空间。</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/image-20210418125331240.png" alt="image-20210418125331240" loading="lazy"></figure>
<h2 id="减治">减治</h2>
<p>算法思想：</p>
<ul>
<li>利用给定实例下问题的解和较小规模实例下相同问题的解之间的关系。</li>
<li>可以从顶至下（递归地）也可以自底向上（非递归地）地运用该关系。</li>
<li>与分治法不同，减治法只针对其部分子问题进行求解，同时也是采取划分后选择计算的思想</li>
</ul>
<p>举例</p>
<ul>
<li>减常量：插入排序、深度优先、广度优先遍历</li>
<li>减常因子：折半查找、三份查找</li>
<li>减可变规模：欧几里得最大公约数、选择问题、插值查找</li>
</ul>
<p>减治法与分治法：</p>
<ul>
<li>二项查找规模减半的两个子问题只有一个问题需要解决，是减治法。分治求和，规模减半的两个子问题都需要求解。</li>
</ul>
<h3 id="生成组合对象">生成组合对象</h3>
<h4 id="johnson-trotter算法">Johnson-Trotter算法</h4>
<pre><code>Algorithm JohnsonTrotter(n) 
//实现用来生成排列的Johnson-Trotter算法 
//输入：一个正整数n 
//输出：{1,...,n}的所有排列的列表
将第一个排列初始化为A={1,2,...n}（方向都为左） 
while 存在一个移动元素 do
	求最大的移动元素k
    把k和它箭头指向的相邻元素互换
    调转所有大于k的元素的方向
    将新排列添加到列表中
</code></pre>
<h4 id="减一法">减一法</h4>
<p>生成n-1个数的排列<br>
将第n个数依次插入n-1个数的每一个排列中<br>
缺点：记录所有中间结果，耗费存储空间</p>
<h3 id="插值查找">插值查找</h3>
<p>与折半查找类似，只是确定mid的方式有所改变：</p>
<figure data-type="image" tabindex="2"><img src="E:%5CGridea%5C%E7%AB%99%E7%82%B9%E6%BA%90%E6%96%87%E4%BB%B61%5Cpost-images%5Cimage-20210415110033670-1618718496262.png" alt="image-20210415110033670" loading="lazy"></figure>
<p>最坏情况：</p>
<ul>
<li>要在[1,10]中查到2，但多数元素分布在[1,2]之前</li>
<li>每次插值查找都只能减少1个元素。</li>
</ul>
<blockquote>
<p>动机：在预测顺序数组是均匀排布的假设前提下，使用插值查找可以在时间复杂度O(log logn)的情况下比<strong>折半查找</strong>O(logn)花费更少的查找次数。</p>
<p>https://blog.csdn.net/zhang971105/article/details/115760010</p>
</blockquote>
<h3 id="dfs">DFS</h3>
<ul>
<li>如果在遍历的过程中，发现某个顶点有一条边指向已经访问过的顶点，且这个已访问过的顶点不是当前顶点的父节点（这里的父节点表示DFS遍历顺序中的父节点），则说明图包含环。</li>
<li>判断连通性：若vis数组存在0值，则该节点未被访问。</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="https://blog.csdn.net/zhang971105/article/details/115760010">【算法复习】减治算法</a></li>
</ul>
<h2 id="变治">变治</h2>
<p>算法思想：</p>
<ul>
<li>一个更简单的实例——<strong>实例化简</strong>——预排序，将问题变为排序好的列表的问题：高斯消去法</li>
<li>一个实例的不同表现——<strong>改变表现</strong>——平衡查找树、堆——改变数据结构：霍纳法则</li>
<li>变为另一个问题的实例——<strong>问题化简</strong>——对NP难问题和NP完全问题的定义</li>
</ul>
<h3 id="高斯消去法-实例化简">高斯消去法-实例化简</h3>
<p>n元一次方程组求解</p>
<p>将方程组系数变为一个下三角全部是0的矩阵</p>
<p>思想：将n元一次方程组求解实例化简为一个容易求解的实例。</p>
<figure data-type="image" tabindex="3"><img src="http://Bule-Zst.gitee.io/post-images/1618454369592.png" alt="" loading="lazy"></figure>
<p>转换方法：</p>
<ul>
<li>用第一个方程的一个倍数和第二个方程求差，将第二个方程中x1系数变为0；同样与其它方程求差，将所有x1系数变为0；</li>
<li>再用第二个方程与其它方程作同样操作，将所有第二个方程后的所有x2系数变为0；</li>
<li>最终得到下三角为0的系数矩阵</li>
</ul>
<h3 id="霍纳法则-改变表现">霍纳法则-改变表现</h3>
<p>经过霍纳法则变换的多项式只需要执行 n 次乘法运算便可以得到 n 阶多项式的值，使得原本n方复杂度的计算变为n，加快运算速度。</p>
<p>用于快速计算多项式的值</p>
<figure data-type="image" tabindex="4"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415110131949.png" alt="image-20210415110131949" loading="lazy"></figure>
<h4 id="二进制幂">二进制幂</h4>
<p>基于改变表现的求幂的算法</p>
<p>任何一个数，都可以变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的累加和，例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1 = 2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">5=2^2+2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">6=2^2+2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>因此，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow></msup><mo>=</mo><msup><mi>a</mi><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">a^n=a^{p(2)}=a^{\sum_{i=0}^n{b_i*2^i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9944599999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944599999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">∗</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">p(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的多项式，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>只能取0或者1。</p>
<p>有两种计算方法，从左到右和从右到左。</p>
<p>以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">a^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>为例，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>13</mn><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">13=1*2^3+1*2^2+0*2^1+1*2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>从左到右：</strong></p>
<figure data-type="image" tabindex="5"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415111446604.png" alt="image-20210415111446604" loading="lazy"></figure>
<p>每一次，先平方，然后，如果n的二进制位为1，则乘上一个a。</p>
<p><strong>从右到左：</strong></p>
<figure data-type="image" tabindex="6"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415111618512.png" alt="image-20210415111618512" loading="lazy"></figure>
<p>预先准备好a的各个幂次的结果，如果n的二进制位为1，则将对应幂次运算结果乘到最终答案中。</p>
<p>（话说，这不是快速幂吗？）</p>
<p>霍纳法则，也可以延伸到X进制的情况。</p>
<figure data-type="image" tabindex="7"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415112335441.png" alt="image-20210415112335441" loading="lazy"></figure>
<h5 id="参考资料-2">参考资料</h5>
<ul>
<li><a href="https://www.cnblogs.com/riasky/p/3509097.html">霍纳法则和二进制幂</a></li>
</ul>
<h2 id="时空权衡">时空权衡</h2>
<p>算法思想：</p>
<ul>
<li>输入增强：对输入进行<strong>预处理</strong>，存储<strong>额外信息</strong>，以加速后续问题的求解。
<ul>
<li>计数排序（比较计数、分布计数）</li>
<li>字符串匹配：Boyer-Moore算法和Horspool提出的简化版</li>
</ul>
</li>
<li>预构造：使用<strong>额外的空间</strong>存储输入（比简单存储更多的空间），以实现更快、更方便的存取。
<ul>
<li>散列法</li>
<li>B树</li>
</ul>
</li>
</ul>
<h3 id="计数排序">计数排序</h3>
<p>比较计数：对数组中的元素两两进行比较，计算Count数组。Count[i]表示比第i个数小的数的个数。</p>
<p>分布计数：预先知道待排数组的范围，统计每个元素出现的次数。</p>
<h3 id="祖先问题">祖先问题</h3>
<p>要求在一棵给定的n顶点二叉树中，确定一个顶点u是否是顶点v的祖先。设计一个属于O(n)的输入增强算法，使我们可以在常量时间内获得树的每一对顶点的足够信息，来对问题求解。</p>
<blockquote>
<p>分析：一个顶点u是顶点v的祖先，当前仅当先序遍历u在v的前面，并且后序遍历u在v的后面。第一个条件，先序遍历u在v的前面，代表要么u是v的祖先，要么u在公共祖先的左子树中而v在公共祖先的右子树中；第二个条件，后序遍历u在v的后面，代表要么u是v的祖先，要么u在公共祖先的右子树中而v在公共祖先的左子树中。综合两个条件，我们可以知道确定一个顶点u是否是顶点v的祖先，其充分必要条件是先序遍历u在v的前面，并且后序遍历u在v的后面。</p>
<p>解答：在O(n)时间对二叉树进行先序遍历和后序遍历，在常量时间内对需要比较的两个节点在先序和后序中比较次序，确定顶点u是否是顶点v的祖先。</p>
<p>https://blog.csdn.net/qq_30432997/article/details/85282116</p>
</blockquote>
<h3 id="字符串匹配">字符串匹配</h3>
<p>要求在一个较长的n个字符的串（称为<strong>文本</strong>）中，寻找一个给定的m个字符的串（称为<strong>模式</strong>）</p>
<h4 id="蛮力法-2">蛮力法</h4>
<p>简单地<strong>从左到右</strong>比较模式和文本中每一个对应的字符，如果不匹配，把模式向右移动一格，再进行下一轮尝试，<strong>最差效率为O(nm)</strong>，随机文本的平均效率O(n+m)=O(n)</p>
<h4 id="horspool算法">Horspool算法</h4>
<ol>
<li>先将文本与模式左对齐</li>
<li>从模式的最后一个字符从后往前进行匹配。</li>
<li>如果全部匹配成功，则结束。</li>
<li>如果匹配失败，分情况讨论：
<ul>
<li>规定：文本中与模式最后一个字符对应的字符为c<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618387864255.png" alt="" loading="lazy"></li>
<li>当模式的前m-1个字符中不存在c时，将模式右移m位。</li>
<li>当模式的前m-1个字符中存在c时，将模式右移，使模式中的c与文本中的c对齐。</li>
<li>回到第2步。</li>
</ul>
</li>
</ol>
<p>时空权衡优化思路-输入增强：<br>
预先计算t数组，t[c]表示：当匹配失败，且文本中对应的字符为c时，模式需要右移的位数。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618388234611.png" alt="" loading="lazy"></p>
<h4 id="boyer-moore算法">Boyer-Moore算法</h4>
<p>Boyer-Moore算法是Horspool算法的升级版，同时运用了坏字符原则和好后缀原则。</p>
<p>在我们进行匹配的时候，我们将第一次碰到的不匹配的字符称为坏字符，而将碰到坏字符之前所匹配到的字符串称为好后缀。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618390709878.png" alt="" loading="lazy"></p>
<p>坏字符原则之前已经介绍过了，就是Horspool算法的核心。这里重点介绍一下好后缀原则。</p>
<p>和坏字符原则一样，我们需要维护一个好后缀数组，那么好后缀数组的含义是什么呢？</p>
<p>它的含义是，需要往前最少数几位，才能让后缀或者后缀的子串匹配上。</p>
<p>我们用S数组表示好后缀数组。S[k]表示的是长度为k的后缀 ，即a[m-k, m-k+1 ... m-2, m-1]。</p>
<p>我们以BAOBAB举例子。</p>
<p>S[1] = 2：表示，B这个后缀，需要最少往前数2位，就能让其匹配上了。<br>
再详细说一下，对于BAOBAB，倒数第三个字符也是B，因此只需要往前数2位，就能让后缀B匹配上了。</p>
<p>我们再来看S[2]，它对应的后缀是AB，但是AB无法匹配，因此我们取子后缀B，这里需要注意，因为我们取的是子后缀，因此如果是类似BB、CB的情况，是无法匹配的，因为原后缀是AB。因此，和子后缀B匹配的只有首位的B，因此S[2] = 5。</p>
<p>这就是好后缀数组的含义。好后缀数组的意义在于，利用了已匹配的字符串的信息，增加了每次移动的位数。</p>
<p>大家可以试一下，如果移动位数少于好后缀数组的值，那么一定是无法匹配上的。</p>
<p>好后缀数组的计算过程可以参考这篇文章：<a href="https://blog.csdn.net/qq_35423154/article/details/109137798">字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则</a></p>
<p><strong>对于坏字符原则和好后缀原则，取最大值进行移动。</strong></p>
<h5 id="参考资料-3">参考资料</h5>
<ul>
<li><a href="https://blog.csdn.net/qq_35423154/article/details/109137798">字符串匹配算法(二)：BM(BoyerMoore)算法、坏字符规则，好后缀规则</a></li>
</ul>
<h4 id="思考题">思考题</h4>
<ul>
<li>使用字符串匹配算法匹配到一个相同字符串后，要查找下一个匹配子串，移动距离是多少？</li>
<li>如果只用坏符号移动表或者好后缀移动表，BM算法能够正确工作吗？</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<p>递归与动态规划的关系：</p>
<ul>
<li>相同点：都需要找到递推关系</li>
<li>不同点：
<ul>
<li>动态规划是自底向上，从停止条件逐步计算出问题的解。</li>
<li>递归是自顶向下，从问题出发，利用递推式逐步减小问题规模，当达到停止条件时，逐步返回，最终求出问题的解。</li>
</ul>
</li>
</ul>
<p>分治法与动态规划的区别：</p>
<ul>
<li><strong>分治方法</strong>将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。</li>
<li><strong>动态规划</strong>应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。这种情况下使用分治算法会重复求解那些子子问题而浪费时间。</li>
<li>By: https://blog.csdn.net/zhang971105/article/details/115759889</li>
<li>动态规划注重：与其对交叠的子问题一次一次求解，还不如对每个较小的子问题只求解一次并把结果记录在表中。</li>
<li>By：https://jinzengnju.github.io/2018/05/22/leetcode高级算法/</li>
</ul>
<h3 id="最优二叉查找树">最优二叉查找树</h3>
<p>假设一次搜索的实际代价为检查的节点的个数，即所发现的节点的深度加1，一次搜索所花费的预期成本为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>(</mo><mi>T</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><msub><mi>k</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mrow><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><msub><mi>d</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>q</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">E(T) = \sum_{i=1}^n {(depth(k_i)+1)*p_i}+\sum_{i=0}^n{(depth(d_i)+1)*q_i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>最优二叉查找树：一次搜索所花费的预期成本最小。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">e[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>k</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">k_i,...,k_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 和虚拟节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_{i-1}, ..., d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 最优 BST 的期望搜索成本。</p>
<p>因此，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>(</mo><mi>T</mi><mo>)</mo><mo>=</mo><mi>e</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">E(T) = e[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示对一棵关键字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>k</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">k_i, ..., k_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的子树，其概率总和：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲
w[i,j] &amp;= \sum…'>\begin{align*}
w[i,j] &amp;= \sum_{k=i}^j p_k + \sum_{k=i-1}^jq_k \\
 &amp; = p_r + w[i,r-1] + w[r+1,j] \\
 &amp; = w[i,j-1] + p_j + q_j
 \end{align*}
</p>
<p>综上所述：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
e[i,j] &amp; = p_r…'>\begin{align}
e[i,j] &amp; = p_r + (e[i,r-1]+w[i,r-1])+(e[r+1,j]+w[r+1,j]) \\
&amp; =e[i,r-1]+e[r+1,j]+w[i,j]
\end{align}
</p>
<pre><code># 动态规划求解最优二叉查找树
# 输入：一个包含n个键对应概率的数组P[1...n],一个包含n个虚拟键对应的概率数组Q[0...n]
# 输出：在最优BST中成功查找的平均比较次数，以及最优BST中子树的根表root

Algorithm OptimalBST(p[1...n],q[0...n]):
    # 初始化保存根节点的root
    root[n][n+1]
    # 初始化只包括虚拟键的子树
    for i ← 1 to n do:
        e[i,i-1] ← q[i-1]
        w[i,i-1] ← q[i-1]
    # 沿着斜对角线向右边推进
    for d ← 1 to n do:
    	for i ← 1 to n - d + 1:
            j ← i + d - 1
            e[i,j] ← 9999999
            w[i,j] ← w[i,j - 1] + p[j] + q[j]
            # 求r移动时取最小期望的时候
            for k ← i to j do:
                temp = e[i,k - 1] + e[k + 1,j] + w[i,j]
                if temp &lt; e[i,j]:
                    e[i,j] = temp
                    root[i][j] = k
    return e[1,n],root

</code></pre>
<h4 id="参考资料-4">参考资料</h4>
<ul>
<li><a href="https://blog.csdn.net/xiajun07061225/article/details/8088784">【算法学习】最优二叉查找树（动态规划）</a></li>
<li><a href="https://www.cnblogs.com/henuliulei/p/10074216.html">最优二叉查找树_动态规划</a></li>
</ul>
<h3 id="背包问题">背包问题</h3>
<pre><code># w[i]表示第i个物品的重量, v[i]表示第i个物品的价值, 下标从V开始
# S表示背包总空间, N表示总共多少个物品
Algorithm bag:
    # N+1行S+1列
    dp = [[0 for i in range(S + 1)] for j in range(N + 1)]
    for i in range(1, N+1):
        for j in range(1, S+1):
            if j &gt; w[i]: # 判断此时背包空间是否大于此时物品重量
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
            else:
            	dp[i][j] = dp[i-1][j]
                
    # 返回在空间为S时前N个物品的最大价值
    return dp[N][S] 

</code></pre>
<h3 id="参考资料-5">参考资料</h3>
<ul>
<li><a href="https://blog.csdn.net/zhang971105/article/details/115759889">【算法复习】动态规划</a></li>
</ul>
<h2 id="迭代改进">迭代改进</h2>
<p>算法思想：</p>
<ul>
<li>贪婪：采用每步最优策略，逐步构造问题的解。最终生成的解，不一定是最优解。</li>
<li>迭代改进：先生成一个可行解，然后，不断通过小的、局部的改变对其进行优化，使目标函数更优。当目标函数无法再优化时，则为最优解。</li>
</ul>
<p>实现过程中可能遇到的困难：</p>
<ul>
<li>如何生成可行解？</li>
<li>如何判断是局部最优解？</li>
<li>如何判断局部最优解是全局最优解？</li>
</ul>
<p>算法实例：遗传算法、蚁群算法、梯度下降算法。</p>
<h3 id="线性规划">线性规划</h3>
<p>线性规划问题：在一系列线性约束下，求一个包含若干变量的线性方程的最优解。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618313856251.png" alt="" loading="lazy"></p>
<h4 id="极值定理">极值定理</h4>
<p>极值定理：可行区域非空的任意线性规划问题有最优解，且最优解总能够在其可行区域的一个<strong>极点</strong>上找到。</p>
<p>利用极值定理解决线性规划问题：</p>
<ul>
<li>生成可行区域的所有极点</li>
<li>计算所有极点对应的问题解，保留最优的</li>
</ul>
<p>极值定理存在的问题：</p>
<ul>
<li>无法生成所有的极点</li>
<li>无法遍历所有的极点（当问题规模变大，极点个数呈爆炸式增长，无法全部遍历）</li>
</ul>
<h4 id="单纯形法">单纯形法</h4>
<p>算法思想：先在可行区域中找到一个极点，然后检查在邻接极点处是否能够优化，如果能，则继续处理该邻接极点；如果不能，则当前极点即为最优解。</p>
<p>局限性：<br>
- 只能解决最大化问题<br>
- 所有变量都非负<br>
- 除 非负约束 外，其余约束都必须为等式。</p>
<h5 id="线性规划问题的标准形式">线性规划问题的标准形式</h5>
<p>能够解决的线性规划问题的标准形式：m个等式约束、n个变量。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618377842782.png" alt="" loading="lazy"></p>
<p>如何转化为标准形式：</p>
<ul>
<li>最小化转为最大化——通过改变目标函数系数正负号</li>
<li>不等问题转为相等问题——通过松弛变量，将松弛变量定义为&gt;=0的新变量</li>
<li>没有非负约束的变量添加约束——定义为 两个带非负约束的新变量的差</li>
</ul>
<p>转化为标准形式的好处：可以用一种简单的方法确定可行区域的极点<br>
确定方法：</p>
<ol>
<li>将约束中的n-m个非基本变量设置成0，利用m个等式求出剩余m个基本变量的解。</li>
<li>如果能求出唯一解，则得到一个基本解。</li>
<li>如果得到的基本解的所有值都非负，则为基本可行解。</li>
</ol>
<p>基本解与区域内的交点一一对应。<br>
基本可行解与可行区域的极点一一对应。</p>
<h5 id="单纯形表">单纯形表</h5>
<p>单纯形<strong>表</strong>：解决线性规划问题的一种方法、工具，其中，蕴含了单纯形法的思想。</p>
<p>单纯形表的计算过程：</p>
<ul>
<li>求得一个基本可行解，作为初始单纯形表。</li>
<li>不断根据规则计算得到下一个单纯形表，每张单纯形表对应一个极点。</li>
<li>对于每张单纯形表，判断是否是最优解或是否有界。</li>
</ul>
<p>具体讲解：<a href="https://www.bilibili.com/video/BV16t411F7Zu?t=697">十分钟带你学单纯形法</a></p>
<p>最优：目标行都为非负。<br>
无界：被选中的非基本变量对应的系数全部小于等于零，则无界，说明目标函数可以无限制增大。详解：<a href="https://www.zhihu.com/question/24146260">运筹学单纯形法无界解的判定原理是什么？</a></p>
<p>如何确定入基变量：（各教材不一样，本文以老师ppt为准）从非基本变量中选择，选择目标行系数最小的变量作为入基变量。<br>
如何确定出基变量：各行变量值除以入基变量所在列对应的系数，取最小。需要注意的是，需要忽略掉系数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 0的那些行。</p>
<p>单纯形表原理：</p>
<ul>
<li><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html">线性规划之单纯形法【超详解+图解】</a></li>
<li><a href="https://blog.csdn.net/xvshu/article/details/23288787">运筹学·单纯形法——原理剖析</a></li>
</ul>
<h5 id="是否能够使用单纯形法解决背包问题如果能请给出解法过程并请指出这是不是一个解决该问题的好算法如果不能请说明原因">是否能够使用单纯形法解决背包问题？如果能，请给出解法过程，并请指出这是不是一个解决该问题的好算法？如果不能，请说明原因。</h5>
<blockquote>
<p>解答：可以通过单纯形法解决背包问题的连续版本，因为它是一般线性规划问题的一个特例。然而，它不是解决这个问题的好方法，因为它可以通过基于贪婪法的更简单的算法更有效地解决。由于对问题变量施加的完整性（0-1）约束，单纯形法无法解决0-1版本的背包问题。</p>
<p>https://blog.csdn.net/qq_30432997/article/details/85283898</p>
</blockquote>
<h5 id="为什么基本可行解与可行区域的极点一一对应">为什么基本可行解与可行区域的极点一一对应？</h5>
<p>我们从二维来理解这个问题，对于高维，也是同样的道理，只是二维比较好描述、且比较好理解。</p>
<p>要解答这个问题，我们先尝试理解另一个问题，为什么基本解与图上的交点一一对应？</p>
<figure data-type="image" tabindex="8"><img src="http://Bule-Zst.gitee.io/post-images/1618367158808.png" alt="" loading="lazy"></figure>
<p>如图，我们能看到很多的交点，在这些交点中，有一些是可行区域的极点，有一些不是。对于那些是可行区域极点的交点，它们对应了基本可行解；对于那些不是可行区域极点的交点，它们对应了基本非可行解，也就是除了基本可行解以外的那些基本解。</p>
<p>我们回到线性规划问题，如下的线性约束一共有3个不等式，但其实本质上应该是4个，对于第三个不等式，可以拆成2个不等式，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1 \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_2 \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<figure data-type="image" tabindex="9"><img src="http://Bule-Zst.gitee.io/post-images/1618367306612.png" alt="" loading="lazy"></figure>
<p>我们只有两个变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），那么从4个不等式中，任取两个，就会得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的一组解。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mn>4</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">C_4^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span>的值为6，因此上图中一共有6个交点。</p>
<p>用更一般的形式说明一下：</p>
<p>原约束方程：<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618368676328.png" alt="" loading="lazy"></p>
<p>标准化后的约束方程：<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618368705133.png" alt="" loading="lazy"></p>
<p>我们用n表示所有变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, x_3, x_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的个数，m表示基本变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">x_3, x_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的个数。在线性约束标准化的过程中，m也表示新加入的松弛变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">x_3, x_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的个数。</p>
<p>根据n和m的定义，我们可以得出，n-m表示原约束方程中变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的个数。因此，我们只需要确定n-m个方程，就可以求出原约束方程中变量（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的值，从而求出目标函数的值。</p>
<p>那么如何将线性约束方程与单纯形表结合起来呢，如果看了之前<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html">讲原理的博客</a>，我们就会知道，每一张单纯形表，其实本质上都是将n-m个非基本变量的值设为0，然后算出原约束方程中n-m个变量的值，从而求出目标表达式的值。</p>
<p>那么，我们将n-m个非基本变量的值设为0，其实就是选择了n-m个不等式。如上所述，当我们选择了n-m个不等式，就能确定原约束方程中n-m个变量的值，也就相当于确定了一个交点。</p>
<p>如果这个交点又是可行区域内的交点，那么其就是可行区域的极点，在单纯形表中的体现就是，基本解的值非负。</p>
<h5 id="参考资料-6">参考资料</h5>
<ul>
<li><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html">线性规划之单纯形法【超详解+图解】</a></li>
<li><a href="https://www.bilibili.com/video/BV16t411F7Zu?t=697">十分钟带你学单纯形法</a></li>
<li><a href="https://blog.csdn.net/xvshu/article/details/23288787">运筹学·单纯形法——原理剖析</a></li>
<li><a href="https://www.zhihu.com/question/39071505/answer/131945180">怎么用简单的语言理解基变量与非基变量？</a></li>
<li><a href="https://www.zhihu.com/question/26840528/answer/34257469">如何理解线性规划中的单纯形法和单纯形表？</a></li>
<li><a href="https://www.zhihu.com/question/24146260">运筹学单纯形法无界解的判定原理是什么？</a></li>
</ul>
<h2 id="其他一些小知识点">其他一些小知识点</h2>
<ul>
<li>2-3树是最简单的B-树（或-树）结构，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树也是一种BST。</li>
<li>堆
<ul>
<li>堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。</li>
<li>使用数组实现堆。对于每一个非叶子节点的父母节点i，其子女将会位于2i与2i+1的位置。（达到这种效果必须要求数组实现时，索引位置为0的地方空出来）。</li>
<li>堆总是满足下列性质：
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
</li>
<li>将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。</li>
<li>从最后的父母节点开始，依次向上检查是否满足父母优势。如果不满足，把节点的键K值和它子女的最大键进行交换。</li>
</ul>
</li>
<li>B树元素的插入：
<ul>
<li>如果要插入的节点已经没有空间，该叶子一分为2，把后面一半的记录放在一个新节点中。在这之后，新节点中最小的键K‘以及指向它的指针要插入到原来的叶子的父母中，递归该过程一直到根中。</li>
</ul>
</li>
</ul>
<h2 id="参考资料-7">参考资料</h2>
<ul>
<li><a href="https://jinzengnju.github.io/2018/05/22/leetcode%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/">leetcode高级算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用码云（gitee）提升博客访问速度]]></title>
        <id>http://Bule-Zst.gitee.io/cRC2jYBGG/</id>
        <link href="http://Bule-Zst.gitee.io/cRC2jYBGG/">
        </link>
        <updated>2021-04-10T03:02:30.000Z</updated>
        <content type="html"><![CDATA[<p>之前写过文章，通过Gridea+github搭建个人博客 <a href="https://bule-zst.gitee.io/ji-yu-grideagithubcoding-da-jian-jing-tai-bo-ke/">基于Gridea+github/coding搭建静态博客</a>，但使用了一段时间后，发现加载速度实在是太慢了，而且cdn更新也不太稳定。</p>
<p>今天突发奇想，可以使用码云部署自己的个人博客，说干就干。</p>
<hr>
<h1 id="gridea个人博客搭建的原理">Gridea个人博客搭建的原理</h1>
<p>首先，和大家讲一下Gridea个人博客的搭建原理，如果只想看操作步骤的话，可以跳过这一节。</p>
<p>Github为我们提供了一个功能，叫github pages，可以用于展示<strong>静态</strong>网页，Gridea正是利用了github pages这一功能来搭建博客的。</p>
<p>我们在github上创建项目后，可以为项目开启github pages功能，开启后，访问对应的网址，就会加载项目中的静态网页，例如在项目根目录下放入index.html文件，当访问项目时，就会展示index.html中的内容。</p>
<p>而，只要是git系列的产品，理论上都有pages的功能，码云也不例外，因此，我们可以将Gridea生成的博客项目推送到码云项目中，然后开启码云项目的pages功能，就可以利用码云来搭建博客了。</p>
<h1 id="具体操作步骤">具体操作步骤</h1>
<h2 id="码云">码云</h2>
<p>首先，需要在码云上创建项目，并开启pages功能，具体可参考<a href="https://gitee.com/help/articles/4136#article-header0">这篇文章</a>。</p>
<p>这里提一些容易忽略的细节：</p>
<ul>
<li>首先，和github不一样，在码云中创建的项目的项目名，需要和用户名一样。</li>
<li>第二，在创建完项目后，需要开启pages服务。</li>
<li>第三，记得要往项目中添加index.html文件，这一步主要用于测试。</li>
</ul>
<p>完成参考文章中的步骤后，访问网址（用户名.gitee.io），看看能不能加载出内容。</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/1618028959506.png" alt="" loading="lazy"></figure>
<h2 id="修改gridea配置">修改Gridea配置</h2>
<p>第二步，需要修改Gridea中的配置<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618029063220.png" alt="" loading="lazy"><br>
其余地方都不变，只需要修改图中红色框框出来的域名，改成码云对应的网址（用户名.gitee.io）</p>
<h2 id="推送项目到码云并更新pages服务">推送项目到码云，并更新pages服务</h2>
<p>第三步，需要将Gridea生成的个人博客项目推送到码云上，在这一步中，我用的是git可视化管理工具-gtikraken，如果git基本功比较好的，也可以在git bash中进行操作。</p>
<p>首先用gitkraken打开本地个人博客项目，目录是：/个人博客项目根目录/output<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618029373237.png" alt="" loading="lazy"><br>
打开后会发现，有一个remote，这个就是之前我们配置的github仓库</p>
<p>我们将码云中创建的项目也添加到remote中<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618029472492.png" alt="" loading="lazy"></p>
<p>然后，点击Gridea中的同步，将本地博客项目同步到github项目中。</p>
<p>之后点击push按钮，将本地项目推送到码云项目中。在点击push按钮后，可能会让我们选择需要推送的目标仓库，注意要选择码云中的项目。</p>
<p>在推送完成后，回到码云项目中，点击Gitee Pages按钮，进入pages管理界面<br>
<img src="http://Bule-Zst.gitee.io/post-images/1618029658643.png" alt="" loading="lazy"></p>
<p>点击更新按钮</p>
<figure data-type="image" tabindex="2"><img src="http://Bule-Zst.gitee.io/post-images/1618029730998.png" alt="" loading="lazy"></figure>
<p>在更新完成后，访问博客网址（用户名.gitee.io），就能看到博客的内容了</p>
<figure data-type="image" tabindex="3"><img src="http://Bule-Zst.gitee.io/post-images/1618029790776.png" alt="" loading="lazy"></figure>
<p>大功告成！</p>
<p>最后还需要说一点，就是，每次推送博客更新到码云项目后，都需要点击pages中的更新按钮进行更新，这是因为对于免费版的码云，不支持pages的自动更新。</p>
<p>虽然这样好像有点麻烦，对我觉得，相对于github的访问速度来说，我还是更偏向于码云一些。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL性能优化]]></title>
        <id>http://Bule-Zst.gitee.io/jvgYk8JbI/</id>
        <link href="http://Bule-Zst.gitee.io/jvgYk8JbI/">
        </link>
        <updated>2021-03-31T03:10:34.000Z</updated>
        <content type="html"><![CDATA[<p>from <a href="https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web">https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web</a></p>
<hr>
<p>MySQL慢查询 优化手段：</p>
<ul>
<li>索引：使用MySQL工具，如explain，看一下查询有没有走索引。</li>
</ul>
<h1 id="索引">索引</h1>
<p>索引是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong>。</p>
<p>数据结构可视化网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<p>索引的常见数据结构：</p>
<ul>
<li>树
<ul>
<li>二叉搜索树：
<ul>
<li>优化思路：使用二叉搜索树，降低IO操作次数。</li>
<li>缺点-退化。当数据递增或递减时，会退化成链表，如，1, 2, 3, 4, 5</li>
</ul>
</li>
<li>二叉平衡树
<ul>
<li>优化思路：减少二叉树层数，降低IO操作次数。</li>
<li>红黑树：缺点-效率低。虽然会自平衡，但当数据量达到500w时，可能树的高度会达到20层，如果查询的数据在叶子结点，20次IO操作依旧很慢。</li>
</ul>
</li>
<li>多路平衡树
<ul>
<li>优化思路：扩展每个节点，使其包含多个索引元素，更进一步减少二叉树层数，降低IO操作次数。</li>
<li>B-Tree</li>
<li><strong>B+Tree</strong>
<ul>
<li>目前MySQL索引采用的数据结构</li>
<li>MySQL中，默认情况下，每个节点可占用的空间大小为16KB。3层B+Tree，约可以存放2000w个索引元素。</li>
</ul>
</li>
<li>B-Tree与B+Tree的比较
<ul>
<li>把数据统一存放在叶子结点中，好处是，非叶子结点可以包含更多的索引元素，因此树的高度更低。</li>
<li>叶子结点之前的连接：更好地支持范围查找。B-树如果要做范围查询，则需要定位到第一个元素后，进行中序遍历。</li>
<li>B+树，每次都会查到叶子结点才结束，因此查询时间较稳定。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Hash表
<ul>
<li>Hash表的效率很多情况下优于B+树</li>
<li>不选择Hash表的原因：
<ul>
<li>Hash冲突（次要）：当存在大量Hash冲突时，会导致链表变长，降低效率。但当链表过长时，MySQL会进行ReHash操作，降低链表长度。</li>
<li>不支持范围查询（主要）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从二叉搜索树到二叉平衡术再到多路平衡树，本质上是逐步降低了磁盘IO次数，那为什么不把所有索引元素都放到一个节点中？这样，只需要一次IO操作就行了。</p>
<ul>
<li>当数据量大的时候，太占内存了，并且有的时候，可能内存容量不允许这么做。</li>
<li>当所有索引都读取到内存后，索引数量太多，可能500w，二分查找效率也会降低。</li>
</ul>
<p>为什么主键推荐用整型，而不是UUID？</p>
<ul>
<li>比较效率。在索引中，会进行多次比较，整形比较速度更快。</li>
<li>存储空间。UUID是字符串，更占空间。</li>
</ul>
<p>为什么 MySQL 官方建议使用自增主键作为表的主键？</p>
<blockquote>
<p>因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。</p>
<p><a href="https://www.jianshu.com/p/39e5b433bbaf">https://www.jianshu.com/p/39e5b433bbaf</a></p>
</blockquote>
<p>聚集索引：叶子结点包含完整的数据记录。例如，InnoDB的主键索引。对于每张表，聚集索引最多只有一个；对于InnoDB表，聚集索引有且仅有一个。<br>
非聚集索引：索引文件和数据文件是分离的。<br>
聚集索引效率高，因为非聚集索引拿到数据地址后，还需要一次IO操作，才能获取数据。</p>
<p>联合索引：本质还是B+树，只是在比大小时，按字段顺序，依次进行比较</p>
<h1 id="存储引擎">存储引擎</h1>
<p>存储引擎是针对表的，不同表可以设置不同的存储引擎。</p>
<p>数据库中存储的数据，默认放在安装目录下的data文件夹中。<br>
一个数据库，对应一个文件夹。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1617329696374.png" alt="" loading="lazy"><br>
一个数据表，对应文件夹中的多个同名文件，不同存储引擎对应的文件结构不一样。<br>
<img src="http://Bule-Zst.gitee.io/post-images/1617330056948.png" alt="" loading="lazy"></p>
<ul>
<li>.frm：frame，表结构的相关信息</li>
<li>InnoDB
<ul>
<li>.ibd：表中的数据及索引。InnoDB的数据和索引，是存储在一起的。</li>
<li>主键索引：
<ul>
<li>索引用B+数的结构存储，数据存储在B+数的叶子结点上。</li>
<li><img src="http://Bule-Zst.gitee.io/post-images/1617331007626.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>二级索引（普通索引）
<ul>
<li>索引用B+树存储，叶子结点存放<strong>主键</strong>信息，获取到主键后，需要再次从主键索引中获取数据信息（回表操作）。</li>
<li>二级索引存主键信息：
<ul>
<li>优点：因为表数据是存在索引中的，伴随索引节点的分裂，表数据的磁盘地址会发生改变，存主键信息避免了二级索引的维护工作。</li>
<li>缺点：1、回表操作，比较耗时；2、存主键，导致二级索引更占空间。</li>
</ul>
</li>
<li><img src="http://Bule-Zst.gitee.io/post-images/1617331631874.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>若表中没有主键，存储引擎会先在表中寻找，看是否存在非空唯一索引，若存在，则对该列或该索引建立聚集索引，若不存在，则维护一个额外的隐藏列（6字节的rowid），用于建立聚集索引。</li>
</ul>
</li>
<li>MyISAM
<ul>
<li>.MYD：MyISAM Data，表中的数据</li>
<li>.MYI：MyISAM Index，索引的相关信息</li>
<li><img src="http://Bule-Zst.gitee.io/post-images/1617330872488.jpg" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h1 id="索引优化原则">索引优化原则</h1>
<ul>
<li>最左前缀原则：对于联合索引，如果要用，那么必须按照建索引时字段的先后顺序去用，不能跳过任何一个字段。</li>
</ul>
<h1 id="简历">简历</h1>
<p>不要光罗列会的技术，要深入地写，写技术细节。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetbrains系列产品重置试用方法]]></title>
        <id>http://Bule-Zst.gitee.io/mQjLrKUHc/</id>
        <link href="http://Bule-Zst.gitee.io/mQjLrKUHc/">
        </link>
        <updated>2021-01-06T03:17:53.000Z</updated>
        <content type="html"><![CDATA[<p>本站惯例：本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。</p>
<p>没错，jetbrains-agent这个项目停止了。市面上漫天飞的各种最新都是其他大神的魔改版本。<br>
我不是要专门写个博文来说明jetbrains-agent项目已经停止，然后缅怀感叹一番。这篇文章是想和大家聊聊另一种思路。</p>
<h1 id="0x0-项目背景">0x0. 项目背景</h1>
<p>Jetbrains家的产品有一个很良心的地方，他会允许你试用30天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。<br>
但很多时候会出现一种情况：IDE并不能按照我们实际的试用时间来计算。<br>
我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）<br>
发现了吗？你未能真的有30天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？</p>
<p>事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。但切记不要无休止的一直试用，这并不是这个插件的本意！</p>
<h1 id="0x1-如何安装">0x1. 如何安装</h1>
<h2 id="1-插件市场安装">1). 插件市场安装：</h2>
<ul>
<li>在Settings/Preferences... -&gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io</li>
<li>搜索：<code>IDE Eval Reset</code>插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？</li>
<li>插件会提示安装成功。</li>
</ul>
<h2 id="2-下载安装">2). 下载安装：</h2>
<ul>
<li>点击这个<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip">链接(v2.1.6)</a>下载插件的zip包（macOS可能会自动解压，然后把zip包丢进回收站）</li>
<li>通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&gt; Plugins 里手动安装插件（Install Plugin From Disk...）</li>
<li>插件会提示安装成功。</li>
</ul>
<h1 id="0x2-如何使用">0x2. 如何使用</h1>
<ul>
<li>一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）</li>
<li>也可以手动唤出插件的主界面：
<ul>
<li>如果IDE没有打开项目，在Welcome界面点击菜单：Get Help -&gt; Eval Reset</li>
<li>如果IDE打开了项目，点击菜单：Help -&gt; Eval Reset</li>
</ul>
</li>
<li>唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：
<ul>
<li>按钮：Reload 用来刷新界面上的显示信息。</li>
<li>按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（此为手动重置方式）</li>
<li>勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式）</li>
</ul>
</li>
</ul>
<h1 id="0x3-如何更新">0x3. 如何更新</h1>
<h2 id="1-插件更新机制推荐">1). 插件更新机制（推荐）：</h2>
<ul>
<li>IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>点击IDE的<code>Check for Updates...</code>菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>插件更新可能会需要重启IDE。</li>
</ul>
<h2 id="2-手动更新">2). 手动更新：</h2>
<ul>
<li>从本页面下载最新的插件zip包安装更新。参考本文：<code>下载安装</code>小节。</li>
<li>插件更新需要重启IDE。</li>
</ul>
<h1 id="0x4-一些说明">0x4. 一些说明</h1>
<ul>
<li>本插件默认不会显示其主界面，如果你需要，参考本文：<code>如何使用</code>小节。</li>
<li>市场付费插件的试用信息也会一并重置。</li>
<li>对于某些付费插件（如: Iedis 2, MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：
<ul>
<li>如果IDE没有打开项目，在Welcome界面点击菜单：Configure -&gt; Edit Custom VM Options... -&gt; 移除 -javaagent: 开头的行。</li>
<li>如果IDE打开了项目，点击菜单：Help -&gt; Edit Custom VM Options... -&gt; 移除 -javaagent: 开头的行。</li>
</ul>
</li>
<li>重置需要重启IDE生效！</li>
<li>重置后并不弹出Licenses对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。</li>
<li>如果长达25天不曾有任何重置动作，IDE会有通知询问你是否进行重置。</li>
<li>如果勾选：Auto reset before per restart ，重置是静默无感知的。</li>
<li>简单来说：勾选了Auto reset before per restart则无需再管，一劳永逸。</li>
</ul>
<h1 id="0x5-开源信息">0x5. 开源信息</h1>
<ul>
<li>插件是学习研究项目，源代码是开放的。源码仓库地址：<a href="https://gitee.com/pengzhile/ide-eval-resetter">Gitee</a>。</li>
<li>如果你有更好的想法，欢迎给我提Pull Request来共同研究完善。</li>
<li>插件源码使用：GPL-2.0开源协议发布。</li>
<li>插件使用PHP编写，毕竟PHP是世界上最好的编程语言！</li>
</ul>
<h1 id="0x6-支持的产品">0x6. 支持的产品</h1>
<ul>
<li>IntelliJ IDEA</li>
<li>AppCode</li>
<li>CLion</li>
<li>DataGrip</li>
<li>GoLand</li>
<li>PhpStorm</li>
<li>PyCharm</li>
<li>Rider</li>
<li>RubyMine</li>
<li>WebStorm</li>
</ul>
<hr>
<p>from <a href="https://zhile.io/2020/11/18/jetbrains-eval-reset.html">https://zhile.io/2020/11/18/jetbrains-eval-reset.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 410. 分割数组的最大值]]></title>
        <id>http://Bule-Zst.gitee.io/vus3sqCc8/</id>
        <link href="http://Bule-Zst.gitee.io/vus3sqCc8/">
        </link>
        <updated>2020-12-30T08:10:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题意">题意</h1>
<p>给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。</p>
<h1 id="解题思路">解题思路</h1>
<h2 id="暴力搜索">暴力搜索</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><msubsup><mi>n</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>{</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mtext> </mtext><mi>M</mi><mo>[</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mtext> </mtext><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub><mo>}</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">M[n,k] = min^n_{j=1}\{max\{ \ M[j,k-1], \ \sum^{n-1}_{i=j}A_i\}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.133108em;vertical-align:-0.383108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">}</span></span></span></span></span></p>
<p>其中，n表示数组长度，k表示数组分成几段。<br>
初始化条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><msub><mi>A</mi><mn>0</mn></msub><mspace linebreak="newline"></mspace><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M[1,k] = A_0 \\ M[n,1] = \sum^{n-1}_{i=0}A_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="动态规划">动态规划</h2>
<p>递归算法拥有指数时间的复杂度，并且会重复计算一些M值。这类的算法一般可以使用动态规划进行优化。使用数组保存一些已经计算得到的值，采用自底向上进行计算</p>
<h2 id="二分查找">二分查找</h2>
<p>此题可以想象成把数据按顺序装入桶中，m即是给定的桶数，问桶的容量至少应该为多少才能恰好把这些数装入k个桶中（按顺序装的）。</p>
<p>首先我们可以知道，桶的容量最少不会小于数组中的最大值，即桶容量的最小值（小于的话，这个数没法装进任何桶中），假设只需要一个桶，那么其容量应该是数组所有元素的和，即桶容量的最大值；其次，桶数量越多，需要的桶的容量就可以越少，即随着桶容量的增加，需要的桶的数量非递增的（二分查找就是利用这点）；我们要求的就是在给定的桶数量m的时候，找最小的桶容量就可以把所有的数依次装入k个桶中。在二分查找的过程中，对于当前的桶容量，我们可以计算出需要的最少桶数requiredPainters，如果需要的桶数量大于给定的桶数量k，说明桶容量太小了，只需在后面找对应的最小容量使需要的桶数恰好等于k；如果计算需要的桶数量小于等于k，说明桶容量可能大了（也可能正好是要找的最小桶容量），不管怎样，该桶容量之后的桶容量肯定不用考虑了（肯定大于最小桶容量），这样再次缩小查找的范围，继续循环直到终止，终止时，当前的桶容量既是最小的桶容量。</p>
<p>对于数组 1 2 3 4 5 6 7，假设k=3，最小桶容量为7（要5个桶），最大桶容量为28（一个桶）</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/1609316379450.png" alt="" loading="lazy"></figure>
<p>第一行表示桶容量，第二行表示需要的桶数，即要求桶数量恰为k的最小桶容量。</p>
<h1 id="代码">代码</h1>
<pre><code class="language-c++">class Solution {
public:
    bool judge( vector&lt;int&gt;&amp; nums, int capacity, int num ) {
        int curCapacity = capacity;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            if( curCapacity &lt; nums[i] ) {
                num--;
                if( num == 0 ) {
                    return false;
                }
                curCapacity = capacity;
                i--;
            } else {
                curCapacity -= nums[i];
            }
        }
        return true;
    }
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        int max, min;
        int sum = 0;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            sum += nums[i];
        }
        max = sum; // 成功的情况
        min = 0; // 失败的情况
        while( min&lt;max-1 ) { // 当两者相邻，就退出
            int mid = ( min+max ) / 2;
            if( judge(nums,mid,m) ) {
                max = mid;
            } else {
                min = mid;
            }
        }
        return max;
    }
};
</code></pre>
<hr>
<p>from <a href="https://www.cnblogs.com/ygh1229/p/10637504.html">https://www.cnblogs.com/ygh1229/p/10637504.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux->Ubuntu下配置telnet环境]]></title>
        <id>http://Bule-Zst.gitee.io/Grj96uz3p/</id>
        <link href="http://Bule-Zst.gitee.io/Grj96uz3p/">
        </link>
        <updated>2020-12-29T10:12:33.000Z</updated>
        <content type="html"><![CDATA[<p>1、首先查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出为空，表示没有开启该服务</p>
<p>2、安装openbsd-inetd</p>
<p><code>apt-get install openbsd-inetd</code></p>
<p>如果已经安装过了，会提示已经安装过了，直接执行下面的步骤就可以了。</p>
<p>3、安装telnetd</p>
<p><code>apt-get install telnetd</code></p>
<p>安装完之后，查看/etc/inetd.conf的内容会多了一行telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p><code>cat /etc/inetd.conf | grep telnet</code></p>
<p>输出： telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p>4、重启openbsd-inetd</p>
<p><code>/etc/init.d/openbsd-inetd restart</code></p>
<p>输出：* Restarting internet superserver inetd</p>
<p>5、查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出：tcp　　0　　0 :telnet　　😗　　LISTEN</p>
<p>此时表明已经开启了telnet服务。</p>
<p>6、telnet登陆测试</p>
<p><code>telnet 127.0.0.1</code></p>
<p>输出： Trying 127.0.0.1… Connected to 127.0.0.1. Escape character is ‘^]’. （停在这里的时候要按Ctrl+] 然后回车）</p>
<p>telnet&gt; （表示登陆成功）</p>
<hr>
<p>from <a href="https://www.cnblogs.com/taomylife/p/7552424.html">https://www.cnblogs.com/taomylife/p/7552424.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刷题记录]]></title>
        <id>http://Bule-Zst.gitee.io/2020-12-26-刷题记录/</id>
        <link href="http://Bule-Zst.gitee.io/2020-12-26-刷题记录/">
        </link>
        <updated>2020-12-26T08:17:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="打表">打表</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/UVA100">UVA100 The 3n + 1 problem</a></li>
</ul>
<h1 id="并查集">并查集</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1111">P1111 修复公路</a></li>
</ul>
<h1 id="二分">二分</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></li>
<li><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></li>
</ul>
<h1 id="分治">分治</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1257">P1257 平面上的最接近点对</a></li>
</ul>
<h1 id="栈">栈</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></li>
<li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></li>
<li><a href="https://leetcode-cn.com/problems/tag-validator/">591. 标签验证器</a></li>
</ul>
<h2 id="单调栈">单调栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a></li>
<li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></li>
</ul>
<h3 id="中缀转后缀">中缀转后缀</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></li>
<li><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></li>
</ul>
<h1 id="单调队列">单调队列</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></li>
</ul>
<h1 id="计算几何">计算几何</h1>
<h2 id="凸包">凸包</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/erect-the-fence/">587. 安装栅栏</a></li>
</ul>
<h1 id="链表">链表</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/insertion-sort-list/147/">147. 对链表进行插入排序</a></li>
</ul>
<h1 id="dp">dp</h1>
<ul>
<li><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364845">ZOJ 1346 Comparing Your Heroes</a></li>
<li><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
<li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li>
</ul>
<h2 id="旅行商问题">旅行商问题</h2>
<ul>
<li><a href="https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d">毕业旅行问题</a></li>
</ul>
<h1 id="模拟">模拟</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/tag-validator/">591. 标签验证器</a></li>
</ul>
<h1 id="全排列生成算法">全排列生成算法</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></li>
</ul>
<h1 id="快速幂">快速幂</h1>
<h2 id="矩阵快速幂">矩阵快速幂</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1962">P1962 斐波那契数列</a></li>
</ul>
<h1 id="图论">图论</h1>
<h2 id="最短路">最短路</h2>
<h3 id="dijkstra">Dijkstra</h3>
<ul>
<li><a href="https://practice.geeksforgeeks.org/problems/minimum-cost-path3833/1">Minimum Cost Path</a></li>
</ul>
<h1 id="思维">思维</h1>
<ul>
<li><a href="https://www.geeksforgeeks.org/pairs-with-same-manhattan-and-euclidean-distance/">Pairs with same Manhattan and Euclidean distance</a></li>
<li><a href="https://practice.geeksforgeeks.org/problems/geek-collects-the-balls5515/1">Geek collects the balls</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[知识点汇总]]></title>
        <id>http://Bule-Zst.gitee.io/zhi_shi_dian_hui_zong/</id>
        <link href="http://Bule-Zst.gitee.io/zhi_shi_dian_hui_zong/">
        </link>
        <updated>2020-12-26T03:32:26.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要收藏一些平时工作学习中遇到的问题的解决方案，供大家参考。</p>
<h1 id="windows子系统">WIndows子系统</h1>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-6---install-your-linux-distribution-of-choice">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a></li>
</ul>
<h1 id="python">Python</h1>
<ul>
<li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">Python安装包大全</a></li>
<li><a href="https://blog.csdn.net/weixin_45523851/article/details/110674141">Could not build wheels for cryptography which use PEP 517 and cannot be installed directly</a></li>
<li><a href="https://blog.csdn.net/qm5132/article/details/105619531/">python和Microsoft Visual C++ Build Tools版本安装</a></li>
<li><a href="https://blog.csdn.net/pyyong2011/article/details/105045883/">python: cookies 解密问题</a></li>
</ul>
<h1 id="算法">算法</h1>
<ul>
<li><a href="https://blog.csdn.net/qq_33935895/article/details/103261211">[算法]分治法解最近对问题</a></li>
<li><a href="https://blog.csdn.net/q547550831/article/details/51541527">分治法——棋盘覆盖问题</a></li>
<li><a href="https://www.cnblogs.com/l1l1/p/9432876.html">求凸包（安德鲁算法）</a></li>
<li><a href="https://blog.csdn.net/peng0614/article/details/81193484">【计算几何/凸包】安德鲁算法（Andrew's Algorithm）详解</a></li>
</ul>
]]></content>
    </entry>
</feed>