<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2022-01-12T05:41:50.138Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[春招保卫战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/">
        </link>
        <updated>2021-12-10T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录与春招相关的一些内容，包括：</p>
<ul>
<li>明年3月份春招（暑期实习）的备战计划</li>
<li>春招过程中需要注意的地方</li>
</ul>
<hr>
<h2 id="备战阶段">备战阶段</h2>
<h3 id="前言">前言</h3>
<p>Java技术栈+计算机基础+算法+项目+加分项（竞赛/开源项目/博客）</p>
<p>大公司更看重基础知识（八股文），小公司更看中现有能力</p>
<p>边面试边准备，不要等完全准备好再去面试</p>
<h3 id="笔试算法">笔试（算法）</h3>
<ul>
<li><a href="https://www.lintcode.com/cat/">lintcode CAT模式 天梯上分</a></li>
<li><a href="https://codetop.cc/home">CodeTop 汇总互联网大厂面试的高频考题 帮助面试者更有针对性地准备面试</a>
<ul>
<li>可直接定位特定公司、部门的面试题</li>
<li>学长学姐都比较推荐</li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/study/live/489/1/1">左神算法笔面试真题精讲</a></li>
<li><a href="https://www.nowcoder.com/ta/exam-bytedance">牛客网 名企编程真题</a>（企业真题可以多刷刷头条 网易 拼多多）</li>
<li><a href="https://www.nowcoder.com/ta/coding-interviews">牛客网 剑指offer</a></li>
<li><a href="https://www.nowcoder.com/ta/leetcode">牛客网 经典必刷编程题库</a></li>
<li><a href="https://www.nowcoder.com/ta/job-code-high">牛客网 名企高频面试题</a></li>
<li><a href="https://leetcode-cn.com/problem-list/2cktkvj/">LeetCode 热题 HOT 100 官方</a></li>
<li><a href="https://leetcode-cn.com/problem-list/2ckc81c/">LeetCode 精选 TOP 面试题 官方</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/158977583">leetcode 精选 by sergio</a></li>
<li><a href="https://www.yuque.com/office/yuque/0/2020/pdf/619289/1605766958275-87ed48a3-0a68-4433-9d3c-b4ea9c829ccb.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fshenjingwa-o51xg%2Fyh6opc%2Fsqqfew%2Fedit">leetcode 精选</a></li>
<li><a href="https://www.zhihu.com/question/24964987/answer/182447205">lintcode 精选</a></li>
<li><a href="https://www.changgy.com/leetcode-101">LeetCode 101：和你一起你轻松刷题（C++）</a></li>
<li><a href="https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/">JavaGuide</a></li>
<li><a href="http://www.cyc2018.xyz/#%E7%AE%97%E6%B3%95">Cyc2018</a></li>
</ul>
<h3 id="面试题java技术栈计算机基础">面试题（Java技术栈+计算机基础）</h3>
<p><strong>刷面经！</strong></p>
<p>备战阶段，就不要去看书或者视频了，书和视频都是用来系统学习知识的，备战阶段要的就是突击！应试！直接刷 <strong>面试题</strong> 就好~</p>
<h4 id="面经">面经</h4>
<p>面试题：</p>
<ul>
<li>
<p><a href="">自己的春招面经 待补充</a></p>
</li>
<li>
<p><a href="https://www.toutiao.com/i6862994550059696654/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1599958973&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=2020091309025201014708310411A6D669&amp;group_id=6862994550059696654&amp;wid=1639135144091">字节</a> （后面的广告，直接忽略即可）</p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/438229187">字节2</a> （后面的广告，直接忽略即可）</p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/293661?from=zhnkw">合集</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/i29juUTnfOKZQIeY08l4RA">其他</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/762719?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">合集 南大 22届 硕 Java后端</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/629687?source_id=profile_create_nctrack&amp;channel=-1">微软+蚂蚁 南大 22届 硕 Java后端 实习面经</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/802981?type=all&amp;order=recall&amp;pos=&amp;page=2&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">合集</a></p>
</li>
<li>
<p>cxy师兄-面经.docx</p>
</li>
<li>
<p><a href="https://pan.baidu.com/s/1yCCeNMb0FNCJKDIE6EASYA#list/path=%2F">大厂面经合集：美团、腾讯、字节、虾皮 各方向都有</a> 提取码【lrp3】 解压码【jk7z】</p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/172152">合集 C++ 基础架构方向</a></p>
</li>
</ul>
<p>心路历程：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/56655579">cyc2018大佬的面经</a></li>
<li><a href="https://www.nowcoder.com/discuss/762719?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">南大 22届 硕 Java后端</a></li>
</ul>
<h4 id="八股文">八股文</h4>
<p>第一遍刷，抓大放小</p>
<p>要形成自己的八股文文档，方便后期复习</p>
<ul>
<li>
<p><a href="http://bule-zst.gitee.io/2021-09-30-JavaHan/">JavaHan</a></p>
</li>
<li>
<p><a href="https://javaguide.cn/">JavaGuide</a></p>
</li>
<li>
<p><a href="https://cyc2018.github.io/CS-Notes/#/">JavaCyc</a></p>
<ul>
<li>
<p>整理了<a href="http://www.cyc2018.xyz/">cyc2018</a>各部分内容pdf版的页数，方便做计划</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211221102750329.png" style="zoom:60%;" />
</li>
</ul>
</li>
<li>
<p><a href="http://passjava.cn/#/88.Interview/01.Redis/Redis1">PassJava-面试必备</a></p>
</li>
<li>
<p><a href="https://github.com/cosen1024/Java-Interview">「Java面试小抄」一份通向理想互联网公司的面试指南，包括 Java基础、集合、Java并发、JVM、MySQL、Redis、Spring、MyBatis、Kafka、操作系统、计算机网络、系统设计、分布式、Java 项目实战等 by 库森</a></p>
</li>
<li>
<p><a href="https://www.zhihu.com/column/c_1339954942191271936">大厂面试 by 程序员库森</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/820419?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">对线面试官系列之Java集合--面试官看了都说好</a></p>
</li>
<li></li>
<li>
<p>下面内容主要整理了需要掌握的知识点，但是没有答案，可以先看上面的内容，下面的查缺补漏时用</p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/61438?from=zhnkw">JAVA后端秋招/春招准备方向</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/359264954">2021春招Java后端开发面试总结【25个技术专题】超详细！</a></p>
</li>
</ul>
<h3 id="项目">项目</h3>
<ul>
<li>
<blockquote>
<p>对实习项目的描述还不够好，没有把实习内容的闪光点描述出来，也没有讲清楚为什么做这个项目，自己通过什么方法去做，以及最后的结果</p>
<p>cyc2018面经 https://zhuanlan.zhihu.com/p/56655579</p>
</blockquote>
</li>
<li>
<p>如何描述自己的项目：</p>
<ul>
<li>
<p>https://www.cnblogs.com/JavaArchitect/p/7586949.html</p>
<ul>
<li>
<table>
<thead>
<tr>
<th>要素</th>
<th>样式</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。</td>
<td>我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到 JS 等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。</td>
</tr>
<tr>
<td>要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。</td>
<td>我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月</td>
</tr>
<tr>
<td>描述你在项目里的角色</td>
<td>我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。</td>
</tr>
<tr>
<td>可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。</td>
<td>用到了Java里面的集合，JDBC等技术，用到了Spring MVC等框架，用技术连接数据库。</td>
</tr>
<tr>
<td>（这部分的风险自己承担）如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。</td>
<td>这个系统是部署在 Linux 上的，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。</td>
</tr>
</tbody>
</table>
</li>
<li>
<table>
<thead>
<tr>
<th>要避免的情况</th>
<th>正确的做法</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>回答很简单。问什么答什么，往往就用一句话回答</td>
<td>把你知道的都说出来，重点突出你知道的思想，框架</td>
<td>问：你SSH用过吗？答：用过。问：在什么项目里用到？答：一个保险项目问：你做了哪方面的事情？答：开发。面试官直接不问了</td>
</tr>
<tr>
<td>说得太流利</td>
<td>适当停顿，边思考边说</td>
<td>让面试官感觉你在背准备的东西，这样后面问题就很难</td>
</tr>
<tr>
<td>项目介绍时什么都说</td>
<td>就说些刚才让准备的一些，而且要有逻辑地说</td>
<td>会让面试官感觉你思路太乱</td>
</tr>
<tr>
<td>过多介绍技术细节</td>
<td>相关技术点到为止，就说你熟悉的技术，等面试官来问</td>
<td>你说到的所有技术要点，都可能会被深问。面试官一般会有自己的面试节奏，如果你在介绍时就太多说技术细节，很有可能被打断，从而没法说出你准备好的亮点。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>这里只列出了部分，具体内容可以看链接，感觉写的挺好的</p>
</li>
</ul>
</li>
<li>
<p>https://zhuanlan.zhihu.com/p/121136858</p>
</li>
<li>
<p>如何介绍自己的项目：STAR法则（背景+目标+行动+结果）：</p>
<ul>
<li>
<p>基本信息：</p>
<ul>
<li>背景+目标：要做什么</li>
<li>项目整体功能</li>
</ul>
</li>
<li>
<p>重点：</p>
<ul>
<li>
<p>行动：干了什么</p>
<ul>
<li>
<p>简短</p>
<ul>
<li>负责的模块</li>
<li>担任的角色与职责</li>
<li>所用的技术点
<ul>
<li>用了什么技术，同类型的技术有哪些，有什么区别，为什么选择这个</li>
<li>介绍时，只需要提用了什么技术，但是后面 3 个问题需要提前准备，防止面试官问</li>
</ul>
</li>
</ul>
</li>
<li>
<p>详细</p>
<ul>
<li>难点是什么（不知道如何实现 或者 实现后出现了bug）</li>
<li>亮点是什么</li>
<li>技术点：</li>
</ul>
</li>
</ul>
</li>
<li>
<p>结果：</p>
<ul>
<li>项目性能、项目成果</li>
<li>对项目的<strong>思考</strong>（优化点和不足）以及<strong>收获</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="智力题">智力题</h3>
<ul>
<li>智力题（或者叫，逻辑思维题、脑筋急转弯），需要提前准备一下</li>
</ul>
<h3 id="简历">简历</h3>
<ul>
<li>专业技能，注明熟练度：熟悉、熟练掌握、精通</li>
<li>不要罗列技术，而是突出，自己通过 XX 技术实现了什么</li>
<li>简历命名：姓名+学校+岗位</li>
<li><a href="https://www.zhihu.com/zvideo/1289637611880026112?utm_source=qq&amp;utm_medium=social&amp;utm_oi=747689983887814656">建议收藏！小白简历这样改，一秒成为优秀简历！秋招必备，让你offer拿到手软！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2OTY4Nzk1Mw==&amp;mid=2247485451&amp;idx=1&amp;sn=6a722f682d1df07404cc79b5aaf41a87&amp;chksm=fcfba2f5cb8c2be30908bc0bf2146c8203d4f055780d6b64d9b2e5570d96b5b0bfae9d872432&amp;scene=21#wechat_redirect">通过 BAT 面试的程序员简历长什么样? 附简历模板</a></li>
<li><a href="https://cyc2018.github.io/page.html">cyc2018 大佬的网页简历</a></li>
</ul>
<h2 id="春招开始">春招开始</h2>
<h3 id="投递">投递</h3>
<h4 id="心得">心得</h4>
<ul>
<li>
<p>海投！一定要海投！</p>
<ul>
<li>疯狂面试，可以积累经验</li>
<li><strong>但有一点需要注意</strong>，就是如果最终拿到实习资格，然后拒掉，会不会影响后期秋招？这个到时候要再确认一下。</li>
<li>对于一些自己不想去的公司或者部门，也可以试着投递，增加经验（如果是部门，提前了解清楚投递会不会影响到自己想去的部门）</li>
</ul>
</li>
<li>
<p>早投递机会更大</p>
</li>
<li>
<p>知乎了解一下boss直聘，到时候找实习，可以把简历放到boss直聘上</p>
</li>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>首先就是策略，一开始最好不要立刻投大厂，因为一上来就面大厂的话容易崩，刚开始面的人少所以难度也会相对高一些，有的还凑合的会被大厂当备胎，很难受的。其次就是能内推就不要走官网，能免笔试免笔试，不是说笔试难度大还是咋地，这玩意其实是玄学，因为你说你一个人做呢没问题，大神嘛无所谓但是你保不齐别人是一个实验室或者一个班级的人在做，如果遇到点坑的题目，你交代了，别人合作做出来了那你被挂能怪谁呢。还有就是如果大家也是合作做题的话，oj的查重或者作弊系统的判别现在越来越严，如果保不齐你被抓到了，可能就被企业拉黑，然后你还不知道，后面怎么投都没面试机会这是最惨的。还有就是大家都是一起做的，然后分数也差不多，但是别人接到了面试而你没有，我就遇到了这样的情况，就很玄学我都怀疑是随机选的人面试。反正就是笔试有风险，大家还是抱紧学长学姐的大腿，能走内推就内推。但是内推之前还是需要能够了解一下这个部门，大概是做什么的，hc的数量以及技术氛围，这点其实很重要，因为一旦进了流程，你反悔就来不及了，如果过了之后还想换部门那只能重新面试，再走一遍别说多恶心了。其实哪个部门最好或者哪个部门最有前景啥的这些问题，真的很难了解的非常清楚，我就纠结过很久很久，这种事情找不到最优解的，不过还好对我而言现在只是实习。</p>
</blockquote>
</li>
<li>
<p>先拿到保底offer，这样心态会好很多</p>
</li>
</ul>
<h4 id="部门信息整理">部门信息整理</h4>
<p>事业群 &gt; 部门 &gt; 中心 &gt; 小组</p>
<ul>
<li>
<p>微众：</p>
<ul>
<li>贷款科技部：<strong>很核心</strong></li>
</ul>
</li>
<li>
<p>阿里系：</p>
<ul>
<li>阿里集团（简称集团）
<ul>
<li>阿里云：很香</li>
<li>天猫精灵团队：</li>
<li>钉钉：</li>
<li>一面、二面、总监面、交叉部门主管面、HR面；每一面都有一票否决权（包括HR面）</li>
<li>转正是否成功，很大程度上取决于HR</li>
</ul>
</li>
<li>蚂蚁
<ul>
<li>CTO线-数据与平台技术事业群-蚂蚁智能引擎与数据中台技术事业部-大数据部
<ul>
<li>一面、二面、笔试、三面、四面、HR面</li>
</ul>
</li>
</ul>
</li>
<li>听同学群里讨论，集团没有蚂蚁好，至少薪资福利这块，没有蚂蚁好</li>
<li>重视项目</li>
</ul>
</li>
<li>
<p>百度：</p>
<ul>
<li>工程效率部门：做内部工具的，对个人成长并不好</li>
<li>企业智能平台：主要是内部系统，虽然会接触到机器学习和大数据，不太好</li>
</ul>
</li>
<li>
<p>字节：</p>
<ul>
<li>基础架构</li>
<li>今日头条：薪资很诱人
<ul>
<li>头条加面有两种情况，一是三轮评级都是 4 可以评 SSP，二是面试官评价差别很大，再面一轮决定是否录用</li>
</ul>
</li>
<li>Data：核心部门</li>
<li>一面、二面、三面，就可以offer了</li>
<li>重视算法</li>
</ul>
</li>
<li>
<p>荣耀：</p>
<ul>
<li>产品线部门：</li>
</ul>
</li>
<li>
<p>Vivo：</p>
</li>
<li>
<p>华为：</p>
<ul>
<li>Cloud Bu：不错</li>
<li>车BU智能座舱产品部</li>
<li>南研所消费者 BG</li>
<li>cyc2018 拿到了十四级最高的薪资</li>
<li>不怎么问技术，重视学历</li>
</ul>
</li>
<li>
<p>华泰证券</p>
<ul>
<li>信息技术部：base南京</li>
</ul>
</li>
<li>
<p>网易</p>
<ul>
<li>杭研院</li>
<li>网易互联网</li>
<li>网易雷火</li>
</ul>
</li>
<li>
<p>TP-Link</p>
</li>
<li>
<p>腾讯</p>
<ul>
<li>微信事业群：gc学长说 挺好的</li>
<li>上海CSIG：很差</li>
<li>重视算法</li>
</ul>
</li>
<li>
<p>深兰科技</p>
</li>
<li>
<p>创新奇智</p>
</li>
<li>
<p>便利蜂</p>
</li>
<li>
<p>携程旅行</p>
</li>
<li>
<p>旷视</p>
</li>
<li>
<p>小米</p>
</li>
<li>
<p>bilibili</p>
</li>
<li>
<p>商汤</p>
</li>
<li>
<p>度小满</p>
</li>
<li>
<p>美团</p>
<ul>
<li>金服：</li>
<li>到店：</li>
<li>重视项目</li>
</ul>
</li>
<li>
<p>拼多多</p>
</li>
<li>
<p>贝壳</p>
</li>
<li>
<p>快手</p>
</li>
<li>
<p>360</p>
</li>
<li>
<p>外企</p>
<ul>
<li>
<p>微软</p>
<ul>
<li>STCA-M365
<ul>
<li>笔试、一面、Leader面</li>
</ul>
</li>
<li>3轮技术面+1轮AA面，AA面最终决定是否通过</li>
</ul>
</li>
<li>
<p>亚马逊</p>
</li>
<li>
<p>谷歌</p>
</li>
<li>
<p>虾皮</p>
</li>
<li>
<p>重视算法</p>
</li>
</ul>
</li>
</ul>
<h4 id="待投">待投</h4>
<ul>
<li><s><a href="https://mp.weixin.qq.com/s?__biz=MzU1MTU2NjcxMQ==&amp;mid=2247504396&amp;idx=1&amp;sn=200877c58bd016dbd5d66aefbee154a3&amp;chksm=fb8dfe14ccfa770246c8c5ffd15eb455fea3c1e307ecb0f16ef8365c61463f6bde033c40850d&amp;mpshare=1&amp;scene=23&amp;srcid=1216AelYAleMD4XYJuv0n2FJ&amp;sharer_sharetime=1639639282713&amp;sharer_shareid=02cdcbb08350c969c2db9d032c863a6d#rd">微软 22.1.1</a> 放弃 觉得自己没有准备好</s></li>
<li>字节 日常实习</li>
<li>宝洁 22.1.14
<ul>
<li><a href="https://mp.weixin.qq.com/s/STCpEoSpSLIntZglntZJfw">官网</a></li>
<li><a href="https://mp.weixin.qq.com/s/1hKslZkERA8okJuSfhX6rw">实习僧链接</a></li>
</ul>
</li>
</ul>
<h4 id="方向">方向</h4>
<ul>
<li>核心业务 &gt; 核心业务基础架构 &gt; 边缘业务基础架构 &gt; 边缘业务</li>
<li>尽量不要去内部系统开发</li>
</ul>
<h3 id="面试中">面试中</h3>
<ul>
<li>
<p>演技</p>
<ul>
<li>最近读了哪些书：假装读过，然后往八股文引</li>
<li>脑筋急转弯：不要直接给最优解，体现思考过程</li>
</ul>
</li>
<li>
<p>软实力</p>
<ul>
<li>保持自信</li>
<li>学会用积极的情绪感染面试官，提供情绪价值
<ul>
<li>活泼一点、积极向上、大大方方、自然不拘谨</li>
</ul>
</li>
</ul>
</li>
<li>
<p>回答面试官问题时，可以用生动形象的例子，这样可能效果更好，也能体现自己的思考</p>
</li>
<li>
<p>引导面试官</p>
<ul>
<li>面试时灵活点，不要太憨，学会引导面试官</li>
<li>聊项目时，可以引导到八股文</li>
</ul>
</li>
<li>
<p>面试前，看一看对应公司的面经，提前做准备</p>
</li>
<li>
<p>面试时问一下对方是哪个部门的，方便后续面试时做相应的准备</p>
</li>
<li>
<p><a href="https://b23.tv/ajxmk5">如何回答面试官最后一个问题——钻石版-哔哩哔哩</a></p>
</li>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>其次就是面试总结了。面试过程当中我建议大家开启手机录音。这样方便事后复盘，我是每次都会再听一遍自己的录音，不论是写面经还是琢磨自己的回答有录音真的方便很多。因为面试期间的紧张感会让你很难用最好的描述回答清楚问题，那么事后总结就会让你在下次遇到同样的问题的时候回答的更好。如果说大家有小伙伴在一起战斗的话那么经常互相分享经验真的会决定你能不能拿到offer，大家的经验会让你迅速成长，说实话面试实习这2月也是我成长的最快的一个阶段。<br>
最后就是信息。在面试结束的时候，一般面试官都会问：你有什么问题问我。这个时候我个人最经常问的就是这个部门正在做什么，如果我进来我会接触到什么。面试官才是最了解这个部门的人，只有从他的口里得到的信息才是最真实也是最有用的，通过他的回答你会了解到这个部门做的产品或者是使用的技术，对于自己的学习方向也有很大的指向作用。其次，我会问的问题就是：您认为我在哪些方面可以提高自己。这个问题其实从侧面可以让你获取你此次面试的结果。因为这个问题不像问我面试能不能过这样直白的面试禁忌。一般面试官会指明他认为你的缺点，如果他在说的时候带有建议的语气以及对你其他方面的肯定那基本是十拿九稳了，再不济有大佬对你的一个建议指导对你自己查漏补缺也是非常有帮助的。说下我自己的经历吧，我在面阿里云3面的时候，那位p9大佬在我问完这个问题之后不仅肯定了我的一些表现还给我推荐了2本书建议我去阅读，这真的是非常良好的面试体验。</p>
</blockquote>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/56655579">cyc2018大佬的面经</a> 读后总结：</p>
<ul>
<li>
<p>对于面试官的问题，要能回答到点上；对于自己擅长的知识点，要学会展开讲。</p>
</li>
<li>
<p>面试过程中，要表现得比较自信（不要自大，也不要自卑）</p>
</li>
<li>
<p>这次面试我表现地非常自信，自己知道的知识都很有信心地表达出来，被问到不会的内容也不会那么慌张，和面试官探讨一些细节，然后说说自己的想法，还有自己看过相关的内容</p>
</li>
<li>
<p>整个春招过程中，会被拒很多次，但要时刻保持信心</p>
</li>
<li>
<p>要学会把问题往自己擅长的领域引</p>
</li>
<li>
<p>当被问到没有掌握的知识，可以通过讨论的方式，给出大概的思路，因为很多技术都是相通的</p>
</li>
<li>
<blockquote>
<p>位运算的问题，面试官让我之后完善了再发给他，过后我写了详细文档讲解了思路，以及使用 JUnit 进行了详细的单元测试，把文档和代码都发给了他</p>
</blockquote>
</li>
<li>
<blockquote>
<p>非技术问题回答的支支吾吾，然后面试官开始质疑我说的内容，给我压力，我没有当场反驳，就说了“哦，好像是这样的”。因为面试官全程都绷着脸，所以我也比较紧张，很多问题没回答好。</p>
<p>这次面试失败的主要原因是自己在应对这种压力时处理地不是很好，主要体现在失去信心以及紧张。</p>
<p>解决方法也简单，做好充分准备来保持信心，受到质疑的时候积极反驳，紧张的时候及时调整心态，可以试试深呼吸或者喝水。</p>
</blockquote>
</li>
<li>
<p>面试中还会涉及到非技术性问题，要有心理准备</p>
</li>
<li>
<blockquote>
<p>面完之后我立马查了一下那个错排问题，证实了我的答案是正确的，于是写了一个详细的文档，联系 HR 让她发给面试官</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>面试回答不要太简单，适当展开，把知道的都说出来</p>
</li>
<li>
<blockquote>
<ol>
<li>
<p><strong>保持谦逊的态度。</strong>：不要不懂装懂，不会的问题可以自己分析并提出自己的见解，对面试官提出的问题，<strong>可以当成和面试官的一次讨论</strong>，不要紧张。<strong>不会的问题，可以在最后的提问环节，再和面试官深入探讨一波</strong></p>
</li>
<li>
<p><strong>展示对知识的热情</strong>。对面试官提出的问题，你一定要绘声绘色的去回答，讲出自己的理解，而不是非常死板的死记硬背。知识是背下来的还是真正理解的，一般老辣的面试官深入问一下就心里有数了，当然这个是建立你对知识充分了解的基础上。</p>
</li>
<li>
<p>**能说什么就说什么。**面试的时候，永远不是看你知不知道，而是看你知道多少，所以说面试官提出问题，<strong>你在思考的时候，一定要简单提一下你的思考过程</strong>，主要是表现自己掌握的知识量，这样即使你没有回答到点上，你也会比什么都不说得到更好的评价。</p>
</li>
<li>
<p>**尝试和面试官产生共鸣。**也许很多时候，面试官提出的问题，他自己都没有想到答案，所以这个时候你要尝试站在和他同一水平上，进行平等交流讨论，一般来说面试官都会对你产生回应，从而使得这场面试更加和谐，增加你成功的几率。</p>
</li>
<li>
<p>面试完一家，总结好经验，就let it go吧，即使挂了也不要影响信心和心情，面试很多情况看缘分</p>
</li>
<li>
<p>求职过程中别和身边的人对比 ，别自我怀疑，专注于过程，别在意结果，反思总结，心态别崩</p>
</li>
<li>
<p>坚持 <strong>+</strong> 努力 ，不到最后一刻别放弃</p>
<p>by https://zhuanlan.zhihu.com/p/357871900</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>把所有面试中的不顺利都当作是压力面</p>
</li>
<li>
<p>面试难的部门，不一定就是好部门</p>
</li>
<li>
<p>一般是部门HR会先打电话联系我，然后再安排面试官进行面试</p>
</li>
<li>
<p>维护好自己的面评</p>
<ul>
<li>放弃春招面试，可能导致秋招不给面试机会</li>
<li>任何一场面试，都不要放松，都要重视</li>
<li>不要相信“提前批 不影响 正式批”，任何一场面试都会有面评记录，后续面试面试官会看的！</li>
</ul>
</li>
<li>
<p>面试时，遇到不会的知识点，不用担心，面试更看重的是思维+表达+沟通+学习能力，而不是已经掌握了多少</p>
</li>
</ul>
<h3 id="内推">内推</h3>
<ul>
<li>
<p>lzy 上海 量化</p>
</li>
<li>
<p>误入凡尘里 B站</p>
</li>
<li>
<p>xxb 阿里云</p>
</li>
<li>
<p>gc 微信</p>
</li>
<li>
<p>字节</p>
<ul>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>有想加入字节跳动 <strong>基础架构</strong> 的同学可以找我内推呀 大量实习和提前批HC！（请搜索基础架构才是~）<br>
直推部门老大直接面试无笔试：可以把简历发送至<a href="mailto:zhuhaochuan.snow@bytedance.com">zhuhaochuan.snow@bytedance.com</a> （注明实习还是校招，岗位）<br>
投递链接：https://job.toutiao.com/s/JNAvu8A<br>
内推码:QDZH4QP</p>
</blockquote>
</li>
<li>
<p>liuqiyang@bytedance.com</p>
</li>
</ul>
</li>
<li>
<p>北京图森未来</p>
<ul>
<li>
<blockquote>
<p>基础架构</p>
<p>目前我也是图森在南京大学的校园大使，大家有想去实习和工作的可以私信我内推呀</p>
<p>https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="春招后">春招后</h2>
<ul>
<li>就算春招失利，也不要灰心，秋招还有机会，参考cyc2018大佬的经历</li>
</ul>
<h2 id="暑期实习-and-秋招">暑期实习 and 秋招</h2>
<ul>
<li>秋招也要早做准备！</li>
<li>实习时，可以利用晚上和周末时间来自我提升，因为还需要为秋招做准备</li>
<li>不要相信实习单位所谓的“一定可以转正成功”</li>
<li>秋招的面试表现直接影响薪资，且竞争激烈程度大于春招，要更加重视</li>
<li>秋招很重要，不要为了实习转正牺牲秋招，<strong>给自己更多的选择</strong></li>
</ul>
<h2 id="秋招后">秋招后</h2>
<ul>
<li>秋招结束也不要放弃机会，有一些补录以及春招的机会，说不定比秋招的offer更好</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java锁机制详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/</id>
        <link href="http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/">
        </link>
        <updated>2021-12-07T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习Java锁机制过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1YB4y1P7xC?p=1">多线程高并发底层锁机制与优化最佳实践</a></li>
</ul>
<hr>
<h2 id="synchronized">Synchronized</h2>
<p>在普通方法上加synchronized，锁的是对象</p>
<p>在静态方法上加synchronized，锁的是class</p>
<h3 id="实现">实现</h3>
<h4 id="jdk16之前">jdk1.6之前</h4>
<p>对 对象内部的monitor对象 进行加锁，如果加锁失败，进入等待队列，当锁释放时，从等待队列中依次唤醒线程</p>
<ul>
<li>非公平锁：先尝试获取锁，如果失败，则进入等待队列</li>
<li>公平锁：直接进入等待队列</li>
</ul>
<p>缺点：</p>
<ul>
<li>重量级锁</li>
<li>线程挂起和唤醒时，需要从用户态切换到内核态
<ul>
<li>之所以需要切换到内核态，是因为，挂起和唤醒操作，是依赖于内核程序完成的，只有进入内核态，才能调用内核中的方法</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_42013590/article/details/107327439">什么是CPU的用户态和内核态</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[脑裂问题]]></title>
        <id>http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/</id>
        <link href="http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/">
        </link>
        <updated>2021-11-06T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习脑裂问题过程中的笔记。</p>
<hr>
<h2 id="什么是脑裂问题">什么是脑裂问题</h2>
<p>简单说，就是在一个集群中，出现两个master节点</p>
<p>原本，一个集群中，只有一个master节点，可以看做是大脑，现在出现了两个，或者多个，就可以想象成大脑分裂了，所以叫脑裂问题</p>
<h2 id="成因以及造成的后果">成因以及造成的后果</h2>
<p>主要是由网络通信故障导致的</p>
<p>一般来说，集群中的master节点都是选举产生的，想象一下，假设两个机房之间出现了通信故障，那么分处于两个机房中的节点就会各自选举出master节点，当网络恢复时，就不知道该听哪个master节点的了。</p>
<h2 id="如何避免">如何避免</h2>
<p>知道了成因，那么，想解决脑裂问题，就需要避免假死亡现象的产生，因为如果master节点正常死亡，监控节点重新选举master节点，是不会产生脑裂问题的。</p>
<p>有以下三种常见方法：</p>
<ul>
<li>
<p>冗余通信：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信</p>
</li>
<li>
<p>过半机制（Quorum）：zookeeper采用的防止脑裂问题的方法，通过这个机制，可以确保就算发生了网络故障，也只会有一个master节点被选出</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211106134247658.png" alt="image-20211106134247658" loading="lazy"></figure>
</li>
<li>
<p>共享存储隔离（Fencing）：能看到共享资源的节点就表示在集群中，能够获得共享资源的锁的节点就是master，看不到共享资源的节点就不在集群中</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://blog.csdn.net/u013374645/article/details/93140148">面试题：Zookeeper是如何解决脑裂问题</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/394160966">分布式系统的“脑裂”到底是个什么玩意？</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/u014156013/article/details/81226424">脑裂问题以及如何避免</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaHan]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-30-JavaHan/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-30-JavaHan/">
        </link>
        <updated>2021-09-30T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>本人的面试八股文（面试小抄），供大家参考。</p>
<p>JavaHan，致敬 JavaGuide，Han指的是憨，并且感觉读起来比较顺口。</p>
<p>为了方便检索，我把所有内容都放在一个文档中的。</p>
<hr>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="概述">概述</h3>
<h4 id="isp">ISP</h4>
<p>互联网服务提供商</p>
<p>ISP 可以从 互联网管理机构 获得许多 IP 地址，个人或机构向 ISP 缴纳一定的费用就可以接入互联网</p>
<h4 id="osi模型-五层模型与-tcpip-模型">OSI模型、五层模型与 TCP/IP 模型</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211217120543019.png" alt="image-20211217120543019" style="zoom:45%;" />
<p>五层模型：</p>
<ul>
<li>物理层：负责在<strong>具体媒体</strong>上传输数据<strong>比特流</strong>，为 数据链路层 屏蔽具体的媒体特性。</li>
<li>数据链路层：负责在<strong>具体链路</strong>上传输<strong>数据帧</strong>，为 网络层 屏蔽具体链路信息（网络层中，主机间的传输，需要经过多条链路）。</li>
<li>网络层：负责在<strong>主机间</strong>传输<strong>数据分组</strong>，为 传输层 屏蔽主机信息。</li>
<li>传输层：负责在<strong>进程间</strong>传输数据，为 应用层 屏蔽进程信息。
<ul>
<li>TCP：传输控制协议，面向连接、可靠的数据传输服务，数据单位为<strong>报文段</strong></li>
<li>UDP：用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是<strong>用户数据报</strong></li>
</ul>
</li>
<li>应用层：负责在<strong>应用间</strong>传输<strong>报文</strong>，例如HTTP、DNS协议。</li>
<li>越底层，数据量越大，逐层封装。</li>
</ul>
<p>OSI模型：</p>
<ul>
<li>表示层：负责数据处理，比如，压缩、加密等，使 应用层 无需关心数据内部格式方面的问题。</li>
<li>会话层：负责会话的连接、维护、断开等。当应用间需要传输数据时，首先需要建立会话；当数据传输完时，会话层会有选择地进行会话的维护；最终，会话层会断开会话。</li>
<li>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</li>
</ul>
<p>TCP/IP 模型：</p>
<ul>
<li>将五层模型中的数据链路层和物理层合并为网络接口层</li>
</ul>
<h3 id="物理层">物理层</h3>
<h3 id="链路层">链路层</h3>
<h4 id="信道复用技术41种">信道复用技术（4+1种）</h4>
<ul>
<li>
<p>频分复用</p>
</li>
<li>
<p>时分复用（TDM）：为每个用户分配固定位置的时隙</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:37%;" />
</li>
<li>
<p>统计时分复用（异步时分复用，STDM）：不固定每个用户在时分复用帧中的位置，只要有数据，就为其分配时隙，用户拿到时隙后，就可以发送数据（注意区分两张图中字母的顺序）</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:37%;" />
</li>
<li>
<p>波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
</li>
<li>
<p>码分复用</p>
</li>
</ul>
<h4 id="ppp-协议">PPP 协议</h4>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<h4 id="arp-地址解析协议">ARP 地址解析协议</h4>
<p>ARP 协议负责根据 IP 地址获取 MAC 地址。</p>
<p>实现原理：每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果某 IP 地址不存在，则通过广播的形式获取。MAC 地址</p>
<p>MAC 地址是链路层地址，长度为 6 字节（6*8=48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h4 id="网络设备">网络设备</h4>
<ul>
<li>集线器：
<ul>
<li>物理层设备，作用于 比特</li>
<li>当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口</li>
<li>如果集线器同时收到两个不同接口的帧，那么就发生了碰撞</li>
</ul>
</li>
<li>交换机：
<ul>
<li>链路层设备，作用于 帧</li>
<li>不会发生碰撞</li>
<li>能根据 MAC 地址进行存储转发</li>
<li>具有自学习能力，能自动生成 交换表</li>
</ul>
</li>
</ul>
<h3 id="网络层">网络层</h3>
<h4 id="概述-2">概述</h4>
<p>网络层的作用：使用 IP 协议，将异构的物理网络连接起来，使得其看起来好像是一个统一的网络</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" alt="img" style="zoom:37%;" />
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>
<p>地址解析协议 ARP（Address Resolution Protocol）</p>
</li>
<li>
<p>网际控制报文协议 ICMP（Internet Control Message Protocol）</p>
</li>
<li>
<p>网际组管理协议 IGMP（Internet Group Management Protocol）</p>
</li>
</ul>
<h4 id="ip-协议">IP 协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom:65%;" />
<p>IP 地址能够在网络世界唯一标识一台电脑，IP 地址一共有32位，即8个字节。</p>
<p>IP 地址的编址方式的三个历史阶段：</p>
<ul>
<li>分类编址：
<ul>
<li>不同分类具有不同的网络号长度，并且是固定的</li>
<li>网络号+主机号</li>
<li>网络地址：指的是，网络号不变，主机位二进制全为0的 ip 地址，类似于电话号码的区号</li>
<li>要达到 Internet 上的某个主机，先利用 IP 地址的高位部分（网络地址）找到该主机所在的网络，再利用 IP 地址的低位部分（主机地址）找到该网络中的主机。</li>
<li>子网掩码，又叫网络掩码、地址掩码。它的作用是，用来指明某个 IP 地址哪些标识位是网络地址，哪些标识位是主机地址</li>
</ul>
</li>
<li>子网划分编址：
<ul>
<li>网络号+子网号+主机号</li>
<li>举例：B 类地址的默认子网掩码为 255.255.0.0（11111111 11111111 00000000 00000000），如果子网占两个比特，那么子网掩码为 255.255.192.0（11111111 11111111 11000000 00000000）</li>
</ul>
</li>
<li>无分类编址（CIDR）：
<ul>
<li>网络前缀号+主机号</li>
<li>在 IP 地址后面加上网络前缀长度，例如，128.14.35.7/20</li>
<li>路由聚合与最长前缀匹配：
<ul>
<li>路由聚合：将 200.23.a.b/23 与 200.23.c.d/23 进行聚合，得到200.23.x.x/20，减少路由表项的数量</li>
<li>最长前缀皮配：如果路由表中存在 A: 200.23.18.0/23 和 B: 200.23.x.x/20，则对于 200.23.18.0/23，选择A与之进行匹配（虽然 B 也能进行匹配，但是不是最长的）</li>
<li>参考：https://blog.csdn.net/iostream1001001/article/details/78126150</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="icmp-网际控制报文协议">ICMP 网际控制报文协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt="img" style="zoom:43%;" />
<p>放在 IP 数据报的数据部分，用于实现一些特定的功能，目的是为了更有效地转发 IP 数据报和提高交付成功的机会。</p>
<p>ICMP 的应用：</p>
<ul>
<li>Ping：用于测试两台主机之间的连通性。</li>
<li>Traceroute：用来跟踪一个数据分组从源点到终点的路径</li>
</ul>
<h4 id="vpn-虚拟专用网">VPN 虚拟专用网</h4>
<p>如何理解：</p>
<ul>
<li>
<p>首先，什么是专用网？主机需要分配 IP 地址才能上网，但往往，一个机构能申请到的 IP 地址是有限的，因此，只能为主机分配本机构内部有效的专用地址。主机间使用专用地址进行通信，构成专用网。</p>
</li>
<li>
<p>什么是虚拟专用网？指的是，该专用网其实是依托于互联网形成的，所以不是实实在在的专用网，而是虚拟专用网。主机 A 向主机 B 发送数据，数据报的源地址和目的地址都是专用地址，在路由器中，会对数据报进行加密、封装，新的数据报源地址和目的地址都是全球地址。在目的路由接收后，再对数据报进行解密，然后根据专用地址进行转发。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt="img" style="zoom:35%;" />
</li>
</ul>
<h4 id="nat-网络地址转换">NAT 网络地址转换</h4>
<p>功能：将专业地址转换成全球地址，或将全球地址转换成专用地址，使得机构内部主机可以上网。</p>
<p>实现：</p>
<ul>
<li>将本地 IP 和全球 IP 一一对应</li>
<li>缺点：拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网</li>
<li>解决方案：NAPT 网络地址与端口转换（将传输层的端口号也用上）</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2719067e-b299-4639-9065-bed6729dbf0b.png" alt="img" style="zoom:63%;" />
<h4 id="路由器">路由器</h4>
<p>位于网络层，只负责主机间的数据传输</p>
<p>功能：路由选择与分组转发</p>
<h4 id="路由选择协议">路由选择协议</h4>
<ul>
<li>
<p>内部网关协议</p>
<ul>
<li>
<p>RIP 路由信息协议：基于距离，依靠路由器间交换路由表，获取整个网络的距离信息</p>
</li>
<li>
<p>OSPF 开放式最短路径优先协议：</p>
<ul>
<li>基于 Dijkstra 提出的最短路径算法 SPF</li>
<li>向内部网络中的所有路由器发送信息，且只有当链路状态发生变化时，路由器才会发送信息，因此信息更新过程收敛得更快</li>
</ul>
</li>
</ul>
</li>
<li>
<p>外部网关协议</p>
<ul>
<li>
<p>BGP 边界网关协议</p>
<ul>
<li>
<p>AS 之间的路由选择很困难，因此，BGP 只能寻找一条比较好的路由，而不是最佳路由</p>
</li>
<li>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" alt="img" style="zoom:63%;" />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传输层">传输层</h3>
<h4 id="udp-vs-tcp">UDP vs TCP</h4>
<ul>
<li>TCP：
<ul>
<li>传输控制协议，面向连接、可靠（超时重传）的数据传输服务，数据单位为<strong>报文段</strong></li>
<li>每一条 TCP 连接，只能一对一</li>
<li>有流量控制、拥塞控制</li>
<li>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li>
</ul>
</li>
<li>UDP：
<ul>
<li>用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是<strong>用户数据报</strong></li>
<li>n对n，n &gt;= 1</li>
<li>无流量控制、拥塞控制</li>
<li>面向报文（对应用层传下来的报文不合并也不拆分，只是添加 UDP 首部）</li>
</ul>
</li>
</ul>
<h4 id="tcp-的三次握手">TCP 的三次握手</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:43%;" />
<ul>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的<strong>序号 x</strong>。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，<strong>确认号为 x+1</strong>，同时也选择一个初始的<strong>序号 y</strong>。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，<strong>确认号为 y+1</strong>，序号为 <strong>x+1</strong>。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p>三次握手的原因：</p>
<ul>
<li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</li>
<li>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</li>
</ul>
<h4 id="tcp-的四次挥手">TCP 的四次挥手</h4>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认报文，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认报文，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>进入 TIME_WAIT 状态的原因</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h4 id="tcp-的滑动窗口">TCP 的滑动窗口</h4>
<p>发送方和接收方，都有滑动窗口，接收方通过报文告知发送方自己窗口（接收窗口）的大小，发送方根据接收窗口大小以及其它信息（见拥塞控制那一节）设置自己窗口（发送窗口）的大小</p>
<p>当发送窗口左侧字节收到确认，右移发送窗口，直到左部第一个字节不是已确认的状态</p>
<p>接收窗口只会按需进行确认，确认后，右移接收窗口。因此，对于发送窗口来说，收到某个字节的确认，就说明，此字节之前的字节，接收方都已接收。</p>
<h4 id="tcp-的流量控制">TCP 的流量控制</h4>
<p>接收方通过确认报文中的窗口字段 <strong>影响</strong> 发送窗口的大小，从而 <strong>影响</strong> 发送速率（注意，我这里用的是 <strong>影响</strong>，而不是 <strong>控制</strong>，见 拥塞控制 那一节，思考原因）</p>
<p>将窗口字段设置为0，则发送方不能发送数据</p>
<h4 id="tcp-的拥塞控制">TCP 的拥塞控制</h4>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>发送窗口大小 = min{ 接收方允许的窗口大小（由确认报文指定），拥塞窗口变量（cwnd） }</p>
<p>拥塞控制算法（慢开始、拥塞避免、快重传、快恢复）流程：</p>
<ul>
<li>
<p>将 cwnd 设置为1（<strong>慢开始</strong>）</p>
</li>
<li>
<p>每次当收到确认报文后，将 cwnd 加倍</p>
<ul>
<li>当 cwnd &gt;= 慢开始门限 ssthresh 后， cwnd 每次只加一（<strong>拥塞避免</strong>）</li>
</ul>
</li>
<li>
<p>如果出现超时，令 ssthresh = cwnd / 2，然后重新执行慢开始（回到第一步）</p>
</li>
<li>
<p>如果连续收到 3 次重复确认，则说明报文段丢失</p>
<ul>
<li>立即重传丢失报文（快重传）</li>
<li>并令 ssthresh = cwnd / 2，cwnd = ssthresh （<strong>快恢复</strong>：无需重新执行慢开始）</li>
</ul>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="img" style="zoom:53%;" />
</li>
</ul>
<h3 id="应用层">应用层</h3>
<h4 id="ftp-文件传送协议">FTP 文件传送协议</h4>
<p>使用 TCP 进行连接，需要两个连接来传送一个文件：控制连接+数据连接</p>
<h4 id="dhcp-动态主机配置协议">DHCP 动态主机配置协议</h4>
<p>由 DHCP 服务器提供配置信息，无需用户手动进行配置。</p>
<p>配置信息包括：IP 地址、子网掩码、网关 IP 地址</p>
<p>DHCP 工作过程：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<h4 id="电子邮件协议">电子邮件协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" alt="img" style="zoom:53%;" />
<p>电子邮件协议包括：SMTP、POP3、IMAP</p>
<ul>
<li>
<p>发送协议：用于将电子邮件从发送服务器发送到接收服务器</p>
<ul>
<li>SMTP 简单邮件传送协议：，但只支持 ASCII 码的邮件主体。为了解决这个问题，增加了 MIME 多用途互联网邮件扩展类型，MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</li>
</ul>
</li>
<li>
<p>读取协议：用于将电子邮件从接收服务器读取到客户端</p>
<ul>
<li>
<p>POP3 邮件读取协议：单向通信，从服务器到客户端。旧版中，用户从服务器读取邮件后，就会把邮件删除，新版中可以不删除邮件。</p>
</li>
<li>
<p>IMAP 网际报文存取协议：双向通信，客户端和服务器上的邮件保持同步，可以同步文件夹、分类等信息。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/v2-dd366f60ce8a2908e36bcc53a57fc615_720w.jpg" alt="img" style="zoom:90%;" />
</li>
</ul>
</li>
</ul>
<h4 id="http-超文本传输协议">HTTP 超文本传输协议</h4>
<p><strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</p>
<h5 id="url">URL</h5>
<p>全称：统一资源定位符（<strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator），用于定位资源</p>
<p>URL 是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，在 URI 的基础上增加了定位能力</p>
<p>URI 除了包含 URL，还包含 URN（<strong>U</strong>niform <strong>R</strong>esource <strong>N</strong>ame，统一资源名称），用来定义一个资源的名称，但不具备定位该资源的能力。例如，urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img" style="zoom:50%;" />
<h5 id="http-状态码">HTTP 状态码</h5>
<p><strong>1XX 信息</strong></p>
<ul>
<li><strong>100 Continue</strong> ：表明到目前为止一切正常，客户端可以发送后续请求或者忽略这个响应。</li>
</ul>
<p><strong>2XX 成功</strong></p>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容，即，不返回全部实体，只返回部分实体。</li>
</ul>
<p><strong>3XX 重定向</strong></p>
<ul>
<li><strong>300 Multiple Choices</strong></li>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。也就是说，对于 303，重定向时一定使用 GET 方法，对于 301 和 302，理论上不应该改变请求方法，但是一般浏览器都会把请求方法改成 GET。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<p><strong>4XX 客户端错误</strong></p>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
<li><strong>406 Not Acceptable</strong></li>
<li><strong>416 Requested Range Not Satisfiable</strong></li>
</ul>
<p><strong>5XX 服务器错误</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h5 id="连接管理">连接管理</h5>
<p>短连接与长连接：当浏览器访问一个包含多张图片的 HTML 页面时，需要请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>。从 HTTP/1.1 开始默认是长连接的，之前默认是短连接，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</p>
<p>流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h5 id="cookie">Cookie</h5>
<ul>
<li>概述：HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 数据保存在客户端本地。Cookie 曾一度用于客户端数据的存储，但现在，Cookie 渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</li>
<li>用途：
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li>创建过程：服务器发送的响应报文包含 <strong>Set-Cookie 首部字段</strong>，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 <strong>Cookie 请求首部字段</strong>发送给服务器。</li>
<li>分类：
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。在 Set-Cookie 字段中指定。</li>
</ul>
</li>
<li>作用域：
<ul>
<li>Domain 标识：指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名（如 developer.mozilla.org）中。</li>
<li>Path 标识：指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：/docs、/docs/Web/。</li>
</ul>
</li>
<li>JavaScript：
<ul>
<li>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问<strong>非 HttpOnly 标记</strong>的 Cookie。</li>
<li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li>
</ul>
</li>
<li>Secure 标识：
<ul>
<li>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。</li>
<li>但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li>
</ul>
</li>
<li>Session：
<ul>
<li>Session 数据存储在服务端</li>
<li>使用过程：将数据存储在服务端，生成唯一 Session ID，将 Session ID 作为 Cookie 传给客户端，客户端之后的每个请求都会带有该 Session ID。</li>
<li>Session ID 安全性问题：应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，避免产生容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li>
<li>若浏览器禁用 Cookie，则需要使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</li>
<li>Cookie VS Session：
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="虚拟主机">虚拟主机</h5>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h5 id="代理">代理</h5>
<p>目的：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>分类：</p>
<ul>
<li>正向代理：用户察觉得到</li>
<li>反向代理：一般位于内部网络中，用户察觉不到</li>
</ul>
<h5 id="https">HTTPS</h5>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>被窃听：使用明文进行通信，内容可能会被窃听；</li>
<li>被伪装：不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>被篡改：无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p>实现方法：</p>
<ul>
<li>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer 安全套接字协议）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</li>
<li>SSL 是一种为网络通信提供安全及数据完整性的一种安全协议，在传输层与应用层之间对网络连接进行加密。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ssl-offloading.jpg" alt="img" style="zoom:50%;" />
<h6 id="加密">加密</h6>
<ul>
<li>对称密钥加密：加密和解密使用同一密钥，运算速度快，无法安全地将密钥传输给通信方</li>
<li>非对称密钥加密：加密和解密使用不同的密钥，运算速度慢，可以更安全地将公开密钥传输给通信发送方，除了用来加密，还可以用来进行签名</li>
<li>HTTPS 采用的加密方式：混合加密机制
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的密钥，从而保证安全性</li>
<li>获取到密钥后，再使用对称密钥加密方式进行通信，从而保证效率</li>
</ul>
</li>
</ul>
<h6 id="认证">认证</h6>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<h6 id="完整性保护">完整性保护</h6>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h6 id="缺点">缺点</h6>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h3 id="综合应用-web-页面请求过程">综合应用-Web 页面请求过程</h3>
<h4 id="dhcp-配置主机信息">DHCP 配置主机信息</h4>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 协议来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，并将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
</ul>
<h4 id="arp-解析-mac-地址">ARP 解析 MAC 地址</h4>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li></li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<h4 id="dns-解析域名">DNS 解析域名</h4>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<h4 id="http-请求页面">HTTP 请求页面</h4>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。（其实和上面所提到的 ARP 协议一样，知道了 IP 地址后，依旧需要获取 MAC 地址，但是为了避免冗余，这里就不写了）</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
<h3 id="socket-套接字">Socket 套接字</h3>
<h4 id="概述-3">概述</h4>
<p>什么是套接字？答：Socket。</p>
<p>那么，什么是Socket？</p>
<ul>
<li>
<p>它本质上是一组接口，或者说一种抽象。</p>
</li>
<li>
<p>谁的接口？谁的抽象？传输层协议的接口或抽象。</p>
</li>
<li>
<p>它有什么用？应用层协议，通过 Socket 可以与传输层协议进行通信。</p>
</li>
<li>
<p>没有 Socket 行不行？不行，如果没有 Socket，那么传输层的协议就只是一种概念，无法具体使用。</p>
<ul>
<li>
<blockquote>
<p>TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样。<br>
<strong>TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口</strong>。</p>
<p>by https://blog.csdn.net/github_34606293/article/details/78230456</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="io-模型">I/O 模型</h4>
<p>一个 输入操作 通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，</p>
<ul>
<li>第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。</li>
<li>第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ul>
<h5 id="阻塞式-io">阻塞式 I/O</h5>
<p>应用进程被阻塞，直到数据从 内核缓冲区 复制到 应用进程缓冲区 中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，<strong>这种模型的 CPU 利用率会比较高</strong>。</p>
<p>注意看图，可以加深理解</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492928416812_4.png" alt="img" style="zoom:80%;" />
<h5 id="非阻塞式-io">非阻塞式 I/O</h5>
<p>应用进程执行 recvfrom 之后，如果数据未准备好，则内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知数据是否准备好，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929000361_5.png" alt="img" style="zoom:80%;" />
<h5 id="io-复用selectpollepoll">I/O 复用（select/poll/epoll）</h5>
<p>使用 select, poll 或 epoll 等待数据，可以同时等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>I/O 复用使得单个进程可以同时处理多个 I/O 事件。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么对于每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929444818_6.png" alt="img" style="zoom:80%;" />
<h5 id="信号驱动式-iosigio">信号驱动式 I/O（SIGIO）</h5>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929553651_7.png" alt="img" style="zoom:80%;" />
<h5 id="异步-ioaio">异步 I/O（AIO）</h5>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。（看图更清晰）</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492930243286_8.png" alt="img" style="zoom:80%;" />
<h5 id="5-种-io-的比较">5 种 I/O 的比较</h5>
<p>这一节主要讨论同步/异步、阻塞/非阻塞的问题，参考：https://www.zhihu.com/question/19732473</p>
<p>首先讲概念</p>
<ul>
<li>同步与异步：主要看调用结果是如何返回的。如果调用结果是由调用者主动等待得到的，那么就算是<strong>同步</strong>；如果调用结果最终是由被调用者主动通知调用者的（比如通过回调函数），那就就算<strong>异步</strong>。</li>
<li>阻塞与非阻塞：主要看等待结果过程中，调用者的状态。如果等待过程中，调用者啥事都不做，那就是<strong>阻塞</strong>；如果等待过程中，调用者做了别的事，那就是<strong>非阻塞</strong>。</li>
</ul>
<p>分类：</p>
<ul>
<li>阻塞式 I/O：同步 阻塞</li>
<li>非阻塞式 I/O：同步 第一阶段非阻塞 第二阶段阻塞</li>
<li>I/O 复用：同步 阻塞</li>
<li>信号驱动式 I/O：第一阶段异步非阻塞 第二阶段同步阻塞</li>
<li>异步 I/O：异步 非阻塞</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492928105791_3.png" alt="img" style="zoom:80%;" />
<h4 id="io-复用">I/O 复用</h4>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h5 id="select-vs-poll">select vs poll</h5>
<ul>
<li>select 和 poll 都可以允许应用程序监听一组文件描述符的状态变化</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
<ul>
<li>有可能函数调用会立即返回</li>
<li>也有可能，会持续监听，超时返回</li>
<li>也有可能，会返回成功，但是读取时报错</li>
</ul>
</li>
<li>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从 应用进程缓冲区 复制到 内核缓冲区（因为 select 和 poll 是系统调用，所以需要将数据拷贝到内核）（<a href="https://bbs.csdn.net/topics/390696333">参考资料</a>）</li>
<li>几乎所有系统都支持 select，部分系统不支持 poll。</li>
</ul>
<h5 id="epoll">epoll</h5>
<p><code>epoll_create()</code> 用于创建 epoll 对象</p>
<p><code>epoll_ctl()</code> 用于向内核注册新的描述符或者是改变某个文件描述符的监听事件</p>
<p><code>epoll_wait()</code> 用于得到事件完成的描述符</p>
<p>已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数，内核会将 I/O 准备好的描述符加入到一个链表中进行管理，等待 <code>epoll_wait()</code> 的调用</p>
<p>从上面的描述可以看出</p>
<ul>
<li>epoll 只需要将描述符从 进程缓冲区 向 内核缓冲区 拷贝一次（select 和 poll 需要再拷贝出来，然后通过遍历获取事件完成的描述符，而 epoll 只需要通过 <code>epoll_wait()</code> 直接获取事件完成的描述符）</li>
<li>并且进程不需要通过轮询来获得事件完成的描述符（<code>epoll_wait()</code>）</li>
</ul>
<p>epoll 仅适用于 Linux OS</p>
<p>epoll 和 poll 一样，没有描述符数量限制</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况（当文件描述符关闭，就会从监听列表中删除）</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_27529917/article/details/82945450">Select和Epoll底层实现的区别</a></li>
<li><a href="https://blog.csdn.net/xiaowenmu1/article/details/90108663">epoll在多线程下的使用</a></li>
</ul>
<h5 id="selectpollepoll-的应用场景">select/poll/epoll 的应用场景</h5>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<ul>
<li>select：
<ul>
<li>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</li>
<li>select 可移植性更好，几乎被所有主流平台所支持。</li>
</ul>
</li>
<li>poll：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li>
<li>epoll：
<ul>
<li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接（因为对于 epoll，描述符是存储在内核中的，所以如果是长连接，就可以一直让内核进行监听）</li>
<li>需要监听的描述符对应的监听事件变化多，而且都非常短暂，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的监听事件改变都需要通过 <code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</li>
</ul>
</li>
</ul>
<h2 id="操作系统">操作系统</h2>
<h3 id="概述-4">概述</h3>
<p>4 个基本特征：并发、共享、虚拟、异步</p>
<p>并发 与 并行：</p>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<p>用户态与内核态：如果一个进程在用户态需要使用内核态的功能，就需要进行系统调用从而陷入内核，由操作系统代为完成相应功能。</p>
<h3 id="进程管理">进程管理</h3>
<h4 id="进程-vs-线程">进程 VS 线程</h4>
<ul>
<li>进程：资源分配的基本单位</li>
<li>线程：独立调度的基本单位</li>
<li>区别与联系
<ul>
<li>一个 进程 中可以有多个 线程，它们共享 进程 资源</li>
<li>线程 不拥有资源，但可以访问 隶属进程 的资源</li>
<li>进程 和 线程 都可被调度，隶属不同进程的线程的切换会引起进程切换</li>
<li>开销不同：
<ul>
<li>进程：
<ul>
<li>创建或撤销：分配或回收资源，如内存空间、I/O 设备等</li>
<li>切换：当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置</li>
</ul>
</li>
<li>线程：
<ul>
<li>切换：只需保存和设置少量寄存器内容</li>
</ul>
</li>
</ul>
</li>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助特定的方法（进程间通信，IPC）</li>
</ul>
</li>
</ul>
<h4 id="进程状态">进程状态</h4>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待除 CPU 时间以外的资源</li>
</ul>
<h4 id="进程调度算法">进程调度算法</h4>
<p>不同系统的调度算法目标不同，因此需要针对不同系统来讨论调度算法</p>
<h5 id="批处理系统">批处理系统</h5>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 最短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死（处于一直等待短作业执行完毕的状态）：因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的<strong>抢占式</strong>版本，按剩余运行时间的顺序进行调度。</p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h5 id="交互式系统">交互式系统</h5>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系。</p>
<p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上层队列没有进程在排队，才能调度下层队列上的进程。</p>
<p>可以将这种调度算法看成是 时间片轮转调度算法和优先级调度算法的结合。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" style="zoom:80%;" />
<h5 id="实时系统">实时系统</h5>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时：</p>
<ul>
<li>硬实时：必须满足绝对的截止时间</li>
<li>软实时：可以容忍一定的超时</li>
</ul>
<h4 id="进程同步">进程同步</h4>
<h5 id="临界资源与临界区">临界资源与临界区</h5>
<p>临界资源：一次只能供一个进程使用的资源</p>
<p>对临界资源进行访问的那段代码称为临界区</p>
<h5 id="互斥-同步与通信">互斥、同步与通信</h5>
<p>进程通信的详细内容看后续章节，这里只是先简单描述一下它们之间在概念上的异同</p>
<ul>
<li>互斥：解决进程间竞争关系（间接制约关系）的手段
<ul>
<li>互斥比较好理解，就是解决进程间的竞争，最典型的例子就是对资源的进程，如临界资源</li>
</ul>
</li>
<li>同步：解决进程间协作关系（直接制约关系）的手段
<ul>
<li>进程间有时需要合作完成某项任务，当某个进程提前完成后，需要等待其他进程完成才能继续，此时就需要进程同步来解决这个问题。也就是说，进程同步解决的是，进程间执行顺序的问题。</li>
<li>互斥也可以看做是一种进程同步，通过资源的竞争，使得两个进程间产生了先后关系，即进程 A 必须等待进程 B 执行完才能继续。</li>
</ul>
</li>
<li>通信：进程间互相发送数据
<ul>
<li>进程同步也可以看做是一种进程通信，但是进程同步往往是在进程间发送信号，而不是实际的数据</li>
<li>进程通信是一种手段，而进程同步是一种目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</li>
</ul>
</li>
</ul>
<p>参考：https://blog.csdn.net/weixin_41413441/article/details/80548683</p>
<h5 id="信号量">信号量</h5>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<h5 id="管程">管程</h5>
<p>也是一种解决进程同步的技术</p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>它的思想是，将共享变量以及对其的操作封装起来，并且保证同一时刻只有一个进程可以进入管程</p>
<p>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对<strong>条件变量</strong>执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。对<strong>条件变量</strong>执行 signal() 操作会唤醒被阻塞的进程。</p>
<p>参考：https://www.cnblogs.com/xidongyu/p/10891303.html</p>
<p>可以看“生产者-消费者问题”中管程的实现加深对管程的理解</p>
<h5 id="经典进程同步问题">经典进程同步问题</h5>
<h6 id="生产者-消费者问题">生产者-消费者问题</h6>
<p>问题描述：使用一个缓冲区来保存物品，缓冲区容量为 N，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p><strong>使用 信号量 实现</strong></p>
<p>以下 3 段话用于帮助理解代码，基础好的同学也可直接看代码进行理解。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 <code>down(mutex)</code> 再执行 <code>down(empty)</code>。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 <code>down(empty)</code> 操作，发现 <code>empty = 0</code>，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 <code>up(empty)</code> 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<pre><code class="language-c++">#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        // produce_item
        down(empty);
        // 临界区开始
        down(mutex);
        // insert item to 缓冲区（临界资源）
        up(mutex);
        // 临界区结束
        up(full);
    }
}

void consumer() {
    while(TRUE) {
        down(full);
        // 临界区开始
        down(mutex);
        // get item from 缓冲区（临界资源）
        // consume_item
        up(mutex);
        // 临界区结束
        up(empty);
    }
}
</code></pre>
<p><strong>使用 管程 实现</strong></p>
<pre><code class="language-pascal">// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        // produce_item
        ProducerConsumer.insert();
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        ProducerConsumer.remove();
        // consume_item
    end
end;
</code></pre>
<h6 id="哲学家进餐问题">哲学家进餐问题</h6>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt="img" style="zoom:80%;" />
<p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p><strong>错误解法：</strong></p>
<p>如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<pre><code class="language-c++">#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
</code></pre>
<p><strong>信号量：</strong></p>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<p>代码的讲解，建议搭配代码一起看：</p>
<ul>
<li>首先，通过 mutex 保证临界资源 state 数组同一时刻只有一个进程可以访问</li>
<li>在这个前提下，就可以根据 state 数组的状态来进行后续的操作</li>
<li>对于每个哲学家，在 eat() 之前都需要 down()，而在 down() 之前会判断左右两边的 state 数组
<ul>
<li>如果左右两边的哲学家都不是 EATING 的状态，则会 up() 并将自身状态设置成 EATING</li>
<li>如果左右两边的哲学家存在 EATING 的状态，则不会进行任何操作，在 down() 时等待身边的哲学家吃完</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#define N 5
typedef int semaphore;

int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界资源是 state 数组，对其修改需要互斥

semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        // think
        take_two(i);
        // eat
        put_two(i);
    }
}

void take_two(int i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = HUNGRY;
    check(i);
    up(mutex);
    // state 的临界区 结束
    down(s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = THINKING;
    // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(LEFT);
    check(RIGHT);
    up(mutex);
    // state 的临界区 结束
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(s[i])，使得 down(s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) {
        state[i] = EATING;
        up(s[i]);
    }
}
</code></pre>
<h6 id="读者-写者问题">读者-写者问题</h6>
<p>问题描述：允许多个进程同时对数据进行读操作，但是不允许 读和写 以及 写和写 操作同时发生。</p>
<p><strong>使用信号量实现：</strong></p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code class="language-c++">typedef int semaphore;
semaphore count_mutex = 1;
int count = 0;

semaphore data_mutex = 1;

void reader() {
    while(TRUE) {
        down(count_mutex);
        count++;
        if(count == 1) down(data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(count_mutex);
        // read
        down(count_mutex);
        count--;
        if(count == 0) up(data_mutex);
        up(count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(data_mutex);
        // write
        up(data_mutex);
    }
}
</code></pre>
<h4 id="进程通信-ipc">进程通信 IPC</h4>
<p>进程通信 与 进程同步 之间的关系，可以见上文“互斥、同步与通信”</p>
<p><strong>管道</strong></p>
<p>管道是通过调用 pipe 函数创建的，filedes[0] 用于读，filedes[1] 用于写。</p>
<p>由 pipe 函数为 filedes 数组进行赋值，之后，可以通过 read write 函数进行读写</p>
<pre><code class="language-c++">#include &lt;unistd.h&gt;

int filedes[2];
pipe( filedes );

read( filedes[0], buf, sizeof(buf) );
write( filedes[1], s, sizeof(s) );
</code></pre>
<p>缺点：</p>
<ul>
<li>
<p>只支持半双工通信（单向交替传输）</p>
</li>
<li>
<p>只能在父子进程或者兄弟进程中使用</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="img" style="zoom:70%;" />
</li>
</ul>
<p><strong>FIFO</strong></p>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<p>之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。</p>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="img" style="zoom:65%;" />
<p><strong>消息队列</strong></p>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<p><strong>信号量</strong></p>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<p><strong>共享存储</strong></p>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。</p>
<p>共享内存使用的不是文件，而是内存的匿名段。</p>
<p><strong>套接字</strong></p>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信</p>
<h3 id="死锁">死锁</h3>
<h4 id="必要条件">必要条件</h4>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h4 id="处理方法">处理方法</h4>
<h5 id="鸵鸟策略">鸵鸟策略</h5>
<p>方法：把头埋在沙子里，假装根本没发生问题。</p>
<p>原理：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>适用场景：当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h5 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h5>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复</p>
<p><strong>每种类型的资源只有一个的死锁检测</strong></p>
<p>即，对于每种类型的资源，被使用了，别的进程就不能再使用了</p>
<p>有向图判环：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" alt="img" style="zoom:80%;" />
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b 所示，它满足了环路等待条件，因此会发生死锁。</p>
<p>该死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<p><strong>每种类型的资源有多个的死锁检测</strong></p>
<p>即，对于每种类型的资源，存在多个，被进程 A 使用了 1 个后，还有其他实例可以供其他进程使用</p>
<p>银行家算法：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt="img" style="zoom:90%;" />
<p>上图中，有 3 个进程 4 个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，算法执行过程对进程进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<p><strong>死锁恢复</strong></p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复
<ul>
<li>假设进程 A 等待资源，进程 B 占用该资源，则对进程 B 进行回滚并将资源分配给进程 A，从而实现死锁恢复。参考：https://blog.csdn.net/zhangxiaojiakele/article/details/106034016</li>
</ul>
</li>
<li>通过杀死进程恢复</li>
</ul>
<h5 id="死锁预防">死锁预防</h5>
<p>在程序运行之前预防发生死锁</p>
<p>破坏 死锁 发生的必要条件</p>
<p><strong>破坏互斥条件</strong></p>
<p>例如，“假脱机打印机技术”允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程</p>
<p><strong>破坏占有和等待条件</strong></p>
<p>一种实现方式是，规定所有进程在开始执行前请求所需要的全部资源</p>
<p><strong>破坏不可抢占条件</strong></p>
<p><strong>破坏环路等待</strong></p>
<p>给资源统一编号，进程只能按编号顺序来请求资源</p>
<h5 id="死锁避免">死锁避免</h5>
<p>在程序运行时避免发生死锁</p>
<p>在为进程分配资源前进行检查，如果发现此次资源分配将导致死锁，则拒绝给该进程分配资源</p>
<p>安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img" style="zoom:80%;" />
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>死锁避免，就是避免进入不安全状态。</p>
<p>使用 银行家算法 判断某状态是否为 安全状态</p>
<h5 id="检测-vs-预防-vs-避免">检测 VS 预防 VS 避免</h5>
<p>检测，是判断当前状态是否发生了死锁</p>
<p>预防，是不给死锁发生的机会</p>
<p>避免，是死锁可能发生，但是避免其发生，例如，避免进入不安全状态。</p>
<h3 id="内存管理">内存管理</h3>
<h4 id="分页机制">分页机制</h4>
<p>通过 分页机制 可以实现 虚拟内存</p>
<p>虚拟内存的目的是为了将物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p>
<p>为了更好的管理内存，操作系统将内存抽象成若干地址空间。同时，地址空间又被分割成多个块，每一块称为一页，因此每页中都包含若干地址空间。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的操作，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许操作系统不用将地址空间中的每一页都映射到物理内存，也就是说一个程序所使用的所有页不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img" style="zoom:90%;" />
<p>例如，有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，因此，通过 虚拟内存技术 便可以在该计算机运行一个 64K 大小的程序。</p>
<p>分页内存管理机制，对于程序来说是透明的，对于程序来说，它只知道地址空间是 0~64K，但其实物理内存空间只有 32KB，在运行过程中，是通过操作系统进行控制的，使得程序感觉上就像在 64KB 的物理内存上运行。</p>
<h5 id="分页系统的地址映射">分页系统的地址映射</h5>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中，页表存储着页（地址空间）和页框（物理内存）的映射表。</p>
<p>一个虚拟地址空间分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>根据页面号，可以定位到页表中的特定行，然后从该行中获取物理内存地址前缀，与偏移量合并，得到物理内存地址。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img" style="zoom:70%;" />
<p>上图的页表存放着 16 个页（16行），这 16 个页需要用 4 个比特位来进行索引定位（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2^4=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>）。</p>
<p>例如，对于虚拟地址（0010 000000000100）</p>
<ul>
<li>根据前 4 位（0010）得知页面号为2，从页表第 2 行读取内容：110 1，其中，前 3 位为物理内存地址前缀，第 4 位表示是否存在于内存中，1 表示存在。</li>
<li>后 12 位存储偏移量，结合刚才的物理内存地址前缀（110），这个页对应的页框的地址为 （110 000000000100）。</li>
</ul>
<h5 id="页面置换算法">页面置换算法</h5>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<p><strong>最佳 OPT Optimal replacement algorithm</strong></p>
<p>选择最长时间不再被访问的页面，将其置换。因为是最长时间不被访问的页面，所以可以保证获得最低的缺页率</p>
<p>这是一种理论算法，无法实现，因为无法获知哪个页面在未来最长时间不被访问</p>
<p>举例：</p>
<p>系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<pre><code class="language-html">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为站在上帝视角，我们知道页面 7 再次被访问的时间最长。</p>
<p><strong>最近最久未使用 LRU Least Recently Used</strong></p>
<p>虽然无法知道未来页面的使用情况，但是可以知道过去页面的使用情况。</p>
<p>LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<p><strong>最近未使用 NRU Not Recently Used</strong></p>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。</p>
<p>其中 R 位会定时被清零。</p>
<p>将页面分成以下四<strong>类</strong>：</p>
<ul>
<li>0：R=0，M=0</li>
<li>1：R=0，M=1</li>
<li>2：R=1，M=0</li>
<li>3：R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从<strong>类</strong>编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<p><strong>先进先出 FIFO First In First Out</strong></p>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<p><strong>第二次机会算法</strong></p>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改。</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<p><strong>时钟 Clock</strong></p>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img" style="zoom:80%;" />
<h4 id="分段机制">分段机制</h4>
<p>现在，请先忘掉分页机制，分段机制是一种独立的机制，和分页机制无关。</p>
<p>分段机制的设计思想是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</p>
<p>一般情况下，程序在运行时都会在内存中存储程序代码和数据，存储程序代码是为了能让程序执行下去（总要把下一行要执行的代码放到内存中吧，不然系统哪知道应该做什么）</p>
<p>基于这个现象，操作系统内存管理分段机制允许程序拥有多个段，在不同段中存储不同类型的数据，且段的大小是可变的。程序无需知道段在物理内存中的位置，只需要使用段偏移量进行访问即可，在程序运行时，操作系统会把段映射到实际的内存空间中。例如，段偏移量是 0000~0100，那么程序实际运行时，会把段映射到 xxxx0000~xxxx0100</p>
<p>因此，分段机制中是不涉及虚拟内存的</p>
<h4 id="分页-vs-分段">分页 VS 分段</h4>
<ul>
<li>空间大小是否可变：分页机制不可变；分段机制可变
<ul>
<li>分页存在覆盖问题：假设页的长度是100，那么程序在访问到 xxx101 时就会出错（xxx为页面号；为了方便，用的是十进制），因为根据地址映射，会把页面号进行替换，得到物理内存地址，但是因为页的长度是 100，所以其实本质上已经访问到下一页了，就会出现覆盖问题。</li>
</ul>
</li>
<li>透明性：分页对程序是透明的，分段是不透明的</li>
<li>目的：
<ul>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间</li>
<li>分段主要为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</li>
</ul>
</li>
</ul>
<h4 id="段页式">段页式</h4>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2019040522291138.png" alt="img" style="zoom:100%;" />
<p>根据段号和段表，获取页表，根据页号和页表，获取物理内存空间前缀，最后根据页内偏移计算出物理地址。</p>
<p>一个程序拥有多个段，每个段包含多个页，每个页会被映射到物理内存</p>
<h3 id="磁盘">磁盘</h3>
<h4 id="磁盘结构">磁盘结构</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/014fbc4d-d873-4a12-b160-867ddaed9807.jpg" alt="img" style="zoom:80%;" />
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<h4 id="磁盘调度算法">磁盘调度算法</h4>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间：主轴转动盘面，使得磁头移动到适当的扇区上</li>
<li><strong>寻道时间</strong>：制动手臂移动，使得磁头移动到适当的磁道上</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，<strong>寻道时间</strong>最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<p><strong>先来先服务 FCFS First Come First Served</strong></p>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。</p>
<p>缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<p><strong>最短寻道时间优先 SSTF Shortest Seek Time First</strong></p>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="img" style="zoom:50%;" />
<p><strong>电梯算法 SCAN</strong></p>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="img" style="zoom:50%;" />
<h3 id="链接">链接</h3>
<h4 id="链接系统">链接系统</h4>
<p>以下是一个 hello.c 程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello, world\n&quot;);
    return 0;
}
</code></pre>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<pre><code class="language-shell">gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" alt="img" style="zoom:80%;" />
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<p>目标文件：</p>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h4 id="静态链接">静态链接</h4>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg" alt="img" style="zoom:80%;" />
<h4 id="动态链接">动态链接</h4>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg" alt="img" style="zoom:80%;" />
<h2 id="linux">Linux</h2>
<h3 id="前言">前言</h3>
<p>面试重点：</p>
<ul>
<li>指令：cat（文件）、grep（查找指令）、cut（管道指令）
<ul>
<li>括号中标出来这些指令所在的章节</li>
</ul>
</li>
<li>文件：实体链接与符号链接</li>
<li>进程管理：SIGCHLD、僵尸进程与孤儿进程</li>
</ul>
<h3 id="常用指令">常用指令</h3>
<p><strong>快捷键</strong></p>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<p><strong>查询指令用法</strong></p>
<p>/usr/share/doc 目录中存放着大部分软件的一整套说明文件</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145459251.png" alt="image-20220104145459251" style="zoom:40%;" />
<p><code>--help</code></p>
<p>指令的基本用法与选项介绍</p>
<p><code>man</code></p>
<p>man 是 manual 的缩写，将指令的具体信息显示出来</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145001620.png" alt="image-20220104145001620" style="zoom:50%;" />
<p>当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型</p>
<p>常用的数字及其类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">代号</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>配置文件</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody>
</table>
<p><code>info</code></p>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转</p>
<p><strong>关机</strong></p>
<p><code>who</code></p>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线</p>
<p><code>sync</code></p>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作</p>
<p><code>shutdown</code></p>
<pre><code class="language-html">## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
</code></pre>
<p><strong>环境变量 PATH</strong></p>
<p>可以在环境变量 PATH 中声明可执行文件的路径</p>
<p>路径之间用 <code>:</code> 分隔</p>
<p><strong>sudo</strong></p>
<p>sudo 允许一般用户使用 root 可执行的命令</p>
<p>不过只有在 <code>/etc/sudoers</code> 配置文件中添加的用户才能使用该指令</p>
<h3 id="vim-的三个模式">Vim 的三个模式</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191209002818626.png" alt="img" style="zoom:50%;" />
<ul>
<li>一般指令模式：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式：按下 &quot;i&quot; 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式：按下 &quot;:&quot; 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在 指令列模式 下，有以下命令用于离开或者保存文件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">:w!</td>
<td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">离开</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">强制离开不保存</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">写入磁盘后离开</td>
</tr>
<tr>
<td style="text-align:center">:wq!</td>
<td style="text-align:center">强制写入磁盘后离开</td>
</tr>
</tbody>
</table>
<h3 id="文件系统理论部分">文件系统（理论部分）</h3>
<h4 id="组成">组成</h4>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<h4 id="文件读取">文件读取</h4>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" alt="img" style="zoom:50%;" />
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" alt="img" style="zoom:60%;" />
<h4 id="磁盘碎片">磁盘碎片</h4>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h4 id="block">block</h4>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">大小</th>
<th style="text-align:center">1KB</th>
<th style="text-align:center">2KB</th>
<th style="text-align:center">4KB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最大单一文件</td>
<td style="text-align:center">16GB</td>
<td style="text-align:center">256GB</td>
<td style="text-align:center">2TB</td>
</tr>
<tr>
<td style="text-align:center">最大文件系统</td>
<td style="text-align:center">2TB</td>
<td style="text-align:center">8TB</td>
<td style="text-align:center">16TB</td>
</tr>
</tbody>
</table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h4 id="inode">inode</h4>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID...；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<h4 id="目录">目录</h4>
<p>目录，也可以理解成文件夹</p>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root)：根目录</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/linux-filesystem.png" alt="img" style="zoom:80%;" />
<h3 id="文件实践部分">文件（实践部分）</h3>
<h4 id="文件属性">文件属性</h4>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间可使用 stat 指令查看</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104155901036.png" alt="image-20220104155901036" style="zoom:50%;" />
<p>三种文件时间：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h4 id="文件与目录的基本操作指令">文件与目录的基本操作指令</h4>
<p>本节主要列出了 8 个基本操作指令，已经掌握的同学可直接跳过</p>
<p><strong>1. ls</strong></p>
<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<pre><code class="language-html">## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
</code></pre>
<p><strong>2. cd</strong></p>
<p>更换当前目录。</p>
<pre><code class="language-text">cd [相对路径或绝对路径]
</code></pre>
<p><strong>3. mkdir</strong></p>
<p>创建目录。</p>
<pre><code class="language-text">## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
</code></pre>
<p><strong>4. rmdir</strong></p>
<p>删除目录，目录必须为空。</p>
<pre><code class="language-html">rmdir [-p] 目录名称
-p ：递归删除目录
</code></pre>
<p><strong>5. touch</strong></p>
<p>更新文件时间或者建立新文件。</p>
<pre><code class="language-html">## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
</code></pre>
<p><strong>6. cp</strong></p>
<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<pre><code class="language-html">cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
</code></pre>
<p><strong>7. rm</strong></p>
<p>删除文件。</p>
<pre><code class="language-html">## rm [-fir] 文件或目录
-r ：递归删除
</code></pre>
<p><strong>8. mv</strong></p>
<p>移动文件。</p>
<pre><code class="language-html">## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
</code></pre>
<h4 id="权限">权限</h4>
<h5 id="修改权限">修改权限</h5>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<pre><code class="language-html">## chmod [-R] xyz dirname/filename
</code></pre>
<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。</p>
<pre><code class="language-html">## chmod 754 .bashrc
</code></pre>
<p>也可以使用符号来设定权限。</p>
<pre><code class="language-html">## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
</code></pre>
<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<pre><code class="language-html">## chmod a+w .bashrc
</code></pre>
<h5 id="默认权限">默认权限</h5>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。</p>
<h5 id="目录的权限">目录的权限</h5>
<p>文件名不是存储在一个文件的内容中，而是存储在该文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h4 id="实体链接-vs-符号链接">实体链接 VS 符号链接</h4>
<p><strong>指令</strong></p>
<pre><code class="language-html">## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
</code></pre>
<p><strong>概念</strong></p>
<p>实体链接，也叫，硬链接</p>
<p>符号链接，也叫，软连接</p>
<p>两者关系如图：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" alt="img" style="zoom:50%;" />
<p>如果不理解，可继续看下面的解析。</p>
<p><strong>实体链接</strong></p>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<pre><code class="language-html">## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</code></pre>
<p><strong>为什么不能对目录创建实体链接</strong>？</p>
<p>因为，目录是支持 <code>cd ../</code> 操作的，因此，如果像文件那样，只是在目录中添加 inode 编号，那么带来的问题就是，在实体链接目录 /d1/d2 中执行 <code>cd ../</code> 可能会跳转到 /d3 中，也就是说，会发现目录错位的现象。为了解决这个问题，那就需要真正创建一个目录，并在目录中为每个文件创建实体链接，但是这样的成本太高了，因此 操作系统禁止用户这么做。</p>
<blockquote>
<p>举例来说，如果你要将 /etc 使用硬链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下的所有文件名同时都与 /etc 下面的文件名要创建硬链接的，而不是仅仅连接到 /etc 和 /etc_hd 而已。并且，将来如果需要在 /etc_hd 目录下创建新文件时，连带的，/etc 下面的数据又得要创建一次硬链接。因此造成环境相当大的复杂度，所以是不支持链接目录的。</p>
<p>by 鸟哥</p>
</blockquote>
<p>其实，Linux 中是存在目录的实体链接的，比如，<code>.</code> 和 <code>..</code>，但是 Linux 不允许用户创建实体链接。</p>
<p><strong>符号链接</strong></p>
<p>符号链接保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<pre><code class="language-html">## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab
</code></pre>
<h4 id="7-个获取文件内容指令">7 个获取文件内容指令</h4>
<p><strong>1. cat</strong></p>
<p>取得文件内容。</p>
<pre><code class="language-html">## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
</code></pre>
<p><strong>2. tac</strong></p>
<p>是 cat 的反向操作，从最后一行开始打印。</p>
<p><strong>3. more</strong></p>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<p><strong>4. less</strong></p>
<p>和 more 类似，但是多了一个向前翻页的功能。</p>
<p><strong>5. head</strong></p>
<p>取得文件前几行。</p>
<pre><code class="language-html">## head [-n number] filename
-n ：后面接数字，代表显示几行的意思
</code></pre>
<p><strong>6. tail</strong></p>
<p>是 head 的反向操作，只是取得是后几行。</p>
<p><strong>7. od</strong></p>
<p>以字符或者十六进制的形式显示二进制文件。</p>
<h4 id="4-个搜索指令">4 个搜索指令</h4>
<p><strong>1. which</strong></p>
<p>指令搜索。</p>
<pre><code class="language-html">## which [-a] command
-a ：将所有指令列出，而不是只列第一个
</code></pre>
<p><strong>2. whereis</strong></p>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<pre><code class="language-html">## whereis [-bmsu] dirname/filename
</code></pre>
<p><strong>3. locate</strong></p>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<pre><code class="language-html">## locate [-ir] keyword
-r：正则表达式
</code></pre>
<p><strong>4. find</strong></p>
<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<pre><code class="language-html">## find [basedir] [option]
example: find . -name &quot;shadow*&quot;
</code></pre>
<p><strong>① 与时间有关的选项</strong></p>
<pre><code class="language-html">-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
</code></pre>
<p>+4、4 和 -4 的指示的时间范围如下：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/658fc5e7-79c0-4247-9445-d69bf194c539.png" alt="img" loading="lazy"></figure>
<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>
<pre><code class="language-html">-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
</code></pre>
<p><strong>③ 与文件权限和名称有关的选项</strong></p>
<pre><code class="language-html">-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
</code></pre>
<h3 id="压缩与打包">压缩与打包</h3>
<h4 id="压缩文件名">压缩文件名</h4>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody>
</table>
<h4 id="3-个压缩指令">3 个压缩指令</h4>
<p><strong>1. gzip</strong></p>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<pre><code class="language-html">$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
</code></pre>
<p><strong>2. bzip2</strong></p>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<pre><code class="language-html">$ bzip2 [-cdkzv#] filename
-k ：保留源文件
</code></pre>
<p><strong>3. xz</strong></p>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<pre><code class="language-html">$ xz [-dtlkc#] filename
</code></pre>
<h4 id="打包指令">打包指令</h4>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
<pre><code class="language-html">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td style="text-align:center">查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td style="text-align:center">解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody>
</table>
<h3 id="bash">Bash</h3>
<h4 id="概念">概念</h4>
<p>Bash 是 Shell 的一种</p>
<p>Shell 指的是一类程序，通过 Shell 程序，可以把我们的命令传递给内核，从而调用计算机硬件执行相关的操作，之后再把执行结果翻译成自然语言，呈现在我们面前。</p>
<p>Bash 是当前大多数 Linux 发行版的默认Shell</p>
<h4 id="特性">特性</h4>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h4 id="变量操作">变量操作</h4>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<pre><code class="language-bash">$ x=abc
$ echo $x
$ echo ${x}
</code></pre>
<p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=&quot;lang is $LANG&quot;，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG'，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<pre><code class="language-html">$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
</code></pre>
<p>使用 [ ] 来对数组进行索引操作：</p>
<pre><code class="language-bash">$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
</code></pre>
<h4 id="指令搜索顺序">指令搜索顺序</h4>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h4 id="数据流重定向">数据流重定向</h4>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准输入 (stdin)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td style="text-align:center">标准输出 (stdout)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td style="text-align:center">标准错误输出 (stderr)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody>
</table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而 有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<pre><code class="language-bash">$ find /home -name .bashrc &gt; list 2&gt;&amp;1
</code></pre>
<h3 id="管道指令">管道指令</h3>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<pre><code class="language-bash">$ ls -al /etc | less
</code></pre>
<p><strong>提取指令 cut</strong></p>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<pre><code class="language-html">$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
</code></pre>
<p>示例 1：last 显示登入者的信息，取出用户名。</p>
<pre><code class="language-html">$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d ' ' -f 1
</code></pre>
<p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<pre><code class="language-html">$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dmtsai&quot;
declare -x HOSTNAME=&quot;study.centos.vbird&quot;
.....(其他省略).....

$ export | cut -c 12-
</code></pre>
<p><strong>排序指令 sort</strong></p>
<p>sort 用于排序。</p>
<pre><code class="language-html">$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
</code></pre>
<p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<pre><code class="language-html">$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
</code></pre>
<p><strong>去重指令 uniq</strong></p>
<p>uniq 可以将重复的数据只取一个。</p>
<pre><code class="language-html">$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
</code></pre>
<p>示例：取得每个人的登录总次数</p>
<pre><code class="language-html">$ last | cut -d ' ' -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
</code></pre>
<p><strong>双向输出重定向指令 tee</strong></p>
<p>输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<pre><code class="language-html">$ tee [-a] file
</code></pre>
<p><strong>5 个字符转换指令</strong></p>
<p><code>tr</code> 用来删除一行中的字符，或者对字符进行替换。</p>
<pre><code class="language-html">$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
</code></pre>
<p>示例，将 last 输出的信息所有小写转换为大写。</p>
<pre><code class="language-html">$ last | tr '[a-z]' '[A-Z]'
</code></pre>
<p><code>col</code> 将 tab 字符转为空格字符。</p>
<pre><code class="language-html">$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
</code></pre>
<p><code>expand</code> 将 tab 转换一定数量的空格，默认是 8 个。</p>
<pre><code class="language-html">$ expand [-t] file
-t ：tab 转为空格的数量
</code></pre>
<p><code>join</code> 将有相同数据的那一行合并在一起。</p>
<pre><code class="language-html">$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
</code></pre>
<p><code>paste</code> 直接将两行粘贴在一起。</p>
<pre><code class="language-html">$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
</code></pre>
<p><strong>分区指令 split</strong></p>
<p>split 将一个文件划分成多个文件。</p>
<pre><code class="language-html">$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
</code></pre>
<h3 id="查找指令-grep">查找指令 grep</h3>
<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<pre><code class="language-html">$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre>
<p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<pre><code class="language-html">$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &quot;glad&quot;.
18:google is the best tools for search keyword
</code></pre>
<p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p>
<pre><code class="language-html">$ grep -n 'a\{2,5\}' regular_express.txt
</code></pre>
<h3 id="2-个格式化输出指令">2 个格式化输出指令</h3>
<p><strong>printf</strong></p>
<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<pre><code class="language-html">$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</code></pre>
<p><strong>awk</strong></p>
<p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p>
<pre><code class="language-html">$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
$ last -n 5 | awk '{print $1 &quot;\t&quot; $3}'
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri
</code></pre>
<p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<pre><code class="language-html">$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename
</code></pre>
<p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<pre><code class="language-text">$ cat /etc/passwd | awk 'BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t &quot; $3}'
root 0
bin 1
daemon 2
</code></pre>
<p>awk 变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody>
</table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<pre><code class="language-html">$ last -n 5 | awk '{print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
</code></pre>
<h3 id="进程管理-2">进程管理</h3>
<h4 id="4-个查看进程指令">4 个查看进程指令</h4>
<p><strong>1. ps</strong></p>
<p>查看某个时间点的进程信息。</p>
<p>示例：查看自己的进程</p>
<pre><code class="language-sh">## ps -l
</code></pre>
<p>示例：查看系统所有进程</p>
<pre><code class="language-sh">## ps aux
</code></pre>
<p>示例：查看特定的进程</p>
<pre><code class="language-sh">## ps aux | grep threadx
</code></pre>
<p><strong>2. pstree</strong></p>
<p>查看进程树。</p>
<p>示例：查看所有进程树</p>
<pre><code class="language-sh">## pstree -A
</code></pre>
<p><strong>3. top</strong></p>
<p>实时显示进程信息。</p>
<p>示例：两秒钟刷新一次</p>
<pre><code class="language-sh">## top -d 2
</code></pre>
<p><strong>4. netstat</strong></p>
<p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<pre><code class="language-sh">## netstat -anp | grep port
</code></pre>
<h4 id="进程状态-2">进程状态</h4>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R</td>
<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
</tbody>
</table>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2bab4127-3e7d-48cc-914e-436be859fb05.png" alt="img" style="zoom:70%;" />
<h4 id="子进程的-sigchld-信号">子进程的 SIGCHLD 信号</h4>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<p><strong>wait()</strong></p>
<pre><code class="language-c">pid_t wait(int *status)
</code></pre>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<p><strong>waitpid()</strong></p>
<pre><code class="language-c">pid_t waitpid(pid_t pid, int *status, int options)
</code></pre>
<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h4 id="僵尸进程">僵尸进程</h4>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h2 id="数据库">数据库</h2>
<p>SQL 相关语法可以参考 <a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E8%AF%AD%E6%B3%95.html">cyc 大佬的博客</a></p>
<p>SQL 相关练习可以参考 <a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E7%BB%83%E4%B9%A0.html#description-15">cyc 大佬的博客</a></p>
<h3 id="sql-语法">SQL 语法</h3>
<h4 id="内连接-自然连接-外连接">内连接、自然连接、外连接</h4>
<ul>
<li>内连接（INNER JOIN）：只显示符合 on 条件的行
<ul>
<li>自连接：自身与自身的内连接</li>
</ul>
</li>
<li>自然连接（NATURAL JOIN）：自动对同名列进行比对，不能使用 on 语句</li>
<li>外连接（OUTER JOIN）：对于不符合 on 条件的行，对应列用 NULL 展示。分为左外连接、右外连接、全外连接</li>
</ul>
<h4 id="字符集">字符集</h4>
<ul>
<li>
<p>字符集（CHARACTER SET）：用于定义编号指代的字符，如，unicode、ascII、gb2312</p>
</li>
<li>
<p>编码：全称为编码格式，指的是具体字符集在传输和存储过程中的格式，如，utf-8、utf-16 是 unicode 的编码格式。</p>
<ul>
<li>
<blockquote>
<p>unicode则是为了让全球能用上统一的字符集而发明的，有6万多个字符，每个字符占2个字节，比如英文a，ascII是97、unicode则是0097（示意的说法）。中文只收录最常用的6000多个汉字。unicode虽然是大一统的标准，但是在表示英文时浪费空间，并且许多古老的程序只支持ascII，unicode从标准设计上来说是不兼容ascII。正因如此在实际使用中unicode会以utf-8，utf-16等编码方式存储是传输。utf-8保持和ascII一致，英文使用1个字节，其他字符使用2-6个字节，比如中文多数是3个字节。</p>
<p>https://www.cnblogs.com/liuliqiang/p/8258716.html</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>校对字符（COLLATE）：即排序规则，用于指定字符间如何进行比较，主要用于排序和分组。例如，utf8_unicode_ci，ci 表示 Case Insensitive，即大小写无关</p>
</li>
</ul>
<h3 id="事务">事务</h3>
<h4 id="基本概念">基本概念</h4>
<p><strong>什么是事务</strong></p>
<p>事务是属于数据库中的一个概念，本质上指的是一系列的操作，但是这些操作会满足一些性质，ACID。</p>
<p>事务可以通过 Commit 提交，也可以使用 Rollback 进行回滚。</p>
<p><strong>ACID</strong></p>
<ul>
<li>原子性 Atomicity：所有操作，要么全部提交，要么全部回滚。
<ul>
<li>回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性</strong> Consistency：强调数据库在逻辑上的一致性状态，依赖于原子性。比如，转账操作，要求多账户余额总和保持一致；扣款操作，要求账户余额变化与扣款金额一致。</li>
<li>隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性 Durability：当事务提交后，该事务中的一系列操作需要能被持久化到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
<ul>
<li>系统发生崩溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
</li>
</ul>
<p>其实，在 ACID 中，最重要的就是一致性，通过一致性，可以保证数据库时刻保持一致性的状态。</p>
<blockquote>
<p>何为一致性状态？它指的是数据处于一种有意义的状态，这种状态是语义上的，而不是语法上的。最常见的例子就是转账，从账户 A 转一笔钱到账户 B，如果账户 A 上的钱减少了，但账户 B 上的钱没有增加，那么就认为此时数据处于不一致的状态。</p>
<p>https://www.cnblogs.com/stone94/p/10409669.html</p>
</blockquote>
<ul>
<li>在无并发的情况下，原子性 可以保证一致性</li>
<li>在有并发的情况下，原子性+隔离性 可以保证一致性</li>
<li>在系统发生崩溃时，持久性 可以保证一致性</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207210437023.png" alt="img" style="zoom:50%;" />
<p><strong>保留点</strong></p>
<p>事务处理中设置的临时占位符，如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<p><strong>autocommit</strong></p>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<h4 id="并发中存在的一致性问题">并发中存在的一致性问题</h4>
<p>在并发环境下，如果事务的隔离性没有得到保证，则会出现很多一致性问题</p>
<p><strong>修改丢失</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221744244.png" alt="img" style="zoom:50%;" />
<p>修改丢失，指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><strong>读脏数据</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221920368.png" alt="img" style="zoom:50%;" />
<p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><strong>不可重复读</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222102010.png" alt="img" style="zoom:50%;" />
<p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><strong>幻读</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222134306.png" alt="img" style="zoom:50%;" />
<p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p>
<ul>
<li>并发控制可以通过<strong>封锁</strong>来实现，但是封锁操作需要用户自己控制，相当复杂。</li>
<li>数据库管理系统提供了事务的<strong>隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ul>
<h4 id="锁">锁</h4>
<h5 id="锁粒度"><strong>锁粒度</strong></h5>
<p>MySQL 中提供了两种锁粒度：行级锁 以及 表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统<strong>开销</strong>就越大。</p>
<p>在选择锁粒度时，需要在 锁开销 和 并发程度 之间做一个权衡。</p>
<h5 id="锁类型"><strong>锁类型</strong></h5>
<p><strong>读写锁</strong></p>
<ul>
<li>互斥锁（E<strong>x</strong>clusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（<strong>S</strong>hared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207213523777.png" alt="img" style="zoom:50%;" />
<p><strong>意向锁</strong></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度锁。</p>
<p>在存在 行级锁 和 表级锁 的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上添加了 IX/IS，IX/IS 都是<strong>表锁</strong>，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207214442687.png" alt="img" style="zoom:50%;" />
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h5 id="封锁协议">封锁协议</h5>
<p><strong>三级封锁协议</strong></p>
<p><em>一级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220440451.png" alt="img" style="zoom:35%;" />
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<p><em>二级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220831843.png" alt="img" style="zoom:35%;" />
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><em>三级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221313819.png" alt="img" style="zoom:35%;" />
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<p><strong>两段锁协议</strong></p>
<p>加锁和解锁分为两个阶段进行。先进行加锁阶段，然后进行解锁阶段。事务进行过程中的所有加锁行为都需要在加锁阶段内完成，解锁同理。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>充分条件：例如，以下操作满足两段锁协议，因此它是可串行化调度的</p>
<pre><code class="language-html">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre>
<p>非必要条件：例如，以下操作不满足两段锁协议，但它还是可串行化调度的。</p>
<pre><code class="language-html">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre>
<h5 id="innodb-的隐式-显式加锁">InnoDB 的隐式、显式加锁</h5>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候<strong>自动</strong>加锁，并且所有的锁都是在同一时刻被释放，这被称为<strong>隐式</strong>加锁。</p>
<p>InnoDB 也可以使用特定的语句进行<strong>显式</strong>加锁，即<strong>手动</strong>加锁：</p>
<pre><code class="language-sql">格式：
SELECT ... LOCK In SHARE MODE; -- 加 X 锁
SELECT ... FOR UPDATE; -- 加 S 锁
例子：
SELECT * FROM table1 WHERE name='张三' LOCK In SHARE MODE;
SELECT * F table1 WHERE name='张三' FOR UPDATE;
</code></pre>
<h4 id="隔离级别">隔离级别</h4>
<ul>
<li>READ UNCOMMITTED (未提交读，也叫脏读）：
<ul>
<li>事务未提交时，依旧可以读取到其所做的修改</li>
<li>该隔离级别在性能上并不会比其他的好太多，但却缺乏其他隔离级别所拥有的好处，因此在实际应用中，一般不使用。</li>
</ul>
</li>
<li>READ COMMITTED (提交读，也叫不可重复读）
<ul>
<li>大部分数据库系统默认的隔离级别，但 MySQL 不是</li>
<li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li>又被称为“不可重复读”，因为同样的查询，在事务提交前和提交后，读取到的数据可能不同。</li>
</ul>
</li>
<li>REPEATABLE READ (可重复读）
<ul>
<li>MySQL 默认的隔离级别</li>
<li>保证了在一个事务中的多次查询结果一致</li>
<li>该隔离级别可通过 MVCC 实现，但是会存在幻读，即，在事务执行过程中，另一事务修改了数据，从而产生“幻行”，两次查询读取到的数据总行数不一样。</li>
<li>InnoDB 和 XtraDB 存储引擎通过 MVCC + Next-Key Locks 解决了幻读的问题。</li>
</ul>
</li>
<li>SERIALIZABLE (可串行化）
<ul>
<li>最高级别的隔离级别</li>
<li>强制事务串行执行，不存在并发，这样多个事务互不干扰，不会出现并发一致性问题</li>
<li>具体实现：为读取的每一行数据加锁</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207223400787.png" alt="img" style="zoom:50%;" />
<h4 id="mvcc-多版本并发控制">MVCC 多版本并发控制</h4>
<p><strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<p>MVCC 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p><strong>基本思想</strong></p>
<p>在锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了 读写锁 来避免不必要的加锁操作，例如，读和读没有互斥关系。但，读和写操作仍然是互斥的。</p>
<p>而 MVCC 利用了多版本的思想，<strong>写</strong>操作更新<strong>最新版本</strong>的快照，而<strong>读</strong>操作去读<strong>旧版本</strong>的快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中，事务的每次修改操作（DELETE、INSERT、UPDATE）都会为<strong>数据行</strong>新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<p>多版本并发控制，每个 数据行快照版本 对应一个事务 id，当事务执行修改操作时，会生成对应的版本，多个 数据行快照版本 之间构成链表，从最新的版本开始寻找，直到找到满足要求的版本。</p>
<p><strong>版本号</strong></p>
<ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<p><strong>Undo 日志</strong></p>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<pre><code class="language-sql">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);
UPDATE t SET x=&quot;b&quot; WHERE id=1;
UPDATE t SET x=&quot;c&quot; WHERE id=1;
</code></pre>
<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191208164808217.png" alt="img" style="zoom:50%;" />
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<p><strong>ReadView</strong></p>
<p>有个多版本后，MVCC 该如何使用它呢？</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220106103143882.png" alt="image-20220106103143882" style="zoom:50%;" />
<p>MVCC 维护了一个 ReadView 结构，主要包含：</p>
<ul>
<li>
<p>m_ids：当前系统未提交的事务列表 {TRX_ID_1, TRX_ID_2, ...}</p>
</li>
<li>
<p>min_trx_id：m_ids 中的最小值</p>
</li>
<li>
<p>max_trx_id：当前系统的版本号</p>
<ul>
<li>
<blockquote>
<p>注意，max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，但是，max_trx_id 的值是 4。</p>
<p>https://www.cnblogs.com/jmliao/p/13204946.html</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>creator_trx_id：当前事务的 ID</p>
</li>
</ul>
<p>在进行 SELECT 操作时，根据<strong>数据行</strong>快照的 TRX_ID 与 min_trx_id 和 max_trx_id 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; min_trx_id，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt;= max_trx_id，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt; TRX_ID_MAX，需要根据隔离级别再进行判断：
<ul>
<li>提交读：如果 TRX_ID 在 m_ids 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<p>对于提交读，ReadView 会在每次执行查询语句时生成一次，对于可重复读，只在第一次查询时生成，之后每次查询，复用第一次生成的 ReadView。</p>
<p><strong>快照读与当前读</strong></p>
<p>MVCC 只会在执行 SELECT 语句时发挥作用，在执行修改操作（INSERT、UPDATE、DELETE）时，依旧会对最新数据进行加锁，这是为了避免发生“修改丢失”。</p>
<p>对于 SELECT 操作，会去多版本快照中读取数据，称为 快照读，快照读不会进行加锁操作</p>
<p>对于其他修改操作，会对需要修改的数据进行加锁，确保修改的是最新的数据，这被称为 当前读。以下操作都是当前读：</p>
<pre><code class="language-sql">INSERT;
UPDATE;
DELETE;
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
</code></pre>
<p><strong>幻读问题</strong></p>
<ul>
<li>MVCC 可以解决 快照读 的幻读问题，因为通过版本控制，只会读到旧版本中的数据，不会发生幻读问题</li>
<li>但是无法解决 当前读 的幻读问题，因为当前读获取的是最新的数据
<ul>
<li>举个例子：</li>
<li>事务1 select *</li>
<li>事务2 insert</li>
<li>事务1 select *，此时没问题，因为是快照读，不会读到事务2的insert</li>
<li>事务1 update，因为 update 是当前读，会读到事务 2 的 insert，所以会把这条数据的版本号改成事务1，此时事务 1 再 select，就会出现幻读</li>
</ul>
</li>
</ul>
<h4 id="next-key-locks">Next-Key Locks</h4>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<p><strong>Record Locks</strong></p>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<p><strong>Gap Locks</strong></p>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<pre><code class="language-sql">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
</code></pre>
<p><strong>Next-Key Locks</strong></p>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定的范围都是前开后闭的区间。</p>
<p>例如，一个索引包含以下值：10, 11, 13, and 20，那么可能被锁住的区间有：</p>
<pre><code class="language-sql">(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
</code></pre>
<p>具体加锁规则为：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/50ff45e7d6f7826867bdc9c4197cf4c6.png" alt="img" style="zoom:50%;" />
<blockquote>
<p>看了这结论，应该可以解答一大部分问题，不过有一句非常非常重点的话需要关注：</p>
<p>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列&lt;=5.7.24，8.0 系列 &lt;=8.0.13</p>
<p>https://blog.csdn.net/qq_36535538/article/details/117623068</p>
</blockquote>
<h3 id="mysql">MySQL</h3>
<h4 id="索引">索引</h4>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h5 id="索引类型">索引类型</h5>
<h6 id="b-tree-索引">B+ Tree 索引</h6>
<p>大多数 MySQL 存储引擎的默认索引类型</p>
<p><strong>原理</strong></p>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是 B Tree 的升级版，在 B Tree 的基础上做了改良：</p>
<ul>
<li>添加了叶子结点顺序访问指针</li>
<li>将数据全部保存在叶子结点上</li>
</ul>
<p>相较于 B Tree，B+ Tree 具有如下优点：</p>
<ul>
<li>保留了 B Tree 的平衡性</li>
<li>可通过顺序访问指针提高区间查询的性能（B Tree中，需要使用中序遍历）</li>
<li>将数据保存在叶子结点上，使得非叶子结点可以存储更多 key，进一步降低树高</li>
<li>每次都会查到叶子结点才结束，因此查询时间较稳定</li>
</ul>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">key_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">key_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，且不为 null，则该指针指向节点的所有 key 大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">key_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">key_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img" style="zoom:50%;" />
<p>当需要进行查找操作时</p>
<p>首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入、删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>
<p><strong>VS 红黑树</strong></p>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p>
<p>（一）B+ 树有更低的<strong>树高</strong></p>
<p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>
<p>（二）磁盘访问原理</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>
<p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与<strong>树高</strong>成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
<p>（三）磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<p><em>（不用红黑树的根本原因还是因为树高！）</em></p>
<p><strong>用法</strong></p>
<ul>
<li>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li>
<li>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</li>
<li>可以指定多个列作为索引列，多个索引列共同组成键。</li>
<li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li>
</ul>
<p><strong>InnoDB 中的 B+ Tree 索引</strong></p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个<strong>聚簇索引</strong>。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img" style="zoom:50%;" />
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img" style="zoom:60%;" />
<h6 id="其他索引">其他索引</h6>
<p><strong>哈希索引</strong></p>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，这样就让 B+ Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<p><strong>全文索引</strong></p>
<p>MyISAM 存储引擎支持全文索引，<strong>用于查找文本中的关键词</strong>，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<p><strong>空间数据索引</strong></p>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h5 id="如何高效使用索引">如何高效使用索引</h5>
<p><strong>独立的列</strong></p>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<pre><code class="language-sql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
</code></pre>
<p><strong>多列索引</strong></p>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<pre><code class="language-sql">SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
</code></pre>
<p><strong>索引列的顺序</strong></p>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<pre><code class="language-sql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
</code></pre>
<pre><code class="language-html">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre>
<p><strong>前缀索引</strong></p>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<p><strong>覆盖索引</strong></p>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h5 id="索引的优点与使用条件">索引的优点与使用条件</h5>
<p>优点：</p>
<ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<p>使用条件：</p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<h4 id="存储引擎">存储引擎</h4>
<p><strong>InnoDB</strong></p>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p><strong>MyISAM</strong></p>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<p><strong>比较</strong></p>
<ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h4 id="数据类型">数据类型</h4>
<p><strong>整型</strong></p>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<p><strong>浮点数</strong></p>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<p><strong>字符串</strong></p>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<p><strong>时间和日期</strong></p>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<ul>
<li>DATETIME</li>
</ul>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<ul>
<li>TIMESTAMP</li>
</ul>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<ul>
<li>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</li>
</ul>
<h3 id="查询性能优化">查询性能优化</h3>
<h4 id="使用-explain-进行分析">使用 Explain 进行分析</h4>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>各字段含义：</p>
<ul>
<li>id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样</li>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>type：针对单表的查询方式
<ul>
<li>all、index、range、ref、eq_ref、const，从左到右效率依次提升</li>
<li>all：全表扫描</li>
<li>index：根据索引的顺序全表扫描</li>
<li>range：索引范围查询，between、&gt;、&lt;、in</li>
<li>ref：查询条件使用索引，但不是唯一索引</li>
<li>eq_ref：查询条件使用唯一索引</li>
<li>const：查询条件使用主键，优化器会把查询优化为一个常量</li>
<li>by https://blog.csdn.net/dennis211/article/details/78170079</li>
</ul>
</li>
<li>possible_keys：可能用到的索引</li>
<li>key : 实际用到的索引</li>
<li>rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）</li>
<li>Extra：
<ul>
<li>Impossible where：查询条件为false</li>
<li>Using where：顺序扫描，where 条件查询</li>
<li>Using index：覆盖索引</li>
<li>Using index condition：索引下推
<ul>
<li>根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表</li>
<li>在表上建立联合索引（name, age）</li>
<li><code>select * from table1 where name like &quot;张%&quot; and age = 23;</code></li>
<li>组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表</li>
<li>by https://zhuanlan.zhihu.com/p/121084592</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优化数据访问">优化数据访问</h4>
<p><strong>减少请求的数据量</strong></p>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<p><strong>减少服务器端扫描的行数</strong></p>
<ul>
<li>最有效的方式是使用覆盖索引进行查询</li>
</ul>
<h4 id="重构查询方式">重构查询方式</h4>
<p><strong>1. 切分大查询</strong></p>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<p>大查询：</p>
<pre><code class="language-sql">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);
</code></pre>
<p>优化后：</p>
<pre><code class="language-sql">rows_affected = 0
do {
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
} while rows_affected &gt; 0
</code></pre>
<p><strong>2. 分解大连接查询</strong></p>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<pre><code class="language-sql">SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
</code></pre>
<h3 id="切分">切分</h3>
<h4 id="水平切分-sharding">水平切分 Sharding</h4>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img" style="zoom:90%;" />
<p>策略：</p>
<ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>事务问题：使用分布式事务来解决，比如 XA 接口。</li>
<li>连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li>
<li>ID 唯一性：
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
</li>
</ul>
<h4 id="垂直切分">垂直切分</h4>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img" style="zoom:90%;" />
<h3 id="分布式">分布式</h3>
<h4 id="主从复制">主从复制</h4>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<h4 id="读写分离">读写分离</h4>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<h3 id="关系型数据库-设计理论">关系型数据库 设计理论</h3>
<p>函数依赖：</p>
<ul>
<li>什么是函数依赖</li>
<li>什么是键码、完全函数依赖、传递函数依赖</li>
</ul>
<p>异常：</p>
<ul>
<li>冗余数据</li>
<li>修改异常</li>
<li>删除异常</li>
<li>插入异常</li>
</ul>
<p>范式</p>
<ul>
<li>第一范式 1NF</li>
<li>第二范式 2NF</li>
<li>第三范式 3NF</li>
</ul>
<h3 id="er-图">ER 图</h3>
<p>http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%85%AB%E3%80%81er-%E5%9B%BE</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://javaguide.cn/">JavaGuide</a></li>
<li><a href="http://www.cyc2018.xyz/">CyC2018</a></li>
</ul>
<hr>
<h2 id="过往内容">过往内容</h2>
<h2 id="数据库-2">数据库</h2>
<h3 id="事务-2">事务</h3>
<h3 id="分布式事务">分布式事务</h3>
<h4 id="两阶段提交与三阶段提交">两阶段提交与三阶段提交</h4>
<p>待看：https://zhuanlan.zhihu.com/p/163864897</p>
<p>两阶段提交：角色包括事务管理器和本地资源管理器</p>
<ul>
<li>第一阶段：事务管理器询问各个本地资源管理器是否提交就绪，如果任意一个本地资源管理器为no，则回滚</li>
<li>第二阶段：事务管理器向本地资源管理器发送commit或roolback消息，本地资源管理器收到消息后进行提交或回滚操作。</li>
</ul>
<p>两阶段提交存在的问题：</p>
<ul>
<li>同步阻塞：资源管理器A占用某资源，资源管理器B也需要该资源</li>
<li>单点故障：事务管理器挂了</li>
<li>数据不一致：不能保证所有资源管理器都提交</li>
</ul>
<p>三阶段提交（TCC）：</p>
<ul>
<li>第一阶段：和两阶段提交的第一阶段相同</li>
<li>第二阶段（缓冲阶段）：precommit 预提交，保证各节点状态相同</li>
<li>第三阶段：和两阶段提交的第二阶段相同</li>
</ul>
<p>三阶段提交（TCC）的优点：</p>
<ul>
<li>引入超时机制，减少阻塞：如果超时，默认abort，但如果是第三阶段，超时则自动提交，两阶段提交无法这么做，因为不存在缓冲阶段</li>
<li>事务管理器集群：幂等操作</li>
</ul>
<h3 id="redis">Redis</h3>
<h4 id="3种集群模式主从-哨兵-集群">3种集群模式：主从、哨兵、集群</h4>
<ul>
<li>主从模式：
<ul>
<li>1个主节点，N个从节点</li>
<li>主节点负责写操作，从节点负责读操作</li>
<li>数据同步</li>
<li>一旦主节点挂了，集群就丧失写功能</li>
</ul>
</li>
<li>哨兵模式
<ul>
<li>主从模式的升级版，添加哨兵</li>
<li>哨兵本质上是一个进程，sentinel进程，负责监控节点状态，如果主节点挂了，会从从节点总竞选得到新的主节点</li>
</ul>
</li>
<li>集群模式
<ul>
<li>主从模式+分区</li>
<li>每个主从集群负责一部分哈希槽</li>
</ul>
</li>
</ul>
<h2 id="并发">并发</h2>
<h3 id="synchronized-和-reentrantlock-的实现及区别">synchronized 和 Reentrantlock 的实现及区别</h3>
<ul>
<li>sychronized 是一个关键字，ReentrantLock 是一个类</li>
<li>sychronized 会自动的加锁与释放锁，ReentrantLock 需要程序员手动加锁与释放锁，因此更灵活，可以根据业务场景进行相应操作</li>
<li>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</li>
<li>sychronized底层有一个锁升级的过程
<ul>
<li>偏向锁：偏向第一次持有锁的线程，该线程无需进行同步操作</li>
<li>轻量级锁：自旋，CAS</li>
<li>重量级锁：线程阻塞时，需要将用户态转到内核态</li>
</ul>
</li>
<li>实现
<ul>
<li>synchronized：锁的是对象，锁信息保存在对象头中，可以是实例对象也可以是类对象<br>
6. 对象：使用汇编指令monitorenter和monitorexit<br>
6. 方法：使用ACC_SYNCHRONIZED标识符，本质上也是monitor的操作</li>
</ul>
<ol start="6">
<li>ReentrantLock：通过代码中的state标识来标识锁的状态</li>
</ol>
</li>
</ul>
<h3 id="cas的缺点">CAS的缺点</h3>
<ul>
<li>ABA问题、CPU空转问题</li>
</ul>
<h3 id="线程池实现机制-配置参数-使用注意点">线程池实现机制、配置参数、使用注意点</h3>
<p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：</p>
<ul>
<li>如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建<br>
新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入<br>
缓冲队列。</li>
<li>如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等<br>
于maximumPoolSize，那么通过handler所指定的策略来处理此任务。</li>
<li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li>
</ul>
<p>配置参数：</p>
<ul>
<li>corePoolSize：目的是更有效地利用CPU资源
<ul>
<li>CPU密集型：CPU核数+1，之所以+1，是为了更优的利用率</li>
<li>IO密集型：CPU 核心数 * (1 + IO 耗时/ CPU 耗时)</li>
</ul>
</li>
<li>MaximumPoolSize、workQueueSize、handler拒绝策略、keepAliveTime</li>
</ul>
<p>注意点：</p>
<ul>
<li>线程池预热方法：prestartAllCoreThreads()</li>
</ul>
<h3 id="如何防止超卖现象">如何防止超卖现象</h3>
<ul>
<li>redis缓存和mysql同步更新</li>
<li>减库存排队，使用窗口进行合并</li>
</ul>
<h2 id="jvm">JVM</h2>
<h3 id="gc">GC</h3>
<h4 id="cms-g1的优缺点">CMS、G1的优缺点</h4>
<p>CMS是老年代的垃圾回收器，用的是标记清除算法，所以会产生内存碎片，但是因为它的回收原理是并发回收，因此STW时间较短。</p>
<p>G1是面向整个堆的垃圾回收器，同时将分区的思想与分代相结合，每次回收时，都会去挑选需要回收的分区，使用的算法是标记整理算法，是jdk9默认的收集器，同时G1可以控制STW的时间，如果到达指定的STW时间，对于剩下的分区，就不进行回收，从而可以控制STW的时间。</p>
<h3 id="如何处理线上的oom">如何处理线上的OOM</h3>
<p>-Xms表示初始堆内存大小，memory startup</p>
<p>-XmX表示最大堆内存大小，memory maximum</p>
<p>-Xmn表示新生代内存大小，包括初始值和最大值，memory nursery/new</p>
<p>示例：-Xms16m -Xmx32m</p>
<p>通过参数配置，让java进程在OOM时自动产生dump文件，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp</p>
<p>通过命令行导出dump文件，jmap -dump:live, file=jmap.hprof [PID]</p>
<p>通过jvisualvm分析dump文件，分析哪些对象比较占内存</p>
<p>两种可能</p>
<ul>
<li>对象确实太大了</li>
<li>内存泄漏：各种连接，如果不手动关闭，则会被GC认为是不可回收的对象，导致内存泄漏</li>
</ul>
<h2 id="网络编程">网络编程</h2>
<h3 id="netty">Netty</h3>
<h4 id="了解reactor模型吗">了解Reactor模型吗？</h4>
<p>问题拆解：与Netty是什么关系，有几种类型，各自的优势是什么</p>
<p>Netty 是一个广泛使用的 Java 网络编程框架</p>
<p>Reactor是1995年由道格拉斯提出的一种高性能网络编程模式，一共有3种形式，单线程Reactor、多线程Reactor和主从多线程Reactor。</p>
<ul>
<li>
<p>单线程Reactor：由一个线程处理连接请求、读写操作</p>
</li>
<li>
<p>多线程Reactor：由一个线程处理连接请求，由线程池处理读写操作。但一个线程依旧可以处理多个读写操作。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/6463324-1f7a2d77cfa17720.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>主从Reactor：由一个线程池处理连接请求，并将连接好的请求发送给读写线程池进行处理。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/6463324-a94066924053c037.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>优势：不同形式适应不同的场景</p>
</li>
</ul>
<h4 id="bytebuf实现原理">ByteBuf实现原理</h4>
<p>在java nio中提供了ByteBuffer作为字节容器，包括4个属性</p>
<ul>
<li>mark：调用mark()方法时，将position的值赋值给mark；调用reset()方法时，将mark的值赋值给position</li>
<li>position：下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新</li>
<li>limit：缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量</li>
<li>capacity：缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变</li>
<li>读写模式切换：flip()方法</li>
</ul>
<p>netty提供了ByteBuf作为字节容器，包括3个属性</p>
<ul>
<li>readIndex、writerIndex、capacity：字面意思</li>
<li>discardReadBytes()：清空已读部分，利用System.arraycopy()方法</li>
</ul>
<h2 id="rpc">RPC</h2>
<h3 id="dubbo">Dubbo</h3>
<h4 id="spi机制了解吗">SPI机制了解吗</h4>
<p>Java SPI：全称 Service Provider Interface，为接口指定实现类，放在 META-INF/services/ 目录里</p>
<p>Java SPI的缺点：无法按需加载实现类，只能逐个进行加载，可能存在某个实现类，很耗资源，但又用不上</p>
<p>Dubbo SPI的优点：</p>
<ul>
<li>可以根据名称，按需加载。原理：在配置文件中由用户提供 名称-类全限定名 的键值对</li>
</ul>
<h4 id="负载均衡算法">负载均衡算法</h4>
<ul>
<li>权重随机算法：获取随机数，然后依次减去每个invorker的权重，直到小于0；如果权重相同，则直接随机</li>
<li>权重轮询算法：每次增加当前权重，选出大于当前权重的invorkers，然后从中按顺序选择</li>
<li>最少活跃调用数算法：每次选出最小活跃的invorker，活跃数为invorker正在处理的请求数，如果不止一个，则对于这些invorkers，使用权重随机算法。</li>
<li>一致性Hash算法：环形Hash空间，虚拟节点，对象迁移，寻找最近节点</li>
</ul>
<h2 id="设计思想">设计思想</h2>
<h3 id="api的设计原则">API的设计原则</h3>
<ul>
<li>单一原则</li>
<li>升级兼容性</li>
<li>幂等设计</li>
</ul>
<h3 id="领域建模">领域建模</h3>
<p>DDD 领域驱动设计</p>
<p>建模：对业务的抽象</p>
<p>领域建模：将建模过程划分成4层：UI 层、应用层、领域层、基建层</p>
<ul>
<li>UI层：负责展示</li>
<li>基建层：负责存储</li>
<li>领域层：负责存储过程中的业务逻辑，只关心是否合法，不管是否合理，例如下订单的操作，设计创建订单和减库存，应该在领域层，而不是应用层</li>
<li>应用层：负责核心业务逻辑，例如，黑名单的业务，应该在应用层，而不应该在领域层</li>
</ul>
<p>参考：https://www.zhihu.com/question/25089273</p>
<h2 id="实战">实战</h2>
<h3 id="做的项目遇到什么问题如何解决">做的项目，遇到什么问题，如何解决</h3>
<h2 id="参考资料-2">参考资料</h2>
<ul>
<li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">分布式事务，这一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/paddix/p/5367116.html">Java并发编程：Synchronized及其实现原理</a></li>
<li><a href="https://blog.csdn.net/kusedexingfu/article/details/103744202">JVM的GC 参数为什么要这么命名：xms、xss、xmn和xmn?</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1578846">未关闭的文件流会引起内存泄露么？</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/3696849.html">Netty中的三种Reactor（反应堆）</a></li>
<li><a href="https://www.jianshu.com/p/3930150bf7f0">Netty系列-一分钟了解ByteBuffer和ByteBuf结构</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/108256452">阿里面试真题：Dubbo的SPI机制 敖丙</a></li>
<li><a href="https://www.jianshu.com/p/60c10eabdfaf">Dubbo负载均衡算法实现</a></li>
<li><a href="https://www.cnblogs.com/twoheads/p/10135896.html">一致性哈希算法(consistent hashing)</a></li>
<li><a href="https://www.bilibili.com/video/BV1Lq4y1S7Rc?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1632973331&amp;unique_k=BEotpJ">朋友投稿！与面试官死磕中间件与库存设计！顺利斩获大厂Offer！</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[限流算法学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/">
        </link>
        <updated>2021-09-27T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习限流算法过程中的笔记。</p>
<hr>
<h2 id="计数器">计数器</h2>
<p>设置一个计数器counter，其有效时间为1分钟（即每分钟计数器会被重置为0）</p>
<p>存在临界问题</p>
<h2 id="漏桶-leaky-bucket">漏桶 Leaky Bucket</h2>
<p>漏桶算法思路很简单，水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，而当入小于出的情况下，漏桶不起任何作用。</p>
<p>流入：以任意速率往桶中放入水滴。<br>
流出：以固定速率从桶中流出水滴。</p>
<p>存在效率较低的问题</p>
<h2 id="令牌桶-token-bucket">令牌桶 Token Bucket</h2>
<p>系统会按恒定 1/QPS 时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水)，如果桶已经满了，令牌就溢出了。如果桶未满，令牌可以积累。新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。</p>
<p>流入：以固定速率从桶中流入水滴<br>
流出：按照任意速率从桶中流出水滴</p>
<h2 id="滑动窗口-rolling-window">滑动窗口 Rolling Window</h2>
<p>滑动窗口代表一段时间，将滑动窗口段划分成多个小格，通过统计滑动窗口中的总请求数，判断是否触发限流。每过一段时间，都将窗口往前移动。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/v2-b2fca280cb01069bc3b30c8b55f9d973_1440w.jpg" alt="img" loading="lazy"></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/duanxz/p/4123068.html">常见限流算法介绍（漏桶算法、令牌桶算法）及实现--待整理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/122431276">精度不够，滑动时间来凑「限流算法第二把法器：滑动时间窗口算法」- 第301篇</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java垃圾回收（GC）]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/">
        </link>
        <updated>2021-09-23T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习JVM垃圾回收过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1T34y1X7xx?p=2&amp;spm_id_from=pageDriver">一节课掌握ZGC垃圾回收器</a></li>
</ul>
<hr>
<h2 id="基础知识">基础知识</h2>
<p>手动回收的问题：</p>
<ul>
<li>内存泄漏</li>
<li>重复回收（多线程）</li>
</ul>
<p>引用计数的问题：</p>
<ul>
<li>
<p>循环引用</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923134958252.png" alt="image-20210923134958252" loading="lazy"></figure>
</li>
</ul>
<h2 id="gc工作原理">GC工作原理</h2>
<h3 id="minor-gc新生代gc">Minor GC（新生代GC）</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png" alt="image-20210727152911187" style="zoom:80%;" />
<ul>
<li>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
<li>根可达算法：将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象。</li>
<li>每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。</li>
<li>如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。</li>
</ul>
<h3 id="minor-gc-vs-full-gc">Minor GC VS Full GC</h3>
<ul>
<li>Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。</li>
<li>Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短</li>
<li>算法不同：
<ul>
<li>Mnior GC用空间换时间，需要两个内存空间，直接Copy</li>
<li>Full GC用时间换空间，需要Mark+Compact</li>
</ul>
</li>
</ul>
<h2 id="zgc垃圾回收器">ZGC垃圾回收器</h2>
<p>将堆划分成3部分：</p>
<ul>
<li>小页面（2M）：对象小于256KB</li>
<li>中页面（32M）：对象在256KM~4MB</li>
<li>大页面（&gt;32M）：对象大于4M</li>
</ul>
<p>指针着色：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png" alt="image-20210923143727759" loading="lazy"></figure>
<p>流程：</p>
<ul>
<li>初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。</li>
<li>并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）</li>
<li>再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。</li>
<li>并发转移准备：筛选需要转移的分区</li>
<li>初始转移：转移与GC Roots直接关联的对象</li>
<li>并发转移：转发表</li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>
<p>为什么初始标记阶段，不标记所有对象？</p>
<p>因为耗时少！</p>
</li>
<li>
<p>为什么不直接进行并发标记？即，初始标记的意义是什么？</p>
<p>初始标记的意义：找根对象</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png" alt="image-20210924093232733" loading="lazy"></figure>
</li>
</ul>
<h3 id="z的含义">Z的含义</h3>
<blockquote>
<p>可能大伙还惦记这标题吧？<strong>ZGC 的 Z 是什么意思？</strong></p>
<p>其实没啥意思，就是个名字而已。</p>
<p>https://blog.csdn.net/yessimida/article/details/109763732</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png" alt="img" loading="lazy"></figure>
<h2 id="其他垃圾回收器">其他垃圾回收器</h2>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png" alt="image-20210923142511010" loading="lazy"></figure>
<ul>
<li>
<p>新生代垃圾回收器</p>
<ul>
<li>Serial：标记-复制算法</li>
<li>ParNew：标记-复制算法+多线程+STW尽量短</li>
<li>Parallel Scavenge：标记-复制算法+多线程+吞吐量可控</li>
</ul>
</li>
<li>
<p>老年代垃圾回收器</p>
<ul>
<li>Serial Old：标记-整理算法</li>
<li>Parallel Old：标记-整理算法+多线程</li>
<li>CMS：标记-清除算法+STW尽量短
<ul>
<li>初始标记、并发标记、重新标记、并发清除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>G1</p>
<ul>
<li>
<p>jdk9 默认的收集器</p>
</li>
<li>
<p>标记-整理算法</p>
</li>
<li>
<p>分区+分代</p>
<blockquote>
<p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；</p>
<p>https://www.jianshu.com/p/aef0f4765098</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>ZGC</p>
<ul>
<li>STW极短</li>
<li>分区思想</li>
<li>染色指针</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/kevin7234/p/10644654.html">jvm minor gc 为什么比 full gc 快很多</a></li>
<li><a href="https://www.zhihu.com/question/35172533">为什么minor gc比full gc/major gc快？</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zookeeper学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/">
        </link>
        <updated>2021-09-16T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习Zookeeper过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1av411w7hp?from=search&amp;seid=1946340734056821588&amp;spm_id_from=333.337.0.0">分布式架构Zookeeper入门实战到底层原理剖析</a></li>
</ul>
<hr>
<h2 id="一致性">一致性</h2>
<ul>
<li>强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。
<ul>
<li>分布式锁</li>
</ul>
</li>
<li>最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。</li>
<li>弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</li>
</ul>
<p>zookeeper只保证最终一致性</p>
<h2 id="zookeeper-最终一致性-实现原理">zookeeper 最终一致性 实现原理</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210916135047212.png" alt="image-20210916135047212" loading="lazy"></figure>
<ul>
<li>Zab协议
<ul>
<li>领导者选举机制
<ul>
<li>比较两个节点谁的数据更<strong>新</strong> (zxid)，如果zxid相等，则比较myid，myid越大越好。zxid为请求id，对应每一个请求，且越靠后的请求，zxid越大。myid对应node节点，每个节点都有一个互不相等的myid，由配置文件指定。</li>
</ul>
</li>
<li>过半机制</li>
<li>两阶段提交机制
<ul>
<li>预提交</li>
<li>ACK（过半机制）</li>
<li>提交</li>
</ul>
</li>
<li>同步机制</li>
</ul>
</li>
<li>Zab协议的问题：
<ul>
<li>节点越多，写请求处理越慢，因为需要等待半数节点返回ACK</li>
<li>解决方案：
<ul>
<li>新增观察者，不参与两阶段提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/546b9dd86c91">弱一致性、强一致性、最终一致性、顺序一致性</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秒杀系统-实战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/">
        </link>
        <updated>2021-09-14T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录如何实现一个秒杀系统，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1CE411s7xN?p=2&amp;spm_id_from=pageDriver">1小时带你用Redis轻松实现秒杀系统（附秒杀系统优化实战）</a></li>
</ul>
<hr>
<h2 id="什么是秒杀系统">什么是秒杀系统</h2>
<p>其实主要的业务流程就是下订单、减库存，只是，该业务流程是在高并发、大流量的场景下进行的。</p>
<h2 id="并发量">并发量</h2>
<p>一般秒杀系统的并发量是万级别的，几万、几十万、几百万。</p>
<p>单机MySQL的并发量一般为几百，最多一千。</p>
<p>单机Tomcat的并发量一般也为几百。</p>
<p>单机Redis的并发量一般为几万。</p>
<h2 id="优化前">优化前</h2>
<p><a href="https://gitee.com/Bule-Zst/picture/raw/master/Seckill-%E4%BC%98%E5%8C%96%E5%89%8D.jpg">项目下载</a>（为了省事，我把文件后缀改成jpg了，这样直接用图床帮我存到云端）</p>
<p>就是一个简单的购物系统，先下单之后再减库存，这个系统在业务逻辑上是没有bug的，最主要的问题就是性能差。</p>
<p>需要注意的是，在系统里用到了事务，从而保证下单和减库存是原子操作，这里补充说一下Springboot事务失效的两个常见原因：</p>
<ul>
<li>内部调用：事务基于AOP，会对事务对象包装一个代理对象，因此不能直接调用事务对象的方法，应该使用Springboot的依赖注入，使用注入对象的方法。</li>
<li>数据库存储引擎不支持：MyISAM是不支持事务的，所以可以检查一下数据库表的存储引擎，如果是MyISAM，需要改成InnoDB。</li>
</ul>
<p>吞吐量为130/s</p>
<h2 id="优化">优化</h2>
<h3 id="redis缓存">Redis缓存</h3>
<p>使用redis做缓存</p>
<p>在秒杀之前，把商品库存信息放到redis中</p>
<p>在秒杀时，先对redis中的库存执行decrement方法，之后判断返回结果是否小于0，如果返回结果大于等于0，则进行秒杀业务，否则说明库存为零。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {}
</code></pre>
<p>吞吐量为1400/s</p>
<h4 id="存在的问题">存在的问题</h4>
<p>缓存不一致问题：一旦秒杀业务过程中发生错误导致事务回滚，那么redis中的库存信息就和数据库中的不一致了。</p>
<p>解决方案：如果事务中出现报错，就在catch语句中让库存加一。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
}
</code></pre>
<h3 id="jvm缓存">JVM缓存</h3>
<p>使用ConcurrentHashMap在JVM级别做缓存，当发现redis中库存为零后，使用ConcurrentHashMap标记当前商品为False。</p>
<p>当收到秒杀请求时，首先判断ConcurrentHashMap中当前商品是否被标记，如果被标记了，说明库存为零，直接return。</p>
<p>使用JVM级别的缓存能更好地提高系统性能，因为redis缓存是需要和redis服务做交互的，伴随网络请求，因此性能没有JVM级别快。</p>
<p>吞吐量为：1815/s</p>
<pre><code class="language-java">if( concurrentHashMap.get(id) != null ) {
    return &quot;fail&quot;;
}

Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    concurrentHashMap.put( id, true );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
</code></pre>
<h4 id="存在的问题-2">存在的问题</h4>
<p>JVM级缓存与redis缓存不一致，主要有两种场景</p>
<ul>
<li>
<p>当秒杀业务中存在异常时，会对redis和concurrentHashMap进行恢复，对redis中的缓存进行increment操作，对ConcurrentHashMap进行remove操作，但此时，redis中的库存很可能是负数的情况，因为在高并发情况下，大量请求被接受，所以redis会执行大量的decrement操作，虽然后续会执行increment操作进行恢复，但是有概率在新的请求被处理时，increment操作还未执行，当新的请求进来后，会发现redis中库存为负数，从而在concurrentHashMap进行标记。所以最终，redis中的库存数可能不为0，而concurrentHashMap中对应的商品却被标记了。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914163636067.png" alt="image-20210914163636067" style="zoom:63%;" />
</li>
<li>
<p>在分布式场景下，不同JVM中的concurrentHashMap很难保证同步，可能在某个JVM中对hashMap进行了恢复，但是别的JVM中，hashMap并没有进行恢复。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>如果是分布式导致的不一致问题，可以使用zookeeper解决。当zookeeper中节点的数据发生改变后，zookeeper会主动通知监听该节点的进程，从而实现分布式下JVM级的缓存同步。之所以使用zookeeper，是因为zookeeper是CP的模型，能较好保证各节点之间的一致性。</li>
<li>如果是单机不一致问题，则借助lua脚本，让redis的减一操作和恢复操作原子化，因为之前出问题的原因就是decr和incr二者之间不具有原子性。</li>
</ul>
<h4 id="修复-lua">修复-lua</h4>
<pre><code class="language-java">if( concurrentHashMap.get(id) != null ) {
    return &quot;fail&quot;;
}

String RELEASE_LOCK_LUA_SCRIPT = &quot;if redis.call('decr', KEYS[1]) == -1 then redis.call('incr', KEYS[1]) return '-1' else return redis.call('get', KEYS[1]) end&quot;;
DefaultRedisScript&lt;String&gt; redisScript = new DefaultRedisScript&lt;&gt;(RELEASE_LOCK_LUA_SCRIPT,String.class);
String result = stringRedisTemplate.execute(redisScript, Collections.singletonList(id+&quot;&quot;) );
if( result.equals(&quot;-1&quot;) ) {
    concurrentHashMap.put( id, true );
    return &quot;fail&quot;;
}

try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
return &quot;ok&quot;;
</code></pre>
<p>吞吐量：1700/s</p>
<h3 id="其他优化手段">其他优化手段</h3>
<ul>
<li>
<p>限流降级</p>
</li>
<li>
<p>Redis集群：提高redis并发量</p>
</li>
<li>
<p>微服务架构</p>
</li>
<li>
<p>异步下单</p>
</li>
<li>
<p>前端优化：静态页面、CDN</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL慢查询优化-实战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/">
        </link>
        <updated>2021-09-13T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录优化MySQL慢查询的完整过程以及心得体会。</p>
<hr>
<h2 id="数据准备">数据准备</h2>
<p>随机生成了50w条数据，具体步骤可以参考这篇博客：<a href="https://blog.csdn.net/qq_36994788/article/details/73216961">mysql插入千万条随机数据</a></p>
<h2 id="前置知识">前置知识</h2>
<p>Explain语句结果中各个字段分表表示什么：</p>
<p>各字段含义：</p>
<ul>
<li>id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样</li>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>type：针对单表的查询方式
<ul>
<li>all、index、range、ref、eq_ref、const，从左到右效率依次提升</li>
<li>all：全表扫描</li>
<li>index：根据索引的顺序全表扫描</li>
<li>range：索引范围查询，between、&gt;、&lt;、in</li>
<li>ref：查询条件使用索引，但不是唯一索引</li>
<li>eq_ref：查询条件使用唯一索引</li>
<li>const：查询条件使用主键，优化器会把查询优化为一个常量</li>
<li>by https://blog.csdn.net/dennis211/article/details/78170079</li>
</ul>
</li>
<li>possible_keys：可能用到的索引</li>
<li>key : 实际用到的索引</li>
<li>rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）</li>
<li>Extra：
<ul>
<li>Impossible where：查询条件为false</li>
<li>Using where：顺序扫描，where 条件查询</li>
<li>Using index：覆盖索引</li>
<li>Using index condition：索引下推
<ul>
<li>根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表</li>
<li>在表上建立联合索引（name, age）</li>
<li><code>select * from table1 where name like &quot;张%&quot; and age = 23;</code></li>
<li>组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102404385.png" alt="image-20210913102404385" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913125829371.png" alt="image-20210913125829371" loading="lazy"></figure>
<h2 id="优化前统计">优化前统计</h2>
<ul>
<li>
<p>select * from emp where deptno = 101;</p>
<p>时间: 0.55s</p>
</li>
</ul>
<h2 id="开始优化">开始优化</h2>
<h3 id="是否走了索引">是否走了索引</h3>
<p>Explain结果：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102307124.png" alt="image-20210913102307124" loading="lazy"></figure>
<p>结果分析：</p>
<p>Extra中为Using where，表示未使用索引，根据where条件顺序扫描</p>
<p>解决方案：对deptno列建立索引</p>
<p>建立索引后，Explain结果：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105003822.png" alt="image-20210913105003822" loading="lazy"></figure>
<p>时间: 3.636s</p>
<p>结果分析：时间反而变长了，猜测，可能是发生了回表操作。</p>
<p>验证：</p>
<p>尝试只select deptno，从而使用覆盖索引。</p>
<p>select deptno from emp where deptno = 101;</p>
<p>时间: 0.095s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110312538.png" alt="image-20210913110312538" loading="lazy"></figure>
<p>注意到Extra出现Using index，表示使用了覆盖索引。</p>
<p>尝试select ename，在这种情况下，会发生回表操作</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 3.189s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110337524.png" alt="image-20210913110337524" loading="lazy"></figure>
<p>未使用覆盖索引</p>
<p>建立联合索引，(deptno, ename)</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 0.033s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105937845.png" alt="image-20210913105937845" loading="lazy"></figure>
<p>使用了覆盖索引</p>
<p>验证结束</p>
<h3 id="是否是最优索引">是否是最优索引</h3>
<p>where条件只对deptno进行了约束，因此是最优索引</p>
<h3 id="是否查询了过多字段">是否查询了过多字段</h3>
<p>select *，查询字段过多，应根据实际业务需要，减少查询字段，例如只查询ename和deptno，这样就可以使用联合索引进行优化。</p>
<h3 id="是否应该进行分库分表">是否应该进行分库分表</h3>
<p>暂时不考虑分库分表</p>
<h3 id="是否数据库服务所在机器性能过低">是否数据库服务所在机器性能过低</h3>
<p>暂时不考虑机器性能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ConcurrentHashMap详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/">
        </link>
        <updated>2021-09-01T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习ConcurrentHashMap过程中的学习笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/4dTDHcwa7M9">ConcurrentHashMap底层原理与源码分析深入详解</a></li>
</ul>
<hr>
<h2 id="hashmap">HashMap</h2>
<p>非线程安全</p>
<p>实现原理：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901135831288.png" alt="image-20210901135831288" loading="lazy"></figure>
<h2 id="hashtable">Hashtable</h2>
<p>线程安全：对put方法加synchronized锁</p>
<p>缺点：性能差</p>
<h2 id="concurrenthashmap-jdk17">ConcurrentHashMap jdk1.7</h2>
<p>class Segment extends Reentralock</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901141125962.png" alt="image-20210901141125962" loading="lazy"></figure>
<h3 id="构造方法">构造方法</h3>
<p>segments数组长度为2的幂，为什么？因为计算下标时需要 <code>h &amp; (length-1)</code>，因此，必须是2的幂。</p>
<p>同时，Segment对象内部的数组，长度也是2的幂，大小为 <code>initialCapacity / concurrencyLevel</code></p>
<p>流程：</p>
<ul>
<li>首先，根据initialCapacity、loadFactor和concurrencyLevel，计算segments数组的大小、segment对象内部table的大小和threshold</li>
<li>然后，初始化Segment对象，并放到segments[0]</li>
</ul>
<pre><code class="language-java">public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &lt; c)
        cap &lt;&lt;= 1;
    // create segments and segments[0]
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
</code></pre>
<h3 id="put">put</h3>
<p>流程：</p>
<ul>
<li>首先，根据key获取Segment对象，如果不存在，则初始化，使用CAS赋值给segments数组</li>
<li>尝试对Segment对象进行加锁
<ul>
<li>如果加锁失败，则边尝试加锁，边遍历table[key]</li>
<li>如果遍历过程中，找到了对应的entry对象，则<strong>停止遍历</strong>。如果遍历完，依旧没有找到entry对象，则新建entry对象，然后<strong>停止遍历</strong>。</li>
<li>停止遍历后
<ul>
<li>继续尝试加锁，如果尝试次数超过 <code>MAX_SCAN_RETRIES</code>，则调用lock方法，阻塞加锁</li>
<li>如果在尝试加锁过程中，发现table[key]被修改（first != table[key]），则重新开始遍历</li>
</ul>
</li>
<li>只有当新建entry对象时，才会在加锁后获取到entry对象，其余情况下，获取到的都为null</li>
</ul>
</li>
<li>加锁成功后，开始遍历table[key]
<ul>
<li>如果找到对应entry对象，则修改其value值</li>
<li>如果没有找到entry对象，则判断之前是否已经新建过entry对象，如果没有，则新建。将新建的entry对象加入到table[key]的头结点之前，然后判断是否需要进行扩容操作。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&lt;K,V&gt;[] tab = table;
        int index = (tab.length - 1) &amp; hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}

private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {
    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = null;
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        HashEntry&lt;K,V&gt; f; // to recheck first below
        if (retries &lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries &gt; MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries &amp; 1) == 0 &amp;&amp;
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
</code></pre>
<h3 id="扩容">扩容</h3>
<ul>
<li>首先，segment数组的长度是不会变的，与并发级别（concurrencyLevel）相同，扩容只在segment对象内部进行</li>
<li>在put方法中，若segment中元素个数超过threshold，则进行rehash。
<ul>
<li>将table大小扩展一倍，并对所有元素放到新table中，同时根据比例因子更新threshold</li>
<li>这里有一个需要说明的地方，在转移中，会去寻找最后一节不需要改动的链表，然后将其整个移动到新table中。怎么理解呢？因为在移动过程中，需要重复创建Entry，比较耗费资源，所以能尽量不创建就不创建。因此，转移过程中，会先找到 lastRun 节点，该节点后面的节点对应的hash值和该节点都一样，所以可以一起移动到新table中。然后再对lastRun节点之前的节点一个一个进行转移。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//扩容，Segment中，只对Segment中的HashEntry[]扩容
@SuppressWarnings(&quot;unchecked&quot;)
private void rehash(HashEntry&lt;K,V&gt; node) {
	HashEntry&lt;K,V&gt;[] oldTable = table;//保存老的HashEntry[]
	int oldCapacity = oldTable.length;
	int newCapacity = oldCapacity &lt;&lt; 1;//扩容为原来的2倍
	threshold = (int)(newCapacity * loadFactor);//计算新的阈值
	HashEntry&lt;K,V&gt;[] newTable =
		(HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];//创建新的HashEntry[]
	int sizeMask = newCapacity - 1;
	for (int i = 0; i &lt; oldCapacity ; i++) {//循环移动老的数组中的元素
		HashEntry&lt;K,V&gt; e = oldTable[i];
		if (e != null) {
			HashEntry&lt;K,V&gt; next = e.next;
			int idx = e.hash &amp; sizeMask;//计算在HashEntry[]中存放的位置
			if (next == null)   //当前节点的下一个节点为null，说明当前链表就一个节点
				newTable[idx] = e;//直接赋值
			else { //存在链表
				HashEntry&lt;K,V&gt; lastRun = e;
				int lastIdx = idx;
				//循环找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
				for (HashEntry&lt;K,V&gt; last = next;
					 last != null;
					 last = last.next) {
					int k = last.hash &amp; sizeMask;
					if (k != lastIdx) {
						lastIdx = k;
						lastRun = last;
					}
				}
				newTable[lastIdx] = lastRun;//复制链表
				//处理lastRun之前的节点，这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
				for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
					V v = p.value;
					int h = p.hash;
					int k = h &amp; sizeMask;
					HashEntry&lt;K,V&gt; n = newTable[k];
					newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
				}
			}
		}
	}
	 // 将新加的 node 放到新数组中刚刚的两个链表之一的头部
	int nodeIndex = node.hash &amp; sizeMask;
	node.setNext(newTable[nodeIndex]);
	newTable[nodeIndex] = node;
	table = newTable;
}
</code></pre>
<h2 id="concurrenthashmap-jdk18">ConcurrentHashMap jdk1.8</h2>
<h3 id="sizectl">sizeCtl</h3>
<ul>
<li>-1：正在初始化</li>
<li>0：未进行初始化</li>
<li>&gt;0：
<ul>
<li>若还未进行初始化，则为初始化时 <code>tabel</code> 的容量</li>
<li>else，为触发下一次扩容的阈值</li>
</ul>
</li>
</ul>
<h3 id="初始化">初始化</h3>
<ul>
<li>如果sizeCtl小于0，则说明正在进行初始化，通过 <code>Thread.yield()</code> 让出CPU时间</li>
<li>else
<ul>
<li>将 <code>sizeCtl</code> 的值赋值为 <code>sc</code>，作为备份，然后将sizeCtl赋值为-1
<ul>
<li>如果sc大于0，初始化长度为sc的table</li>
<li>else，初始化长度为 <code>DEFAULT_CAPACITY</code> 的table</li>
</ul>
</li>
<li>将 <code>n-(n&gt;&gt;&gt;2)</code> 的值赋值给sizeCtl，<code>n-(n&gt;&gt;&gt;2)</code> 表示 <code>0.75*n</code> ，所以sizeCtl为触发下一次扩容的阈值</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre>
<h3 id="put-2">put</h3>
<ul>
<li>
<p>for循环</p>
<ul>
<li>
<p>如果table为空，则初始化table，然后重新循环</p>
</li>
<li>
<p>如果table[i]为空，则初始化node节点，然后放到table[i]中</p>
<ul>
<li>如果“放”操作成功，则结束循环</li>
<li>因为存在并发，“放”的操作可能失败，如果失败，则重新循环。</li>
</ul>
</li>
<li>
<p>如果table[i]的状态是MOVED，说明当前正在扩容，则帮忙一起扩容，扩容结束后，重新循环。</p>
</li>
<li>
<p>以上3个条件都不满足，则对table[i]加锁</p>
<ul>
<li>
<p>如果table[i]为链表，则遍历链表，并维护binCount变量，寻找key是否存在</p>
<ul>
<li>如果存在，则更新value，结束遍历</li>
<li>如果不存在，利用尾插法，插入新的node节点，结束遍历</li>
</ul>
</li>
<li>
<p>如果table[i]为红黑树，则向红黑树中插入node节点，将binCount设为2</p>
</li>
<li>
<p>插入完成后，如果binCount大于等于TREEIFY_THRESHOLD（默认为8），则将table[i]由链表转换成红黑树。</p>
</li>
<li>
<p>退出循环</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果key在原先链表、红黑树中不存在（即，需要插入新节点），则调用 <code>addCount(1L, binCount)</code> 将count加1。</p>
</li>
</ul>
<pre><code class="language-java">final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh &gt;= 0) {
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
</code></pre>
<h4 id="链表转红黑树">链表转红黑树</h4>
<ul>
<li>根据链表，生成新的TreeNode类型的双向链表，hd为头结点</li>
<li>利用 <code>TreeBin(TreeNode&lt;K,V&gt; b)</code> 构造函数，由双向链表转成红黑树</li>
</ul>
<pre><code class="language-java">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {
    Node&lt;K,V&gt; b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            tryPresize(n &lt;&lt; 1);
        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&lt;K,V&gt; hd = null, tl = null;
                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {
                        TreeNode&lt;K,V&gt; p =
                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));
                }
            }
        }
    }
}
</code></pre>
<h6 id="treebin与treenode">TreeBin与TreeNode</h6>
<p>在jdk1.8的HashMap中，没有使用TreeBin，为什么ConcurrentHashMap中使用了TreeBin？</p>
<ul>
<li>避免红黑树头结点发生变化：
<ul>
<li>在节点插入到红黑树的过程中，头结点可能会因为左移而改变，但是在ConcurrentHashMap中，是需要对头结点进行加锁操作的，一旦头结点发生改变，那么别的线程，就不会受到锁的限制，从而造成错误。</li>
</ul>
</li>
</ul>
<h4 id="addcount">addCount</h4>
<p>功能梳理：</p>
<ul>
<li>让ConcurrentHashMap的size加x</li>
<li>在满足一定条件的情况下，对ConcurrentHashMap进行扩容</li>
</ul>
<p>流程梳理：</p>
<ul>
<li>
<p>加x部分：</p>
<ul>
<li>
<p>对ConcurrentHashMap的size进行加x操作有两种选择：</p>
<ul>
<li>对counterCells加x（可以先看size方法，加深对counterCells的理解）</li>
<li>对baseCount加x</li>
</ul>
</li>
<li>
<p>首先判断counterCells是否为空，如果不为空，则进入if内部，对counterCells加x</p>
</li>
<li>
<p>如果counterCells为空，则尝试对baseCount进行加x操作</p>
<ul>
<li>如果成功，则结束，进入后续扩容部分</li>
<li>如果失败，则同样进入if内部，对counterCells加x</li>
</ul>
</li>
<li>
<p>对counterCells加x的操作流程：</p>
<ul>
<li>如果counterCells为空，则①</li>
<li>如果counterCells不为空，但是length小于等于0，则①
<ul>
<li>这里补充一点，代码里的写法是 <code>(m = as.length - 1) &lt; 0</code> ，为什么要这么做呢，因为后续需要使用m进行与操作获取数组下标位置，与的时候是需要用 <code>length-1</code> 的，所以直接在上面的判断中进行赋值。</li>
</ul>
</li>
<li>如果counterCells不为空，且length也大于0，则判断对应下标位置的元素 <code>as[ThreadLocalRandom.getProbe() &amp; m]</code> 是否为空，如果为空，则①</li>
<li>如果对应下标位置的元素也不为空，则尝试直接对该元素进行加x操作，如果失败，则①</li>
<li>①：调用 <code>fullAddCount(x, uncontended)</code> 对counterCells加x，addCount方法结束</li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩容部分：</p>
<ul>
<li>不进行扩容的情况
<ul>
<li>check小于0</li>
<li>对counterCells进行加x操作，并且check小于等于1</li>
<li>调用fullAddCount对counterCells进行加x操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
        if (check &lt;= 1)
            return;
        s = sumCount();
    }
    if (check &gt;= 0) {
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
</code></pre>
<h5 id="fulladdcount">fullAddCount</h5>
<ul>
<li>使用线程的探针值对h进行赋值</li>
<li>for循环
<ul>
<li>如果counterCells不为空，且长度等于0
<ul>
<li>如果counterCells数组对应下标位置元素为空
<ul>
<li>将collide赋值为false</li>
<li>如果counterCells未被其他线程占用，则尝试使用x为对应位置进行初始化，如果初始化成功，则退出循环</li>
</ul>
</li>
<li>如果wasUncontended为false，则将wasUncontended改为true。
<ul>
<li>wasUncontended：表示上一次没有冲突</li>
<li>如果为false，则说明有冲突，所以直接跳到最后一条语句，更新h的值</li>
</ul>
</li>
<li>尝试使用CAS对数组对应下标位置的元素加x
<ul>
<li>如果成功，则退出循环</li>
</ul>
</li>
<li></li>
<li></li>
<li>更新h的值</li>
</ul>
</li>
<li>else，如果cellsBusy为0（说明counterCells没有被其他线程占用）
<ul>
<li>则对counterCells进行初始化，初始化为长度为2的数组，并将x的值添加到数组中</li>
<li>如果成功，则退出循环</li>
</ul>
</li>
<li>else，尝试对baseCount进行加x操作
<ul>
<li>如果成功，则退出循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final void fullAddCount(long x, boolean wasUncontended) {
    int h;
    if ((h = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit();      // force initialization
        h = ThreadLocalRandom.getProbe();
        wasUncontended = true;
    }
    
    boolean collide = false;                // True if last slot nonempty
    for (;;) {
        CounterCell[] as; CounterCell a; int n; long v;
        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) {
            if ((a = as[(n - 1) &amp; h]) == null) {
                if (cellsBusy == 0) {            // Try to attach new Cell
                    CounterCell r = new CounterCell(x); // Optimistic create
                    if (cellsBusy == 0 &amp;&amp;
                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                        boolean created = false;
                        try {               // Recheck under lock
                            CounterCell[] rs; int m, j;
                            if ((rs = counterCells) != null &amp;&amp;
                                (m = rs.length) &gt; 0 &amp;&amp;
                                rs[j = (m - 1) &amp; h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                break;
            else if (counterCells != as || n &gt;= NCPU)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 &amp;&amp;
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                try {
                    if (counterCells == as) {// Expand table unless stale
                        CounterCell[] rs = new CounterCell[n &lt;&lt; 1];
                        for (int i = 0; i &lt; n; ++i)
                            rs[i] = as[i];
                        counterCells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = ThreadLocalRandom.advanceProbe(h);
        }
        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;
                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
            boolean init = false;
            try {                           // Initialize table
                if (counterCells == as) {
                    CounterCell[] rs = new CounterCell[2];
                    rs[h &amp; 1] = new CounterCell(x);
                    counterCells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
            break;                          // Fall back on using base
    }
}
</code></pre>
<h3 id="size">size</h3>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_36625757/article/details/90074355">JDK1.7&amp;1.8中ConcurrentHashMap解析</a></li>
<li><a href="https://www.bilibili.com/video/BV1H64y1X7yM?p=6">我敢说这是B站最详细的hashmap及ConcurrentHashMap底层原理解析，16个小时带你吃透所有知识</a></li>
</ul>
]]></content>
    </entry>
</feed>