<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Bule-Zst.github.io</id>
    <title>Bule-Zst</title>
    <updated>2021-03-31T04:33:41.531Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Bule-Zst.github.io"/>
    <link rel="self" href="https://Bule-Zst.github.io/atom.xml"/>
    <logo>https://Bule-Zst.github.io/images/avatar.png</logo>
    <icon>https://Bule-Zst.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[B站讲的最好的MySQL数据库教程全集 2020最新版-图灵学院诸葛]]></title>
        <id>https://Bule-Zst.github.io/jvgYk8JbI/</id>
        <link href="https://Bule-Zst.github.io/jvgYk8JbI/">
        </link>
        <updated>2021-03-31T03:10:34.000Z</updated>
        <content type="html"><![CDATA[<p>from <a href="https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web">https://www.bilibili.com/video/BV1xh411Z79d?share_source=copy_web</a></p>
<hr>
<p>MySQL慢查询 优化手段：</p>
<ul>
<li>索引：使用MySQL工具，如explain，看一下查询有没有走索引。</li>
</ul>
<p>索引是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong>。<br>
索引的常见数据结构：</p>
<ul>
<li>Hash表</li>
<li>二叉搜索树：
<ul>
<li>优化思路：使用二叉搜索树，降低IO操作次数。</li>
<li>缺点-退化。当数据递增或递减时，会退化成链表，如，1, 2, 3, 4, 5</li>
</ul>
</li>
<li>二叉平衡树
<ul>
<li>优化思路：减少二叉树层数，降低IO操作次数。</li>
<li>红黑树：缺点-效率低。虽然会自平衡，但当数据量达到500w时，可能树的高度会达到20层，如果查询的数据在叶子结点，20次IO操作依旧很慢。</li>
</ul>
</li>
<li>多路平衡树
<ul>
<li>优化思路：扩展每个节点，使其包含多个索引元素，更进一步减少二叉树层数，降低IO操作次数。</li>
<li>B-Tree</li>
<li><strong>B+Tree</strong>
<ul>
<li>目前MySQL索引采用的数据结构</li>
<li>MySQL中，默认情况下，每个节点可占用的空间大小为16KB。3层B+Tree，约可以存放2000w个索引元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从二叉搜索树到二叉平衡术再到多路平衡树，本质上是逐步降低了磁盘IO次数，那为什么不把所有索引元素都放到一个节点中？这样，只需要一次IO操作就行了。</p>
<ul>
<li>当数据量大的时候，太占内存了，并且有的时候，可能内存容量不允许这么做。</li>
<li>当所有索引都读取到内存后，索引数量太多，可能500w，二分查找效率也会降低。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jetbrains系列产品重置试用方法]]></title>
        <id>https://Bule-Zst.github.io/mQjLrKUHc/</id>
        <link href="https://Bule-Zst.github.io/mQjLrKUHc/">
        </link>
        <updated>2021-01-06T03:17:53.000Z</updated>
        <content type="html"><![CDATA[<p>本站惯例：本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。</p>
<p>没错，jetbrains-agent这个项目停止了。市面上漫天飞的各种最新都是其他大神的魔改版本。<br>
我不是要专门写个博文来说明jetbrains-agent项目已经停止，然后缅怀感叹一番。这篇文章是想和大家聊聊另一种思路。</p>
<h1 id="0x0-项目背景">0x0. 项目背景</h1>
<p>Jetbrains家的产品有一个很良心的地方，他会允许你试用30天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。<br>
但很多时候会出现一种情况：IDE并不能按照我们实际的试用时间来计算。<br>
我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）<br>
发现了吗？你未能真的有30天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？</p>
<p>事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。但切记不要无休止的一直试用，这并不是这个插件的本意！</p>
<h1 id="0x1-如何安装">0x1. 如何安装</h1>
<h2 id="1-插件市场安装">1). 插件市场安装：</h2>
<ul>
<li>在Settings/Preferences... -&gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io</li>
<li>搜索：<code>IDE Eval Reset</code>插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？</li>
<li>插件会提示安装成功。</li>
</ul>
<h2 id="2-下载安装">2). 下载安装：</h2>
<ul>
<li>点击这个<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip">链接(v2.1.6)</a>下载插件的zip包（macOS可能会自动解压，然后把zip包丢进回收站）</li>
<li>通常可以直接把zip包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences... -&gt; Plugins 里手动安装插件（Install Plugin From Disk...）</li>
<li>插件会提示安装成功。</li>
</ul>
<h1 id="0x2-如何使用">0x2. 如何使用</h1>
<ul>
<li>一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）</li>
<li>也可以手动唤出插件的主界面：
<ul>
<li>如果IDE没有打开项目，在Welcome界面点击菜单：Get Help -&gt; Eval Reset</li>
<li>如果IDE打开了项目，点击菜单：Help -&gt; Eval Reset</li>
</ul>
</li>
<li>唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：
<ul>
<li>按钮：Reload 用来刷新界面上的显示信息。</li>
<li>按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（此为手动重置方式）</li>
<li>勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式）</li>
</ul>
</li>
</ul>
<h1 id="0x3-如何更新">0x3. 如何更新</h1>
<h2 id="1-插件更新机制推荐">1). 插件更新机制（推荐）：</h2>
<ul>
<li>IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>点击IDE的<code>Check for Updates...</code>菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>插件更新可能会需要重启IDE。</li>
</ul>
<h2 id="2-手动更新">2). 手动更新：</h2>
<ul>
<li>从本页面下载最新的插件zip包安装更新。参考本文：<code>下载安装</code>小节。</li>
<li>插件更新需要重启IDE。</li>
</ul>
<h1 id="0x4-一些说明">0x4. 一些说明</h1>
<ul>
<li>本插件默认不会显示其主界面，如果你需要，参考本文：<code>如何使用</code>小节。</li>
<li>市场付费插件的试用信息也会一并重置。</li>
<li>对于某些付费插件（如: Iedis 2, MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：
<ul>
<li>如果IDE没有打开项目，在Welcome界面点击菜单：Configure -&gt; Edit Custom VM Options... -&gt; 移除 -javaagent: 开头的行。</li>
<li>如果IDE打开了项目，点击菜单：Help -&gt; Edit Custom VM Options... -&gt; 移除 -javaagent: 开头的行。</li>
</ul>
</li>
<li>重置需要重启IDE生效！</li>
<li>重置后并不弹出Licenses对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。</li>
<li>如果长达25天不曾有任何重置动作，IDE会有通知询问你是否进行重置。</li>
<li>如果勾选：Auto reset before per restart ，重置是静默无感知的。</li>
<li>简单来说：勾选了Auto reset before per restart则无需再管，一劳永逸。</li>
</ul>
<h1 id="0x5-开源信息">0x5. 开源信息</h1>
<ul>
<li>插件是学习研究项目，源代码是开放的。源码仓库地址：<a href="https://gitee.com/pengzhile/ide-eval-resetter">Gitee</a>。</li>
<li>如果你有更好的想法，欢迎给我提Pull Request来共同研究完善。</li>
<li>插件源码使用：GPL-2.0开源协议发布。</li>
<li>插件使用PHP编写，毕竟PHP是世界上最好的编程语言！</li>
</ul>
<h1 id="0x6-支持的产品">0x6. 支持的产品</h1>
<ul>
<li>IntelliJ IDEA</li>
<li>AppCode</li>
<li>CLion</li>
<li>DataGrip</li>
<li>GoLand</li>
<li>PhpStorm</li>
<li>PyCharm</li>
<li>Rider</li>
<li>RubyMine</li>
<li>WebStorm</li>
</ul>
<hr>
<p>from <a href="https://zhile.io/2020/11/18/jetbrains-eval-reset.html">https://zhile.io/2020/11/18/jetbrains-eval-reset.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 410. 分割数组的最大值]]></title>
        <id>https://Bule-Zst.github.io/vus3sqCc8/</id>
        <link href="https://Bule-Zst.github.io/vus3sqCc8/">
        </link>
        <updated>2020-12-30T08:10:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题意">题意</h1>
<p>给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。</p>
<h1 id="解题思路">解题思路</h1>
<h2 id="暴力搜索">暴力搜索</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><msubsup><mi>n</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>{</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>{</mo><mtext> </mtext><mi>M</mi><mo>[</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mtext> </mtext><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub><mo>}</mo><mo>}</mo></mrow><annotation encoding="application/x-tex">M[n,k] = min^n_{j=1}\{max\{ \ M[j,k-1], \ \sum^{n-1}_{i=j}A_i\}\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.133108em;vertical-align:-0.383108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">}</span></span></span></span></span></p>
<p>其中，n表示数组长度，k表示数组分成几段。<br>
初始化条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>]</mo><mo>=</mo><msub><mi>A</mi><mn>0</mn></msub><mspace linebreak="newline"></mspace><mi>M</mi><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M[1,k] = A_0 \\ M[n,1] = \sum^{n-1}_{i=0}A_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="动态规划">动态规划</h2>
<p>递归算法拥有指数时间的复杂度，并且会重复计算一些M值。这类的算法一般可以使用动态规划进行优化。使用数组保存一些已经计算得到的值，采用自底向上进行计算</p>
<h2 id="二分查找">二分查找</h2>
<p>此题可以想象成把数据按顺序装入桶中，m即是给定的桶数，问桶的容量至少应该为多少才能恰好把这些数装入k个桶中（按顺序装的）。</p>
<p>首先我们可以知道，桶的容量最少不会小于数组中的最大值，即桶容量的最小值（小于的话，这个数没法装进任何桶中），假设只需要一个桶，那么其容量应该是数组所有元素的和，即桶容量的最大值；其次，桶数量越多，需要的桶的容量就可以越少，即随着桶容量的增加，需要的桶的数量非递增的（二分查找就是利用这点）；我们要求的就是在给定的桶数量m的时候，找最小的桶容量就可以把所有的数依次装入k个桶中。在二分查找的过程中，对于当前的桶容量，我们可以计算出需要的最少桶数requiredPainters，如果需要的桶数量大于给定的桶数量k，说明桶容量太小了，只需在后面找对应的最小容量使需要的桶数恰好等于k；如果计算需要的桶数量小于等于k，说明桶容量可能大了（也可能正好是要找的最小桶容量），不管怎样，该桶容量之后的桶容量肯定不用考虑了（肯定大于最小桶容量），这样再次缩小查找的范围，继续循环直到终止，终止时，当前的桶容量既是最小的桶容量。</p>
<p>对于数组 1 2 3 4 5 6 7，假设k=3，最小桶容量为7（要5个桶），最大桶容量为28（一个桶）</p>
<figure data-type="image" tabindex="1"><img src="https://Bule-Zst.github.io/post-images/1609316379450.png" alt="" loading="lazy"></figure>
<p>第一行表示桶容量，第二行表示需要的桶数，即要求桶数量恰为k的最小桶容量。</p>
<h1 id="代码">代码</h1>
<pre><code class="language-c++">class Solution {
public:
    bool judge( vector&lt;int&gt;&amp; nums, int capacity, int num ) {
        int curCapacity = capacity;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            if( curCapacity &lt; nums[i] ) {
                num--;
                if( num == 0 ) {
                    return false;
                }
                curCapacity = capacity;
                i--;
            } else {
                curCapacity -= nums[i];
            }
        }
        return true;
    }
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        int max, min;
        int sum = 0;
        for( int i = 0; i &lt; nums.size(); ++i ) {
            sum += nums[i];
        }
        max = sum; // 成功的情况
        min = 0; // 失败的情况
        while( min&lt;max-1 ) { // 当两者相邻，就退出
            int mid = ( min+max ) / 2;
            if( judge(nums,mid,m) ) {
                max = mid;
            } else {
                min = mid;
            }
        }
        return max;
    }
};
</code></pre>
<hr>
<p>from <a href="https://www.cnblogs.com/ygh1229/p/10637504.html">https://www.cnblogs.com/ygh1229/p/10637504.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux->Ubuntu下配置telnet环境]]></title>
        <id>https://Bule-Zst.github.io/Grj96uz3p/</id>
        <link href="https://Bule-Zst.github.io/Grj96uz3p/">
        </link>
        <updated>2020-12-29T10:12:33.000Z</updated>
        <content type="html"><![CDATA[<p>1、首先查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出为空，表示没有开启该服务</p>
<p>2、安装openbsd-inetd</p>
<p><code>apt-get install openbsd-inetd</code></p>
<p>如果已经安装过了，会提示已经安装过了，直接执行下面的步骤就可以了。</p>
<p>3、安装telnetd</p>
<p><code>apt-get install telnetd</code></p>
<p>安装完之后，查看/etc/inetd.conf的内容会多了一行telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p><code>cat /etc/inetd.conf | grep telnet</code></p>
<p>输出： telnet stream tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd</p>
<p>4、重启openbsd-inetd</p>
<p><code>/etc/init.d/openbsd-inetd restart</code></p>
<p>输出：* Restarting internet superserver inetd</p>
<p>5、查看telnet运行状态</p>
<p><code>netstat -a | grep telnet</code></p>
<p>输出：tcp　　0　　0 :telnet　　😗　　LISTEN</p>
<p>此时表明已经开启了telnet服务。</p>
<p>6、telnet登陆测试</p>
<p><code>telnet 127.0.0.1</code></p>
<p>输出： Trying 127.0.0.1… Connected to 127.0.0.1. Escape character is ‘^]’. （停在这里的时候要按Ctrl+] 然后回车）</p>
<p>telnet&gt; （表示登陆成功）</p>
<hr>
<p>from <a href="https://www.cnblogs.com/taomylife/p/7552424.html">https://www.cnblogs.com/taomylife/p/7552424.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题库]]></title>
        <id>https://Bule-Zst.github.io/ti_ku/</id>
        <link href="https://Bule-Zst.github.io/ti_ku/">
        </link>
        <updated>2020-12-26T08:17:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="打表">打表</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/UVA100">UVA100 The 3n + 1 problem</a></li>
</ul>
<h1 id="并查集">并查集</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1111">P1111 修复公路</a></li>
</ul>
<h1 id="二分">二分</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></li>
<li><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></li>
</ul>
<h1 id="分治">分治</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1257">P1257 平面上的最接近点对</a></li>
</ul>
<h1 id="栈">栈</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/tag-validator/">591. 标签验证器</a></li>
</ul>
<h2 id="单调栈">单调栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
</ul>
<h1 id="计算几何">计算几何</h1>
<h2 id="凸包">凸包</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/erect-the-fence/">587. 安装栅栏</a></li>
</ul>
<h1 id="链表">链表</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/insertion-sort-list/147/">147. 对链表进行插入排序</a></li>
</ul>
<h1 id="dp">dp</h1>
<ul>
<li><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364845">ZOJ 1346 Comparing Your Heroes</a></li>
<li><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[知识点汇总]]></title>
        <id>https://Bule-Zst.github.io/zhi_shi_dian_hui_zong/</id>
        <link href="https://Bule-Zst.github.io/zhi_shi_dian_hui_zong/">
        </link>
        <updated>2020-12-26T03:32:26.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要收藏一些平时工作学习中遇到的问题的解决方案，供大家参考。</p>
<h1 id="windows子系统">WIndows子系统</h1>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-6---install-your-linux-distribution-of-choice">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a></li>
</ul>
<h1 id="python">Python</h1>
<ul>
<li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">Python安装包大全</a></li>
<li><a href="https://blog.csdn.net/weixin_45523851/article/details/110674141">Could not build wheels for cryptography which use PEP 517 and cannot be installed directly</a></li>
<li><a href="https://blog.csdn.net/qm5132/article/details/105619531/">python和Microsoft Visual C++ Build Tools版本安装</a></li>
<li><a href="https://blog.csdn.net/pyyong2011/article/details/105045883/">python: cookies 解密问题</a></li>
</ul>
<h1 id="算法">算法</h1>
<ul>
<li><a href="https://blog.csdn.net/qq_33935895/article/details/103261211">[算法]分治法解最近对问题</a></li>
<li><a href="https://blog.csdn.net/q547550831/article/details/51541527">分治法——棋盘覆盖问题</a></li>
<li><a href="https://www.cnblogs.com/l1l1/p/9432876.html">求凸包（安德鲁算法）</a></li>
<li><a href="https://blog.csdn.net/peng0614/article/details/81193484">【计算几何/凸包】安德鲁算法（Andrew's Algorithm）详解</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NexT主题设置Valine评论系统邮件提醒]]></title>
        <id>https://Bule-Zst.github.io/hxfRZLp5C/</id>
        <link href="https://Bule-Zst.github.io/hxfRZLp5C/">
        </link>
        <updated>2020-12-21T14:08:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天无意间看到很久之前写的一篇文章有新的评论，而评论时间呢也是10天以前的。这就有点伤了啊，别人兴致冲冲地提了疑惑，而我却10天后才看到。经过这一茬，意识到评论提醒功能的重要性。由于我使用的是hexo+NexT主题+Valine评论系统，自然而然地就去<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine官网</a>看了看，没想到还真有提醒的功能「<a href="https://valine.js.org/notify.html" target="_blank" rel="noopener">邮件提醒</a>」。</p>
<p>这里就给大家讲讲Valine中如何配置邮件提醒功能。</p>
<h2 id="Valine邮件提醒"><a href="#Valine邮件提醒" class="headerlink" title="Valine邮件提醒"></a>Valine邮件提醒</h2><p>Valine评论功能是基于<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud</a>的，Valine评论功能还不能跑起来的可以看看我之前写的文章《<a href="/2345860311#comment_system">Hexo使用NexT主题及配置</a>》，其中就有详细的使用说明，这里就不展开了。</p>
<p>Valine官方提供的邮件提醒功能是基于<code>Leancloud的密码重置邮件提醒</code>，操作步骤如下：</p>
<p>进入<code>Leancloud</code>&gt;选择你的评论所存放的<code>应用</code>&gt;<code>设置</code>&gt;<code>邮件模板</code>，按下图设置好用于<code>重置密码</code>的邮件主题&gt;然后保存:</p>
![](https://Bule-Zst.github.io/post-images/1608560201989.jpg)
<ol>
<li><p>修改邮件主题：<code>你在  的评论收到了新的评论</code></p>
</li>
<li><p>修改内容：将下面的代码复制到“内容”中，并将其中的<code>你的网址首页链接</code>改为你的网址首页链接。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi, {{username}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">你在 {{appname}} 的评论收到了新的回复，请点击查看：</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"你的网址首页链接"</span> <span class="attr">style</span>=<span class="string">"display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;"</span>&gt;</span>马上查看<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>点击“保存”按钮</p>
</li>
<li><p>修改<span class="label label-info">NexT主题配置文件</span>，搜索<code>valine</code>（快速定位），将其中的<code>notify</code>改为<code>true</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  gaKW5SWAvf7NBolU9wFbxN8O-gzGxoHsz</span><br><span class="line">  appkey: susRJyHS8Fq1SyKXg0r9ad65</span><br><span class="line">  notify: true # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 您的评论可以一针见血 (*^ω^*)~~ # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>发送次数过多，可能会暂时被Leancloud 屏蔽邮件发送功能  </li>
<li>由于<code>邮件提醒</code>功能使用的<code>Leancloud的密码重置邮件提醒</code>，只能传递<code>昵称</code>、<code>邮箱</code>两个属性，所以邮件提醒链接<code>无法直达指定文章页</code>。<strong>请悉知</strong>。  </li>
<li>开启<code>邮件提醒</code>会默认开启<code>验证码</code>选项。  </li>
<li><p>该功能目前还在测试阶段，谨慎使用。</p>
</li>
<li><p>目前<code>邮件提醒</code>正处于测试阶段，仅在<code>子级</code>对存在邮件地址的<code>父级</code>发表评论时发送邮件</p>
</li>
</ul>
<h2 id="第三方支持"><a href="#第三方支持" class="headerlink" title="第三方支持"></a>第三方支持</h2><p>这里重点讲一下第三方<code>邮件提醒</code>：<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a> (by <a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">@zhaojun1998</a>)</p>
<p>这也先需要将Valine的评论功能成功跑起来。</p>
<p>然后进入 <a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">Leancloud</a> 对应的 Valine 应用中。</p>
<ol>
<li>点击 <code>云引擎 -&gt; 设置</code> 填写代码库并保存：<code>https://github.com/zhaojun1998/Valine-Admin</code></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://Bule-Zst.github.io/post-images/1608560645315.png" alt="" loading="lazy"></figure>
<ol start="2">
<li><p>切换到部署标签页，分支使用 master，点击部署即可：<br></p>
<figure data-type="image" tabindex="2"><img src="https://Bule-Zst.github.io/post-images/1608560340962.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Bule-Zst.github.io/post-images/1608560360122.png" alt="" loading="lazy"></figure>
</li>
<li><p>设置云引擎的环境变量</p>
<figure data-type="image" tabindex="4"><img src="https://Bule-Zst.github.io/post-images/1608560540352.png" alt="" loading="lazy"></figure>
<p><strong>必选参数</strong></p>
<ul>
<li><code>SITE_NAME</code> : 网站名称。</li>
<li><code>SITE_URL</code> : 网站地址, <strong>最后不要加 <code>/</code> 。</strong></li>
<li><code>SMTP_USER</code> : SMTP 服务用户名，一般为邮箱地址。</li>
<li><code>SMTP_PASS</code> : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li>
<li><code>SMTP_SERVICE</code> : 邮件服务提供商，支持 <code>QQ</code>、<code>163</code>、<code>126</code>、<code>Gmail</code>、<code>"Yahoo"</code>、<code>......</code>  ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services" target="_blank" rel="noopener">Nodemailer Supported services</a>。 — <em>如这里没有你使用的邮件提供商，请查看<a href="/高级配置.md#自定义邮件服务器">自定义邮件服务器</a></em></li>
<li><code>SENDER_NAME</code> : 寄件人名称。</li>
</ul>
<p>由于我使用的是我自己的企业邮箱，所以这边的<code>SMTP_SERVICE</code>就不适用了，需要用这三个参数替换：<code>SMTP_HOST</code>、<code>SMTP_PORT</code>、<code>SMTP_SECURE</code>。</p>
<p>详细说明如下：</p>
<ul>
<li><code>SMTP_HOST</code> : 邮件服务提供商 SMTP 地址，如 qq : <code>smtp.qq.com</code>，<em>此项需要自行查询或询问其服务商</em>。</li>
<li><code>SMTP_PORT</code> : 邮件服务提供商 SMTP 端口, <em>此项需要自行查询或询问其服务商</em>。</li>
<li><code>SMTP_SECURE</code> : 是否启用加密, 默认为 <code>true</code>，一般不需要设置，如有特殊请自行配置。 <em>此项需要自行查询或询问其服务商</em>。</li>
</ul>
<p>如果也同我一样使用阿里云企业邮箱，<code>SMTP_HOST</code>、<code>SMTP_PORT</code>、<code>SMTP_SECURE</code>可以照我的写。</p>
<p>可以看到上图中，我的自定义环境变量还多了2个，分别是：</p>
<ul>
<li><code>TO_EMAIL</code>：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到<code>SMTP_USER</code>。</li>
<li><code>TEMPLATE_NAME</code>：设置提醒邮件的主题，目前内置了两款主题，分别为 <code>default</code> 与 <code>rainbow</code>。默认为 <code>default</code> 。</li>
</ul>
<h3 id="Web-评论管理"><a href="#Web-评论管理" class="headerlink" title="Web 评论管理"></a>Web 评论管理</h3><p>此项目还为 Valine 提供了更方便的评论管理功能，可以在 web 端对评论进行查看与删除操作。配置方式如下。</p>
![](https://Bule-Zst.github.io/post-images/1608560421062.png)
<p>后台登录需要账号密码，需要在这里设置，只需要填写 <code>email</code>、<code>password</code>、<code>username</code>，这三个字段即可, 使用  <code>email</code> 作为账号登陆即可。（为了安全考虑，此 <code>email</code> 必须为配置中的 <code>SMTP_USER</code> 或 <code>TO_EMAIL</code>， 否则不允许登录）<br></p>
<figure data-type="image" tabindex="5"><img src="https://Bule-Zst.github.io/post-images/1608560447539.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Web 后台目前仅有 <code>查看</code> 与 <code>删除</code> 功能</p>
</blockquote>
<h3 id="LeanCloud-休眠策略"><a href="#LeanCloud-休眠策略" class="headerlink" title="LeanCloud 休眠策略"></a>LeanCloud 休眠策略</h3><p>免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：</p>
<ul>
<li>每天必须休眠 6 个小时</li>
<li>30 分钟内没有外部请求，则休眠。</li>
<li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li>
</ul>
<p>分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。</p>
<p>附 <code>Linux crontab</code> 定时器代码：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注 : 此 <code>crontab</code> 不是 <code>LeanCloud</code> 后台的定时任务，如果你没有 <code>Linux</code> 服务器来配置此定时器，那么可以在此 <a href="https://github.com/zhaojun1998/Valine-Admin/issues/1" target="_blank" rel="noopener">issues</a> 中回复<strong>zhaojun1998</strong>，让他帮你加上。</p>
</blockquote>
</li>
</ol>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p><strong class="lable-red">更新新版本与更改环境变量均需要重启容器后生效。</strong></p>
<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4>
<figure data-type="image" tabindex="6"><img src="https://Bule-Zst.github.io/post-images/1608560469789.png" alt="" loading="lazy"></figure>
<hr>
<p>from <a href="https://www.nhtzj.com/3315416634/">https://www.nhtzj.com/3315416634/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防御式编程（Defensive Programming）]]></title>
        <id>https://Bule-Zst.github.io/dU5GQhPud/</id>
        <link href="https://Bule-Zst.github.io/dU5GQhPud/">
        </link>
        <updated>2020-12-20T08:34:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>新的一年开始了，大家都立下了什么新年flag呢？好久没有更新简书了，最近在看《代码大全》对于第八章的防御式编程颇有感慨，正好最近又是在准备公司的技术分享，索性用<code>md</code>写了篇博文，总结了一下又增加了一些我个人的理解，在这里跟各位分享一下。</p>
<h1 id="defensive-programming">Defensive Programming</h1>
<figure data-type="image" tabindex="1"><img src="https://Bule-Zst.github.io/post-images/1608456004690.webp" alt="" loading="lazy"></figure>
<p><strong>防御式编程（Defensive Programming）</strong>是提高软件质量技术的有益辅助手段</p>
<p>怎么理解呢？防御式编程思想的理解可以参考防御式驾驶：</p>
<p>在防御式驾驶中要建立这样一种思维，那就是你水远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。</p>
<figure data-type="image" tabindex="2"><img src="https://Bule-Zst.github.io/post-images/1608456590306.png" alt="" loading="lazy"></figure>
<p>防御式编程的主要思想是：</p>
<p><strong>子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。</strong></p>
<p>更一般地说，其核心想法是要承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点来编程序，这种思想是将可能出现的错误造成的影响控制在有限的范围内。</p>
<h2 id="保护程序免遭非法输入数据的破坏">保护程序免遭非法输入数据的破坏</h2>
<p>计算机领域有着一句<code>GIGO(Garbage In Garbage Out)</code>俗语，翻译过来就是<code>垃圾进，垃圾出</code>，意思就是<code>有垃圾数据进来后，出来的也是垃圾数据</code>。</p>
<figure data-type="image" tabindex="3"><img src="https://Bule-Zst.github.io/post-images/1608456659523.png" alt="" loading="lazy"></figure>
<p>而就目前而言，对于已经成型的产品可能单单是这种原则并不适用，而是应该做到<code>垃圾进，什么也不出</code>、<code>垃圾进，出去的是错误提示</code>、<code>垃圾进，经过筛选提取，出去的是有用信息</code>或是<code>不许垃圾进来</code>。换句话说，<code>GIGO</code>于今天的标准看来已然是差劲程序的标志了。</p>
<p>防御式编程针对垃圾进这种情况，有以下三种方法处理：</p>
<h4> 1、检查所有来源于外部的数据</h4>
<p>当从文件、用户、网络或其他外部接口中获取数据时，应检查所获得的数据值，以确保它在允许的范围内。</p>
<h4> 2、检查子程序所有输入参数的值</h4>
<p>检查子程序输入参数的值，事实上和检查来源于外部的数据一样，只不过数据来源于其他子程序而非外部接口。</p>
<h4> 3、决定如何处理错误的输入数据</h4>
<p>一旦检测到非法的参数，你该如何处理它呢？根据情况的不同，你可以选择适合你的<code>错误处理技术</code>或<code>断言</code>来处理。</p>
<p>接下来我们将针对以上所说的情况讲解防御式编程中需要掌握的方式：</p>
<h2 id="断言">断言</h2>
<figure data-type="image" tabindex="4"><img src="https://Bule-Zst.github.io/post-images/1608456704145.webp" alt="" loading="lazy"></figure>
<p>断言是指在开发期间使用的、让程序在运行时进行自检的代码（通常为宏或一个子程序）。断言为真则程序正常运行，断言为假则意味着代码中发生了错误。</p>
<p>举个例子：一份客户信息程序要求包含记录数不超过10，我们加一个断言。当记录数小于10，断言会默默无语两眼泪，当超过10，断言就会大声的说程序中存在一个错误！</p>
<p>断言对于大型复杂程序或可靠性要求极高的程序来说尤为重要。通过使用断言，程序员能更快速排查出因修改代码或者别的原因，而弄进程序里不匹配的接口和错误等。</p>
<p>OC中内置的断言：（<strong>iOS每个线程都可以指定断言处理器。想设置一个 NSAssertionHandler 的子类来处理失败的断言，在线程的 threadDictionary 对象中设置 NSAssertionHandlerKey 字段即可</strong>）</p>
<p>对NSAssertionHandler有兴趣的童鞋请移步：<a href="https://nshipster.cn/nsassertionhandler/" target="_blank" rel="nofollow">传送门</a></p>
<pre><code>#define NSAssert(condition, desc, ...)  \
    do {                \
    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
    if (__builtin_expect(!(condition), 0)) {        \
            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
            __assert_file__ = __assert_file__ ? __assert_file__ : @&quot;&lt;Unknown File&gt;&quot;; \
        [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
        object:self file:__assert_file__ \
            lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
    }               \
        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
    } while(0)
#endif
</code></pre>
<p>下面将介绍一下断言使用时的建议：</p>
<h4> 1、建立自己的断言机制</h4>
<p>很多时候，系统自带的断言无法满足我们的需求，比如iOS断言在release模式下会失效，那么我们可以自定义断言来适应我们的项目</p>
<p>下面是C++的断言宏示例：</p>
<pre><code>
#define ASSERT(condition, message) {    \
    if (!condition) {                   \
        Log(&quot;ERROR &quot;,condition,message);\
        exit( EXIT_FAILURE );           \
    }                                   \
}                                       \

</code></pre>
<p>OC中示例：</p>
<pre><code>#define WYHAssert(condition, desc)  \
if (DEBUG) {                        \
   NSAssert(condition, desc);       \
}else {                             \
   NSString *app_build = [[NSBundle mainBundle].infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; \
NSLog(@&quot;Assert Error condition:%@ (desc: %@) \n Occur in &lt;%s&gt;&lt;第%d行&gt; , AppBuildVersion:%@&quot;,condition,desc,__FILE__,__LINE__,app_build); \
   [LogModule postLog];                            \
} \
</code></pre>
<h4> 2、用错误处理代码处理预期发生的状况，用断言去处理那些不可发生的错误！</h4>
<p>断言和错误处理代码的区别：</p>
<p>断言是用来检查永远不该发生的情况，而错误处理代码(error-handling code)是用来检查不太可能经常发生的情况，这些情况是能在写代码时被预料的，且在产品正式上线时也要处理这些情况，因而说错误处理通常用来检查有害的输入数据，而断言是用于检查代码中的bug ！</p>
<p>有种方式可以让你更好理解断言：</p>
<blockquote>
<p>把断言看做是可执行的注解，你不能依赖它来让代码正常工作，但与编程语言中的注解相比，它更能主动地对程序中的假定做出说明。</p>
</blockquote>
<h4> 3、利用断言来注解前条件和后条件</h4>
<p>前条件（先验条件）和后条件(后验条件)专有名词最初来自于<a href="https://baike.baidu.com/item/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1/2180000?fr=aladdin" target="_blank" rel="nofollow">契约式设计(Design by Contract)(DbC)</a>，使用契约式设计时，每个子程序或类与程序的其余部分都形成了一份契约。</p>
<blockquote>
<p>很多语言都有对这种断言的支持。然而DbC认为这些契约对于软件的正确性至关重要，它们应当是设计过程的一部分。实际上，DbC提倡首先写断言。（百度百科）</p>
</blockquote>
<p>前条件：子程序或类的调用方代码再调用子程序或实例化对象之前要确保为真的属性。前条件是调用方对其所调用的代码要承担的义务。</p>
<p>后条件：子程序或类在执行结束后要确保为真的属性，后条件是子程序或类对调用方代码所承担的责任。</p>
<p>而断言是用来说明前后条件的有利工具。</p>
<p>下面举个例子说明：</p>
<pre><code>/// 警报站坐标
private class EStationCoordinate: NSObject {

    var latitude: Float?
    
    var longitude: Float?
    
    var elevation: Float = 0.0
    
    init(_ latitude: Float,_ longitude: Float,_ elevation: Float) {
        super.init()
        
        self.latitude = latitude
        self.longitude = longitude
        self.elevation = elevation
    }
}


/// 取得报警站坐标
///
/// - Parameters:
///   - latitude: &lt;#latitude description#&gt;
///   - longitude: &lt;#longitude description#&gt;
///   - elevation: &lt;#elevation description#&gt;
/// - Returns: &lt;#return value description#&gt;
private func createEmergencyCoordinate(_ latitude: Float,_ longitude: Float,_ elevation: Float) -&gt; EStationCoordinate {
    
    // precondition
    assert(-90 &lt;= latitude &amp;&amp; latitude &lt;= 90, &quot;latitude must within range !&quot;);
    
    assert(0 &lt;= longitude &amp;&amp; longitude &lt; 360, &quot;longitude must within range !&quot;);
    
    assert(100 &lt;= elevation &amp;&amp; elevation &lt; 500, &quot;elevation must within range !&quot;);
    
    // handle .... searching in local
    
    // postcondition
    assert(isContain, &quot;local not contain this coordinate !&quot;)
    
    var coordinate = EStationCoordinate(latitude,longitude,elevation)
    
    return coordinate
    
}
</code></pre>
<p>如果变量latitude、longitude和elevation都是来源于系统外部，那么就应该用错误处理代码来检查和处理非法的数值，而如果变量的值是源于可信的系统内部，并且这段程序是基于这些值不会超出合法范围的假定而设计，使用断言则是非常合适的。</p>
<h4> 4、避免将需要执行的子程序放到断言中</h4>
<p>如果把需要执行的子程序代码写在断言的codition条件里，那么当你关闭断言功能时，编译器很可能就把这些代码排除在外了，下面举一个例子：</p>
<pre><code>- (void)postFileToServer {
    
    // .... make file
    
    NSAssert([self compressFileToZip], @&quot;File can't be compressed !&quot;);
    
    // ... post to server 
}

- (BOOL)compressFileToZip {
    
    //... compress file and create a zip path !
    if (zipPath.length &gt; 0) {
        
        return YES;
    }
    return NO;
}
</code></pre>
<p>这样如果未编译断言，则condition语句的子程序也将不会执行，应修改为以下：</p>
<pre><code>- (void)postFileToServer {
    
    // .... make file
    BOOL isCompressSuccess = [self compressFileToZip];
    
    NSAssert(isCompressSuccess, @&quot;File can't be compressed !&quot;);
    
    // ... post to server
}
</code></pre>
<h2 id="错误处理技术">错误处理技术</h2>
<figure data-type="image" tabindex="5"><img src="https://Bule-Zst.github.io/post-images/1608456741675.webp" alt="" loading="lazy"></figure>
<p>前面我们提过了，断言是处理程序代码中那些不应发生的错误，那么又如何处理那些我们预料之内的可能发生的错误呢？</p>
<p>首先我们要明确对于程序而言，处理错误最恰当的方式是要根据程序软件的类别而定，进而言之就是对于程序的两个概念：<em>健壮性与正确性</em></p>
<h4> 程序的健壮性 </h4></h4>
<p>定义：健壮性具体指的是系统在不正常的输入或不正常的外部环境下仍能表现出正常的程度。</p>
<p>健壮性的原则：</p>
<ul>
<li>不断尝试采取措施来包容错误的输入以此让程序正常运转（对自己的代码要保守，对用户的行为要开放）</li>
<li>考虑各种各样的极端情况，没有impossible</li>
<li>即使终止执行，也要准确/无歧义的向用户展示全面的错误信息</li>
<li>错误信息有助于进行debug</li>
</ul>
<p>例如：视频游戏中的绘图子程序接收到了一个错误的颜色输入，那么在设计的时候可以针对这种情况，采用它的默认背景色或前景色继续绘制，而不是让程序崩溃或退出。</p>
<h4> 程序的正确性</h4>
<p>定义：正确性意味着程序永不返回不准确的结果，即使这样做会不返回结果或是直接退出程序。</p>
<p>例如：在设计控制治疗癌症病人的放疗设备的软件时，当软件接收到错误的放射剂量，那么也许直接关闭程序就是最佳的选择，哪怕重启也比冒险施放错误的放射剂量要好的多。</p>
<p>总结，两者之间的区别在于：</p>
<ul>
<li>正确性：永不给用户错误的结果，哪怕是退出程序</li>
<li>健壮性：尽可能的保持软件运行而不是总是退出</li>
</ul>
<p>了解了程序的健壮性与正确性，我们就可以采用以下几种手段，或结合起来使用错误处理技术：</p>
<p><strong>1、返回中立值：</strong></p>
<p>有时，处理错误的最佳做法就是继续执行操作并简单的返回一个没有危害的值。</p>
<p>比如，一个基于输入颜色的绘图子程序接收到了一个错误的颜色输入，它可以忽略这个错误的颜色，而是采用默认的底色或前景色继续进行绘制，而不是直接崩溃。</p>
<p><strong>2、换用下一个正确的数据</strong></p>
<p>在处理轮询查询状态的子程序时，如果某次查询出的输出数据错误或有误，大可以忽略本次错误的数据，继续等待下一次轮询时读取正确的数据<br>
<p>（例如，如果你以每秒100次的速度读取体温计的数据，如果某一次得到的数据有误，我们可以再等上1/100秒后继续读取正确的数据）</p>
<p><strong>3、返回与前次相同的数据</strong></p>
<p>还是举上一个例子，如果体温计在1/100秒读取到的是一个错误数据，那么大可以返回上一次正确的数据，因为温度在1/100秒内变化不会太大。</p>
<p><strong>4、换用最接近的合法值</strong></p>
<p>比如，当我们在编写一个滑块在规定区域内滑动的程序时，如果滑块超过规定区域，我们可以取最接近于超过区域的安全数值返回。</p>
<p><strong>5、把警告信息记录到日志文件中</strong></p>
<p>在检测到错误数据时，可以选择在日志文件中记录一条警告信息，然后继续执行。</p>
<p><strong>6、返回一个错误状态码</strong></p>
<p>可以决定只让徐彤的某些部分处理错误，其他部分则不在局部处理错误，而是简单的返回一个错误码。</p>
<p>比如在用户信息编辑页面有一个保存按钮，当某些信息填写错误时，这时只是记录一个错误码，当点击保存按钮时才去判断验证这个错误码是否存在，决定是否允许用户执行下一步操作</p>
<p><strong>7、调用错误处理子程序或对象</strong></p>
<p>把错误处理都集中在一个全局的错误处理子程序或对象中，这种方法优点在于能把错误处理的职责集中到一起，从而让调试变得更简单。而代价则是整个程序都要知道这个集中点，并与之紧密耦合。</p>
<p>什么意思呢？比如在一系列有上下文关系的请求中，针对所有的请求错误，我们只封装一个错误管理类来集中管理这些错误。</p>
<p><strong>8、当错误发生时显示出错消息</strong></p>
<p>这种方法可以把错误处理的开销减到最小，然而你需要衡量此时的错误消息对于用户而言是否是友善的，相反对于攻击者而言，尽量不要让他们利用错误信息来发现如何攻击这个系统。</p>
<p><strong>9、关闭程序</strong></p>
<p>有一些更偏向于<code>正确性</code>的程序，当检测到错误发生时，也许关闭程序是最佳的选择。</p>
<p>如上面谈到的<code>癌症病人的放疗设备的软件</code></p>
<h2 id="异常">异常</h2>
<figure data-type="image" tabindex="6"><img src="https://Bule-Zst.github.io/post-images/1608456771734.webp" alt="" loading="lazy"></figure>
<p>异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。</p>
<blockquote>
<p>异常处理，英文名为exceptional handling, 是代替日渐衰落的error code方法的新法，提供error code 所未能具体的优势。异常处理分离了接收和处理错误代码。这个功能理清了编程者的思绪，也帮助代码增强了可读性，方便了维护者的阅读和理解。 异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理使用 try、catch 和 finally 关键字来尝试可能未成功的操作，处理失败，以及在事后清理资源。(百度百科)</p>
</blockquote>
<p>如果在一个子程序中遇到了预料之外的情况，但并不知道如何处理的话，你就可以选择抛出一个异常。</p>
<p>异常的基本结构是：子程序使用throw抛出一个异常对象，再被调用链上层其他子程序的try-catch语句捕获。(<strong>内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止</strong>)</p>
<p>我知道听到这，肯定有人懵逼了，我们来看下面的例子：</p>
<pre><code>+ (void)tryFirstException {
    @try {
        // 1
        [self trySecondException];
        
    } @catch (NSException *exception) {
        //2
        NSLog(@&quot;First reason:%@&quot;,exception.reason);
        
    } @finally {
        //3
    }
    //4
}

+ (void)trySecondException {
    @try {
        //5
        [self tryThirldException];
        
    } @catch (NSException *exception) {
        //6
        @throw exception; //如果将这段代码注释后又会怎样？
        NSLog(@&quot;Second reason:%@&quot;,exception.reason);
    } @finally {
        //7
    }
    //8
}

+ (void)tryThirldException {
    //9
    @throw [NSException exceptionWithName:@&quot;Exc&quot; reason:@&quot;no reason!&quot; userInfo:nil];
}
</code></pre>
<p>有人知道程序应该怎么执行吗？</p>
<blockquote>
<p>许多常见的程序设计语言，包括Actionscript，Ada，BlitzMax，C++，C#，D，ECMAScript，Eiffel，Java，ML，Object Pascal（如Delphi，Free Pascal等），Objective-C，Ocaml，PHP（version 5），PL/1，Prolog，Python，REALbasic，Ruby，Visual Prolog以及大多数.NET程序设计语言，内建的异常机制都是沿着函数调用栈的函数调用逆向搜索，直到遇到异常处理代码为止。一般在这个异常处理代码的搜索过程中逐级完成栈卷回（stack unwinding）。但Common Lisp是个例外，它不采取栈卷回，因此允许异常处理完后在抛出异常的代码处原地恢复执行。</p>
</blockquote>
<p>下面将给予一些使用异常的建议：</p>
<h4> 1、用异常通知程序的其他部分，发生了不可忽略的错误</h4>
<p>异常机制的优越之处，在于它能提供一种无法被忽略的错误通知机制。其他错误处理技术有可能会导致错误在不知不觉中向外扩散，而异常则消除了这种可能性。</p>
<h4> 2、只在真正例外的情况下才抛出异常</h4>
<p>仅在真正例外的情况下才使用异常————换句话说，就是仅在其他编码实践方法无法解决的情况下才使用异常。这种情况跟断言相似————都是用来处理那些不仅罕见甚至永远不该发生的情况。</p>
<h4> 3、不能用异常来推卸责任</h4>
<p>如果某种错误情况可以在局部处理，那就应该在局部处理它。不要把本可以处理的错误当成一个未被捕获的异常抛出去。</p>
<h4> 4、避免在构造函数和析构函数中抛出异常，除非你在同一个地方把它们捕获</h4>
<p>如果尝试在构造函数或析构函数中抛出异常，则处理异常将变得非常复杂。<br>
<p>比如在C++中，只有对象在完全构造之后才能调用析构函数，也就是说如果再构造函数中抛出异常，就不会调用析构函数，从而造成潜在的资源泄漏。</p></p>
<h4> 5、在恰当的抽象层次抛出异常</h4>
<p>当你决定把一个异常传给调用方时，请确保异常的抽象层次与子程序的接口抽象层次一致。<br>
<p>（比如在A类的某一子程序中，有一个getDefenseId的方法，在方法中的某些步骤中，我们抛出了一个文件读写错误的异常，这本应由层次更低的内部类F专职去做的事，却错误的在A类中抛出异常，破坏了封装性，也暴露了一些私有的实现细节，这显然不是我们想要的）</p></p>
<h4> 6、在异常消息中加入关于导致异常发生的全部信息</h4>
<p>比如因为一个索引值错误而抛出的，就应该在异常消息中包含索引的上下界限一级非法的索引下标值等信息。</p>
<h4> 7、避免使用空的catch语句</h4>
<p>不要视图敷衍一个不知该如何处理的异常</p>
<h4> 8、考虑创建一个集中的异常报告机制</h4>
<p>封装一个异常报告的子程序（或基类）专门快速方便的报告程序中需要主动抛出的异常（异常处理器），将对于异常的使用更加标准化</p>
<h4> 9、考虑异常的替换机制</h4>
<p>虽然一些编程语言对于异常的支持已有5~10年甚至更久的历史，但关于如何安全使用异常的经验仍然还是很少。</p>
<p>拿iOS举例，<code>Apple.inc</code>虽然同时提供了错误处理（<code>NSError</code>）和异常处理（<code>Exception</code>）两种机制，但是Apple不建议我们主动去使用Exception，更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。</p>
<blockquote>
<p>Important: In many environments, use of exceptions is fairly commonplace. For example, you might throw an exception to signal that a routine could not execute normally—such as when a file is missing or data could not be parsed correctly. Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors. Instead you should use the return value of a method or function to indicate that an error has occurred, and provide information about the problem in an error object. For more information, see Error Handling Programming Guide.</p>
<p>(developer.apple.com)</p>
</blockquote>
<p>感兴趣的童鞋请移步苹果官网 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168" target="_blank" rel="nofollow">传送门</a></p>
<p>多说一句，虽然apple不推荐我们经常主动使用Exception，但针对于crash的异常捕捉，iOS是可以通过<code>NSSetUncaughtExceptionHandler</code>来捕获大部分crash的，但值得注意的是无法捕获那些由于<code>内存溢出</code>、<code>野指针BAD_ACCESS</code>导致的crash，比如<code>Flurry</code>中对<code>crash</code>处理就是这么运作的。</p>
<pre><code>    - (void) uncaughtExceptionHandler(NSException *exception) 
    {
        [Flurry logError:@&quot;Uncaught&quot; message:@&quot;Crash!&quot; exception:exception];
    }
 
    - (void)applicationDidFinishLaunching:(UIApplication *)application
    {
        NSSetUncaughtExceptionHandler(&amp;uncaughtExceptionHandler);
        [Flurry startSession:@&quot;YOUR_API_KEY&quot;];
        // ....
    }
</code></pre>
<h2 id="隔栏">隔栏</h2>
<figure data-type="image" tabindex="7"><img src="https://Bule-Zst.github.io/post-images/1608456801568.webp" alt="" loading="lazy"></figure>
<p>隔栏是防御式编程中的一种容损策略，举个例子，大家可以这样来理解：</p>
<p>船体外壳上装备隔离舱，如果船只与冰山相撞导致船体破裂，隔离舱就会被封闭起来，从而保护船体的其余部分不会受到影响。<br>
<p>（<code>隔栏</code>过去叫<code>防火墙</code>，但现在<code>防火墙</code>这一术语常用来代指阻止恶意网络攻击）</p></p>
<p>如下图：</p>
<figure data-type="image" tabindex="8"><img src="https://Bule-Zst.github.io/post-images/1608456820092.webp" alt="" loading="lazy"></figure>
<p> </p>
<p><code>5毛钱特效</code>翻译过来就是：</p>
<figure data-type="image" tabindex="9"><img src="https://Bule-Zst.github.io/post-images/1608457186869.webp" alt="" loading="lazy"></figure>
<p>左侧外部接口数据假定是肮脏的不可信的，中间这些类（子程序）构成<code>隔栏</code>，负责清理和验证数据并返回可信的数据，最右侧的类（子程序）全部在假定数据干净（安全）的基础上工作，这样可以让大部分的代码无须再担负检查错误数据的职责！</p>
<p>这种策略可以拟一个比较生动的例子，可以看做是手术室里使用的一种策略。<br>
<p>任何东西在允许进入手术室之前都要经过消毒处理，因此手术室里的任何东西都可以认为是安全的。这其中最核心的设计决策是<code>规定什么可以进入手术室，什么不可以，还有把手术室的门设在哪里</code></p></p>
<p>在编程中也是如此，约定哪些子程序可认为是在安全区域里的，哪些又是在安全区域外的，哪些负责清理数据（完成这一工作最简单的方法是在得到外部数据时，立即进行清理，不过数据往往需要经过一层以上的清理，因此多层清理有时也是必须的）</p>
<p>隔栏的应用：<br>
<p>隔栏的使用使断言和错误处理有了清晰的区分，隔栏外部的程序应该使用错误处理技术，在那里对数据做的任何处理假定都是不安全的。而隔栏内部的程序里就应该使用断言技术，因为传进来的数据应该已在通过隔栏时被清理过了。如果隔栏内部的子程序检测到了错误的数据，那么应该是程序里的错误而不是程序外的错误。</p></p>
<h2 id="辅助调试代码">辅助调试代码</h2>
<p>防御式编程的另一重要方面就是使用调试助手（辅助调试代码），调试助手非常之强大👍，可以帮助我们快速检查错误。</p>
<p>应用在开发期间应牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具。</p>
<h4> 1、应尽早的引入辅助调试代码</h4>
<p>越早进入辅助调试代码，它能够提供的帮助也越大。如果你经常遇到某些问题，尝试自己编写或引入一些<code>辅助调试代码</code>，它就会自始至终在项目中帮助你。</p>
<h4> 2、采用进攻式编程</h4>
<figure data-type="image" tabindex="10"><img src="https://Bule-Zst.github.io/post-images/1608456836309.webp" alt="" loading="lazy"></figure>
<p>什么又是进攻式编程，其实这也是防御式编程中的一种习惯，其思想在于：</p>
<blockquote>
<p>尽量让异常的情况在开发期间暴露出来，而在产品上线时自我恢复。</p>
</blockquote>
<p>比如你有一段switch case语句用来处理事件，在开发期间应尽量考虑所有你能预料得到的情况并作出处理，另外在default case语句中，如果是开发阶段可以采用<code>进攻式编程处理</code>，而在产品正式上线期间，针对default case应更稳妥一些，比如记录错误日志。</p>
<p>下面列举一下进攻式编程的方法：</p>
<ul>
<li>确保断言语句使程序终止运行</li>
<li>完全填充分配到的所有内存</li>
<li>完全填充己分配到的所有文件或流</li>
<li>确保每一个case 语句中的default分支或else 分支都能产生严重错误（如终止程序）</li>
<li>在删除一个对象之前把它填满垃圾数据</li>
<li>让程序将错误日志主动用电子邮件或推送发送给开发者（安防目前采用）</li>
</ul>
<h4> 3、计划移除调试辅助的代码</h4>
<p>如果是商用软件，调试用的代码有时会使软件的体积变大且速度变慢，从而给程序造成巨大的性能影响。要事先做好准备计划，避免调试用的代码和程序原代码纠缠不清，下面列举一些可以选择的移除方法：</p>
<ul>
<li>
<p>使用类似ant和make这样的版本控制工具</p>
<p>（可以从同一套源码编译出不同版本的程序。在开发模式下，你可以让make工具把所有的调试代码都包含进来一起编译。而在产品上线期间，把那些调试代码排除在外。）</p>
</li>
<li>
<p>使用内置的预处理器（<code>C++ #字符为预处理器指令，包含#if、#warning、#include、#define等</code>）</p>
<p>（如果你所用的编程环境里有预处理器，你可以用预处理器来包含或排除调试的代码）</p>
</li>
</ul>
<pre><code>- (void)handleSomething {
    
#ifdef DEBUG
    
    [self debugF];//通常为一些debug用的耗时操作
#else
    
    [self releaseF];
#endif
    
}
</code></pre>
<ul>
<li>为应用增加调试模式的入口</li>
</ul>
<p>如果你的应用需要同时支持两种模式（发布和调试），那么我们可以自定义进入调试模式的入口，而不是针对编译层次的DEBUG，我们的调试代码的嵌入也依赖于这个调试模式是否开启，下面将演示安防app内定义的调试模式。</p>
<h2 id="对防御式编程采取防御的姿态">对防御式编程采取防御的姿态</h2>
<p>说了这么多，那么是不是防御式代码越多越好呢？</p>
<p>其实也不是，多度的防御式编程也会引起问题，如果你在每一个能想到的地方都用每一种能想到的方法来检查参数、处理错误，那么你的程序会变得臃肿而缓慢，更糟的事，多度的防御式代码换来的是软件的复杂度。</p>
<p>这说明，防御式编程引入的代码也并非不会有缺陷，和其他代码一样，你同样能轻而易举的在防御式编程添加的代码中找到错误，尤其是当你随手编写这些代时更是如此。</p>
<p>因此，要考虑好什么地方需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。</p>
<h2 id="总结">总结</h2>
<ul>
<li>程序代码中对错误处理的方式远比<code>GIGO</code>复杂的多。</li>
<li>防御式编程技术可以让错误更容易发现问题、更容易修改，并减少错误对产品代码的破坏。</li>
<li>遵从防御式编程的思想去开发，会让你在开发阶段就提前处理了许多问题，提高代码质量，降低测试周期，要做到主动去发现错误并做出处理（<strong>千万不要存侥幸心理，明明可以多考虑几种情况，偏偏却要忽略它们的可能性</strong>），而不是等到bug隐式的出现所带来的未曾预料的灾难。</li>
<li>错误处理技术更适用于暴露的接口程序或类，而断言则更强调不可允许的错误，多适用于不暴露在外的私有方法（或内部类）。</li>
<li>处理错误最恰当的方式是要根据程序软件的类别而定，更倾向于<strong>正确性</strong>还是<strong>健壮性</strong>。</li>
<li>异常提供了一种与代码正常流程角度不同的错误处理手段，但同时也应该在异常和其他错误处理手段之间进行权衡比较，比如iOS中就很少采用异常处理机制。</li>
<li>合理的运用辅助调试代码，会让你不管是在开发还是发布阶段都能更快速定位问题，并从容地解决问题。（预处理器就是个很好的选择）</li>
</ul>
<p>最后，我对于防御式编程的理解是，我认为程序的好坏与其健壮性（和正确性）有很大的联系，所有的程序开发人员都要对它有足够的重视，主动去迎战错误，从一点一滴开始做起，不要忽视任何的细节，不能盲目依赖测试去发现bug，而是以测试驱动编程，不断地思考可能发生的问题以进行预防，做一个聪明的程序员。这才是防御式编程所告诉我们的事 ！</p>
<h2 id="推荐">推荐</h2>
<p>最后列举一下文中出现的引用来源及一些推荐看的文章或书籍：</p>
<ul>
<li>《代码大全第2版》第八章防御式编程</li>
<li><a href="https://pan.baidu.com/s/1yfmqkf84CJ6Zpbj4-_TlUQ" target="_blank" rel="nofollow">《Writing Solid Code》断言的使用</a></li>
<li><a href="https://pan.baidu.com/s/1DYNOJrl7AJLhlRCY4gCnDQ" target="_blank" rel="nofollow">《Object-Oriented Software Construction》中有关于契约式设计的前置条件、后置条件、不变式的权威概述。</a></li>
<li><a href="https://nshipster.cn/" target="_blank" rel="nofollow">NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocExceptionHandling.html#//apple_ref/doc/uid/TP30001163-CH13-TPXREF168" target="_blank" rel="nofollow">苹果对于Exception Handling介绍</a></li>
</ul>
<hr>
<p>from <a href="https://www.jianshu.com/p/34f1dfa3aa8e">https://www.jianshu.com/p/34f1dfa3aa8e</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《高性能MySql》笔记]]></title>
        <id>https://Bule-Zst.github.io/jtLxs4zLq/</id>
        <link href="https://Bule-Zst.github.io/jtLxs4zLq/">
        </link>
        <updated>2020-12-20T01:00:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="笔记的主要内容">笔记的主要内容</h1>
<p>这篇博客主要用于记录《高性能MySQL》这本书的读书笔记，篇幅可能很长，因为书的篇幅本身就不小。在书中，作者有提到，不同章节之间相对独立，因此我也会尽量保持独立性。如果大家对我的读书笔记感兴趣，欢迎选取大家感兴趣的章节进行阅读。</p>
<p>本笔记的主要内容有：</p>
<ul>
<li>对书中部分内容的摘抄</li>
<li>对精华内容的个人总结</li>
<li>相关基础知识的补充</li>
</ul>
<p>笔记的目的：</p>
<ul>
<li>对于我来说，本笔记希望能够取代书籍，当自己觉得有必要回顾《高性能MySQL》这本书时，只需要简单过一遍笔记即可。</li>
<li>对于大家来说，大家可以把我的读书笔记当成一个引言，先阅读我的笔记，之后，如果对于某些章节感兴趣，再去阅读书的相应章节，这样能节省大家的一些时间。</li>
</ul>
<h1 id="mysql全称">MySQL全称</h1>
<p>这是一个最基本的问题，但惭愧的是，在读这本书之前，我竟然没有思考过这个问题。</p>
<p>“My” 是因为 Monty 的女儿叫做 My，而 “SQL” 就是 Structured Query Language（结构化查询语言），用于和数据库交互的语言。</p>
<p>因此，对于MySQL的读法，应该是My<sub>S</sub>Q<sub>L，而不是My</sub>Se~Cou。</p>
<h1 id="译者序">译者序</h1>
<p>MySQL的存储引擎主要使用的是InnoDB。</p>
<h1 id="前言">前言</h1>
<p>与第二版相比，本书更强调原因，而不是结果。作者希望告诉大家“为什么MySQL这么做”，而不仅仅是“MySQL做了什么”。</p>
<p>正如作者所说：</p>
<blockquote>
<p>我们希望能够尝试回到下面这样的问题：“给出MySQL 的内部结构和操作，对于实际应用能带来什么帮助？为什么能有这样的帮助？如何让MySQL 适合（或者不适合）特定的需求？”。</p>
</blockquote>
<h2 id="本书的结构">本书的结构</h2>
<ul>
<li>第1章：基础
<ul>
<li>MySQL的架构及其存储引擎的关键设计</li>
<li>关系型数据库和事务的基础知识</li>
<li>MySQL的入门知识</li>
</ul>
</li>
<li>第2-7章：<strong>使用</strong>MySQL前需要了解的基础知识，未特别标注的章节内容如章节标题所示。
<ul>
<li>第2章 MySQL 基准测试</li>
<li>第3章 服务器性能剖析：介绍了常用于故障诊断和服务器性能问题分析的一种面向响应时间的方法。</li>
<li>第4章 Schema 与数据类型优化：涵盖了不同数据类型的细节差别以及表设计的原则。</li>
<li>第5章 创建高性能的索引</li>
<li>第6章 查询性能优化</li>
<li>第7章 MySQL 高级特性
<ul>
<li>介绍了MySQL 的高级特性是如何工作的</li>
<li>包括分区、存储引擎、触发器，以及字符集</li>
<li>高级特性的实现可能有别于其他数据库，因此理解它们对于性能可能会带来新的收益</li>
</ul>
</li>
</ul>
</li>
<li>第8-9章：如何让MySQL、应用程序及硬件一起很好地工作
<ul>
<li>第8章 优化服务器设置：介绍了如何配置MySQL, 以便更好地利用硬件，达到更好的可靠性和鲁棒性。</li>
<li>第9章 操作系统和硬件优化：解释了如何让操作系统和硬件工作得更好。</li>
</ul>
</li>
<li>第10-15章：MySQL在实际应用场景中的相关知识
<ul>
<li>第10章 复制</li>
<li>第11章 可扩展的MySQL</li>
<li>第12章 高可用性：如何保障 MySQL 稳定而正确地持续运行</li>
<li>第13章 云端的MySQL</li>
<li>第14章 应用层优化：解释了什么是全方位的优化 (full-stack optimization) , 就是从前端到后端的整体优化，从用户体验开始直到数据库。</li>
<li>第15章 备份与恢复</li>
</ul>
</li>
</ul>
<h2 id="使用示例代码">使用示例代码</h2>
<p>本书中的示例代码的获取：http://www.highperfmysql.com</p>
<h1 id="第1章-mysql架构与历史">第1章 MySQL架构与历史</h1>
<p>理解MySQL架构的好处在于能够充分发挥MySQL的性能，因此，就算对于开发人员，了解其架构也是很有必要的。</p>
<p>其中，最重要、最与众不同的特性是其存储引擎架构，在接下来的章节会具体介绍。</p>
<h2 id="11-mysql逻辑架构">1.1 MySQL逻辑架构</h2>
<p>MySQL的逻辑架构图如下：</p>
<figure data-type="image" tabindex="1"><img src="%E9%AB%98%E6%80%A7%E8%83%BDMySql%E7%AC%94%E8%AE%B0.assets/image-20201220092718896.png" alt="image-20201220092718896" loading="lazy"></figure>
<p>最上层（客户端）：大部分基于网络的服务都有这一层。</p>
<p>中间层：MySQL的核心层，大部分功能都是在这一层实现的。</p>
<p>最下层（存储引擎）：这一层包含了众多种类的存储引擎，不同存储引擎具有各自的优缺点，中间层通过API与存储引擎进行交互。</p>
<h3 id="111-连接管理与安全性">1.1.1 连接管理与安全性</h3>
<h3 id="112-优化与执行">1.1.2 优化与执行</h3>
<p>在MySQL内部，会对用户的查询进行优化，包括重写查询、决定表的读取顺序、选择合适的索引。同时，用户也可以使用特定的关键字 1、提示优化器，影响其决策过程；2、了解MySQL的优化过程。</p>
<p>对于Select语句，MySQL会优先检查<em>查询缓存</em>。</p>
<h2 id="12-并发控制">1.2 并发控制</h2>
<p>解决多线程的一个方法是加锁，保证同一时刻只有一个线程对数据进行修改，但这种处理方式本质上其实不是<strong>并发</strong>。</p>
<h3 id="121-读写锁">1.2.1 读写锁</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[完全小白教程：使用Coding Pages和Gridea搭建个人博客]]></title>
        <id>https://Bule-Zst.github.io/wan-quan-xiao-bai-jiao-cheng-shi-yong-coding-pages-he-gridea-da-jian-ge-ren-bo-ke/</id>
        <link href="https://Bule-Zst.github.io/wan-quan-xiao-bai-jiao-cheng-shi-yong-coding-pages-he-gridea-da-jian-ge-ren-bo-ke/">
        </link>
        <updated>2020-12-18T12:27:13.000Z</updated>
        <content type="html"><![CDATA[<div class="RichText ztext Post-RichText"><p>2020/07/14更新</p><p>如果严格按照教程步骤操作了，还是出现远程连接失败的问题，可以尝试修改仓库名，例如我的仓库名叫myblog，在Gridea配置里，把仓库名设为myblog/myblog。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_b.png" data-caption="" data-size="normal" data-rawwidth="778" data-rawheight="85" class="origin_image zh-lightbox-thumb" width="778" data-original="https://pic2.zhimg.com/v2-86b676984105e58d319c6d56293267ad_r.jpg"/></figure><hr><p>上一篇文章写了使用Github Pages和Gridea来搭建个人博客：</p><a target="_blank" href="https://zhuanlan.zhihu.com/p/165948546" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg" data-image-width="1280" data-image-height="720" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">海边的卡夫卡：完全小白教程：使用Github Pages和Gridea搭建个人博客</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">&#8203;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>zhuanlan.zhihu.com</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--horizontal" alt="图标" src="https://pic1.zhimg.com/v2-fccdcf1f6e8a31fc59da10690b6237fc_180x120.jpg"></span></span></a><p>但Github毕竟是国外的服务器，访问速度很慢，如果你只是想要在国内访问你的博客，你完全可以使用国内的<b>Coding Pages</b>来代替Github Pages。</p><h2>1 Coding Pages开通</h2><h3>1.1 Coding账号注册</h3><p>原来的Coding个人版合并到团队版了，所以这里我详细说下Coding的注册。</p><p>进入<a href="https://link.zhihu.com/?target=https%3A//e.coding.net/signup%3F_ga%3D2.238701378.316970461.1592676170-1921038398.1592620024" class=" wrap external" target="_blank" rel="nofollow noreferrer">注册页面</a>，创建新团队，这个团队名称要记住，后面要用到，然后创建用户，完成注册。</p><h3>1.2 创建项目</h3><p>登录后，点击项目，发现只有一个示例项目，我们新建一个项目。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="939" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic3.zhimg.com/v2-e02b20de76c8cb3cebe989a02e845056_r.jpg"/>
</figure><p>选择第一个——代码托管项目。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1550" data-rawheight="689" class="origin_image zh-lightbox-thumb" width="1550" data-original="https://pic2.zhimg.com/v2-ce10057d87cd37ff3bd0d857bc7666bd_r.jpg"/></figure><p>然后填写项目名称，往下拉点完成创建。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_b.jpg" data-caption="" data-size="normal" data-rawwidth="1049" data-rawheight="766" class="origin_image zh-lightbox-thumb" width="1049" data-original="https://pic2.zhimg.com/v2-df2b99864998ed5915beb1d86812a431_r.jpg"/></figure><p>创建后是这样的，点左下角的项目设置。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="941" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic2.zhimg.com/v2-9acebc8db0556e623b24a60f27869aad_r.jpg"/></figure><p>点功能开关，把<b>持续集成</b>和<b>持续部署</b>开关打开。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="940" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic2.zhimg.com/v2-b3de37c60db4f79cd554a86af3564ba1_r.jpg"/></figure><p>进入代码仓库，如果还没有初始化，就先初始化仓库，勾选那个readme，就可以初始化了。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1917" data-rawheight="941" class="origin_image zh-lightbox-thumb" width="1917" data-original="https://pic3.zhimg.com/v2-a9d5df2f76c172659faa07886ee3969a_r.jpg"/></figure><h3>1.3 实名认证</h3><p>点网页左上角猴子的图标回主页，点左下角团队设置。团队所有者在【团队管理】-&gt;【团队设置】-&gt;【实名认证】，可进行团队实名认证。实名认证后，团队将可以使用 Pages 部署等产品功能。</p><h3>1.4 使用静态网站服务</h3><p>回到myblog项目，点【持续部署】-&gt;【静态网站】-&gt;【立即发布静态网站】。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_b.jpg" data-caption="" data-size="normal" data-rawwidth="1916" data-rawheight="940" class="origin_image zh-lightbox-thumb" width="1916" data-original="https://pic3.zhimg.com/v2-dfa3b7b7335df71b8e69d3b1f32b9f36_r.jpg"/></figure><p>名称还是叫myblog吧，保存。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_b.jpg" data-caption="" data-size="normal" data-rawwidth="1916" data-rawheight="941" class="origin_image zh-lightbox-thumb" width="1916" data-original="https://pic3.zhimg.com/v2-989fbb95852b5d2f717534e39b2676ce_r.jpg"/></figure><p>这里就是你的博客访问地址了（我的有两个，是因为我已经绑定域名了），不过现在点开，会显示404，别急嘛。点右上角的设置，来绑定域名，毕竟他给的这个网址好难记QAQ</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="940" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic1.zhimg.com/v2-fd71c6210cca2b60f306abbc49f3ea10_r.jpg"/></figure><p>点了设置后，往下拉，绑定域名，保存修改。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_b.jpg" data-caption="" data-size="normal" data-rawwidth="1622" data-rawheight="517" class="origin_image zh-lightbox-thumb" width="1622" data-original="https://pic3.zhimg.com/v2-0a7890a9a58c85f929cfe3e84c57df92_r.jpg"/></figure><h3>1.5 生成令牌</h3><p>右上角头像点开，点【个人设置】。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_b.jpg" data-caption="" data-size="normal" data-rawwidth="458" data-rawheight="347" class="origin_image zh-lightbox-thumb" width="458" data-original="https://pic3.zhimg.com/v2-5b79df9c7eb537e614f982834bdc421e_r.jpg"/></figure><p>点【访问令牌】-&gt;【新建令牌】。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1403" data-rawheight="625" class="origin_image zh-lightbox-thumb" width="1403" data-original="https://pic1.zhimg.com/v2-94b281d3a536125870458e619390165c_r.jpg"/></figure><p>你可以把权限都勾上，然后点【创建令牌】。</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_b.jpg" data-caption="" data-size="normal" data-rawwidth="1237" data-rawheight="910" class="origin_image zh-lightbox-thumb" width="1237" data-original="https://pic4.zhimg.com/v2-e25e6fdab144b3ebb0726a7bda69688f_r.jpg"/></figure><p>点这个图标复制令牌，另外你的令牌用户名也是后面要用到的。</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1097" data-rawheight="262" class="origin_image zh-lightbox-thumb" width="1097" data-original="https://pic4.zhimg.com/v2-58f6b015615a71de66727bd496e05e7b_r.jpg"/></figure><h2>2 Gridea远程部署</h2><p>Gridea下载请参考我上一篇文章，运行Gridea，配置。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_b.jpg" data-caption="" data-size="normal" data-rawwidth="1484" data-rawheight="992" class="origin_image zh-lightbox-thumb" width="1484" data-original="https://pic2.zhimg.com/v2-802990ae28d0a396fdbfeb4e5b66f625_r.jpg"/></figure><blockquote>如果你没有绑定域名，就填他提供给你的网址，CNAME就不填。<br>仓库用户名为你的<b>团队名</b>。</blockquote><p>保存后，点检测远程连接，如果没有问题就可以同步了。</p><p>OK，可以正常访问了~</p></div>
<hr>
<p>from <a href="https://zhuanlan.zhihu.com/p/166114376">https://zhuanlan.zhihu.com/p/166114376</a></p>
]]></content>
    </entry>
</feed>