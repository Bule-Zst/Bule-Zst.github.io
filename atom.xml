<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2021-07-29T10:35:18.888Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[JMM学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-28-JMM学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-28-JMM学习笔记/">
        </link>
        <updated>2021-07-28T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习JMM过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/B67o2UcNvG8">深入理解并发内存模型JMM与内存屏障</a></li>
</ul>
<hr>
<h2 id="java内存模型">Java内存模型</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210728151840865.png" alt="image-20210728151840865" style="zoom:60%;" />
<p>对于静态变量，每个线程中会存储变量副本。</p>
<blockquote>
<p>只要不影响到变量的值、变量不参与运算，则不会从主内存中拉取，比如while、if、赋值给其他变量、作为方法参数等</p>
<p>https://blog.csdn.net/ren421259121/article/details/90447853</p>
</blockquote>
<p>以下程序会死循环：</p>
<pre><code class="language-java">public class Main {
    static boolean exit = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread() {
            @Override
            public void run() {
                while( !exit ) {

                }
                System.out.println( &quot;end&quot; );
            }
        }.start();
        Thread.sleep(2000);
        exit = true;
    }
}
</code></pre>
<h2 id="jmm的原子操作">JMM的原子操作</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210729144205406.png" alt="image-20210729144205406" style="zoom:80%;" />
<h2 id="volatile">volatile</h2>
<p>作用：保证多线程间共享变量的可见性</p>
<p>实现原理：</p>
<ul>
<li>禁止JVM优化：指令重排、使用寄存器</li>
<li>利用CPU lock指令为总线加锁</li>
</ul>
<h3 id="缓存一致性协议-vs-volatile">缓存一致性协议 VS volatile</h3>
<h4 id="缓存一致性协议mesi">缓存一致性协议（MESI）</h4>
<p>四种状态：</p>
<ul>
<li>M（Modified）：在缓存行中被标记为Modified的值，与主存中的值不同，这个值将会在它被读取之前写入内存，并且状态置为Shared。</li>
<li>E（Exclusive）：在缓存行中被标记为Exclusive的值与主存中的值一致，被读取时置为Shared状态，被写时置为Modified状态。</li>
<li>S（Shared）：值也可能存在于其他缓存中，但是它的值和主存中的值一致。</li>
<li>I（Invalid）：缓存行无效。</li>
</ul>
<p>关于状态之间的转换以及更详细介绍MESI的内容，可以看这篇博客：https://www.cnblogs.com/igoodful/p/9493156.html</p>
<p>做个总结，MESI协议，保证了各CPU缓存之间的一致性。</p>
<h4 id="volatile是否多余">volatile是否多余</h4>
<p>既然MESI协议可以保证各CPU缓存之间数据的一致性，那么为什么还需要volatile关键词来保证各线程之间数据的可见性（一致性）呢？volatile关键字是否多余？</p>
<p>答：不多余</p>
<p>理由：</p>
<ul>
<li>
<p>出发点不同：</p>
<ul>
<li>MESI协议保证了主内存和各CPU缓存的一致，而volatile保证了java进程中各线程之间的一致性。如果没有MESI，那么各线程之间一定是不一致的，但只有MESI，也不能完全保证各线程间的一致性。</li>
</ul>
</li>
<li>
<p>实现的功能不同：</p>
<ul>
<li>
<p>MESI的功能上文已经说过了，即，保证了各CPU缓存之间的一致性</p>
</li>
<li>
<p>volatile的功能：</p>
<ul>
<li>
<p>防止JVM优化</p>
</li>
<li>
<p>防止数据从CPU cache以外的地方读取，这里做一下说明，MESI只能保证主内存和CPU缓存（CPU cache）的一致性，但CPU中还有很多额外的组件用于数据存储，这些组件可以提高CPU数据读写的效率，而这些组件的一致性MESI是不保证的。</p>
<blockquote>
<p>因为 MESI只是保证了多核cpu的独占cache之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。有些arm和power架构的cpu还可能有load buffer或者invalid queue等等。</p>
<p>https://www.zhihu.com/question/296949412</p>
</blockquote>
</li>
<li>
<p>保证多个变量的顺序一致，即，consistency。因为volatile会对总线加锁，且防止指令重排，所以可以保证用volatile修饰的多个变量之间的操作顺序。而MESI只能保证单个变量的操作顺序，即coherence。</p>
<blockquote>
<p>Coherence deals with maintaining a global order in which writes to a single location or single variable are seen by all processors.</p>
<p>Consistency deals with the ordering of operations to multiple locations with respect to all processors.</p>
<p>https://www.zhihu.com/question/296949412</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><s>### CPU lock指令</s></p>
<p><s>CPU lock指令会将对应缓存行的状态改成E，并立即修改主内存中的数据。其他CPU通过总线嗅探机制，监听到数据的修改，将自己工作内存中的缓存行状态改成I。</s></p>
<p><s>如果不使用volatile关键字，JVM则不会使用lock指令，此时，对变量的修改会导致缓存行的状态变成M，并不会修改主内存的数据，因此会导致不同线程中共享变量数据不一致。</s></p>
<p><s>之所以不修改主内存，是因为对主内存的操作相对于CPU操作来说过于耗时，因此不会频繁操作主内存。</s></p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://www.cnblogs.com/xrq730/p/7048693.html">就是要你懂Java中volatile关键字实现原理</a></li>
<li><a href="https://www.zhihu.com/question/63120810">java多线程在单核CPU上，还是需要volatile synchronized吗？</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S-Scheduler学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/">
        </link>
        <updated>2021-07-28T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习K8S-Scheduler过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;seid=1977024601217253447">阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍</a></li>
</ul>
<hr>
<p>调度器功能：负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。</p>
<p>什么是Pod：Pod是K8S中最小的调度单元，Pod和docker容器的关系就相当于docker容器和进程，在目前的技术环境下，往往一个服务依赖于多个docker容器，因此，k8s中提出了Pod的概念，使用Pod对docker容器进行打包，统一进行调度。</p>
<h2 id="对pod进行自定义排序">对Pod进行自定义排序</h2>
<ul>
<li>按名称排序：kubectl get pods --sort-by=.metadata.name</li>
<li>按创建时间进行排序：kubectl get pods --sort-by=.metadata.creationTimestamp</li>
<li>按启动时间进行排序：kubectl get pods --sort-by=.status.startTime</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://blog.csdn.net/m0_50434960/article/details/114851074">k8s:Kubernetes 调度器介绍</a></li>
<li><a href="https://www.jianshu.com/p/bfaa566f17fe">细说kubernetes - 为什么是pod？</a></li>
<li><a href="https://www.cnblogs.com/yangyuliufeng/p/14257928.html">k8s调度器扩展机制</a></li>
<li><a href="https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;seid=1977024601217253447">阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM性能调优学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/">
        </link>
        <updated>2021-07-27T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习JVM性能调优过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/mmv27Dfr291">双十一亿级电商系统JVM性能调优实战</a></li>
</ul>
<hr>
<h2 id="java虚拟机组成">Java虚拟机组成</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png" alt="image-20210727153842086" style="zoom:67%;" />
<ul>
<li>类装载子系统</li>
<li>字节码执行引擎</li>
<li>运行时数据区（内存模型）
<ul>
<li>栈（线程）
<ul>
<li>存放程序运行过程中的数据</li>
<li>栈 -&gt; 线程 -&gt; 方法
<ul>
<li>从栈中划分一块区域给线程，再从这块区域中划分一块给方法</li>
<li>方法中的局部变量就存在对应区域内</li>
</ul>
</li>
</ul>
</li>
<li>程序计数器：记录每个线程当前运行的代码在方法区中的位置</li>
<li>堆：存放程序运行过程中产生的对象</li>
<li>方法区（元空间）：常量+静态变量+类信息</li>
</ul>
</li>
</ul>
<h2 id="gc工作原理">GC工作原理</h2>
<h3 id="minor-gc新生代gc">Minor GC（新生代GC）</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png" alt="image-20210727152911187" style="zoom:80%;" />
<ul>
<li>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
<li>将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象。</li>
<li>每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。</li>
<li>如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。</li>
</ul>
<h3 id="minor-gc-vs-full-gc">Minor GC VS Full GC</h3>
<ul>
<li>Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。</li>
<li>Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短</li>
<li>算法不同：
<ul>
<li>Mnior GC用空间换时间，需要两个内存空间，直接Copy</li>
<li>Full GC用时间换空间，需要Mark+Compact</li>
</ul>
</li>
</ul>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://www.cnblogs.com/kevin7234/p/10644654.html">jvm minor gc 为什么比 full gc 快很多</a></li>
<li><a href="https://www.zhihu.com/question/35172533">为什么minor gc比full gc/major gc快？</a></li>
</ul>
<h2 id="arthas工具">Arthas工具</h2>
<p>阿里JVM性能调优工具</p>
<ul>
<li>
<p>dashboard：显示监控仪表盘</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155106380.png" alt="image-20210727155106380" style="zoom:50%;" />
</li>
<li>
<p>thread thread_id：显示占用CPU较多的代码行数</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155209073.png" alt="image-20210727155209073" style="zoom:70%;" />
</li>
<li>
<p>jad：反编译运行中的代码</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155320962.png" alt="image-20210727155320962" style="zoom:80%;" />
</li>
</ul>
<h2 id="性能调优">性能调优</h2>
<p>目的：减少 STW 的次数。</p>
<p>STW: Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。</p>
<p>Full GC的SWT时间远大于Minor GC。</p>
<p>调优方法：</p>
<ul>
<li>对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。</li>
<li>对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。</li>
<li>使用不同的垃圾收集器，不同收集器，适用于不同的场景。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png" alt="image-20210727162355407" style="zoom:55%;" />
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[非对称加密的应用]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-19-非对称加密的应用/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-19-非对称加密的应用/">
        </link>
        <updated>2021-07-19T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原理">原理</h2>
<p>稍微提一下原理</p>
<p>主要原理是，用一定的数学方法生成一对密钥对（公钥+私钥），公钥加密后，私钥可以解密，同时，私钥加密后，公钥也可以解密。</p>
<h2 id="应用">应用</h2>
<h3 id="数据传输">数据传输</h3>
<p>1、A生成一对密钥对，把公钥发给B。</p>
<p>2、B把需要传输的数据用公钥进行加密，然后发给A。</p>
<p>3、A收到后，用私钥进行解密，即可获取数据。</p>
<h4 id="如何防截获">如何防截获</h4>
<p>使用报文摘要算法</p>
<p>接上文</p>
<p>B在第2步传数据时，使用报文摘要算法对所发数据进行摘要生成，之后，用自己的私钥对摘要进行加密，然后伴随数据一起发给A。</p>
<p>A在收到后，对自己的私钥对数据进行解密，从而获取数据，之后再用B的公钥对摘要进行解密，然后比对收到的数据和摘要是否匹配，从而验证数据是否被篡改。</p>
<h3 id="身份验证">身份验证</h3>
<p>A要证明自己的身份</p>
<p>B向A发送一段数据</p>
<p>A用自己的私钥进行加密，然后发回给B，B用A的公钥进行解密，比对数据是否为自己发给A的数据，从而验证A的身份。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Docker容器内创建新的Docker容器]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-15-在Docker容器内创建新的Docker容器/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-15-在Docker容器内创建新的Docker容器/">
        </link>
        <updated>2021-07-15T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="要解决的问题">要解决的问题</h2>
<p>这篇文章主要解决的问题如标题所述：如何在Docker容器内创建新的Docker容器。受限于标题长度，没法详细描述要解决的问题，因此，第一节首先讲一下问题场景。</p>
<p>随着Docker技术以及微服务结构的普及，现在越来越多的应用被打包放在Docker容器中，并且，为了采用微服务的架构，应用通常是需要拆分成多个Docker容器的。</p>
<p>那么，这就带来了一个问题，如何在一个Docker容器内去控制别的Docker容器。这里需要啰嗦一句，我想表达的意思并不是在一个Docker容器的内部创建新的Docker容器，而是说，在一个Docker容器内部，控制宿主机，让其创建新的Docker容器。</p>
<p>问题描述讲完了，接下来说一下如何实现。</p>
<h2 id="如何解决">如何解决</h2>
<p>解决这个问题，就需要涉及到Docker的通信机制。</p>
<p>Docker分为服务端和客户端。当服务端启动后，会在/var/run/文件夹中创建docker.sock这个文件，并且会持续监听这个文件。当有请求被写到docker.sock文件时，Docker服务端就会执行相应的操作。</p>
<p>以往我们使用docker run等命令时，其实本质上也是往docker.sock文件中写请求。</p>
<p>了解到这一点后，我们在创建Docker容器时，就可以把宿主机的docker.sock文件挂载到容器内部，这样，便可以在容器内部控制宿主机对容器的操作了。</p>
<p>一共有两种方式，第一种是，在容器内部安装docker客户端，然后便可以像在宿主机中一样，使用docker命令，不同的地方时，docker命令控制的并不是容器内部的Docker服务端，而是宿主机中的Docker服务端。</p>
<p>可以使用如下命令进行容器的创建<code>curl -XPOST --unix-socket /var/run/docker.sock -d '{&quot;Image&quot;:&quot;centos&quot;}' -H 'Content-Type: application/json' http://localhost/containers/create</code>。</p>
<p>第二种方法是，使用docker-java，通过java api操作宿主机中的Docker服务端。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/dd0c814680ba">解析 /var/run/docker.sock</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/94224305">Docker客户端连接远程Docker服务</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 169. 多数元素]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-02-Leetcode 169. 多数元素/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-02-Leetcode 169. 多数元素/">
        </link>
        <updated>2021-07-02T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></p>
<hr>
<h2 id="题目">题目</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210702100456543.png" alt="image-20210702100456543" loading="lazy"></figure>
<h2 id="解法">解法</h2>
<h3 id="哈希表">哈希表</h3>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; counts;
        int majority = 0, cnt = 0;
        for (int num: nums) {
            ++counts[num];
            if (counts[num] &gt; cnt) {
                majority = num;
                cnt = counts[num];
            }
        }
        return majority;
    }
};
</code></pre>
<h3 id="分治">分治</h3>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<p>思路：如果数 <code>a</code> 是数组 <code>nums</code> 的众数，如果我们将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数（</p>
<h4 id="时间复杂度分析">时间复杂度分析</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mn>2</mn><mi>n</mi><mi mathvariant="normal">​</mi></mrow><annotation encoding="application/x-tex">T(n)=2T({n\over2})+2n​
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mord">​</span></span></span></span></span></p>
<p>主定理：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>d</mi></msup><mo>)</mo><mspace linebreak="newline"></mspace><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>d</mi></msup><mo>)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mo>&gt;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>d</mi></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>O</mi><mo>(</mo><msup><mi>b</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mo>&lt;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">T(n)=aT({n\over b})+O(n^d) \\
T(n) = \left\{ \begin{array}{lr} 
O(n^d) &amp; d &gt; log_ba \\
O(n^dlogn) &amp; d = log_ba \\
O(b^{log_ba}) &amp; d &lt; log_ba
\end{array} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6273239999999998em;vertical-align:-1.5636619999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.063662em;"><span style="top:-4.214554em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.0054459999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-1.7963380000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5636619999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.063662em;"><span style="top:-4.214554em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span></span></span><span style="top:-3.0054459999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span></span></span><span style="top:-1.7963380000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5636619999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<pre><code class="language-c++">class Solution {
    int count_in_range(vector&lt;int&gt;&amp; nums, int target, int lo, int hi) {
        int count = 0;
        for (int i = lo; i &lt;= hi; ++i)
            if (nums[i] == target)
                ++count;
        return count;
    }
    int majority_element_rec(vector&lt;int&gt;&amp; nums, int lo, int hi) {
        if (lo == hi)
            return nums[lo];
        int mid = (lo + hi) / 2;
        int left_majority = majority_element_rec(nums, lo, mid);
        int right_majority = majority_element_rec(nums, mid + 1, hi);
        if (count_in_range(nums, left_majority, lo, hi) &gt; (hi - lo + 1) / 2)
            return left_majority;
        if (count_in_range(nums, right_majority, lo, hi) &gt; (hi - lo + 1) / 2)
            return right_majority;
        return -1;
    }
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        return majority_element_rec(nums, 0, nums.size() - 1);
    }
};
</code></pre>
<h3 id="排序">排序</h3>
<h4 id="快速排序">快速排序</h4>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn) 栈空间</p>
<h4 id="堆排序">堆排序</h4>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
</code></pre>
<h3 id="随机化">随机化</h3>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>思路：随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p>
<p>期望：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msub><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>∗</mo><mfrac><mn>1</mn><msup><mn>2</mn><mi>i</mi></msup></mfrac><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">E=lim_{n\to+\infty}\sum_{i=1}^n i * {1\over 2^i}=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7570857142857143em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        while (true) {
            int candidate = nums[rand() % nums.size()];
            int count = 0;
            for (int num : nums)
                if (num == candidate)
                    ++count;
            if (count &gt; nums.size() / 2)
                return candidate;
        }
        return -1;
    }
};
</code></pre>
<h3 id="多数投票算法">多数投票算法</h3>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<pre><code>nums:      [#, 7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:     7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      0  1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
               7  7  7  7  7  7   7  7   7  7  7  7   7  7  7  7
value:      0  1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
</code></pre>
<p>步骤：</p>
<ol>
<li>检测count是否为0，如果为0，就用当前数组的元素值更新candidate。</li>
<li>如果当前数组的元素值和candidate相同，那么，count++，否则，count--。</li>
<li>当数组遍历完时，当前的candidate，就是我们要的答案。</li>
</ol>
<p>特性：</p>
<ul>
<li>count永远不为负数。</li>
<li>当candidate和最终答案不相同时，count和value呈相反数；如果candidate和最终答案相同，count和value是相等的。</li>
<li>value的最终值等于：7的个数-非7的个数。</li>
</ul>
<p>多数投票算法证明：</p>
<ul>
<li>
<p>如果候选人不是7，则7会和其他<strong>非</strong>候选人一起反对候选人，所以候选人一定会下台(count==0时发生换届选举)</p>
</li>
<li>
<p>如果候选人是7，则 7 会支持自己，其他候选人会反对，但因为 7 票数超过一半，所以 7 一定会成功当选</p>
</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count &lt; 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter ThreadGroup LoopController各参数含义梳理]]></title>
        <id>http://Bule-Zst.gitee.io/2021-06-29-Jmeter ThreadGroup LoopController各参数含义梳理/</id>
        <link href="http://Bule-Zst.gitee.io/2021-06-29-Jmeter ThreadGroup LoopController各参数含义梳理/">
        </link>
        <updated>2021-06-29T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="实例">实例</h2>
<pre><code class="language-xml">&lt;ThreadGroup guiclass=&quot;ThreadGroupGui&quot; testclass=&quot;ThreadGroup&quot; testname=&quot;线程组&quot; enabled=&quot;true&quot;&gt;
	&lt;stringProp name=&quot;ThreadGroup.on_sample_error&quot;&gt;continue&lt;/stringProp&gt;
	&lt;elementProp name=&quot;ThreadGroup.main_controller&quot; elementType=&quot;LoopController&quot; guiclass=&quot;LoopControlPanel&quot; testclass=&quot;LoopController&quot; testname=&quot;循环控制器&quot; enabled=&quot;true&quot;&gt;
		&lt;boolProp name=&quot;LoopController.continue_forever&quot;&gt;false&lt;/boolProp&gt;
		&lt;intProp name=&quot;LoopController.loops&quot;&gt;-1&lt;/intProp&gt;
	&lt;/elementProp&gt;
	&lt;stringProp name=&quot;ThreadGroup.num_threads&quot;&gt;20&lt;/stringProp&gt;
	&lt;stringProp name=&quot;ThreadGroup.ramp_time&quot;&gt;1&lt;/stringProp&gt;
	&lt;boolProp name=&quot;ThreadGroup.scheduler&quot;&gt;true&lt;/boolProp&gt;
	&lt;stringProp name=&quot;ThreadGroup.duration&quot;&gt;600&lt;/stringProp&gt;
	&lt;stringProp name=&quot;ThreadGroup.delay&quot;&gt;&lt;/stringProp&gt;
	&lt;boolProp name=&quot;ThreadGroup.same_user_on_next_iteration&quot;&gt;true&lt;/boolProp&gt;
&lt;/ThreadGroup&gt;
</code></pre>
<h2 id="参数说明">参数说明</h2>
<ul>
<li>ThreadGroup.num_threads：并发线程数</li>
<li>LoopController.loops：每个线程的循环次数，-1表示无限循环。</li>
<li>压测的总请求数：ThreadGroup.num_threads * LoopController.loops</li>
<li>调度器配置
<ul>
<li>ThreadGroup.duration：线程组的持续时间</li>
<li>ThreadGroup.delay：启动延迟</li>
</ul>
</li>
<li>ThreadGroup.scheduler：调度器是否生效</li>
</ul>
<h2 id="压测是否结束">压测是否结束</h2>
<ul>
<li>如果调度器不生效，则线程组达到循环次数后，压测结束。</li>
<li>如果调度器生效，则每次循环结束后，都会检查持续时间，如果大于ThreadGroup.duration，则压测结束。在此过程中，如果线程组达到循环次数，也会结束压测。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenResty学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-06-25-OpenResty学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-06-25-OpenResty学习笔记/">
        </link>
        <updated>2021-06-25T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="是什么-能做什么">是什么、能做什么</h2>
<p>OpenResty 是一个基于 Nginx 的 Web 平台。Web开发人员可以使用 OpenResty 搭建 Web 平台。借助于OpenResty，开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种由 C 语言实现的功能模块，从而实现特定的Web 业务需求。</p>
<p>OpenResty 本质上是集成了 Lua 组件的 Nginx，是Nginx Plus。</p>
<h2 id="优点-缺点是什么">优点、缺点是什么</h2>
<ul>
<li>优点
<ul>
<li>高并发
<ul>
<li>相较于apache（200-300）、tomcat（1000），Nginx可以支持几万的并发量，因此，我们常常使用Nginx做负载均衡，OpenResty的出现，使得开发人员可以依托 Lua 脚本在 Nginx 的内部添加业务代码，充分利用Nginx高并发的优势。</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>暂未发现</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://www.runoob.com/w3cnote/openresty-intro.html</li>
<li>https://www.zhihu.com/question/266535644?sort=created</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跳表]]></title>
        <id>http://Bule-Zst.gitee.io/2021-06-24-跳表/</id>
        <link href="http://Bule-Zst.gitee.io/2021-06-24-跳表/">
        </link>
        <updated>2021-06-24T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<blockquote>
<p>跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树（AVL）媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p>
<p>https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210624182132534.png" alt="image-20210624182132534" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210624191004554.png" alt="image-20210624191004554" loading="lazy"></figure>
<h2 id="原理">原理</h2>
<p>学过数据结构的都知道，在单链表中查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过2分的方式缩减时间复杂度。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205210928206" alt="这里写图片描述" loading="lazy"></figure>
<p>如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205211105653" alt="这里写图片描述" loading="lazy"></figure>
<p>如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。</p>
<p>那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205211246498" alt="这里写图片描述" loading="lazy"></figure>
<p>如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787" alt="这里写图片描述" loading="lazy"></figure>
<p>我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？</p>
<p>如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。</p>
<p>至此为止，我们引入了最理想的跳跃表，但是如果想要在上图中插入或者删除一个元素呢？比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。我们知道，平衡二叉树的调整是一件令人头痛的事情，左旋右旋左右旋……一般人还真记不住，而调整一个理想的跳跃表将是一个比调整平衡二叉树还复杂的操作。幸运的是，我们并不需要通过复杂的操作调整连接来维护这样完美的跳跃表。有一种基于概率统计的插入算法，也能得到时间复杂度为O(logn)的查询效率，这种跳跃表才是我们真正要实现的。</p>
<h2 id="实现">实现</h2>
<h3 id="抛硬币">抛硬币</h3>
<p>先讨论插入，我们先看理想的跳跃表结构，L2层的元素个数是L1层元素个数的1/2，L3层的元素个数是L2层的元素个数的1/2，以此类推。从这里，我们可以想到，只要在插入时尽量保证上一层的元素个数是下一层元素的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么样才能在插入时保证上一层元素个数是下一层元素个数的1/2呢？很简单，抛硬币就能解决了！假设元素X要插入跳跃表，很显然，L1层肯定要插入X。那么L2层要不要插入X呢？我们希望上层元素个数是下层元素个数的1/2，所以我们有1/2的概率希望X插入L2层，那么抛一下硬币吧，正面就插入，反面就不插入。那么L3到底要不要插入X呢？相对于L2层，我们还是希望1/2的概率插入，那么继续抛硬币吧！以此类推，元素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。</p>
<p>在此还是以上图为例：跳跃表的初试状态如下图，表中没有一个元素：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212059243" alt="这里写图片描述" loading="lazy"></figure>
<p>如果我们要插入元素2，首先是在底部插入元素2，如下图：</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212313963" alt="这里写图片描述" loading="lazy"></figure>
<p>然后我们抛硬币，结果是正面，那么我们要将2插入到L2层，如下图:</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212409123" alt="这里写图片描述" loading="lazy"></figure>
<p>继续抛硬币，结果是反面，那么元素2的插入操作就停止了，插入后的表结构就是上图所示。接下来，我们插入元素33，跟元素2的插入一样，现在L1层插入33，如下图：</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212458264" alt="这里写图片描述" loading="lazy"></figure>
<p>然后抛硬币，结果是反面，那么元素33的插入操作就结束了，插入后的表结构就是上图所示。接下来，我们插入元素55，首先在L1插入55，插入后如下图：</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212553339" alt="这里写图片描述" loading="lazy"></figure>
<p>然后抛硬币，结果是正面，那么L2层需要插入55，如下图：</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212659309" alt="这里写图片描述" loading="lazy"></figure>
<p>继续抛硬币，结果又是正面，那么L3层需要插入55，如下图：</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205212712590" alt="这里写图片描述" loading="lazy"></figure>
<p>以此类推，我们插入剩余的元素。当然因为规模小，结果很可能不是一个理想的跳跃表。但是如果元素个数n的规模很大，学过概率论的同学都知道，最终的表结构肯定非常接近于理想跳跃表。</p>
<p>当然，这样的分析在感性上是很直接的，但是时间复杂度的证明实在复杂，在此我就不深究了，感兴趣的可以去看关于跳跃表的paper。再讨论删除，删除操作没什么讲的，直接删除元素，然后调整一下删除元素后的指针即可。跟普通的链表删除操作完全一样。再来讨论一下时间复杂度，插入和删除的时间复杂度就是查询元素插入位置的时间复杂度，这不难理解，所以是O(logn)。</p>
<h3 id="随机数">随机数</h3>
<p>在上一节中，我们采用抛硬币的方式来决定新元素插入的最高层数，这当然不能在程序中实现。代码中，我们采用随机数生成的方式来获取新元素插入的最高层数。我们先估摸一下n的规模，然后定义跳跃表的最大层数maxLevel，那么底层，也就是第0层，元素是一定要插入的，概率为1；最高层，也就是maxLevel层，元素插入的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup></mrow><annotation encoding="application/x-tex">1/2^{maxLevel}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>我们先随机生成一个范围为0~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{maxLevel}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的一个整数r。那么元素r小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{maxLevel-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的概率为1/2，r小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{maxLevel-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>的概率为1/4，……，r小于2的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1/2^{maxLevel-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，r小于1的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>L</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup></mrow><annotation encoding="application/x-tex">1/2^{maxLevel}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>举例，假设maxLevel为4，那么r的范围为0~15，则r小于8的概率为1/2，r小于4的概率为1/4，r小于2的概率为1/8，r小于1的概率为1/16。1/16正好是maxLevel层插入元素的概率，以此类推。</p>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210624193459656.png" alt="image-20210624193459656" loading="lazy"></figure>
<p>以上分析是随机数算法的关键。算法跟实现跟语言无关，以下贴一下C++语言的代码实现。</p>
<h3 id="代码">代码</h3>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/Bule-Zst/picture/raw/master/20161205211539787" alt="这里写图片描述" loading="lazy"></figure>
<p>Node* next;</p>
<p>Node* next[MAXL];</p>
<p>next[2] = null;</p>
<pre><code class="language-c++">struct SkipListNode {
    int val;
    vector&lt;SkipListNode *&gt; level;
    SkipListNode (int _val, int sz=32) : val(_val), level(sz, nullptr) {}
};

class Skiplist {
public:
    SkipListNode *head, *tail;
    int level, length;
    static int MAXL = 32;

    Skiplist() {
        level = length = 0;
        tail = new SkipListNode(INT_MAX, 0);
        head = new SkipListNode(-INT_MAX);
        for (int i = 0; i &lt; MAXL; ++i) {
            head-&gt;level[i] = tail;
        }
    }

    SkipListNode* find(int val) {
        SkipListNode *p = head;
        for (int i = level - 1; i &gt;= 0; --i) {
            while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) {
                p = p-&gt;level[i];
            }
        }
        p = p-&gt;level[0];
        return p;
    }

    bool search(int target) {
        SkipListNode *p = find(target);
        return p-&gt;val == target;
    }

    void add(int val) {
        vector&lt;SkipListNode *&gt; update(MAXL);
        SkipListNode *p = head;
        for (int i = level - 1; i &gt;= 0; --i) {
            while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) {
                p = p-&gt;level[i];
            }
            update[i] = p;
        }
        int lv = randomLevel();
        if (lv &gt; level) {
            lv = ++level;
            update[lv - 1] = head;
        }
        SkipListNode *newNode = new SkipListNode(val, lv);
        for (int i = lv - 1; i &gt;= 0; --i) {
            p = update[i];
            newNode-&gt;level[i] = p-&gt;level[i];
            p-&gt;level[i] = newNode;
        }
        ++length;
    }

    bool erase(int val) {
        vector&lt;SkipListNode *&gt; update(MAXL + 1);
        SkipListNode *p = head;
        for (int i = level - 1; i &gt;= 0; --i) {
            while (p-&gt;level[i] &amp;&amp; p-&gt;level[i]-&gt;val &lt; val) {
                p = p-&gt;level[i];
            }
            update[i] = p;
        }
        p = p-&gt;level[0];
        if (p-&gt;val != val) return false;
        for (int i = 0; i &lt; level; ++i) {
            if (update[i]-&gt;level[i] != p) {
                break;
            }
            update[i]-&gt;level[i] = p-&gt;level[i];
        }
        while (level &gt; 0 &amp;&amp; head-&gt;level[level - 1] == tail)
            --level;
        --length;
        return true;
    }

    int randomLevel() {
        int level, r = rand(), target = INT_MAX/2;
        level = 0;
        for (int i = 1; i &lt; MAXL; i++)
            if( r &gt; INT_MAX-target ) {
                level = i;
                target /= 2;
            } else {
                break;
            }
        return level+1;
    }
};
</code></pre>
<h2 id="练习">练习</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表</a></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</li>
<li>https://blog.csdn.net/u013709270/article/details/53470428</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kafka学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-06-09-Kafka学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-06-09-Kafka学习笔记/">
        </link>
        <updated>2021-06-09T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习Kafka过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://coding.imooc.com/class/434.html">Kafka多维度系统精讲，从入门到熟练掌握</a></li>
</ul>
<hr>
<p>课程大纲：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210609101437740.png" alt="image-20210609101437740" loading="lazy"></figure>
<h2 id="partition">Partition</h2>
<p>Partition 在 Kafka 中是分区的意思。</p>
<p>Kafka 中每个 Topic 可以划分多个分区，同一个 Topic 下的不同分区包含的消息是不同的。</p>
<p>Kafka 通过 offset 可以保证消息在分区中的顺序性，但是跨分区是无序的，即 Kafka 只保证在同一个分区内的消息是有序的。</p>
<p>每一条消息发送到 broker 的时候，会根据 Partition 的分区规则计算，然后选择将该消息存储到哪一个 Partition。</p>
<p>参考资料：https://blog.csdn.net/lzb348110175/article/details/100764105</p>
<p>Partition和Consumer的关系不能是1对多，即，一个Partition由多个Comsumer进行消费。</p>
<ul>
<li>这是由Consumer的消费机制决定的，Consumer在拿到消息后，需要在处理完后向Kafka提交处理结果，即，告诉Kafka这批消息已经处理好了（可以以自动的方式进行提交，也可以手动提交）。而在Kafka中，最小颗粒度的数据存储就是Partition，那么，如果有两个Consumer同时消费一个Partiton，就会导致线程不安全，即，两个Consumer同时拿到数据，然后导致数据冲突。</li>
<li>如果是多个Consumer对应多个Partition，则不会出现这个情况，因为不同Partition之间是不会相互影响的。</li>
</ul>
<h2 id="解读源码">解读源码</h2>
<ul>
<li>Producer在创建时，会新建发送线程，该线程会定时批量发送所有的消息。因此，Kafka是批量发送，不是调用一次send就发送一次，所以效率较高。</li>
<li>当调用send后，会将消息存储在batch（批次）中，当达到一定阈值时，发送线程会自动进行消息的批量发送。因此，严格意义上，消息发送不是由send实现的。</li>
<li>Kafka是线程安全的，可以多线程复用</li>
</ul>
<h2 id="配置">配置</h2>
<ul>
<li>Producer
<ul>
<li>ACKS_CONFIG：消息传递保障</li>
<li>RETRIES_CONFIG：发送失败后重试次数</li>
<li>BATCH_SIZE_CONFIG：最大批次容量</li>
<li>LINGER_MS_CONFIG：批量发送间隔时间</li>
<li>BUFFER_MEMORY_CONFIG：缓存大小</li>
<li>BATCH_SIZE <strong>VS</strong> BUFFER_MEMORY
<ul>
<li>参考资料：https://blog.csdn.net/u010711495/article/details/113250402</li>
<li>Kafka的所有信息都会存在缓存中，包括配置信息、消息等，一旦缓存满了，Kafka就会禁止用户再发送消息；而对于最大批次容量，当批次实际大小达到最大批次容量时，就会触发发送线程的发送；因此，一般缓存大小都是大于最大批次容量的。</li>
</ul>
</li>
<li></li>
<li>KEY_SERIALIZER_CLASS_CONFIG：key序列化类</li>
<li>VALUE_SERIALIZER_CLASS_CONFIG：value序列化类</li>
<li>PARTITIONER_CLASS_CONFIG：自定义partition选择</li>
</ul>
</li>
</ul>
<h2 id="消息传递保障">消息传递保障</h2>
<ul>
<li>最多一次：发了就不管了</li>
<li>最少一次：一直发，直到收到响应</li>
<li>正好一次：一直发，直到收到响应，但是接收方需要去重</li>
</ul>
<h2 id="key的作用">Key的作用</h2>
<p>Kafka的消息是一对键值对，Key在Kafka中的主要作用是选择分区，若用户没有指定分区，则Kafka会根据key的hash决定分区的选择。</p>
<p>Kafka在设计时使用键值对的形式，可以为使用者提供功能上的扩展，例如可以自定义分区规则，将相同key的消息放在同一个分区中。</p>
<p>当然，如果某些业务场景下对key没有特殊要求，这个字段也是可以不填的。</p>
<h2 id="kafka-vs-redis">Kafka VS Redis</h2>
<p>Redis List的缺点：</p>
<ul>
<li>不支持重复消费：消息一旦被消费，就会从 Redis 中删除，无法再被其他消费者消费。</li>
<li>消息丢失：消费者获取消息后，若发生异常宕机，则消息就会丢失。</li>
<li>当List达到最大长度，则无法继续添加新的消息。</li>
</ul>
<p>Redis Pub/Sub的缺点：</p>
<ul>
<li>消息丢失
<ul>
<li>消费者下线</li>
<li>Redis 宕机</li>
<li>消息堆积：当消息超过消费者缓冲区大小，Redis 会强制消费者下线</li>
</ul>
</li>
</ul>
<p>参考资料：https://www.jianshu.com/p/c37368c867f8</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/lzb348110175/category_9309572.html">CSDN kafka-扛麻袋的少年</a></li>
</ul>
]]></content>
    </entry>
</feed>