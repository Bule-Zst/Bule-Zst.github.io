<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2021-09-14T10:02:06.559Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[秒杀系统-实战.md]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/">
        </link>
        <updated>2021-09-14T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录如何实现一个秒杀系统，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1CE411s7xN?p=2&amp;spm_id_from=pageDriver">1小时带你用Redis轻松实现秒杀系统（附秒杀系统优化实战）</a></li>
</ul>
<hr>
<h2 id="什么是秒杀系统">什么是秒杀系统</h2>
<p>其实主要的业务流程就是下订单、减库存，只是，该业务流程是在高并发、大流量的场景下进行的。</p>
<h2 id="并发量">并发量</h2>
<p>一般秒杀系统的并发量是万级别的，几万、几十万、几百万。</p>
<p>单机MySQL的并发量一般为几百，最多一千。</p>
<p>单机Tomcat的并发量一般也为几百。</p>
<p>单机Redis的并发量一般为几万。</p>
<h2 id="优化前">优化前</h2>
<p><a href="https://gitee.com/Bule-Zst/picture/raw/master/Seckill-%E4%BC%98%E5%8C%96%E5%89%8D.jpg">项目下载</a>（为了省事，我把文件后缀改成jpg了，这样直接用图床帮我存到云端）</p>
<p>就是一个简单的购物系统，先下单之后再减库存，这个系统在业务逻辑上是没有bug的，最主要的问题就是性能差。</p>
<p>需要注意的是，在系统里用到了事务，从而保证下单和减库存是原子操作，这里补充说一下Springboot事务失效的两个常见原因：</p>
<ul>
<li>内部调用：事务基于AOP，会对事务对象包装一个代理对象，因此不能直接调用事务对象的方法，应该使用Springboot的依赖注入，使用注入对象的方法。</li>
<li>数据库存储引擎不支持：MyISAM是不支持事务的，所以可以检查一下数据库表的存储引擎，如果是MyISAM，需要改成InnoDB。</li>
</ul>
<p>性能：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914151845646.png" alt="image-20210914151845646" loading="lazy"></figure>
<p>吞吐量为130/s</p>
<h2 id="优化">优化</h2>
<h3 id="redis缓存">Redis缓存</h3>
<p>使用redis做缓存</p>
<p>在秒杀之前，把商品库存信息放到redis中</p>
<p>在秒杀时，先对redis中的库存执行decrement方法，之后判断返回结果是否小于0，如果返回结果大于等于0，则进行秒杀业务，否则说明库存为零。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {}
</code></pre>
<p>性能：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914154013003.png" alt="image-20210914154013003" loading="lazy"></figure>
<p>吞吐量为1400/s</p>
<h4 id="存在的问题">存在的问题</h4>
<p>缓存不一致问题：一旦秒杀业务过程中发生错误导致事务回滚，那么redis中的库存信息就和数据库中的不一致了。</p>
<p>解决方案：如果事务中出现报错，就在catch语句中让库存加一。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
}
</code></pre>
<h3 id="jvm缓存">JVM缓存</h3>
<p>使用ConcurrentHashMap在JVM级别做缓存，当发现redis中库存为零后，使用ConcurrentHashMap标记当前商品为False。</p>
<p>当收到秒杀请求时，首先判断ConcurrentHashMap中当前商品是否被标记，如果被标记了，说明库存为零，直接return。</p>
<p>使用JVM级别的缓存能更好地提高系统性能，因为redis缓存是需要和redis服务做交互的，伴随网络请求，因此性能没有JVM级别快。</p>
<p>性能：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914164139365.png" alt="image-20210914164139365" loading="lazy"></figure>
<p>吞吐量为：1815/s</p>
<pre><code class="language-java">if( concurrentHashMap.get(id) != null ) {
    return &quot;fail&quot;;
}

Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    concurrentHashMap.put( id, true );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
</code></pre>
<h4 id="存在的问题-2">存在的问题</h4>
<p>JVM级缓存与redis缓存不一致，主要有两种场景</p>
<ul>
<li>
<p>当秒杀业务中存在异常时，会对redis和concurrentHashMap进行恢复，对redis中的缓存进行increment操作，对ConcurrentHashMap进行remove操作，但此时，redis中的库存很可能是负数的情况，因为在高并发情况下，大量请求被接受，所以redis会执行大量的decrement操作，虽然后续会执行increment操作进行恢复，但是有概率在新的请求被处理时，increment操作还未执行，当新的请求进来后，会发现redis中库存为负数，从而在concurrentHashMap进行标记。所以最终，redis中的库存数可能不为0，而concurrentHashMap中对应的商品却被标记了。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914163636067.png" alt="image-20210914163636067" style="zoom:63%;" />
</li>
<li>
<p>在分布式场景下，不同JVM中的concurrentHashMap很难保证同步，可能在某个JVM中对hashMap进行了恢复，但是别的JVM中，hashMap并没有进行恢复。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>如果是分布式导致的不一致问题，可以使用zookeeper解决。当zookeeper中节点的数据发生改变后，zookeeper会主动通知监听该节点的进程，从而实现分布式下JVM级的缓存同步。</li>
<li>如果是单机不一致问题，暂时没想好如何解决。</li>
</ul>
<h3 id="其他优化手段">其他优化手段</h3>
<ul>
<li>
<p>限流降级</p>
</li>
<li>
<p>Redis集群：提高redis并发量</p>
</li>
<li>
<p>微服务架构</p>
</li>
<li>
<p>异步下单</p>
</li>
<li>
<p>前端优化：静态页面、CDN</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL慢查询优化-实战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/">
        </link>
        <updated>2021-09-13T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录优化MySQL慢查询的完整过程以及心得体会。</p>
<hr>
<h2 id="数据准备">数据准备</h2>
<p>随机生成了50w条数据，具体步骤可以参考这篇博客：<a href="https://blog.csdn.net/qq_36994788/article/details/73216961">mysql插入千万条随机数据</a></p>
<h2 id="前置知识">前置知识</h2>
<p>Explain语句结果中各个字段分表表示什么：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102404385.png" alt="image-20210913102404385" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913125829371.png" alt="image-20210913125829371" loading="lazy"></figure>
<h2 id="优化前统计">优化前统计</h2>
<ul>
<li>
<p>select * from emp where deptno = 101;</p>
<p>时间: 0.55s</p>
</li>
</ul>
<h2 id="开始优化">开始优化</h2>
<h3 id="是否走了索引">是否走了索引</h3>
<p>Explain结果：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102307124.png" alt="image-20210913102307124" loading="lazy"></figure>
<p>结果分析：</p>
<p>Extra中为Using where，表示未使用索引，根据where条件顺序扫描</p>
<p>解决方案：对deptno列建立索引</p>
<p>建立索引后，Explain结果：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105003822.png" alt="image-20210913105003822" loading="lazy"></figure>
<p>时间: 3.636s</p>
<p>结果分析：时间反而变长了，猜测，可能是发生了回表操作。</p>
<p>验证：</p>
<p>尝试只select deptno，从而使用覆盖索引。</p>
<p>select deptno from emp where deptno = 101;</p>
<p>时间: 0.095s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110312538.png" alt="image-20210913110312538" loading="lazy"></figure>
<p>注意到Extra出现Using index，表示使用了覆盖索引。</p>
<p>尝试select ename，在这种情况下，会发生回表操作</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 3.189s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110337524.png" alt="image-20210913110337524" loading="lazy"></figure>
<p>未使用覆盖索引</p>
<p>建立联合索引，(deptno, ename)</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 0.033s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105937845.png" alt="image-20210913105937845" loading="lazy"></figure>
<p>使用了覆盖索引</p>
<p>验证结束</p>
<h3 id="是否是最优索引">是否是最优索引</h3>
<p>where条件只对deptno进行了约束，因此是最优索引</p>
<h3 id="是否查询了过多字段">是否查询了过多字段</h3>
<p>select *，查询字段过多，应根据实际业务需要，减少查询字段，例如只查询ename和deptno，这样就可以使用联合索引进行优化。</p>
<h3 id="是否应该进行分库分表">是否应该进行分库分表</h3>
<p>暂时不考虑分库分表</p>
<h3 id="是否数据库服务所在机器性能过低">是否数据库服务所在机器性能过低</h3>
<p>暂时不考虑机器性能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ConcurrentHashMap详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/">
        </link>
        <updated>2021-09-01T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习ConcurrentHashMap过程中的学习笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/4dTDHcwa7M9">ConcurrentHashMap底层原理与源码分析深入详解</a></li>
</ul>
<hr>
<h2 id="hashmap">HashMap</h2>
<p>非线程安全</p>
<p>实现原理：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901135831288.png" alt="image-20210901135831288" loading="lazy"></figure>
<h2 id="hashtable">Hashtable</h2>
<p>线程安全：对put方法加synchronized锁</p>
<p>缺点：性能差</p>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<p>class Segment extends Reentralock</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901141125962.png" alt="image-20210901141125962" loading="lazy"></figure>
<h3 id="扩容">扩容</h3>
<p>segments数组大小不变，与扩增级别（concurrencyLevel）相同</p>
<p>触发扩容后，只会在Segment对象内部进行扩容，不会整体扩容</p>
<h3 id="源码">源码</h3>
<h4 id="初始化">初始化</h4>
<p>segments数组长度为2的幂，为什么？因为计算下标时需要 <code>h &amp; (length-1)</code>，因此，必须是2的幂。</p>
<p>同时，Segment对象内部的数组，长度也是2的幂</p>
<h4 id="put">put</h4>
<p>在put时会对Segment对象进行初始化，使用了CAS</p>
<p>在等待锁的过程中，提前生成entry对象</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901160244226.png" alt="image-20210901160244226" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务架构与Spring Cloud Alibaba框架学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-08-28-微服务架构与Spring Cloud Alibaba框架学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-08-28-微服务架构与Spring Cloud Alibaba框架学习笔记/">
        </link>
        <updated>2021-08-28T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习微服务架构与Spring Cloud Alibaba框架过程中的学习笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/bJKCoGeUWY7">微服务Spring Cloud Alibaba三高架构实战视频.mp4</a></li>
<li><a href="https://www.aliyundrive.com/s/1TgXEyrFN2p">阿里微服务架构Spring Cloud Alibaba源码深度剖析视频.mp4</a></li>
</ul>
<hr>
<h2 id="微服务架构的优势劣势">微服务架构的优势劣势</h2>
<ul>
<li>优势
<ul>
<li>单一服务崩溃，不会影响其他服务的正常运行</li>
<li>方便大型团队的开发和管理</li>
<li>方便对特定服务的扩容</li>
<li>不同服务使用不同的数据库，便于数据库的管理</li>
</ul>
</li>
<li>劣势
<ul>
<li>增加运维难度</li>
<li>引发分布式事务问题</li>
<li>bug定位困难</li>
</ul>
</li>
</ul>
<h2 id="服务扩容方案">服务扩容方案</h2>
<h3 id="nginx负载均衡">nginx负载均衡</h3>
<p>需要手动修改nginx配置，对运维要求较高</p>
<h3 id="spring-cloud-alibaba">Spring Cloud Alibaba</h3>
<p>使用注册中心组件-nacos</p>
<h4 id="实现原理">实现原理</h4>
<p>客户端：默认集成Ribbon，Ribbon定时从Nacos上拉取相关信息。当客户端通过rest调用服务时，会被Ribbon拦截，Ribbon会根据本地的服务信息替换链接。Ribbon默认使用的是轮询负载均衡。</p>
<p>服务端：服务端启动后，会向Nacos注册服务，并开启心跳任务，定时向Nacos发送消息以证明自身存活。</p>
<h2 id="高可用">高可用</h2>
<p>核心链路中，某些服务未调用成功，则触发服务降级。服务降级可通过 sentinel组件 实现。</p>
<p>sentinel组件还可以帮我们实现限流、熔断功能。</p>
<p>限流：限制访问量。</p>
<p>熔断：对于大概率失败的请求调用，直接调用降级服务。</p>
<h3 id="限流算法">限流算法</h3>
<p>滑动时间窗、漏桶、令牌桶</p>
<h2 id="高并发">高并发</h2>
<h3 id="nacos">nacos</h3>
<p>如何解决读写冲突问题：读写分离，在副本上进行写，写完之后再覆盖掉原有数据。</p>
<h2 id="高扩展">高扩展</h2>
<h3 id="nacos-2">nacos</h3>
<p>namespace -&gt; group -&gt; cluster -&gt; instance</p>
<p>namespace: test, dev...</p>
<p>group: 交易微服务分组、仓储微服务分组</p>
<p>cluster: 多地部署，深圳、杭州、北京、成都</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082845291.png" alt="image-20210830082845291" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210830082920845.png" alt="image-20210830082920845" loading="lazy"></figure>
<h2 id="分布式事务">分布式事务</h2>
<p>借助 seata组件 完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-08-26-ConcurrentHashMap扩容机制/</id>
        <link href="http://Bule-Zst.gitee.io/2021-08-26-ConcurrentHashMap扩容机制/">
        </link>
        <updated>2021-08-26T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习 HashMap 过程中的笔记。</p>
<hr>
<h2 id="扩容机制">扩容机制</h2>
<p>首先要了解 HashMap 的底层结构，如图所示，数组+单向链表（红黑树）。</p>
<p>当单链表长度大于8时，~~数组长度达到64时，~~会由链表转换成红黑树。（依据：源码）</p>
<pre><code class="language-java">for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &amp;&amp;
        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
        break;
    p = e;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210826131403378.png" alt="image-20210826131403378" loading="lazy"></figure>
<p>初始时，数组长度为16，当数组中超过16*0.75=12个位置被使用后，数组会被扩容到32，之后会扩容到64。</p>
<p>这里需要注意的是，必须是数组中12个位置被使用过，并不是说HashMap中存放12个元素，这里容易混淆。</p>
<p>同样，附上代码：</p>
<pre><code class="language-java">if (++size &gt; threshold)
    resize();
</code></pre>
<p>比例因子：</p>
<p>默认为0.75，也就是说，虽然数组长度为16，但只能存放16*0.75=12个元素。</p>
<h2 id="看源码梳理put方法逻辑">看源码，梳理put方法逻辑</h2>
<p>源码如下：</p>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<ul>
<li>首先根据key计算hash值</li>
<li>根据hash值，从table中取出node
<ul>
<li>如果node为空，则根据key-value构造node，放到table相应位置中，并将size++，如果size超过阈值（容量*比例因子），则会进行扩容操作。</li>
<li>如果node不为空
<ul>
<li>如果node为红黑树，则会调用putTreeVal，向树中添加元素</li>
<li>如果node为单链表，则会遍历单链表
<ul>
<li>如果找到与key-value相等的元素，则直接返回。如果没找到，则新建</li>
<li>在遍历的过程中，如果发现链表长度大于TREEIFY_THRESHOLD（默认为8），则会将单链表转为红黑树。</li>
<li>分支逻辑：在转换过程中，如果发现当前table数组的大小小于MIN_TREEIFY_CAPACITY（默认为64），则不会进行转换，而是进行扩容操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/xpsallwell/article/details/88071038">ConcurrentHashMap扩容原理</a></li>
<li><a href="https://blog.csdn.net/zuokaopuqingnian/article/details/79508730">ArrayList HashMap ConcurrentHashMap扩容机制</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AQS、CAS学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-08-23-AQS、CAS学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-08-23-AQS、CAS学习笔记/">
        </link>
        <updated>2021-08-23T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习AQS、CAS过程中的笔记。</p>
<hr>
<h2 id="cas的应用">CAS的应用</h2>
<p>保证原子性</p>
<blockquote>
<p>上面我们了解了cas是什么了，那么它能解决什么问题呢？它可以解决多线程并发安全的问题，以前我们对一些多线程操作的代码都是使用synchronize关键字，来保证线程安全的问题；现在我们将cas放入到多线程环境里我们看一下它是怎么解决的，我们假设有A、B两个线程同时执行一个int值value自增的代码，并且同时获取了当前的value，我们还要假设线程B比A快了那么0.00000001s，所以B先执行，线程B执行了cas操作之后，发现当前值和预期值相符，就执行了自增操作，此时这个value = value + 1;然后A开始执行，A也执行了cas操作，但是此时value的值和它当时取到的值已经不一样了，所以此次操作失败，重新取值然后比较成功，然后将value值更新，这样两个线程进入，value值自增了两次，符合我们的预期。</p>
<p>https://blog.csdn.net/ln_6am/article/details/85642853</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/40025595">AQS 如何使用</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/u011506543/article/details/82392338">JAVA CAS实现原理与使用</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring中Bean、AOP、事务学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-08-10-Spring中Bean、AOP、事务学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-08-10-Spring中Bean、AOP、事务学习笔记/">
        </link>
        <updated>2021-08-10T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习Spring Bean、AOP、事务过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/JBxJZYEJADm">Spring之IOC、AOP、事务底层原理详解</a></li>
</ul>
<hr>
<h2 id="bean">Bean</h2>
<p>Bean对象默认为单例Bean，即根据Bean的name获取对象，相同name对应相同的对象。如果是独立Bean，就算name相同，也依旧是不同的对象。</p>
<h3 id="bean-vs-对象">Bean VS 对象</h3>
<ul>
<li>定义：Bean一定是对象，但对象不一定是Bean，只有被Spring管理的对象才是Bean对象。</li>
<li>特性：Bean对象中的Bean<strong>子</strong>对象，会被Spring自动注入。</li>
</ul>
<h3 id="bean创建流程">Bean创建流程</h3>
<ol>
<li>实例化（无参构造方法）</li>
<li>依赖注入
<ol>
<li>初始化前：@PostConstruct</li>
<li>初始化：InitializingBean</li>
<li>初始化后：AOP，生成代理对象</li>
</ol>
</li>
</ol>
<h2 id="spring容器">Spring容器</h2>
<p>本质上是Map，先根据.class进行寻找，如果找到的结果不唯一，则继续根据name进行寻找</p>
<pre><code class="language-java">class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService2 ) {
	不报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
	@Bean
	public OrderService orderService2() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	报错
}
---------------------------------------------------------
class AppConfig {
	@Bean
	public OrderService orderService1() {
		return new OrderService();
	}
}

public UserService( OrderService orderService1, OrderService orderService123 ) {
	不报错
}
</code></pre>
<h2 id="aop">AOP</h2>
<h2 id="事务">事务</h2>
<p>具有事务的对象为代理对象，切面逻辑为“开启事务”。</p>
<h3 id="事务失效">事务失效</h3>
<h4 id="存储引擎">存储引擎</h4>
<p>MySQL默认存储引擎是MyISAM，该存储引擎不知道事务，需要切换成InnoDB。</p>
<h4 id="内部调用">内部调用</h4>
<pre><code class="language-java">@Transactional
public void test() {
	jdbcTemplate.execute(&quot;insert t1 values(1,1,1)&quot;);
	a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
</code></pre>
<p>以上代码不会报错，原因是：</p>
<p>事务开启的逻辑是在代理对象中进行的，上述代码中a()方法的调用是在target对象中进行的，因此在调用a()方法时，不会触发事务相关的逻辑，因此事务失效。</p>
<p>解决方案：</p>
<pre><code class="language-java">@Autowired
private UserService userService;

@Transactional
public void test() {
	jdbcTemplate.execute(&quot;insert t1 values(1,1,1)&quot;);
	userService.a();
}

// Propagation.NEVER: throw an exception if a transaction exists
@Transactional(propagation=Propagation.NEVER)
public void a() {}
</code></pre>
<h2 id="问题">问题</h2>
<ul>
<li>Bean初始化，为什么有了initializingBean，还要PostConstructor</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JMM学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-28-JMM学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-28-JMM学习笔记/">
        </link>
        <updated>2021-07-28T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习JMM过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/B67o2UcNvG8">深入理解并发内存模型JMM与内存屏障</a></li>
</ul>
<hr>
<h2 id="java内存模型">Java内存模型</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210728151840865.png" alt="image-20210728151840865" style="zoom:60%;" />
<p>对于静态变量，每个线程中会存储变量副本。</p>
<blockquote>
<p>只要不影响到变量的值、变量不参与运算，则不会从主内存中拉取，比如while、if、赋值给其他变量、作为方法参数等</p>
<p>https://blog.csdn.net/ren421259121/article/details/90447853</p>
</blockquote>
<p>以下程序会死循环：</p>
<pre><code class="language-java">public class Main {
    static boolean exit = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread() {
            @Override
            public void run() {
                while( !exit ) {

                }
                System.out.println( &quot;end&quot; );
            }
        }.start();
        Thread.sleep(2000);
        exit = true;
    }
}
</code></pre>
<h2 id="jmm的原子操作">JMM的原子操作</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210729144205406.png" alt="image-20210729144205406" style="zoom:80%;" />
<h2 id="volatile">volatile</h2>
<p>作用：保证多线程间共享变量的可见性、有序性。不保证原子性，原子性需通过synchronized保证。</p>
<p>实现原理：</p>
<ul>
<li>JVM级：禁止JVM优化：指令重排、使用寄存器</li>
<li>CPU级：利用CPU lock指令为总线加锁</li>
</ul>
<h3 id="可见性">可见性</h3>
<h4 id="缓存一致性协议-vs-volatile">缓存一致性协议 VS volatile</h4>
<h5 id="缓存一致性协议mesi">缓存一致性协议（MESI）</h5>
<p>四种状态：</p>
<ul>
<li>M（Modified）：在缓存行中被标记为Modified的值，与主存中的值不同，这个值将会在它被读取之前写入内存，并且状态置为Shared。</li>
<li>E（Exclusive）：在缓存行中被标记为Exclusive的值与主存中的值一致，被读取时置为Shared状态，被写时置为Modified状态。</li>
<li>S（Shared）：值也可能存在于其他缓存中，但是它的值和主存中的值一致。</li>
<li>I（Invalid）：缓存行无效。</li>
</ul>
<p>关于状态之间的转换以及更详细介绍MESI的内容，可以看这篇博客：https://www.cnblogs.com/igoodful/p/9493156.html</p>
<p>做个总结，MESI协议，保证了各CPU缓存之间的一致性。</p>
<h5 id="volatile是否多余">volatile是否多余</h5>
<p>既然MESI协议可以保证各CPU缓存之间数据的一致性（可见性），那么为什么还需要volatile关键词来保证各线程之间数据的一致性（可见性）呢？volatile关键字是否多余？</p>
<p>答：不多余</p>
<p>理由：</p>
<ul>
<li>
<p>出发点不同：</p>
<ul>
<li>MESI协议保证了主内存和各CPU缓存的一致，而volatile保证了java进程中各线程之间的一致性。如果没有MESI，那么各线程之间一定是不一致的，但只有MESI，也不能完全保证各线程间的一致性。</li>
</ul>
</li>
<li>
<p>实现的功能不同：</p>
<ul>
<li>
<p>MESI的功能上文已经说过了，即，保证了各CPU缓存之间的一致性</p>
</li>
<li>
<p>volatile的功能：</p>
<ul>
<li>
<p>防止JVM优化</p>
</li>
<li>
<p>防止数据从CPU cache以外的地方读取，这里做一下说明，MESI只能保证主内存和CPU缓存（CPU cache）的一致性，但CPU中还有很多额外的组件用于数据存储，这些组件可以提高CPU数据读写的效率，而这些组件的一致性MESI是不保证的。</p>
<blockquote>
<p>因为 MESI只是保证了多核cpu的独占cache之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。有些arm和power架构的cpu还可能有load buffer或者invalid queue等等。</p>
<p>https://www.zhihu.com/question/296949412</p>
</blockquote>
</li>
<li>
<p>保证多个变量的顺序一致，即，consistency。因为volatile会对总线加锁，且防止指令重排，所以可以保证用volatile修饰的多个变量之间的操作顺序。而MESI只能保证单个变量的操作顺序，即coherence。</p>
<blockquote>
<p>Coherence deals with maintaining a global order in which writes to a single location or single variable are seen by all processors.</p>
<p>Consistency deals with the ordering of operations to multiple locations with respect to all processors.</p>
<p>https://www.zhihu.com/question/296949412</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><s>### CPU lock指令</s></p>
<p><s>CPU lock指令会将对应缓存行的状态改成E，并立即修改主内存中的数据。其他CPU通过总线嗅探机制，监听到数据的修改，将自己工作内存中的缓存行状态改成I。</s></p>
<p><s>如果不使用volatile关键字，JVM则不会使用lock指令，此时，对变量的修改会导致缓存行的状态变成M，并不会修改主内存的数据，因此会导致不同线程中共享变量数据不一致。</s></p>
<p><s>之所以不修改主内存，是因为对主内存的操作相对于CPU操作来说过于耗时，因此不会频繁操作主内存。</s></p>
<h4 id="reference">Reference</h4>
<ul>
<li><a href="https://www.cnblogs.com/xrq730/p/7048693.html">就是要你懂Java中volatile关键字实现原理</a></li>
<li><a href="https://www.zhihu.com/question/63120810">java多线程在单核CPU上，还是需要volatile synchronized吗？</a></li>
</ul>
<h3 id="有序性">有序性</h3>
<h4 id="重排序原则">重排序原则</h4>
<ul>
<li>as-if-serial：不管怎么重排序 (编译器和处理器为了提高并行度)，(单线程) 程序的执行结果不能被改变。</li>
<li>happens-before：本质上其实和第一点类似，就是保证单线程程序的语义不被改变。</li>
</ul>
<p>面试题：单例模式下对象半初始化问题</p>
<h4 id="内存屏障">内存屏障</h4>
<p>JVM内存屏障指令：LoadLoad, LoadStore, StoreLoad, StoreStore</p>
<p>对于volatile修饰的变量，在JVM级，会在该操作前后添加内存屏障指令，在CPU级，会通过lock指令实现内存屏障。</p>
<h2 id="面试题">面试题</h2>
<h3 id="volatile有什么特点和synchornized相比有什么区别">volatile有什么特点，和synchornized相比有什么区别？</h3>
<ul>
<li>volatile的特点：保证可见性和有序性，不保证原子性</li>
<li>volatile VS synchronized
<ul>
<li>修饰对象不同：volatile修饰变量，synchronized修饰方法和代码块</li>
<li>原子性：volatile不保证，synchronized保证</li>
<li>是否造成阻塞：volatile不会，synchronized会</li>
<li>volatile为轻量级锁，synchronized为重量级锁</li>
<li>都保证原子性和有序性</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S-Scheduler学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-28-K8S-Scheduler学习笔记/">
        </link>
        <updated>2021-07-28T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习K8S-Scheduler过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;seid=1977024601217253447">阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍</a></li>
</ul>
<hr>
<p>调度器功能：负责整个集群资源的调度功能，根据特定的调度算法和策略，将 Pod 调度到最优的工作节点上面去，从而更加合理、更加充分的利用集群的资源。</p>
<p>什么是Pod：Pod是K8S中最小的调度单元，Pod和docker容器的关系就相当于docker容器和进程，在目前的技术环境下，往往一个服务依赖于多个docker容器，因此，k8s中提出了Pod的概念，使用Pod对docker容器进行打包，统一进行调度。</p>
<h2 id="对pod进行自定义排序">对Pod进行自定义排序</h2>
<ul>
<li>按名称排序：kubectl get pods --sort-by=.metadata.name</li>
<li>按创建时间进行排序：kubectl get pods --sort-by=.metadata.creationTimestamp</li>
<li>按启动时间进行排序：kubectl get pods --sort-by=.status.startTime</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://blog.csdn.net/m0_50434960/article/details/114851074">k8s:Kubernetes 调度器介绍</a></li>
<li><a href="https://www.jianshu.com/p/bfaa566f17fe">细说kubernetes - 为什么是pod？</a></li>
<li><a href="https://www.cnblogs.com/yangyuliufeng/p/14257928.html">k8s调度器扩展机制</a></li>
<li><a href="https://www.bilibili.com/video/BV12J411q7k4?from=search&amp;seid=1977024601217253447">阿里技术大牛 30 分钟讲透 Kubernetes : 调度器的调度流程和算法介绍</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM性能调优学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-07-27-JVM性能调优学习笔记/">
        </link>
        <updated>2021-07-27T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习JVM性能调优过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/mmv27Dfr291">双十一亿级电商系统JVM性能调优实战</a></li>
</ul>
<hr>
<h2 id="java虚拟机组成">Java虚拟机组成</h2>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png" alt="image-20210727153842086" style="zoom:67%;" />
<ul>
<li>类装载子系统</li>
<li>字节码执行引擎</li>
<li>运行时数据区（内存模型）
<ul>
<li>栈（线程）
<ul>
<li>存放程序运行过程中的数据</li>
<li>栈 -&gt; 线程 -&gt; 方法
<ul>
<li>从栈中划分一块区域给线程，再从这块区域中划分一块给方法</li>
<li>方法中的局部变量就存在对应区域内</li>
</ul>
</li>
</ul>
</li>
<li>程序计数器：记录每个线程当前运行的代码在方法区中的位置</li>
<li>堆：存放程序运行过程中产生的对象</li>
<li>方法区（元空间）：常量+静态变量+类信息</li>
</ul>
</li>
</ul>
<h2 id="gc工作原理">GC工作原理</h2>
<h3 id="minor-gc新生代gc">Minor GC（新生代GC）</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png" alt="image-20210727152911187" style="zoom:80%;" />
<ul>
<li>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
<li>将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象。</li>
<li>每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。</li>
<li>如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。</li>
</ul>
<h3 id="minor-gc-vs-full-gc">Minor GC VS Full GC</h3>
<ul>
<li>Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。</li>
<li>Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短</li>
<li>算法不同：
<ul>
<li>Mnior GC用空间换时间，需要两个内存空间，直接Copy</li>
<li>Full GC用时间换空间，需要Mark+Compact</li>
</ul>
</li>
</ul>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://www.cnblogs.com/kevin7234/p/10644654.html">jvm minor gc 为什么比 full gc 快很多</a></li>
<li><a href="https://www.zhihu.com/question/35172533">为什么minor gc比full gc/major gc快？</a></li>
</ul>
<h2 id="arthas工具">Arthas工具</h2>
<p>阿里JVM性能调优工具</p>
<ul>
<li>
<p>dashboard：显示监控仪表盘</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155106380.png" alt="image-20210727155106380" style="zoom:50%;" />
</li>
<li>
<p>thread thread_id：显示占用CPU较多的代码行数</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155209073.png" alt="image-20210727155209073" style="zoom:70%;" />
</li>
<li>
<p>jad：反编译运行中的代码</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727155320962.png" alt="image-20210727155320962" style="zoom:80%;" />
</li>
</ul>
<h2 id="性能调优">性能调优</h2>
<p>目的：减少 STW 的次数。</p>
<p>STW: Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。</p>
<p>Full GC的SWT时间远大于Minor GC。</p>
<p>调优方法：</p>
<ul>
<li>对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。</li>
<li>对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。</li>
<li>使用不同的垃圾收集器，不同收集器，适用于不同的场景。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png" alt="image-20210727162355407" style="zoom:55%;" />
]]></content>
    </entry>
</feed>