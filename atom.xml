<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2022-02-06T08:39:47.107Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[JavaHan]]></title>
        <id>http://Bule-Zst.gitee.io/2022-02-01-JavaHan/</id>
        <link href="http://Bule-Zst.gitee.io/2022-02-01-JavaHan/">
        </link>
        <updated>2022-02-01T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>本人的面试八股文（面试小抄），供大家参考。</p>
<p>JavaHan，致敬 JavaGuide，Han指的是憨，并且感觉读起来比较顺口。</p>
<p>为了方便检索，我把所有内容都放在一个文档中的。</p>
<hr>
<h2 id="java">Java</h2>
<h3 id="java-基础">Java 基础</h3>
<h4 id="数据类型">数据类型</h4>
<p><strong>基本类型</strong></p>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<p><strong>包装类型</strong></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<pre><code class="language-java">Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
</code></pre>
<p><strong>缓存池</strong></p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre><code class="language-java">public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
</code></pre>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<pre><code class="language-java">Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
</code></pre>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<h4 id="string">String</h4>
<p><strong>概述</strong></p>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<p><strong>不可变的好处</strong></p>
<ul>
<li>可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
<p><strong>String StringBuffer StringBuilder 的区别</strong></p>
<p>1. 可变性</p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p>2. 线程安全</p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><strong>String Pool</strong></p>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 &quot;aaa&quot; 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code class="language-java">String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);           // true
</code></pre>
<p>如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code class="language-java">String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;
System.out.println(s5 == s6);  // true
</code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中，跟随 GC 被回收。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<p><strong>new String(&quot;abc&quot;)</strong></p>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。</p>
<ul>
<li>&quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code class="language-java">public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
</code></pre>
<pre><code class="language-java">String a = &quot;a&quot;;
String b = new String( a );

Class c = String.class;
Field field = c.getDeclaredField(&quot;value&quot;);
field.setAccessible( true );

System.out.println( a==b );                              // false

System.out.println( field.get( a ) == field.get( b ) );  // true
</code></pre>
<h4 id="运算">运算</h4>
<p><strong>参数传递</strong></p>
<p>Java 的参数是以 值传递 的形式传入方法中，而不是引用传递（传递变量的地址）。</p>
<p>例如 Dog dog 中的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<p><strong>float 与 double</strong></p>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<pre><code class="language-java">// float f = 1.1;
</code></pre>
<p>1.1f 字面量才是 float 类型。</p>
<pre><code class="language-java">float f = 1.1f;
</code></pre>
<p><strong>隐式类型转换</strong></p>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<pre><code class="language-java">short s1 = 1;
// s1 = s1 + 1;
</code></pre>
<p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<pre><code class="language-java">s1 += 1;
s1++;
</code></pre>
<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre><code class="language-java">s1 = (short) (s1 + 1);
</code></pre>
<p><strong>switch</strong></p>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<pre><code class="language-java">String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}
</code></pre>
<p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h4 id="关键字">关键字</h4>
<h5 id="final">final</h5>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h5 id="static">static</h5>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<p>静态方法只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p>
<p><strong>3. 静态语句块</strong></p>
<p>静态语句块，在且仅在 类加载时运行一次。</p>
<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<pre><code class="language-java">public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在<strong>使用静态变量和方法时</strong>不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<pre><code class="language-java">import static com.xxx.ClassName.*
</code></pre>
<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<pre><code class="language-java">public static String staticField = &quot;静态变量&quot;;

static {
    System.out.println(&quot;静态语句块&quot;);
}

public String field = &quot;实例变量&quot;;

{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre>
<p>最后才是构造函数的初始化。</p>
<pre><code class="language-java">public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}
</code></pre>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h4 id="object-通用方法">Object 通用方法</h4>
<h5 id="equals">equals()</h5>
<p>用来判断两个对象是否<strong>等价</strong></p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<ul>
<li>自反性：x.equals(x); // true</li>
<li>对称性：x.equals(y) == y.equals(x); // true</li>
<li>传递性：if (x.equals(y) &amp;&amp; y.equals(z))  x.equals(z); // true;</li>
<li>一致性：多次调用 equals() 方法结果不变</li>
<li>与 null 的比较：对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li>
</ul>
<p>等价（<code>equals()</code>）与相等（<code>==</code>）的区别：</p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<p>实现：</p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<pre><code class="language-java">@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    EqualExample that = (EqualExample) o;

    if (x != that.x) return false;
    if (y != that.y) return false;
    return z == that.z;
}
</code></pre>
<h5 id="hashcode">hashCode()</h5>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<pre><code class="language-java">EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
</code></pre>
<h5 id="tostring">toString()</h5>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为哈希值的无符号十六进制表示。</p>
<h5 id="clone">clone()</h5>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法（父类的 protected 方法，对于子类来说，是 private 方法）</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;
}
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
</code></pre>
<p>重写 clone() 得到以下实现：</p>
<pre><code class="language-java">public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
</code></pre>
<pre><code class="language-java">CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
java.lang.CloneNotSupportedException: CloneExample
</code></pre>
<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<pre><code class="language-java">public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象引用同一个对象。</p>
<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象引用不同对象。</p>
<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<pre><code class="language-java">public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
</code></pre>
<pre><code class="language-java">CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
</code></pre>
<h4 id="继承">继承</h4>
<h5 id="访问权限">访问权限</h5>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见：表示其它类可以用这个类创建实例对象。</li>
<li>成员可见：表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<h5 id="抽象类与接口">抽象类与接口</h5>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且<strong>不允许</strong>定义为 private 或者 protected。从 Java 9 开始，允许将<strong>方法</strong>定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h5 id="super">super</h5>
<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。使用 super() 调用父类构造函数，必须放在第一条语句。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<h5 id="重写与重载">重写与重载</h5>
<p><strong>1. 重写（Override）</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList&lt;Integer&gt;，是父类返回类型 List&lt;Integer&gt; 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<pre><code class="language-java">/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println(&quot;A.show(A)&quot;);
    }

    public void show(C obj) {
        System.out.println(&quot;A.show(C)&quot;);
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println(&quot;B.show(A)&quot;);
    }
}

class C extends B {
}

class D extends C {
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
</code></pre>
<p><strong>2. 重载（Overload）</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h4 id="反射">反射</h4>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p>反射的优点：</p>
<ul>
<li>可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li>类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li>调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<p>反射的缺点：</p>
<ul>
<li>性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li>
<li>安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li>
<li>内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
<h4 id="其他">其他</h4>
<p><strong>异常</strong></p>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/PPjwP.png" alt="img" style="zoom:13%;" />
<p><strong>泛型</strong></p>
<pre><code class="language-java">public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
</code></pre>
<p><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></p>
<p><strong>注解</strong></p>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><strong>Java vs C++</strong></p>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<p><strong>JRE vs JDK</strong></p>
<ul>
<li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li>
<li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li>
</ul>
<h4 id="vs-python">vs python</h4>
<ul>
<li>虚拟机：java 和 python 的运行，都是基于虚拟机</li>
<li>核心：java 的核心是虚拟机，python 的核心是类库</li>
<li>动静态：python 是全动态的，可以在运行时修改代码，变量也是动态的；java 的变量是静态的，必须事先声明</li>
<li>起源：python 是对标 c 语言的，类是后加的；java 是对标 c++ 的，主要为了解决 c++ 指针问题</li>
<li>开发模式：
<ul>
<li>python 适合敏捷开发；java 适合多人合作开发</li>
<li>python 更“自由”；java 更“规范”</li>
</ul>
</li>
<li>性能：源于强大的虚拟机，java 性能要优于 python，且对于 java 虚拟机是可以进行调优的</li>
<li></li>
<li>python 是脚本语言，比较轻便，可以很方便地调用 c 语言函数或 c++ 库，因此广泛用于数据分析、图像算法等领域</li>
<li>java 虚拟机巨大，一般用在服务端，对数据库支持良好</li>
</ul>
<p>Java 和 Python 有哪些区别？ - find goo的回答 - 知乎 https://www.zhihu.com/question/20491745/answer/100741761</p>
<h4 id="从编写到运行的过程">从编写到运行的过程</h4>
<p>编译器 -&gt; .class</p>
<p>类加载器 加载到 虚拟机</p>
<p>虚拟机内部的解释器进行运行</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/57c3e650eaf14983061e74cf29fa964a.png" alt="在这里插入图片描述" style="zoom:50%;" />
<p>https://www.pianshen.com/article/91151664011/</p>
<h3 id="java-容器">Java 容器</h3>
<h4 id="概述">概述</h4>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<p><strong>Collection</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191208220948084.png" alt="img" style="zoom:40%;" />
<p>1. Set</p>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
<li>LinkedHashSet <strong>vs</strong> HashSet
<ul>
<li>LinkedHashSet 基于 LinkedHashMap</li>
<li>HashSet 基于 HashMap</li>
<li>LinkedHashSet 继承于 HashSet，HashSet 中有一个特定供 LinkedHashSet 使用的构造函数</li>
<li>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220120140335907.png" alt="image-20220120140335907" style="zoom:30%;" />
</li>
</ul>
</li>
</ul>
<p>2. List</p>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p>3. Queue</p>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<p><strong>Map</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20201101234335837.png" alt="img" style="zoom:40%;" />
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h4 id="容器中的设计模式">容器中的设计模式</h4>
<p><strong>迭代器模式</strong></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
for (String item : list) {
    System.out.println(item);
}
</code></pre>
<p><strong>适配器模式</strong></p>
<p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<pre><code class="language-java">@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)
</code></pre>
<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<pre><code class="language-java">Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
</code></pre>
<p>也可以使用以下方式调用 asList()：</p>
<pre><code class="language-java">List list = Arrays.asList(1, 2, 3);
</code></pre>
<p>说明：</p>
<p>通过 asList() 方法，把数组对象包装成 List 对象。在 asList() 方法的内部实现中，把数组直接赋值给了内部类 ArrayList 的数组字段，且为 final。</p>
<p>使用 asList() 获得的 List，不支持 add() 操作，仅能对已有数据进行 get 和 set。</p>
<h4 id="源码分析">源码分析</h4>
<p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h5 id="arraylist">ArrayList</h5>
<p><strong>1. 概览</strong></p>
<p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<p>数组的默认大小为 10。</p>
<pre><code class="language-java">private static final int DEFAULT_CAPACITY = 10;
</code></pre>
<p><strong>2. 扩容</strong></p>
<p>使用 add() 方法添加元素，在 add() 方法内部，会自动进行必要的扩容。</p>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<p><strong>3. 删除元素</strong></p>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<p><strong>4. 序列化</strong></p>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<pre><code class="language-java">transient Object[] elementData; // non-private to simplify nested class access
</code></pre>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<p><strong>5. Fail-Fast</strong></p>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<p>检测 modCount 是否改变，主要是为了确保在序列化的过程中，没有别的线程对 ArrayList 进行修改</p>
<h5 id="vector">Vector</h5>
<p><strong>1. 同步</strong></p>
<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<pre><code class="language-java">public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
</code></pre>
<p><strong>2. 扩容</strong></p>
<p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<pre><code class="language-java">public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
</code></pre>
<p><strong>3. 与 ArrayList 的比较</strong></p>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<p><strong>4. 替代方案</strong></p>
<p><strong>SynchronizedList</strong></p>
<p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);
</code></pre>
<p>SynchronizedList 类是 Collections 类的静态内部类</p>
<p>SynchronizedList <strong>vs</strong> Vector：</p>
<ul>
<li>SynchronizedList 使用同步代码块，而 Vector 使用同步方法</li>
<li>扩容机制不同，ArrayList 默认是 1.5 倍，Vector 是 2 倍</li>
<li>SynchronizedList 可以让任何 List 都变成线程安全的，例如，获取线程安全的 LinkedList 对象</li>
<li>SynchronizedList 可以指定锁定的对象，在构造函数中可为 mutex 初始化，mutex 为同步代码块的锁定对象</li>
<li><a href="https://www.cnblogs.com/lujiahua/p/11408789.html">SynchronizedList和Vector的区别</a></li>
</ul>
<p><strong>CopyOnWriteArrayList</strong></p>
<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<pre><code class="language-java">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h5 id="copyonwritearraylist">CopyOnWriteArrayList</h5>
<p><strong>1. 读写分离</strong></p>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}
</code></pre>
<p><strong>2. 适用场景</strong></p>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h5 id="linkedlist">LinkedList</h5>
<p><strong>1. 概览</strong></p>
<p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<pre><code class="language-java">private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
}
</code></pre>
<p>每个链表存储了 first 和 last 指针：</p>
<pre><code class="language-java">transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;
</code></pre>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191208233940066.png" alt="img" style="zoom:40%;" />
<p><strong>2. 与 ArrayList 的比较</strong></p>
<p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h5 id="hashmap">HashMap</h5>
<p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<p><strong>1. 存储结构</strong></p>
<p>数组+单向链表（红黑树）</p>
<p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png" alt="img" style="zoom:40%;" />
<p><strong>2. 拉链法的工作原理</strong></p>
<pre><code class="language-java">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);
</code></pre>
<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以<strong>头插法</strong>方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191208235258643.png" alt="img" style="zoom:40%;" />
<p><strong>3. put 操作</strong></p>
<p><strong>3.1 jdk1.7</strong></p>
<pre><code class="language-java">public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
</code></pre>
<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<p><strong>3.2 jdk1.8</strong></p>
<p>源码如下：</p>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<p>流程梳理：</p>
<ul>
<li>首先根据key计算hash值</li>
<li>根据hash值，从table中取出node
<ul>
<li>如果node为空，则根据key-value构造node，放到table相应位置中</li>
<li>如果node不为空
<ul>
<li>如果node为红黑树，则会调用putTreeVal，向树中添加元素</li>
<li>如果node为单链表，则会遍历单链表
<ul>
<li>如果找到与key-value相等的元素，则直接返回。</li>
<li>如果没找到，则在尾部新建节点。新建后，如果发现链表长度大于TREEIFY_THRESHOLD（默认为8），则会将单链表转为红黑树。
<ul>
<li>分支逻辑：在转换过程中，如果发现当前table数组的大小小于MIN_TREEIFY_CAPACITY（默认为64），则不会进行转换，而是进行扩容操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最后，将size++，如果size超过阈值（容量*比例因子），则会进行扩容操作。</li>
</ul>
</li>
</ul>
<p><strong>4. 确定桶下标</strong></p>
<p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<pre><code class="language-java">// 计算 hash 值
int hash = hash(key);
// 根据 hash 值计算桶下标
int i = indexFor(hash, table.length);
</code></pre>
<p><strong>4.1 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<pre><code class="language-text">x   : 00010000
x-1 : 00001111
</code></pre>
<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<pre><code class="language-text">y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre>
<p>这个性质和 y 对 x 取模效果是一样的：</p>
<pre><code class="language-text">y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre>
<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<pre><code class="language-java">static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre>
<p><strong>5. 扩容</strong></p>
<p><strong>5.1 基本原理</strong></p>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">capacity</td>
<td style="text-align:left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:left">键值对数量。</td>
</tr>
<tr>
<td style="text-align:center">threshold</td>
<td style="text-align:left">size 的临界值</td>
</tr>
<tr>
<td style="text-align:center">loadFactor</td>
<td style="text-align:left">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p><strong>扩容时机</strong>：添加元素前先检查 size，如果 size 大于等于 threshold，就进行扩容操作，令 capacity 为原来的两倍</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>
<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<p><strong>5.2 重新计算桶下标</strong></p>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<pre><code class="language-html">capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<p><strong>6. 计算数组容量</strong></p>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<pre><code class="language-text">mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111110
mask |= mask &gt;&gt; 4    11111111
</code></pre>
<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<pre><code class="language-text">num      10010000
mask+1  100000000
</code></pre>
<p>以下是 HashMap 中计算数组容量的代码：</p>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<p><strong>7. 链表转红黑树</strong></p>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<p>在转换过程中，如果发现当前 table 长度小于 MIN_TREEIFY_CAPACITY，则会停止转换，而进行扩容。</p>
<pre><code class="language-java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
</code></pre>
<p><strong>8. 与 Hashtable 的比较</strong></p>
<ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。
<ul>
<li>fail-fast（快速失败）：遍历过程中，源 modCount 被修改，则直接抛异常</li>
<li>fail-safe（安全失败）：遍历过程中，源数据可被修改</li>
<li><a href="https://blog.csdn.net/biglxl/article/details/77462266">fail-fast和fail-safe详解</a></li>
</ul>
</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h5 id="concurrenthashmap">ConcurrentHashMap</h5>
<p>jdk 1.7</p>
<p><strong>1. 存储结构</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191209001038024.png" alt="img" style="zoom:40%;" />
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre><code class="language-java">static final int DEFAULT_CONCURRENCY_LEVEL = 16;
</code></pre>
<p><strong>2. size 操作</strong></p>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<pre><code class="language-java">/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
</code></pre>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<pre><code class="language-java">/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre>
<p><strong>3. JDK 1.8 的改动</strong></p>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时将其转换为红黑树。</p>
<h5 id="linkedhashmap">LinkedHashMap</h5>
<p><strong>存储结构</strong></p>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>
<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre><code class="language-java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p>accessOrder 决定了顺序，默认为 false</p>
<ul>
<li>false：插入顺序</li>
<li>true：LRU</li>
</ul>
<pre><code class="language-java">final boolean accessOrder;
</code></pre>
<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre>
<p><strong>afterNodeAccess()</strong></p>
<p>当一个节点被访问时，如果 accessOrder 为 true（LRU），则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<p><strong>afterNodeInsertion()</strong></p>
<p>在 put 等操作之后执行</p>
<p>当 removeEldestEntry() 方法返回 true 时，会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<p>当 evict 为 false 时，就不会自动删除元素</p>
<pre><code class="language-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
</code></pre>
<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="language-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>
<p><strong>维护链表</strong></p>
<p>LinkedHashMap 继承于 HashMap</p>
<p>重载 newNode() 方法，当新建节点时，添加到链表中</p>
<pre><code class="language-java">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
</code></pre>
<p>重载 afterNodeRemoval() 方法，当删除节点时，从链表中同步删除</p>
<pre><code class="language-java">void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    p.before = p.after = null;
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
</code></pre>
<p><strong>LRU 缓存</strong></p>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<pre><code class="language-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}

public static void main(String[] args) {
    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();
    cache.put(1, &quot;a&quot;);
    cache.put(2, &quot;b&quot;);
    cache.put(3, &quot;c&quot;);
    cache.get(1);
    cache.put(4, &quot;d&quot;);
    System.out.println(cache.keySet());
}

[3, 1, 4]
</code></pre>
<h5 id="weakhashmap">WeakHashMap</h5>
<p><strong>存储结构</strong></p>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<pre><code class="language-java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;
</code></pre>
<p><strong>ConcurrentCache</strong></p>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<pre><code class="language-java">public final class ConcurrentCache&lt;K, V&gt; {

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
</code></pre>
<h3 id="java-并发">Java 并发</h3>
<h4 id="使用线程">使用线程</h4>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
<p><strong>实现 Runnable 接口</strong></p>
<p>需要实现接口中的 run() 方法。</p>
<pre><code class="language-java">public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
</code></pre>
<p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
</code></pre>
<p><strong>实现 Callable 接口</strong></p>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<pre><code class="language-java">public class MyCallable implements Callable&lt;Integer&gt; {
    public Integer call() {
        return 123;
    }
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
</code></pre>
<p><strong>继承 Thread 类</strong></p>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<pre><code class="language-java">public class MyThread extends Thread {
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
</code></pre>
<p><strong>实现接口 VS 继承 Thread</strong></p>
<p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h4 id="基础线程机制">基础线程机制</h4>
<p><strong>Executor</strong></p>
<p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
</code></pre>
<p><strong>Daemon</strong></p>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
</code></pre>
<p><strong>sleep()</strong></p>
<p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<pre><code class="language-java">public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>
<p><strong>yield()</strong></p>
<p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<pre><code class="language-java">public void run() {
    Thread.yield();
}
</code></pre>
<h4 id="中断">中断</h4>
<p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<p><strong>InterruptedException</strong></p>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<pre><code class="language-java">public class InterruptExample {

    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println(&quot;Thread run&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println(&quot;Main run&quot;);
}
</code></pre>
<pre><code>Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>
<p><strong>interrupted()</strong></p>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<pre><code class="language-java">public class InterruptExample {

    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
            }
            System.out.println(&quot;Thread end&quot;);
        }
    }
}
public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();
}
</code></pre>
<p><strong>Executor 的中断操作</strong></p>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<pre><code class="language-java">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; {
        try {
            Thread.sleep(2000);
            System.out.println(&quot;Thread run&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println(&quot;Main run&quot;);
}
</code></pre>
<pre><code>Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<pre><code class="language-java">Future&lt;?&gt; future = executorService.submit(() -&gt; {
    // ..
});
future.cancel(true);
</code></pre>
<p>Future.cancel( boolean )</p>
<ul>
<li>传入true会中断线程停止任务</li>
<li>传入false则会让线程正常执行至完成</li>
<li></li>
<li>线程处于<strong>等待</strong>状态：此时调用 <code>cancel()</code> 方法不管传入true还是false都会标记为取消，任务依然保存在任务队列中，但当轮到此任务运行时会直接跳过。</li>
<li>线程处于<strong>运行中</strong>：此时传入true会中断正在执行的任务，传入false则不会中断。</li>
<li>线程处于<strong>完成</strong>状态：此时 <code>cancel()</code> 不会起任何作用，因为任务已经完成了。</li>
</ul>
<p><a href="https://blog.csdn.net/StefanTimber/article/details/73823689">关于Future.cancel(false)</a></p>
<h4 id="互斥同步">互斥同步</h4>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h5 id="synchronized">synchronized</h5>
<p><strong>原理</strong></p>
<p>对象的监视器：monitor</p>
<p>monitorenter：尝试获取 monitor</p>
<p>monitorexit：释放 monitor</p>
<p><strong>1. 同步一个代码块</strong></p>
<pre><code class="language-java">public void func() {
    synchronized (this) {
        // ...
    }
}
</code></pre>
<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<pre><code class="language-java">public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}
</code></pre>
<pre><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<pre><code class="language-java">public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}
</code></pre>
<pre><code>0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</code></pre>
<p><strong>2. 同步一个方法</strong></p>
<pre><code class="language-java">public synchronized void func () {
    // ...
}
</code></pre>
<p>它和同步代码块一样，作用于同一个对象。</p>
<p><strong>3. 同步一个类</strong></p>
<pre><code class="language-java">public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
</code></pre>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<pre><code class="language-java">public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}
</code></pre>
<pre><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<p><strong>4. 同步一个静态方法</strong></p>
<pre><code class="language-java">public synchronized static void fun() {
    // ...
}
</code></pre>
<p>作用于整个类。</p>
<h5 id="reentrantlock">ReentrantLock</h5>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<pre><code class="language-java">public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}

public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
}
</code></pre>
<pre><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<h5 id="比较">比较</h5>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>使用选择</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h4 id="线程间的协作">线程间的协作</h4>
<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<p><strong>join()</strong></p>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<pre><code class="language-java">public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println(&quot;A&quot;);
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;B&quot;);
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
</code></pre>
<pre><code>A
B
</code></pre>
<p><strong>wait() notify() notifyAll()</strong></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>wait() 方法会释放当前线程持有的对象锁，并进入等待队列（等待队列中的线程会被挂起，等待唤醒，不会竞争锁）</p>
<p>notify() 方法会将任意一个在等待队列中的线程移动到同步队列（在同步队列中的线程会竞争锁）</p>
<p>两个方法都只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException：</p>
<ul>
<li>对于 wait() 方法，因为要释放锁，所以等先获取锁</li>
<li>对于 notify() 方法，必须在同步方法或同步块中使用，是 java 的规范，因为 wait() 的初衷就是释放锁，让别的线程获取锁，当进行一些操作后，再唤醒自身。所以，必须在同步块中才有意义。</li>
<li><a href="https://www.cnblogs.com/wxw7blog/p/7396906.html">为什么wait()，notify()和notifyAll()必须在同步块或同步方法中调用</a></li>
</ul>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<pre><code class="language-java">public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println(&quot;before&quot;);
        notifyAll();
    }

    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;after&quot;);
    }
}

public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}
</code></pre>
<pre><code>before
after
</code></pre>
<p>实现原理：</p>
<ul>
<li>对于加锁解锁操作，主要是对 对象头 进行修改</li>
<li>对于同步队列、等待队列，主要基于队列实现，当锁被释放后，由 JVM 对同步队列中的线程进行唤醒。</li>
</ul>
<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
<p><strong>await() signal() signalAll()</strong></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<p>与 wait() notify() 相同，await() signal() 也必须放在同步块中（lock.lock() lock.unlock()）</p>
<pre><code class="language-java">public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println(&quot;before&quot;);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println(&quot;after&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}
</code></pre>
<pre><code>before
after
</code></pre>
<h4 id="线程状态">线程状态</h4>
<p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p>
<p><strong>新建（NEW）</strong></p>
<p>创建后尚未启动。</p>
<p><strong>可运行（RUNABLE）</strong></p>
<p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p>
<p><strong>阻塞（BLOCKED）</strong></p>
<p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p>
<p><strong>无限期等待（WAITING）</strong></p>
<p>等待其它线程显式地唤醒。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<p><strong>限期等待（TIMED_WAITING）</strong></p>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody>
</table>
<p>调用 Thread.sleep() 方法使线程进入限期<strong>等待</strong>状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期<strong>等待</strong>时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p><strong>死亡（TERMINATED）</strong></p>
<p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<h4 id="juc-aqs">J.U.C - AQS</h4>
<p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h5 id="countdownlatch"><strong>CountDownLatch</strong></h5>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="img" style="zoom:60%;" />
<pre><code class="language-java">public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;run..&quot;);
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println(&quot;end&quot;);
        executorService.shutdown();
    }
}
</code></pre>
<pre><code>run..run..run..run..run..run..run..run..run..run..end
</code></pre>
<h5 id="cyclicbarrier"><strong>CyclicBarrier</strong></h5>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<pre><code class="language-java">public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img" loading="lazy"></figure>
<pre><code class="language-java">public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;before..&quot;);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print(&quot;after..&quot;);
            });
        }
        executorService.shutdown();
    }
}
</code></pre>
<pre><code>before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
</code></pre>
<h5 id="semaphore"><strong>Semaphore</strong></h5>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<pre><code class="language-java">public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++) {
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + &quot; &quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
</code></pre>
<pre><code>2 1 2 2 2 2 2 1 2 2
</code></pre>
<h4 id="juc-其它组件">J.U.C - 其它组件</h4>
<h5 id="futuretask"><strong>FutureTask</strong></h5>
<p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&lt;V&gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<pre><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;
public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;
</code></pre>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<pre><code class="language-java">public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i &lt; 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -&gt; {
            System.out.println(&quot;other task is running...&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}
</code></pre>
<pre><code>other task is running...
4950
</code></pre>
<h5 id="blockingqueue"><strong>BlockingQueue</strong></h5>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong> ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p>
<p>示例：使用 BlockingQueue 实现生产者消费者问题</p>
<pre><code class="language-java">public class ProducerConsumer {

    private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put(&quot;product&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;produce..&quot;);
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;consume..&quot;);
        }
    }
}
public static void main(String[] args) {
    for (int i = 0; i &lt; 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i &lt; 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i &lt; 3; i++) {
        Producer producer = new Producer();
        producer.start();
    }
}
</code></pre>
<pre><code>produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..
</code></pre>
<h5 id="forkjoin"><strong>ForkJoin</strong></h5>
<p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<pre><code class="language-java">public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first &lt;= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i &lt;= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
</code></pre>
<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p>
<pre><code class="language-java">public class ForkJoinPool extends AbstractExecutorService
</code></pre>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<p>例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" alt="img" style="zoom:60%;" />
<h4 id="线程不安全示例">线程不安全示例</h4>
<p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<pre><code class="language-java">public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code>997
</code></pre>
<h4 id="java-内存模型">Java 内存模型</h4>
<p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h5 id="主内存与工作内存"><strong>主内存与工作内存</strong></h5>
<p>处理器上的寄存器的读写速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" alt="img" style="zoom:50%;" />
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" alt="img" style="zoom:50%;" />
<h5 id="内存间交互操作"><strong>内存间交互操作</strong></h5>
<p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="img" style="zoom:50%;" />
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h5 id="内存模型三大特性">内存模型三大特性</h5>
<p><strong>1. 原子性</strong></p>
<p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="img" style="zoom:50%;" />
<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" alt="img" style="zoom:50%;" />
<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<pre><code class="language-java">public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code>1000
</code></pre>
<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<pre><code class="language-java">public class AtomicSynchronizedExample {
    private int cnt = 0;

    public synchronized void add() {
        cnt++;
    }

    public synchronized int get() {
        return cnt;
    }
}

public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
</code></pre>
<pre><code>1000
</code></pre>
<p><strong>2. 可见性</strong></p>
<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>
<p>volatile</p>
<ul>
<li>实现原理：
<ul>
<li>JVM：在操作前后添加内存屏障指令</li>
<li>CPU：使用 lock 指令，对总线加锁，实现内存屏障，并保证可见性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</p>
</li>
<li>
<p>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</p>
</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<p><strong>3. 有序性</strong></p>
<p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>可以通过 synchronized 来保证多线程的有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h5 id="先行发生原则">先行发生原则</h5>
<p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<p>先行发生原则，指的是，在满足某些条件时，若操作 A 在时间上先于操作 B，那么，<strong>从逻辑上看</strong>，操作 A 一定先于操作 B。</p>
<p>解释两点：</p>
<ul>
<li>为什么时间上已经有先后顺序了，还需要先行发生原则？因为多线程之间的无序性。</li>
<li>为什么我说的是“从逻辑上”？因为事实就是如此，在先行发生原则下，可能操作 A 晚于操作 B 发生，但是先行发生原则能保证，逻辑上，一定是先 A 后 B。详见：<a href="https://blog.csdn.net/wangdong5678999/article/details/80960118">先行发生原则(happens-before)介绍</a></li>
</ul>
<p><strong>1. 单一线程原则</strong></p>
<blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img" style="zoom:50%;" />
<p><strong>2. 管程锁定规则</strong></p>
<blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img" style="zoom:50%;" />
<p><strong>3. volatile 变量规则</strong></p>
<blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img" style="zoom:50%;" />
<p><strong>4. 线程启动规则</strong></p>
<blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img" style="zoom:50%;" />
<p><strong>5. 线程加入规则</strong></p>
<blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img" style="zoom:50%;" />
<p><strong>6. 线程中断规则</strong></p>
<blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<p><strong>7. 对象终结规则</strong></p>
<blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<p><strong>8. 传递性</strong></p>
<blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h4 id="实现线程安全的方法">实现线程安全的方法</h4>
<p>定义：多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<p>线程安全有以下几种实现方式：</p>
<h5 id="不可变"><strong>不可变</strong></h5>
<p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<pre><code class="language-java">public class ImmutableExample {
    public static void main(String[] args) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put(&quot;a&quot;, 1);
    }
}
Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
</code></pre>
<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<pre><code class="language-java">public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
</code></pre>
<h5 id="线程同步">线程同步</h5>
<h6 id="互斥同步阻塞同步"><strong>互斥同步（阻塞同步）</strong></h6>
<p>synchronized 和 ReentrantLock。</p>
<h6 id="非阻塞同步"><strong>非阻塞同步</strong></h6>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p><strong>1. CAS</strong></p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<p><strong>2. AtomicInteger</strong></p>
<p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<pre><code class="language-java">private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
</code></pre>
<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<pre><code class="language-java">public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
</code></pre>
<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<pre><code class="language-java">public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
</code></pre>
<p><strong>3. ABA</strong></p>
<p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h5 id="无同步方案"><strong>无同步方案</strong></h5>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<p><strong>1. 栈封闭</strong></p>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<pre><code class="language-java">public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i &lt; 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}

public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; example.add100());
    executorService.execute(() -&gt; example.add100());
    executorService.shutdown();
}
</code></pre>
<pre><code>100
100
</code></pre>
<p><strong>2. 线程本地存储（Thread Local Storage）</strong></p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<pre><code class="language-java">public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<pre><code>1
</code></pre>
<p>为了理解 ThreadLocal，先看以下代码：</p>
<pre><code class="language-java">public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<p>它所对应的底层结构图为：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/6782674c-1bfe-4879-af39-e9d722a95d39.png" alt="img" style="zoom:50%;" />
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<pre><code class="language-java">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<pre><code class="language-java">public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>
<p>get() 方法类似。</p>
<pre><code class="language-java">public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre>
<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<p><strong>3. 可重入代码（Reentrant Code）</strong></p>
<p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h4 id="jdk16-synchronized-锁优化">jdk1.6 synchronized 锁优化</h4>
<h5 id="锁消除"><strong>锁消除</strong></h5>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<pre><code class="language-java">public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
</code></pre>
<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<pre><code class="language-java">public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
</code></pre>
<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h5 id="锁粗化">锁粗化</h5>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h5 id="锁升级">锁升级</h5>
<p><strong>主要流程</strong></p>
<p>线程对对象进行加锁，当获取到锁后，首先会对对象加偏向锁，加完偏向锁，如果有别的线程也想对该对象加锁，则该对象的偏向锁会转换成轻量级锁。在轻量级锁的情况下，如果 CAS 超过一定次数，则会转成重量级锁。</p>
<p><a href="https://zhuanlan.zhihu.com/p/92808298">synchronized锁升级优化</a></p>
<p><strong>自旋锁</strong></p>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<p><strong>轻量级锁</strong></p>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 锁标记位 对应了五个状态，这些状态在左侧的 锁状态 中给出。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/v2-e47232518a4e042f31a9e0eb6a48f88c_1440w.jpg" alt="img" style="zoom:90%;" />
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" alt="img" style="zoom:50%;" />
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/baaa681f-7c52-4198-a5ae-303b9386cf47.png" alt="img" style="zoom:50%;" />
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<h4 id="多线程开发良好的实践">多线程开发良好的实践</h4>
<ul>
<li>给线程起个有意义的名字，这样可以方便找 Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使用 BlockingQueue 实现生产者消费者问题。</li>
<li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>
<h3 id="java-虚拟机">Java 虚拟机</h3>
<p>本文大部分内容参考 <strong>周志明《深入理解 Java 虚拟机》</strong> ，想要深入学习的话请看原书。</p>
<h4 id="运行时数据区域">运行时数据区域</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727153842086.png" alt="image-20210727153842086" style="zoom:40%;" />
<p><strong>程序计数器</strong></p>
<p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</p>
<p>记录每个线程当前运行的代码在方法区中的位置</p>
<p><strong>Java 虚拟机栈</strong></p>
<p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>对栈帧的创建、入栈、出栈，由虚拟机进行控制</p>
<p>局部变量表 存放基本数据类型变量或者对象的引用</p>
<p>栈 -&gt; 线程 -&gt; 方法：从栈中划分一块区域给线程，再从这块区域中划分一块给方法</p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p>
<pre><code class="language-java">java -Xss2M HackTheJava
</code></pre>
<p>该区域可能抛出以下异常（栈溢出）：</p>
<ul>
<li>（单个线程栈 溢出）如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java 虚拟机将抛出一个StackOverFlowError异常</li>
<li>（整个虚拟机栈 溢出）如果 java 虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是依旧无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那 java 虚拟机将会抛出一个OutOfMemoryError异常</li>
<li>java栈内存溢出怎么产生？ - skywa的回答 - 知乎 https://www.zhihu.com/question/28637033/answer/41568606</li>
</ul>
<p>栈溢出的场景：</p>
<ul>
<li>递归调用</li>
<li>启动线程过多</li>
</ul>
<p><strong>本地方法栈</strong></p>
<p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" alt="img" style="zoom:40%;" />
<p><strong>堆</strong></p>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<pre><code class="language-java">java -Xms1M -Xmx2M HackTheJava
</code></pre>
<p><strong>方法区</strong></p>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成<strong>永久代</strong>来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至<strong>元空间</strong>，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<p><strong>运行时常量池</strong></p>
<p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p><strong>直接内存</strong></p>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h4 id="垃圾回收">垃圾回收</h4>
<p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h5 id="判断一个对象是否可被回收">判断一个对象是否可被回收</h5>
<p><strong>1. 引用计数算法</strong></p>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<pre><code class="language-java">public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
</code></pre>
<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<p><strong>2. 可达性分析算法</strong></p>
<p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="img" style="zoom:50%;" />
<p><strong>3. 方法区的回收</strong></p>
<p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p><strong>4. finalize()</strong></p>
<p>类似 C++ 的析构函数，用于关闭外部资源，但 try-finally 等方式可以做得更好。并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h5 id="引用类型">引用类型</h5>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<p><strong>1. 强引用</strong></p>
<p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<pre><code class="language-java">Object obj = new Object();
</code></pre>
<p><strong>2. 软引用</strong></p>
<p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<pre><code class="language-java">Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;  // 使对象只被软引用关联
</code></pre>
<p><strong>3. 弱引用</strong></p>
<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<pre><code class="language-java">Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
obj = null;
</code></pre>
<p><strong>4. 虚引用</strong></p>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<pre><code class="language-java">Object obj = new Object();
PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);
obj = null;
</code></pre>
<h5 id="垃圾收集算法">垃圾收集算法</h5>
<p><strong>1. 标记 - 清除</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="img" style="zoom:50%;" />
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<p><strong>2. 标记 - 整理</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="img" style="zoom:50%;" />
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<p><strong>3. 标记-复制</strong></p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="img" style="zoom:50%;" />
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有<strong>多于 10%</strong> 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行<strong>空间分配担保</strong>，也就是借用老年代的空间存储放不下的对象。</p>
<p><strong>4. 分代收集</strong></p>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h5 id="垃圾收集器">垃圾收集器</h5>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png" alt="image-20210923142511010" style="zoom:70%;" />
<p>以上是 HotSpot 虚拟机中的 7+3 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h6 id="概述-2">概述</h6>
<ul>
<li>
<p>新生代垃圾回收器</p>
<ul>
<li>Serial：标记-复制算法+单线程</li>
<li>ParNew：标记-复制算法+多线程+STW尽量短</li>
<li>Parallel Scavenge：标记-复制算法+多线程+吞吐量可控</li>
</ul>
</li>
<li>
<p>老年代垃圾回收器</p>
<ul>
<li>Serial Old：标记-整理算法+单线程</li>
<li>Parallel Old：标记-整理算法+吞吐量</li>
<li>CMS：标记-清除算法+STW尽量短
<ul>
<li>初始标记、并发标记、重新标记、并发清除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>G1</p>
<ul>
<li>
<p>jdk9 默认的收集器</p>
</li>
<li>
<p>标记-整理算法</p>
</li>
<li>
<p>分区+分代</p>
<blockquote>
<p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；</p>
<p>https://www.jianshu.com/p/aef0f4765098</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>ZGC</p>
<ul>
<li>STW极短</li>
<li>分区思想</li>
<li>染色指针</li>
</ul>
</li>
</ul>
<h6 id="1-serial-收集器">1. Serial 收集器</h6>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="img" style="zoom:60%;" />
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h6 id="2-parnew-收集器">2. ParNew 收集器</h6>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="img" style="zoom:60%;" />
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h6 id="3-parallel-scavenge-收集器">3. Parallel Scavenge 收集器</h6>
<p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“<strong>吞吐量</strong>优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h6 id="4-serial-old-收集器">4. Serial Old 收集器</h6>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="img" style="zoom:60%;" />
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h6 id="5-parallel-old-收集器">5. Parallel Old 收集器</h6>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img" style="zoom:60%;" />
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h6 id="6-cms-收集器">6. CMS 收集器</h6>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img" style="zoom:60%;" />
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h6 id="7-g1-收集器">7. G1 收集器</h6>
<p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img" style="zoom:50%;" />
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img" style="zoom:50%;" />
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<blockquote>
<p>RS被用来记录从其他Region指向一个Region的指针情况。因此，一个Region就会有一个RS。这种记录可以带来一个极大的好处：在回收一个Region的时候不需要执行全堆扫描，只需要检查它的RS就可以找到外部引用</p>
<p>https://www.jianshu.com/p/aef0f4765098</p>
</blockquote>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img" style="zoom:60%;" />
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p><strong>回收原理与 CMS 类似，只是在最终回收时，利用分区的思想，全局采用标记整理算法，局部采用复制算法。</strong></p>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<p><a href="https://blog.csdn.net/u011546953/article/details/78994882">CMS收集器与G1收集器</a></p>
<h6 id="8-zgc">8. ZGC</h6>
<p>将堆划分成3部分：</p>
<ul>
<li>小页面（2M）：对象小于256KB</li>
<li>中页面（32M）：对象在256KM~4MB</li>
<li>大页面（&gt;32M）：对象大于4M</li>
</ul>
<p>指针着色：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png" alt="image-20210923143727759" loading="lazy"></figure>
<p>流程：</p>
<ul>
<li>初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。</li>
<li>并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）</li>
<li>再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。</li>
<li>并发转移准备：筛选需要转移的分区</li>
<li>初始转移：转移与GC Roots直接关联的对象</li>
<li>并发转移：转发表</li>
</ul>
<p><strong>思考</strong></p>
<ul>
<li>
<p>为什么初始标记阶段，不标记所有对象？</p>
<p>因为耗时少！</p>
</li>
<li>
<p>为什么不直接进行并发标记？即，初始标记的意义是什么？</p>
<p>初始标记的意义：找根对象</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png" alt="image-20210924093232733" style="zoom:50%;" />
</li>
</ul>
<p><strong>Z的含义</strong></p>
<blockquote>
<p>可能大伙还惦记这标题吧？<strong>ZGC 的 Z 是什么意思？</strong></p>
<p>其实没啥意思，就是个名字而已。</p>
<p>https://blog.csdn.net/yessimida/article/details/109763732</p>
</blockquote>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png" alt="img" style="zoom:40%;" />
<h4 id="内存分配与回收策略">内存分配与回收策略</h4>
<h5 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h5>
<ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。虽然使用的是复制算法，但非垃圾对象较少，因此拷贝时间较短。
<ul>
<li>用空间换时间，需要两个内存空间，直接Copy</li>
</ul>
</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。
<ul>
<li>用时间换空间，需要Mark+Compact</li>
</ul>
</li>
<li>Major GC (Old GC)：回收老年代。</li>
</ul>
<p>Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。</p>
<p>对于大多数老年代的垃圾收集器，回收过程都是新生代和老年代一起收集的，因此是 Full GC，对于 CMS，回收过程只针对老年代，因此是 Major GC。</p>
<ul>
<li>
<blockquote>
<p>因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC</p>
<p>https://www.zhihu.com/question/41922036</p>
</blockquote>
</li>
</ul>
<h5 id="内存分配策略">内存分配策略</h5>
<p><strong>1. 对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<p><strong>2. 大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p><strong>3. 长期存活的对象进入老年代</strong></p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<p><strong>4. 动态对象年龄判定</strong></p>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<p><strong>5. 空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h5 id="full-gc-的触发条件">Full GC 的触发条件</h5>
<p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>1. 调用 System.gc()</strong></p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<p><strong>2. 老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<p><strong>3. 空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<p><strong>4. JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<p><strong>5. Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h5 id="性能调优-减少-stw">性能调优-减少 STW</h5>
<p>性能调优的目的：减少 STW 的时间</p>
<p>STW：Stop-The-World，在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。</p>
<p>Full GC 的 SWT 时间远大于 Minor GC，因此需要尽量减少 Full GC 的次数</p>
<p>调优方法：</p>
<ul>
<li>对业务场景进行分析，为年轻代和老年代分配适当的空间，减少Full GC的频率。</li>
<li>对于“朝花夕拾”的对象，通过参数调优防止其进入老年代。</li>
<li>使用不同的垃圾收集器，不同收集器，适用于不同的场景。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727162355407.png" alt="image-20210727162355407" style="zoom:55%;" />
<h4 id="类加载机制">类加载机制</h4>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<p><strong>类的生命周期</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" alt="img" style="zoom:40%;" />
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p><strong>类加载过程</strong></p>
<p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<p><strong>1. 加载</strong></p>
<p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<p><strong>2. 验证</strong></p>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>3. 准备</strong></p>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<pre><code class="language-java">public static int value = 123;
</code></pre>
<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<pre><code class="language-java">public static final int value = 123;
</code></pre>
<p><strong>4. 解析</strong></p>
<p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<p><strong>5. 初始化</strong></p>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<pre><code class="language-java">public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
</code></pre>
<p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<pre><code class="language-java">static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
</code></pre>
<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<p><strong>类初始化时机</strong></p>
<p><strong>1. 主动引用</strong></p>
<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<p><strong>2. 被动引用</strong></p>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<pre><code class="language-java">System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
</code></pre>
<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<pre><code class="language-java">SuperClass[] sca = new SuperClass[10];
</code></pre>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<pre><code class="language-java">System.out.println(ConstClass.HELLOWORLD);
</code></pre>
<p><strong>类与类加载器</strong></p>
<p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<p><strong>类加载器分类</strong></p>
<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</li>
<li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><strong>双亲委派模型</strong></p>
<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" alt="img" style="zoom:40%;" />
<p><strong>1. 工作过程</strong></p>
<p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<p><strong>2. 好处</strong></p>
<p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<p><strong>3. 实现</strong></p>
<p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<pre><code class="language-java">public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
</code></pre>
<p><strong>自定义类加载器实现</strong></p>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<pre><code class="language-java">public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + &quot;.class&quot;;
    }
}
</code></pre>
<pre><code class="language-java">FileSystemClassLoader loader = new FileSystemClassLoader(&quot;rootDir&quot;);
Class&lt;?&gt; clazz = loader.loadClass(&quot;类名&quot;);
Object o = clazz.newInstance();
</code></pre>
<h3 id="java-io">Java IO</h3>
<h4 id="磁盘操作file">磁盘操作：File</h4>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<pre><code class="language-java">public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
</code></pre>
<p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h4 id="字节操作inputstream-和-outputstream">字节操作：InputStream 和 OutputStream</h4>
<p><strong>实现文件复制</strong></p>
<pre><code class="language-java">public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
</code></pre>
<p><strong>装饰者模式</strong></p>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" alt="img" style="zoom:40%;" />
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<pre><code class="language-java">FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
</code></pre>
<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h4 id="字符操作reader-和-writer">字符操作：Reader 和 Writer</h4>
<p><strong>编码与解码</strong></p>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>Java 的内存编码使用双字节编码 UTF-16，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<p><strong>String 的编码方式</strong></p>
<p>String 可以看成一个<strong>字符</strong>序列，可以指定一个编码方式将它编码为<strong>字节</strong>序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<pre><code class="language-java">String str1 = &quot;中文&quot;;
byte[] bytes = str1.getBytes(&quot;UTF-8&quot;);
String str2 = new String(bytes, &quot;UTF-8&quot;);
System.out.println(str2);
</code></pre>
<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<p>双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。</p>
<pre><code class="language-java">byte[] bytes = str1.getBytes();
</code></pre>
<p><strong>Reader 与 Writer</strong></p>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h4 id="对象操作serializable">对象操作：Serializable</h4>
<p><strong>序列化</strong></p>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<p><strong>Serializable</strong></p>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<p><strong>transient</strong></p>
<p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<pre><code class="language-java">private transient Object[] elementData;

/**
 * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that
 * is, serialize it).
 *
 * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
 *             instance is emitted (int), followed by all of its elements
 *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
 */
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();
 
    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);
 
    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }
 
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<h4 id="网络操作socket">网络操作：Socket</h4>
<p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<p><strong>InetAddress</strong></p>
<p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<pre><code class="language-java">InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);
</code></pre>
<p><strong>URL</strong></p>
<p>可以直接从 URL 中读取字节流数据。</p>
<pre><code class="language-java">public static void main(String[] args) throws IOException {

    URL url = new URL(&quot;http://www.baidu.com&quot;);

    /* 字节流 */
    InputStream is = url.openStream();

    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);

    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();
}
</code></pre>
<p><strong>Sockets</strong></p>
<ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" alt="img" style="zoom:60%;" />
<p><strong>Datagram</strong></p>
<ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h4 id="nio">NIO</h4>
<p>NIO 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向<strong>块</strong>的 I/O。</p>
<h5 id="流与块">流与块</h5>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h5 id="通道与缓冲区">通道与缓冲区</h5>
<p><strong>1. 通道</strong></p>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道是对 NIO 的具体实现。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p><strong>2. 缓冲区</strong></p>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h5 id="缓冲区状态变量">缓冲区状态变量</h5>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="img" style="zoom:60%;" />
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="img" style="zoom:60%;" />
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="img" style="zoom:60%;" />
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="img" style="zoom:60%;" />
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="img" style="zoom:60%;" />
<h5 id="文件-nio-实例">文件 NIO 实例</h5>
<p>以下展示了使用 NIO 快速复制文件的实例：</p>
<pre><code class="language-java">public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的文件通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);

        /* 清空缓冲区 */
        buffer.clear();
    }
}
</code></pre>
<h5 id="选择器">选择器</h5>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><strong>1. 创建选择器</strong></p>
<pre><code class="language-java">Selector selector = Selector.open();
</code></pre>
<p><strong>2. 将通道注册到选择器上</strong></p>
<pre><code class="language-java">ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<pre><code class="language-java">public static final int OP_READ = 1 &lt;&lt; 0;
public static final int OP_WRITE = 1 &lt;&lt; 2;
public static final int OP_CONNECT = 1 &lt;&lt; 3;
public static final int OP_ACCEPT = 1 &lt;&lt; 4;
</code></pre>
<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<pre><code class="language-java">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>
<p><strong>3. 监听事件</strong></p>
<pre><code class="language-java">int num = selector.select();
</code></pre>
<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<p><strong>4. 获取到达的事件</strong></p>
<pre><code class="language-java">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
</code></pre>
<p><strong>5. 事件循环</strong></p>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<pre><code class="language-java">while (true) {
    int num = selector.select();
    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
</code></pre>
<h5 id="内存映射文件">内存映射文件</h5>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<pre><code class="language-java">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
</code></pre>
<h5 id="nio-vs-普通-io">NIO vs 普通 I/O</h5>
<p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="概述-3">概述</h3>
<h4 id="isp">ISP</h4>
<p>互联网服务提供商</p>
<p>ISP 可以从 互联网管理机构 获得许多 IP 地址，个人或机构向 ISP 缴纳一定的费用就可以接入互联网</p>
<h4 id="osi模型-五层模型与-tcpip-模型">OSI模型、五层模型与 TCP/IP 模型</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211217120543019.png" alt="image-20211217120543019" style="zoom:45%;" />
<p>五层模型：</p>
<ul>
<li>物理层：负责在<strong>具体媒体</strong>上传输数据<strong>比特流</strong>，为 数据链路层 屏蔽具体的媒体特性。</li>
<li>数据链路层：负责在<strong>具体链路</strong>上传输<strong>数据帧</strong>，为 网络层 屏蔽具体链路信息（网络层中，主机间的传输，需要经过多条链路）。</li>
<li>网络层：负责在<strong>主机间</strong>传输<strong>数据分组</strong>，为 传输层 屏蔽主机信息。</li>
<li>传输层：负责在<strong>进程间</strong>传输数据，为 应用层 屏蔽进程信息。
<ul>
<li>TCP：传输控制协议，面向连接、可靠的数据传输服务，数据单位为<strong>报文段</strong></li>
<li>UDP：用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是<strong>用户数据报</strong></li>
</ul>
</li>
<li>应用层：负责在<strong>应用间</strong>传输<strong>报文</strong>，例如HTTP、DNS协议。</li>
<li>越底层，数据量越大，逐层封装。</li>
</ul>
<p>OSI模型：</p>
<ul>
<li>表示层：负责数据处理，比如，压缩、加密等，使 <strong>应用层</strong> 无需关心数据内部格式方面的问题。</li>
<li>会话层：负责会话的连接、维护、断开等。当应用间需要传输数据时，首先需要建立会话；当数据传输完时，会话层会有选择地进行会话的维护；最终，会话层会断开会话。</li>
<li>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</li>
</ul>
<p>TCP/IP 模型：</p>
<ul>
<li>将五层模型中的数据链路层和物理层合并为网络接口层</li>
</ul>
<h3 id="物理层">物理层</h3>
<h3 id="链路层">链路层</h3>
<h4 id="信道复用技术41种">信道复用技术（4+1种）</h4>
<ul>
<li>
<p>频分复用</p>
</li>
<li>
<p>时分复用（TDM）：为每个用户分配固定位置的时隙</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:37%;" />
</li>
<li>
<p>统计时分复用（异步时分复用，STDM）：不固定每个用户在时分复用帧中的位置，只要有数据，就为其分配时隙，用户拿到时隙后，就可以发送数据（注意区分两张图中字母的顺序）</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:37%;" />
</li>
<li>
<p>波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
</li>
<li>
<p>码分复用</p>
</li>
</ul>
<h4 id="ppp-协议">PPP 协议</h4>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<h4 id="arp-地址解析协议">ARP 地址解析协议</h4>
<p>ARP 协议负责根据 IP 地址获取 MAC 地址。</p>
<p>实现原理：每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果某 IP 地址不存在，则通过广播的形式获取。MAC 地址</p>
<p>MAC 地址是链路层地址，长度为 6 字节（6*8=48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h4 id="网络设备">网络设备</h4>
<ul>
<li>集线器：
<ul>
<li>物理层设备，作用于 比特</li>
<li>当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口</li>
<li>如果集线器同时收到两个不同接口的帧，那么就发生了碰撞</li>
</ul>
</li>
<li>交换机：
<ul>
<li>链路层设备，作用于 帧</li>
<li>不会发生碰撞</li>
<li>能根据 MAC 地址进行存储转发</li>
<li>具有自学习能力，能自动生成 交换表</li>
</ul>
</li>
</ul>
<h3 id="网络层">网络层</h3>
<h4 id="概述-4">概述</h4>
<p>网络层的作用：使用 IP 协议，将异构的物理网络连接起来，使得其看起来好像是一个统一的网络</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" alt="img" style="zoom:37%;" />
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>
<p>地址解析协议 ARP（Address Resolution Protocol）</p>
</li>
<li>
<p>网际控制报文协议 ICMP（Internet Control Message Protocol）</p>
</li>
<li>
<p>网际组管理协议 IGMP（Internet Group Management Protocol）</p>
</li>
</ul>
<h4 id="ip-协议">IP 协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom:65%;" />
<p>IP 地址能够在网络世界唯一标识一台电脑，IP 地址一共有32位，即8个字节。</p>
<p>IP 地址的编址方式的三个历史阶段：</p>
<ul>
<li>分类编址：
<ul>
<li>不同分类具有不同的网络号长度，并且是固定的</li>
<li>网络号+主机号</li>
<li>网络地址：指的是，网络号不变，主机位二进制全为0的 ip 地址，类似于电话号码的区号</li>
<li>要达到 Internet 上的某个主机，先利用 IP 地址的高位部分（网络地址）找到该主机所在的网络，再利用 IP 地址的低位部分（主机地址）找到该网络中的主机。</li>
<li>子网掩码，又叫网络掩码、地址掩码。它的作用是，用来指明某个 IP 地址哪些标识位是网络地址，哪些标识位是主机地址</li>
</ul>
</li>
<li>子网划分编址：
<ul>
<li>网络号+子网号+主机号</li>
<li>举例：B 类地址的默认子网掩码为 255.255.0.0（11111111 11111111 00000000 00000000），如果子网占两个比特，那么子网掩码为 255.255.192.0（11111111 11111111 11000000 00000000）</li>
</ul>
</li>
<li>无分类编址（CIDR）：
<ul>
<li>网络前缀号+主机号</li>
<li>在 IP 地址后面加上网络前缀长度，例如，128.14.35.7/20</li>
<li>路由聚合与最长前缀匹配：
<ul>
<li>路由聚合：将 200.23.a.b/23 与 200.23.c.d/23 进行聚合，得到200.23.x.x/20，减少路由表项的数量</li>
<li>最长前缀皮配：如果路由表中存在 A: 200.23.18.0/23 和 B: 200.23.x.x/20，则对于 200.23.18.0/23，选择A与之进行匹配（虽然 B 也能进行匹配，但是不是最长的）</li>
<li>参考：https://blog.csdn.net/iostream1001001/article/details/78126150</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="icmp-网际控制报文协议">ICMP 网际控制报文协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt="img" style="zoom:43%;" />
<p>放在 IP 数据报的数据部分，用于实现一些特定的功能，目的是为了更有效地转发 IP 数据报和提高交付成功的机会。</p>
<p>ICMP 的应用：</p>
<ul>
<li>Ping：用于测试两台主机之间的连通性。</li>
<li>Traceroute：用来跟踪一个数据分组从源点到终点的路径</li>
</ul>
<h4 id="vpn-虚拟专用网">VPN 虚拟专用网</h4>
<p>如何理解：</p>
<ul>
<li>
<p>首先，什么是专用网？主机需要分配 IP 地址才能上网，但往往，一个机构能申请到的 IP 地址是有限的，因此，只能为主机分配本机构内部有效的专用地址。主机间使用专用地址进行通信，构成专用网。</p>
</li>
<li>
<p>什么是虚拟专用网？指的是，该专用网其实是依托于互联网形成的，所以不是实实在在的专用网，而是虚拟专用网。主机 A 向主机 B 发送数据，数据报的源地址和目的地址都是专用地址，在路由器中，会对数据报进行加密、封装，新的数据报源地址和目的地址都是全球地址。在目的路由接收后，再对数据报进行解密，然后根据专用地址进行转发。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt="img" style="zoom:35%;" />
</li>
</ul>
<h4 id="nat-网络地址转换">NAT 网络地址转换</h4>
<p>功能：将专业地址转换成全球地址，或将全球地址转换成专用地址，使得机构内部主机可以上网。</p>
<p>实现：</p>
<ul>
<li>将本地 IP 和全球 IP 一一对应</li>
<li>缺点：拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网</li>
<li>解决方案：NAPT 网络地址与端口转换（将传输层的端口号也用上）</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2719067e-b299-4639-9065-bed6729dbf0b.png" alt="img" style="zoom:63%;" />
<h4 id="路由器">路由器</h4>
<p>位于网络层，只负责主机间的数据传输</p>
<p>功能：路由选择与分组转发</p>
<h4 id="路由选择协议">路由选择协议</h4>
<ul>
<li>
<p>内部网关协议</p>
<ul>
<li>
<p>RIP 路由信息协议：基于距离，依靠路由器间交换路由表，获取整个网络的距离信息</p>
</li>
<li>
<p>OSPF 开放式最短路径优先协议：</p>
<ul>
<li>基于 Dijkstra 提出的最短路径算法 SPF</li>
<li>向内部网络中的所有路由器发送信息，且只有当链路状态发生变化时，路由器才会发送信息，因此信息更新过程收敛得更快</li>
</ul>
</li>
</ul>
</li>
<li>
<p>外部网关协议</p>
<ul>
<li>
<p>BGP 边界网关协议</p>
<ul>
<li>
<p>AS 之间的路由选择很困难，因此，BGP 只能寻找一条比较好的路由，而不是最佳路由</p>
</li>
<li>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" alt="img" style="zoom:63%;" />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传输层">传输层</h3>
<h4 id="udp-vs-tcp">UDP vs TCP</h4>
<ul>
<li>TCP：
<ul>
<li>传输控制协议，面向连接、可靠（超时重传）的数据传输服务，数据单位为<strong>报文段</strong></li>
<li>每一条 TCP 连接，只能一对一</li>
<li>有流量控制、拥塞控制</li>
<li>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li>
</ul>
</li>
<li>UDP：
<ul>
<li>用户数据报协议，无连接、尽最大努力的数据传输服务，数据单位是<strong>用户数据报</strong></li>
<li>n对n，n &gt;= 1</li>
<li>无流量控制、拥塞控制</li>
<li>面向报文（对应用层传下来的报文不合并也不拆分，只是添加 UDP 首部）</li>
</ul>
</li>
</ul>
<h4 id="tcp-的三次握手">TCP 的三次握手</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:43%;" />
<ul>
<li>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的<strong>序号 x</strong>。</p>
</li>
<li>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，<strong>确认号为 x+1</strong>，同时也选择一个初始的<strong>序号 y</strong>。</p>
</li>
<li>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，<strong>确认号为 y+1</strong>，序号为 <strong>x+1</strong>。</p>
</li>
<li>
<p>B 收到 A 的确认后，连接建立。</p>
</li>
<li></li>
<li>
<p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li></li>
</ul>
<p>三次握手的原因：</p>
<ul>
<li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</li>
<li>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</li>
</ul>
<h4 id="syn-攻击">SYN 攻击</h4>
<p>客户端第一次握手后，故意不进行第三次握手，导致服务端保存大量半连接，占用系统资源。</p>
<p>解决方案：</p>
<ul>
<li>限制同时打开的半连接数目</li>
<li>缩短超时时间：在超时时间内，服务器会不停重发请求，直到达到超时时间，然后放弃掉该半连接</li>
</ul>
<h4 id="tcp-的四次挥手">TCP 的四次挥手</h4>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认报文，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认报文，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>进入 TIME_WAIT 状态的原因</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h4 id="tcp-的滑动窗口">TCP 的滑动窗口</h4>
<p>发送方和接收方，都有滑动窗口，接收方通过报文告知发送方自己窗口（接收窗口）的大小，发送方根据接收窗口大小以及其它信息（见拥塞控制那一节）设置自己窗口（发送窗口）的大小</p>
<p>当发送窗口左侧字节收到确认，右移发送窗口，直到左部第一个字节不是已确认的状态</p>
<p>接收窗口只会按需进行确认，确认后，右移接收窗口。因此，对于发送窗口来说，收到某个字节的确认，就说明，此字节之前的字节，接收方都已接收。</p>
<h4 id="tcp-的流量控制">TCP 的流量控制</h4>
<p>接收方通过确认报文中的窗口字段 <strong>影响</strong> 发送窗口的大小，从而 <strong>影响</strong> 发送速率（注意，我这里用的是 <strong>影响</strong>，而不是 <strong>控制</strong>，见 拥塞控制 那一节，思考原因）</p>
<p>将窗口字段设置为0，则发送方不能发送数据</p>
<h4 id="tcp-的拥塞控制">TCP 的拥塞控制</h4>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>发送窗口大小 = min{ 接收方允许的窗口大小（由确认报文指定），拥塞窗口变量（cwnd） }</p>
<p>拥塞控制算法（慢开始、拥塞避免、快重传、快恢复）流程：</p>
<ul>
<li>
<p>将 cwnd 设置为1（<strong>慢开始</strong>）</p>
</li>
<li>
<p>每次当收到确认报文后，将 cwnd 加倍</p>
<ul>
<li>当 cwnd &gt;= <strong>慢开始门限</strong> ssthrsh 后， cwnd 每次只加一（<strong>拥塞避免</strong>）</li>
</ul>
</li>
<li>
<p>如果出现超时，令 ssthresh = cwnd / 2，然后重新执行慢开始（回到第一步）</p>
</li>
<li>
<p>如果连续收到 3 次重复确认，则说明报文段丢失</p>
<ul>
<li>立即重传丢失报文（<strong>快重传</strong>）</li>
<li>并令 ssthresh = cwnd / 2，cwnd = ssthresh （<strong>快恢复</strong>：无需重新执行慢开始）</li>
</ul>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="img" style="zoom:40%;" />
</li>
</ul>
<h4 id="tcp-如何保证可靠性">TCP 如何保证可靠性</h4>
<p>6点：</p>
<ul>
<li>校验和
<ul>
<li>计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中</li>
</ul>
</li>
<li>序列号与确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p><a href="https://www.jianshu.com/p/42dbcd39c3e7">TCP 如何保证可靠性</a></p>
<h4 id="tcp-的序号">TCP 的序号</h4>
<p>序号指的是，报文段在整个报文中的位置</p>
<blockquote>
<p>假设主机A的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流，主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500 000字节的文件组成，其MSS（最大报文段长度）为1000字节，数据流的首字节编号是0，如下图所示：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/20190507215823752.png" alt="img" style="zoom:60%;" />
<p>https://blog.csdn.net/wangquan1992/article/details/89930585</p>
</blockquote>
<p>初始序号是随机产生的</p>
<h3 id="应用层">应用层</h3>
<h4 id="ftp-文件传送协议">FTP 文件传送协议</h4>
<p>使用 TCP 进行连接，需要两个连接来传送一个文件：控制连接+数据连接</p>
<h4 id="dhcp-动态主机配置协议">DHCP 动态主机配置协议</h4>
<p>由 DHCP 服务器提供配置信息，无需用户手动进行配置。</p>
<p>配置信息包括：IP 地址、子网掩码、网关 IP 地址</p>
<p>DHCP 工作过程：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<h4 id="dns-协议">DNS 协议</h4>
<p>域名 -&gt; ip 地址</p>
<h4 id="电子邮件协议">电子邮件协议</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" alt="img" style="zoom:53%;" />
<p>电子邮件协议包括：SMTP、POP3、IMAP</p>
<ul>
<li>
<p>发送协议：用于将电子邮件从发送服务器发送到接收服务器</p>
<ul>
<li>SMTP 简单邮件传送协议：，但只支持 ASCII 码的邮件主体。为了解决这个问题，增加了 MIME 多用途互联网邮件扩展类型，MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</li>
</ul>
</li>
<li>
<p>读取协议：用于将电子邮件从接收服务器读取到客户端</p>
<ul>
<li>
<p>POP3 邮件读取协议：单向通信，从服务器到客户端。旧版中，用户从服务器读取邮件后，就会把邮件删除，新版中可以不删除邮件。</p>
</li>
<li>
<p>IMAP 网际报文存取协议：双向通信，客户端和服务器上的邮件保持同步，可以同步文件夹、分类等信息。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/v2-dd366f60ce8a2908e36bcc53a57fc615_720w.jpg" alt="img" style="zoom:90%;" />
</li>
</ul>
</li>
</ul>
<h4 id="http-超文本传输协议">HTTP 超文本传输协议</h4>
<p><strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</p>
<p>根据名字我们可以了解到，HTTP 主要用于传输超文本，最常见的就是 html 页面。</p>
<h5 id="url">URL</h5>
<p>全称：统一资源定位符（<strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator），用于定位资源</p>
<p>URL 是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，在 URI 的基础上增加了定位能力</p>
<p>URI 除了包含 URL，还包含 URN（<strong>U</strong>niform <strong>R</strong>esource <strong>N</strong>ame，统一资源名称），用来定义一个资源的名称，但不具备定位该资源的能力。例如，urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img" style="zoom:50%;" />
<h5 id="http-状态码">HTTP 状态码</h5>
<p><strong>1XX 信息</strong></p>
<ul>
<li><strong>100 Continue</strong> ：表明到目前为止一切正常，客户端可以发送后续请求或者忽略这个响应。</li>
</ul>
<p><strong>2XX 成功</strong></p>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容，即，不返回全部实体，只返回部分实体。</li>
</ul>
<p><strong>3XX 重定向</strong></p>
<ul>
<li><strong>300 Multiple Choices</strong></li>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。也就是说，对于 303，重定向时一定使用 GET 方法，对于 301 和 302，理论上不应该改变请求方法，但是一般浏览器都会把请求方法改成 GET。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<p><strong>4XX 客户端错误</strong></p>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
<li><strong>406 Not Acceptable</strong></li>
<li><strong>416 Requested Range Not Satisfiable</strong></li>
</ul>
<p><strong>5XX 服务器错误</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h5 id="连接管理">连接管理</h5>
<p>短连接与长连接：当浏览器访问一个包含多张图片的 HTML 页面时，需要请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>。从 HTTP/1.1 开始默认是长连接的，之前默认是短连接，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</p>
<p>流水线：默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h5 id="cookie">Cookie</h5>
<ul>
<li>概述：HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 数据保存在客户端本地。Cookie 曾一度用于客户端数据的存储，但现在，Cookie 渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</li>
<li>用途：
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li>创建过程：服务器发送的响应报文包含 <strong>Set-Cookie 首部字段</strong>，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 <strong>Cookie 请求首部字段</strong>发送给服务器。</li>
<li>分类：
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。在 Set-Cookie 字段中指定。</li>
</ul>
</li>
<li>作用域：
<ul>
<li>Domain 标识：指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名（如 developer.mozilla.org）中。</li>
<li>Path 标识：指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：/docs、/docs/Web/。</li>
</ul>
</li>
<li>JavaScript：
<ul>
<li>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问<strong>非 HttpOnly 标记</strong>的 Cookie。</li>
<li>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li>
</ul>
</li>
<li>Secure 标识：
<ul>
<li>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。</li>
<li>但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li>
</ul>
</li>
<li>Session：
<ul>
<li>Session 数据存储在服务端</li>
<li>使用过程：将数据存储在服务端，生成唯一 Session ID，将 Session ID 作为 Cookie 传给客户端，客户端之后的每个请求都会带有该 Session ID。</li>
<li>Session ID 安全性问题：应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，避免产生容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li>
<li>若浏览器禁用 Cookie，则需要使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</li>
<li>Cookie VS Session：
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="虚拟主机">虚拟主机</h5>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h5 id="代理">代理</h5>
<p>目的：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>分类：</p>
<ul>
<li>正向代理：用户察觉得到</li>
<li>反向代理：一般位于内部网络中，用户察觉不到</li>
</ul>
<h5 id="https">HTTPS</h5>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>被窃听：使用明文进行通信，内容可能会被窃听；</li>
<li>被伪装：不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>被篡改：无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p>实现方法：</p>
<ul>
<li>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer 安全套接字协议）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</li>
<li>SSL 是一种为网络通信提供安全及数据完整性的一种安全协议，在传输层与应用层之间对网络连接进行加密。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ssl-offloading.jpg" alt="img" style="zoom:50%;" />
<h6 id="加密">加密</h6>
<ul>
<li>
<p>对称密钥加密：加密和解密使用同一密钥，运算速度快，无法安全地将密钥传输给通信方</p>
</li>
<li>
<p>非对称密钥加密：加密和解密使用不同的密钥，运算速度慢，可以更安全地将公开密钥传输给通信发送方，除了用来加密，还可以用来进行签名</p>
<ul>
<li>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220125153836682.png" alt="image-20220125153836682" style="zoom:30%;" />
</li>
</ul>
</li>
<li>
<p>HTTPS 采用的加密方式：混合加密机制</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的密钥，从而保证安全性</li>
<li>获取到密钥后，再使用对称密钥加密方式进行通信，从而保证效率</li>
</ul>
</li>
</ul>
<h6 id="认证">认证</h6>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字签名：用私钥加密过的原文摘要</p>
<p>数字签名：用 CA 私钥加密过的公钥</p>
<p>数字签名生成及验证过程：</p>
<ul>
<li>发送方：通过摘要算法生成原文的摘要，利用自身私钥对摘要进行加密，然后把加密后的摘要以及原文发送给接收方</li>
<li>接收方：通过发送方的公钥对加密后的摘要进行解密，然后计算原文的摘要，与解密后的摘要进行比对，如果一致，则认证通过</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？阮一峰</a></p>
<p><a href="https://blog.csdn.net/yangdiao127/article/details/70478498">证书与签名（二）：数字签名流程与签名认证流程</a></p>
<h6 id="完整性保护">完整性保护</h6>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h6 id="缺点">缺点</h6>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h3 id="综合应用-web-页面请求过程">综合应用-Web 页面请求过程</h3>
<p><strong>概述</strong></p>
<ul>
<li>找网关（DHCP）</li>
<li>根据网关，找目标服务器（DNS）</li>
<li>发送</li>
<li>网关是什么：<a href="https://www.zhihu.com/question/21787311/answer/19316065">网关和路由器的区别是什么？ - 吕小星的回答 - 知乎</a></li>
</ul>
<h4 id="dhcp-配置主机信息">DHCP 配置主机信息</h4>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 协议来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，并将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
</ul>
<h4 id="arp-解析-mac-地址">ARP 解析 MAC 地址</h4>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li></li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<h4 id="dns-解析域名">DNS 解析域名</h4>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<h4 id="http-请求页面">HTTP 请求页面</h4>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。（其实和上面所提到的 ARP 协议一样，知道了 IP 地址后，依旧需要获取 MAC 地址，但是为了避免冗余，这里就不写了）</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
<h3 id="socket-套接字">Socket 套接字</h3>
<h4 id="概述-5">概述</h4>
<p>什么是套接字？答：Socket。</p>
<p>那么，什么是Socket？</p>
<ul>
<li>
<p>它本质上是一组接口，或者说一种抽象。</p>
</li>
<li>
<p>谁的接口？谁的抽象？传输层协议的接口或抽象。</p>
</li>
<li>
<p>它有什么用？应用层协议，通过 Socket 可以与传输层协议进行通信。</p>
</li>
<li>
<p>没有 Socket 行不行？不行，如果没有 Socket，那么传输层的协议就只是一种概念，无法具体使用。</p>
<ul>
<li>
<blockquote>
<p>TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样。<br>
<strong>TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口</strong>。</p>
<p>by https://blog.csdn.net/github_34606293/article/details/78230456</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="io-模型">I/O 模型</h4>
<p>一个 输入操作 通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，</p>
<ul>
<li>第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。</li>
<li>第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ul>
<h5 id="阻塞式-io">阻塞式 I/O</h5>
<p>应用进程被阻塞，直到数据从 内核缓冲区 复制到 应用进程缓冲区 中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，<strong>这种模型的 CPU 利用率会比较高</strong>。</p>
<p>注意看图，可以加深理解</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492928416812_4.png" alt="img" style="zoom:80%;" />
<h5 id="非阻塞式-io">非阻塞式 I/O</h5>
<p>应用进程执行 recvfrom 之后，如果数据未准备好，则内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知数据是否准备好，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929000361_5.png" alt="img" style="zoom:80%;" />
<h5 id="io-复用selectpollepoll">I/O 复用（select/poll/epoll）</h5>
<p>使用 select, poll 或 epoll 等待数据，可以同时等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>I/O 复用使得单个进程可以同时处理多个 I/O 事件。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么对于每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929444818_6.png" alt="img" style="zoom:80%;" />
<h5 id="信号驱动式-iosigio">信号驱动式 I/O（SIGIO）</h5>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492929553651_7.png" alt="img" style="zoom:80%;" />
<h5 id="异步-ioaio">异步 I/O（AIO）</h5>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。（看图更清晰）</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492930243286_8.png" alt="img" style="zoom:80%;" />
<h5 id="5-种-io-的比较">5 种 I/O 的比较</h5>
<p>这一节主要讨论同步/异步、阻塞/非阻塞的问题，参考：https://www.zhihu.com/question/19732473</p>
<p>首先讲概念</p>
<ul>
<li>同步与异步：主要看调用结果是如何返回的。如果调用结果是由调用者主动等待得到的，那么就算是<strong>同步</strong>；如果调用结果最终是由被调用者主动通知调用者的（比如通过回调函数），那就就算<strong>异步</strong>。</li>
<li>阻塞与非阻塞：主要看等待结果过程中，调用者的状态。如果等待过程中，调用者啥事都不做，那就是<strong>阻塞</strong>；如果等待过程中，调用者做了别的事，那就是<strong>非阻塞</strong>。</li>
</ul>
<p>分类：</p>
<ul>
<li>阻塞式 I/O：同步 阻塞</li>
<li>非阻塞式 I/O：同步 第一阶段非阻塞 第二阶段阻塞</li>
<li>I/O 复用：同步 阻塞</li>
<li>信号驱动式 I/O：第一阶段异步非阻塞 第二阶段同步阻塞</li>
<li>异步 I/O：异步 非阻塞</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1492928105791_3.png" alt="img" style="zoom:80%;" />
<h4 id="io-复用">I/O 复用</h4>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h5 id="select-vs-poll">select vs poll</h5>
<ul>
<li>select 和 poll 都可以允许应用程序监听一组文件描述符的状态变化</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
<ul>
<li>有可能函数调用会立即返回</li>
<li>也有可能，会持续监听，超时返回</li>
<li>也有可能，会返回成功，但是读取时报错</li>
</ul>
</li>
<li>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从 应用进程缓冲区 复制到 内核缓冲区（因为 select 和 poll 是系统调用，所以需要将数据拷贝到内核）（<a href="https://bbs.csdn.net/topics/390696333">参考资料</a>）</li>
<li>几乎所有系统都支持 select，部分系统不支持 poll。</li>
</ul>
<h5 id="epoll">epoll</h5>
<p><code>epoll_create()</code> 用于创建 epoll 对象</p>
<p><code>epoll_ctl()</code> 用于向内核注册新的描述符或者是改变某个文件描述符的监听事件</p>
<p><code>epoll_wait()</code> 用于得到事件完成的描述符</p>
<p>已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数，内核会将 I/O 准备好的描述符加入到一个链表中进行管理，等待 <code>epoll_wait()</code> 的调用</p>
<p>从上面的描述可以看出</p>
<ul>
<li>epoll 只需要将描述符从 进程缓冲区 向 内核缓冲区 拷贝一次（select 和 poll 需要再拷贝出来，然后通过遍历获取事件完成的描述符，而 epoll 只需要通过 <code>epoll_wait()</code> 直接获取事件完成的描述符）</li>
<li>并且进程不需要通过轮询来获得事件完成的描述符（<code>epoll_wait()</code>）</li>
</ul>
<p>epoll 仅适用于 Linux OS</p>
<p>epoll 和 poll 一样，没有描述符数量限制</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况（当文件描述符关闭，就会从监听列表中删除）</p>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_27529917/article/details/82945450">Select和Epoll底层实现的区别</a></li>
<li><a href="https://blog.csdn.net/xiaowenmu1/article/details/90108663">epoll在多线程下的使用</a></li>
</ul>
<h5 id="selectpollepoll-的应用场景">select/poll/epoll 的应用场景</h5>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<ul>
<li>select：
<ul>
<li>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</li>
<li>select 可移植性更好，几乎被所有主流平台所支持。</li>
</ul>
</li>
<li>poll：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li>
<li>epoll：
<ul>
<li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接（因为对于 epoll，描述符是存储在内核中的，所以如果是长连接，就可以一直让内核进行监听）</li>
<li>需要监听的描述符对应的监听事件变化多，而且都非常短暂，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的监听事件改变都需要通过 <code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</li>
</ul>
</li>
</ul>
<h2 id="操作系统">操作系统</h2>
<h3 id="概述-6">概述</h3>
<p>4 个基本特征：并发、共享、虚拟、异步</p>
<p>并发 与 并行：</p>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<p>用户态与内核态：如果一个进程在用户态需要使用内核态的功能，就需要进行系统调用从而陷入内核，由操作系统代为完成相应功能。</p>
<h3 id="进程管理">进程管理</h3>
<h4 id="进程-vs-线程">进程 VS 线程</h4>
<ul>
<li>进程：资源分配的基本单位</li>
<li>线程：独立调度的基本单位</li>
<li>区别与联系
<ul>
<li>一个 进程 中可以有多个 线程，它们共享 进程 资源</li>
<li>线程 不拥有资源，但可以访问 隶属进程 的资源</li>
<li>进程 和 线程 都可被调度，隶属不同进程的线程的切换会引起进程切换</li>
<li>开销不同：
<ul>
<li>进程：
<ul>
<li>创建或撤销：分配或回收资源，如内存空间、I/O 设备等</li>
<li>切换：当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置</li>
</ul>
</li>
<li>线程：
<ul>
<li>切换：只需保存和设置少量寄存器内容</li>
</ul>
</li>
</ul>
</li>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助特定的方法（进程间通信，IPC）</li>
</ul>
</li>
</ul>
<h4 id="进程状态">进程状态</h4>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待除 CPU 时间以外的资源</li>
</ul>
<h4 id="进程调度算法">进程调度算法</h4>
<p>不同系统的调度算法目标不同，因此需要针对不同系统来讨论调度算法</p>
<h5 id="批处理系统">批处理系统</h5>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 最短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死（处于一直等待短作业执行完毕的状态）：因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的<strong>抢占式</strong>版本，按剩余运行时间的顺序进行调度。</p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h5 id="交互式系统">交互式系统</h5>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系。</p>
<p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上层队列没有进程在排队，才能调度下层队列上的进程。</p>
<p>可以将这种调度算法看成是 时间片轮转调度算法和优先级调度算法的结合。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" style="zoom:80%;" />
<h5 id="实时系统">实时系统</h5>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时：</p>
<ul>
<li>硬实时：必须满足绝对的截止时间</li>
<li>软实时：可以容忍一定的超时</li>
</ul>
<h4 id="进程同步">进程同步</h4>
<h5 id="临界资源与临界区">临界资源与临界区</h5>
<p>临界资源：一次只能供一个进程使用的资源</p>
<p>对临界资源进行访问的那段代码称为临界区</p>
<h5 id="互斥-同步与通信">互斥、同步与通信</h5>
<p>进程通信的详细内容看后续章节，这里只是先简单描述一下它们之间在概念上的异同</p>
<ul>
<li>互斥：解决进程间竞争关系（间接制约关系）的手段
<ul>
<li>互斥比较好理解，就是解决进程间的竞争，最典型的例子就是对资源的进程，如临界资源</li>
</ul>
</li>
<li>同步：解决进程间协作关系（直接制约关系）的手段
<ul>
<li>进程间有时需要合作完成某项任务，当某个进程提前完成后，需要等待其他进程完成才能继续，此时就需要进程同步来解决这个问题。也就是说，进程同步解决的是，进程间执行顺序的问题。</li>
<li>互斥也可以看做是一种进程同步，通过资源的竞争，使得两个进程间产生了先后关系，即进程 A 必须等待进程 B 执行完才能继续。</li>
</ul>
</li>
<li>通信：进程间互相发送数据
<ul>
<li>进程同步也可以看做是一种进程通信，但是进程同步往往是在进程间发送信号，而不是实际的数据</li>
<li>进程通信是一种手段，而进程同步是一种目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</li>
</ul>
</li>
</ul>
<p>参考：https://blog.csdn.net/weixin_41413441/article/details/80548683</p>
<h5 id="信号量">信号量</h5>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<h5 id="管程">管程</h5>
<p>也是一种解决进程同步的技术</p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>它的思想是，将共享变量以及对其的操作封装起来，并且保证同一时刻只有一个进程可以进入管程</p>
<p>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对<strong>条件变量</strong>执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。对<strong>条件变量</strong>执行 signal() 操作会唤醒被阻塞的进程。</p>
<p>参考：https://www.cnblogs.com/xidongyu/p/10891303.html</p>
<p>可以看“生产者-消费者问题”中管程的实现加深对管程的理解</p>
<h5 id="经典进程同步问题">经典进程同步问题</h5>
<h6 id="生产者-消费者问题">生产者-消费者问题</h6>
<p>问题描述：使用一个缓冲区来保存物品，缓冲区容量为 N，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p><strong>使用 信号量 实现</strong></p>
<p>以下 3 段话用于帮助理解代码，基础好的同学也可直接看代码进行理解。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 <code>down(mutex)</code> 再执行 <code>down(empty)</code>。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 <code>down(empty)</code> 操作，发现 <code>empty = 0</code>，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 <code>up(empty)</code> 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<pre><code class="language-c++">#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        // produce_item
        down(empty);
        // 临界区开始
        down(mutex);
        // insert item to 缓冲区（临界资源）
        up(mutex);
        // 临界区结束
        up(full);
    }
}

void consumer() {
    while(TRUE) {
        down(full);
        // 临界区开始
        down(mutex);
        // get item from 缓冲区（临界资源）
        // consume_item
        up(mutex);
        // 临界区结束
        up(empty);
    }
}
</code></pre>
<p><strong>使用 管程 实现</strong></p>
<pre><code class="language-pascal">// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        // produce_item
        ProducerConsumer.insert();
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        ProducerConsumer.remove();
        // consume_item
    end
end;
</code></pre>
<h6 id="哲学家进餐问题">哲学家进餐问题</h6>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt="img" style="zoom:80%;" />
<p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p><strong>错误解法：</strong></p>
<p>如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<pre><code class="language-c++">#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
</code></pre>
<p><strong>信号量：</strong></p>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<p>代码的讲解，建议搭配代码一起看：</p>
<ul>
<li>首先，通过 mutex 保证临界资源 state 数组同一时刻只有一个进程可以访问</li>
<li>在这个前提下，就可以根据 state 数组的状态来进行后续的操作</li>
<li>对于每个哲学家，在 eat() 之前都需要 down()，而在 down() 之前会判断左右两边的 state 数组
<ul>
<li>如果左右两边的哲学家都不是 EATING 的状态，则会 up() 并将自身状态设置成 EATING</li>
<li>如果左右两边的哲学家存在 EATING 的状态，则不会进行任何操作，在 down() 时等待身边的哲学家吃完</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#define N 5
typedef int semaphore;

int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界资源是 state 数组，对其修改需要互斥

semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        // think
        take_two(i);
        // eat
        put_two(i);
    }
}

void take_two(int i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = HUNGRY;
    check(i);
    up(mutex);
    // state 的临界区 结束
    down(s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    // state 的临界区 开始
    down(mutex);
    state[i] = THINKING;
    // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(LEFT);
    check(RIGHT);
    up(mutex);
    // state 的临界区 结束
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(s[i])，使得 down(s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) {
        state[i] = EATING;
        up(s[i]);
    }
}
</code></pre>
<h6 id="读者-写者问题">读者-写者问题</h6>
<p>问题描述：允许多个进程同时对数据进行读操作，但是不允许 读和写 以及 写和写 操作同时发生。</p>
<p><strong>使用信号量实现：</strong></p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code class="language-c++">typedef int semaphore;
semaphore count_mutex = 1;
int count = 0;

semaphore data_mutex = 1;

void reader() {
    while(TRUE) {
        down(count_mutex);
        count++;
        if(count == 1) down(data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(count_mutex);
        // read
        down(count_mutex);
        count--;
        if(count == 0) up(data_mutex);
        up(count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(data_mutex);
        // write
        up(data_mutex);
    }
}
</code></pre>
<h4 id="进程通信-ipc">进程通信 IPC</h4>
<p>进程通信 与 进程同步 之间的关系，可以见上文“互斥、同步与通信”</p>
<p><strong>管道</strong></p>
<p>管道是通过调用 pipe 函数创建的，filedes[0] 用于读，filedes[1] 用于写。</p>
<p>由 pipe 函数为 filedes 数组进行赋值，之后，可以通过 read write 函数进行读写</p>
<pre><code class="language-c++">#include &lt;unistd.h&gt;

int filedes[2];
pipe( filedes );

read( filedes[0], buf, sizeof(buf) );
write( filedes[1], s, sizeof(s) );
</code></pre>
<p>缺点：</p>
<ul>
<li>
<p>只支持半双工通信（单向交替传输）</p>
</li>
<li>
<p>只能在父子进程或者兄弟进程中使用</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="img" style="zoom:70%;" />
</li>
</ul>
<p><strong>FIFO</strong></p>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<p>之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。</p>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="img" style="zoom:65%;" />
<p><strong>消息队列</strong></p>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<p><strong>信号量</strong></p>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<p><strong>共享存储</strong></p>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。</p>
<p>共享内存使用的不是文件，而是内存的匿名段。</p>
<p><strong>套接字</strong></p>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信</p>
<h3 id="死锁">死锁</h3>
<h4 id="必要条件">必要条件</h4>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h4 id="处理方法">处理方法</h4>
<h5 id="鸵鸟策略">鸵鸟策略</h5>
<p>方法：把头埋在沙子里，假装根本没发生问题。</p>
<p>原理：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>适用场景：当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h5 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h5>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复</p>
<p><strong>每种类型的资源只有一个的死锁检测</strong></p>
<p>即，对于每种类型的资源，被使用了，别的进程就不能再使用了</p>
<p>有向图判环：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" alt="img" style="zoom:80%;" />
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b 所示，它满足了环路等待条件，因此会发生死锁。</p>
<p>该死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<p><strong>每种类型的资源有多个的死锁检测</strong></p>
<p>即，对于每种类型的资源，存在多个，被进程 A 使用了 1 个后，还有其他实例可以供其他进程使用</p>
<p>银行家算法：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt="img" style="zoom:90%;" />
<p>上图中，有 3 个进程 4 个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，算法执行过程对进程进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<p><strong>死锁恢复</strong></p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复
<ul>
<li>假设进程 A 等待资源，进程 B 占用该资源，则对进程 B 进行回滚并将资源分配给进程 A，从而实现死锁恢复。参考：https://blog.csdn.net/zhangxiaojiakele/article/details/106034016</li>
</ul>
</li>
<li>通过杀死进程恢复</li>
</ul>
<h5 id="死锁预防">死锁预防</h5>
<p>在程序运行之前预防发生死锁</p>
<p>破坏 死锁 发生的必要条件</p>
<p><strong>破坏互斥条件</strong></p>
<p>例如，“假脱机打印机技术”允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程</p>
<p><strong>破坏占有和等待条件</strong></p>
<p>一种实现方式是，规定所有进程在开始执行前请求所需要的全部资源</p>
<p><strong>破坏不可抢占条件</strong></p>
<p><strong>破坏环路等待</strong></p>
<p>给资源统一编号，进程只能按编号顺序来请求资源</p>
<h5 id="死锁避免">死锁避免</h5>
<p>在程序运行时避免发生死锁</p>
<p>在为进程分配资源前进行检查，如果发现此次资源分配将导致死锁，则拒绝给该进程分配资源</p>
<p>安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img" style="zoom:80%;" />
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>死锁避免，就是避免进入不安全状态。</p>
<p>使用 银行家算法 判断某状态是否为 安全状态</p>
<h5 id="检测-vs-预防-vs-避免">检测 VS 预防 VS 避免</h5>
<p>检测，是判断当前状态是否发生了死锁</p>
<p>预防，是不给死锁发生的机会</p>
<p>避免，是死锁可能发生，但是避免其发生，例如，避免进入不安全状态。</p>
<h3 id="内存管理">内存管理</h3>
<h4 id="分页机制">分页机制</h4>
<p>通过 分页机制 可以实现 虚拟内存</p>
<p>虚拟内存的目的是为了将物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p>
<p>为了更好的管理内存，操作系统将内存抽象成若干地址空间。同时，地址空间又被分割成多个块，每一块称为一页，因此每页中都包含若干地址空间。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的操作，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许操作系统不用将地址空间中的每一页都映射到物理内存，也就是说一个程序所使用的所有页不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img" style="zoom:90%;" />
<p>例如，有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，因此，通过 虚拟内存技术 便可以在该计算机运行一个 64K 大小的程序。</p>
<p>分页内存管理机制，对于程序来说是透明的，对于程序来说，它只知道地址空间是 0~64K，但其实物理内存空间只有 32KB，在运行过程中，是通过操作系统进行控制的，使得程序感觉上就像在 64KB 的物理内存上运行。</p>
<h5 id="分页系统的地址映射">分页系统的地址映射</h5>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中，页表存储着页（地址空间）和页框（物理内存）的映射表。</p>
<p>一个虚拟地址空间分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>根据页面号，可以定位到页表中的特定行，然后从该行中获取物理内存地址前缀，与偏移量合并，得到物理内存地址。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img" style="zoom:70%;" />
<p>上图的页表存放着 16 个页（16行），这 16 个页需要用 4 个比特位来进行索引定位（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2^4=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>）。</p>
<p>例如，对于虚拟地址（0010 000000000100）</p>
<ul>
<li>根据前 4 位（0010）得知页面号为2，从页表第 2 行读取内容：110 1，其中，前 3 位为物理内存地址前缀，第 4 位表示是否存在于内存中，1 表示存在。</li>
<li>后 12 位存储偏移量，结合刚才的物理内存地址前缀（110），这个页对应的页框的地址为 （110 000000000100）。</li>
</ul>
<h5 id="页面置换算法">页面置换算法</h5>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<p><strong>最佳 OPT Optimal replacement algorithm</strong></p>
<p>选择最长时间不再被访问的页面，将其置换。因为是最长时间不被访问的页面，所以可以保证获得最低的缺页率</p>
<p>这是一种理论算法，无法实现，因为无法获知哪个页面在未来最长时间不被访问</p>
<p>举例：</p>
<p>系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<pre><code class="language-html">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为站在上帝视角，我们知道页面 7 再次被访问的时间最长。</p>
<p><strong>最近最久未使用 LRU Least Recently Used</strong></p>
<p>虽然无法知道未来页面的使用情况，但是可以知道过去页面的使用情况。</p>
<p>LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<p><strong>最近未使用 NRU Not Recently Used</strong></p>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。</p>
<p>其中 R 位会定时被清零。</p>
<p>将页面分成以下四<strong>类</strong>：</p>
<ul>
<li>0：R=0，M=0</li>
<li>1：R=0，M=1</li>
<li>2：R=1，M=0</li>
<li>3：R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从<strong>类</strong>编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<p><strong>先进先出 FIFO First In First Out</strong></p>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<p><strong>第二次机会算法</strong></p>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改。</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<p><strong>时钟 Clock</strong></p>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img" style="zoom:80%;" />
<h4 id="分段机制">分段机制</h4>
<p>现在，请先忘掉分页机制，分段机制是一种独立的机制，和分页机制无关。</p>
<p>分段机制的设计思想是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</p>
<p>一般情况下，程序在运行时都会在内存中存储程序代码和数据，存储程序代码是为了能让程序执行下去（总要把下一行要执行的代码放到内存中吧，不然系统哪知道应该做什么）</p>
<p>基于这个现象，操作系统内存管理分段机制允许程序拥有多个段，在不同段中存储不同类型的数据，且段的大小是可变的。程序无需知道段在物理内存中的位置，只需要使用段偏移量进行访问即可，在程序运行时，操作系统会把段映射到实际的内存空间中。例如，段偏移量是 0000~0100，那么程序实际运行时，会把段映射到 xxxx0000~xxxx0100</p>
<p>因此，分段机制中是不涉及虚拟内存的</p>
<h4 id="分页-vs-分段">分页 VS 分段</h4>
<ul>
<li>空间大小是否可变：分页机制不可变；分段机制可变
<ul>
<li>分页存在覆盖问题：假设页的长度是100，那么程序在访问到 xxx101 时就会出错（xxx为页面号；为了方便，用的是十进制），因为根据地址映射，会把页面号进行替换，得到物理内存地址，但是因为页的长度是 100，所以其实本质上已经访问到下一页了，就会出现覆盖问题。</li>
</ul>
</li>
<li>透明性：分页对程序是透明的，分段是不透明的</li>
<li>目的：
<ul>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间</li>
<li>分段主要为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</li>
</ul>
</li>
</ul>
<h4 id="段页式">段页式</h4>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2019040522291138.png" alt="img" style="zoom:100%;" />
<p>根据段号和段表，获取页表，根据页号和页表，获取物理内存空间前缀，最后根据页内偏移计算出物理地址。</p>
<p>一个程序拥有多个段，每个段包含多个页，每个页会被映射到物理内存</p>
<h3 id="用户态与内核态">用户态与内核态</h3>
<p>首先明确概念，用户态和内核态指的是什么？指的是，cpu 所处的状态。若 cpu 处于用户态，那么程序只能访问其自身所拥有的内存空间，不允许访问外围设备，不能强占 cpu 资源，而如果 cpu 处于内核态，则程序可以访问内存的所有数据，可以访问外围设备，可以控制 cpu 切换进程。</p>
<p>可以发现，若 cpu 处于内核态，程序的权限将变得无限高，因此，只有在发生 系统调用 时，cpu 才会从用户态切换到内核态，并且切换到内核态后，cpu 只会执行系统函数，并在执行结束后把结果返回给程序。</p>
<p>https://www.cnblogs.com/maxigang/p/9041080.html</p>
<h3 id="磁盘">磁盘</h3>
<h4 id="磁盘结构">磁盘结构</h4>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/014fbc4d-d873-4a12-b160-867ddaed9807.jpg" alt="img" style="zoom:80%;" />
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<h4 id="磁盘调度算法">磁盘调度算法</h4>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间：主轴转动盘面，使得磁头移动到适当的扇区上</li>
<li><strong>寻道时间</strong>：制动手臂移动，使得磁头移动到适当的磁道上</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，<strong>寻道时间</strong>最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<p><strong>先来先服务 FCFS First Come First Served</strong></p>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。</p>
<p>缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<p><strong>最短寻道时间优先 SSTF Shortest Seek Time First</strong></p>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="img" style="zoom:50%;" />
<p><strong>电梯算法 SCAN</strong></p>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="img" style="zoom:50%;" />
<h3 id="链接">链接</h3>
<h4 id="链接系统">链接系统</h4>
<p>以下是一个 hello.c 程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello, world\n&quot;);
    return 0;
}
</code></pre>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<pre><code class="language-shell">gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" alt="img" style="zoom:80%;" />
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<p>目标文件：</p>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h4 id="静态链接">静态链接</h4>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg" alt="img" style="zoom:80%;" />
<h4 id="动态链接">动态链接</h4>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg" alt="img" style="zoom:80%;" />
<h2 id="linux">Linux</h2>
<h3 id="前言">前言</h3>
<p>面试重点：</p>
<ul>
<li>指令：cat（文件）、grep（查找指令）、cut（管道指令）
<ul>
<li>括号中标出来这些指令所在的章节</li>
</ul>
</li>
<li>文件：实体链接与符号链接</li>
<li>进程管理：SIGCHLD、僵尸进程与孤儿进程</li>
</ul>
<h3 id="常用指令">常用指令</h3>
<p><strong>快捷键</strong></p>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<p><strong>查询指令用法</strong></p>
<p>/usr/share/doc 目录中存放着大部分软件的一整套说明文件</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145459251.png" alt="image-20220104145459251" style="zoom:40%;" />
<p><code>--help</code></p>
<p>指令的基本用法与选项介绍</p>
<p><code>man</code></p>
<p>man 是 manual 的缩写，将指令的具体信息显示出来</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104145001620.png" alt="image-20220104145001620" style="zoom:50%;" />
<p>当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型</p>
<p>常用的数字及其类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">代号</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>配置文件</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody>
</table>
<p><code>info</code></p>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转</p>
<p><strong>关机</strong></p>
<p><code>who</code></p>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线</p>
<p><code>sync</code></p>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作</p>
<p><code>shutdown</code></p>
<pre><code class="language-html">## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
</code></pre>
<p><strong>环境变量 PATH</strong></p>
<p>可以在环境变量 PATH 中声明可执行文件的路径</p>
<p>路径之间用 <code>:</code> 分隔</p>
<p><strong>sudo</strong></p>
<p>sudo 允许一般用户使用 root 可执行的命令</p>
<p>不过只有在 <code>/etc/sudoers</code> 配置文件中添加的用户才能使用该指令</p>
<h3 id="vim-的三个模式">Vim 的三个模式</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191209002818626.png" alt="img" style="zoom:50%;" />
<ul>
<li>一般指令模式：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式：按下 &quot;i&quot; 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式：按下 &quot;:&quot; 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在 指令列模式 下，有以下命令用于离开或者保存文件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">:w!</td>
<td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">离开</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">强制离开不保存</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">写入磁盘后离开</td>
</tr>
<tr>
<td style="text-align:center">:wq!</td>
<td style="text-align:center">强制写入磁盘后离开</td>
</tr>
</tbody>
</table>
<h3 id="文件系统理论部分">文件系统（理论部分）</h3>
<h4 id="组成">组成</h4>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<h4 id="文件读取">文件读取</h4>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" alt="img" style="zoom:50%;" />
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" alt="img" style="zoom:60%;" />
<h4 id="磁盘碎片">磁盘碎片</h4>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h4 id="block">block</h4>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">大小</th>
<th style="text-align:center">1KB</th>
<th style="text-align:center">2KB</th>
<th style="text-align:center">4KB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最大单一文件</td>
<td style="text-align:center">16GB</td>
<td style="text-align:center">256GB</td>
<td style="text-align:center">2TB</td>
</tr>
<tr>
<td style="text-align:center">最大文件系统</td>
<td style="text-align:center">2TB</td>
<td style="text-align:center">8TB</td>
<td style="text-align:center">16TB</td>
</tr>
</tbody>
</table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h4 id="inode">inode</h4>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID...；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<h4 id="目录">目录</h4>
<p>目录，也可以理解成文件夹</p>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root)：根目录</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/linux-filesystem.png" alt="img" style="zoom:80%;" />
<h3 id="文件实践部分">文件（实践部分）</h3>
<h4 id="文件属性">文件属性</h4>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间可使用 stat 指令查看</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220104155901036.png" alt="image-20220104155901036" style="zoom:50%;" />
<p>三种文件时间：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h4 id="文件与目录的基本操作指令">文件与目录的基本操作指令</h4>
<p>本节主要列出了 8 个基本操作指令，已经掌握的同学可直接跳过</p>
<p><strong>1. ls</strong></p>
<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<pre><code class="language-html">## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
</code></pre>
<p><strong>2. cd</strong></p>
<p>更换当前目录。</p>
<pre><code class="language-text">cd [相对路径或绝对路径]
</code></pre>
<p><strong>3. mkdir</strong></p>
<p>创建目录。</p>
<pre><code class="language-text">## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
</code></pre>
<p><strong>4. rmdir</strong></p>
<p>删除目录，目录必须为空。</p>
<pre><code class="language-html">rmdir [-p] 目录名称
-p ：递归删除目录
</code></pre>
<p><strong>5. touch</strong></p>
<p>更新文件时间或者建立新文件。</p>
<pre><code class="language-html">## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
</code></pre>
<p><strong>6. cp</strong></p>
<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<pre><code class="language-html">cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
</code></pre>
<p><strong>7. rm</strong></p>
<p>删除文件。</p>
<pre><code class="language-html">## rm [-fir] 文件或目录
-r ：递归删除
</code></pre>
<p><strong>8. mv</strong></p>
<p>移动文件。</p>
<pre><code class="language-html">## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
</code></pre>
<h4 id="权限">权限</h4>
<h5 id="修改权限">修改权限</h5>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<pre><code class="language-html">## chmod [-R] xyz dirname/filename
</code></pre>
<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。</p>
<pre><code class="language-html">## chmod 754 .bashrc
</code></pre>
<p>也可以使用符号来设定权限。</p>
<pre><code class="language-html">## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
</code></pre>
<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<pre><code class="language-html">## chmod a+w .bashrc
</code></pre>
<h5 id="默认权限">默认权限</h5>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。</p>
<h5 id="目录的权限">目录的权限</h5>
<p>文件名不是存储在一个文件的内容中，而是存储在该文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h4 id="实体链接-vs-符号链接">实体链接 VS 符号链接</h4>
<p><strong>指令</strong></p>
<pre><code class="language-html">## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
</code></pre>
<p><strong>概念</strong></p>
<p>实体链接，也叫，硬链接</p>
<p>符号链接，也叫，软连接</p>
<p>两者关系如图：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" alt="img" style="zoom:50%;" />
<p>如果不理解，可继续看下面的解析。</p>
<p><strong>实体链接</strong></p>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<pre><code class="language-html">## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</code></pre>
<p><strong>为什么不能对目录创建实体链接</strong>？</p>
<p>因为，目录是支持 <code>cd ../</code> 操作的，因此，如果像文件那样，只是在目录中添加 inode 编号，那么带来的问题就是，在实体链接目录 /d1/d2 中执行 <code>cd ../</code> 可能会跳转到 /d3 中，也就是说，会发现目录错位的现象。为了解决这个问题，那就需要真正创建一个目录，并在目录中为每个文件创建实体链接，但是这样的成本太高了，因此 操作系统禁止用户这么做。</p>
<blockquote>
<p>举例来说，如果你要将 /etc 使用硬链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下的所有文件名同时都与 /etc 下面的文件名要创建硬链接的，而不是仅仅连接到 /etc 和 /etc_hd 而已。并且，将来如果需要在 /etc_hd 目录下创建新文件时，连带的，/etc 下面的数据又得要创建一次硬链接。因此造成环境相当大的复杂度，所以是不支持链接目录的。</p>
<p>by 鸟哥</p>
</blockquote>
<p>其实，Linux 中是存在目录的实体链接的，比如，<code>.</code> 和 <code>..</code>，但是 Linux 不允许用户创建实体链接。</p>
<p><strong>符号链接</strong></p>
<p>符号链接保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<pre><code class="language-html">## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab
</code></pre>
<h4 id="7-个获取文件内容指令">7 个获取文件内容指令</h4>
<p><strong>1. cat</strong></p>
<p>取得文件内容。</p>
<pre><code class="language-html">## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
</code></pre>
<p><strong>2. tac</strong></p>
<p>是 cat 的反向操作，从最后一行开始打印。</p>
<p><strong>3. more</strong></p>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<p><strong>4. less</strong></p>
<p>和 more 类似，但是多了一个向前翻页的功能。</p>
<p><strong>5. head</strong></p>
<p>取得文件前几行。</p>
<pre><code class="language-html">## head [-n number] filename
-n ：后面接数字，代表显示几行的意思
</code></pre>
<p><strong>6. tail</strong></p>
<p>是 head 的反向操作，只是取得是后几行。</p>
<p><strong>7. od</strong></p>
<p>以字符或者十六进制的形式显示二进制文件。</p>
<h4 id="4-个搜索指令">4 个搜索指令</h4>
<p><strong>1. which</strong></p>
<p>指令搜索。</p>
<pre><code class="language-html">## which [-a] command
-a ：将所有指令列出，而不是只列第一个
</code></pre>
<p><strong>2. whereis</strong></p>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<pre><code class="language-html">## whereis [-bmsu] dirname/filename
</code></pre>
<p><strong>3. locate</strong></p>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<pre><code class="language-html">## locate [-ir] keyword
-r：正则表达式
</code></pre>
<p><strong>4. find</strong></p>
<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<pre><code class="language-html">## find [basedir] [option]
example: find . -name &quot;shadow*&quot;
</code></pre>
<p><strong>① 与时间有关的选项</strong></p>
<pre><code class="language-html">-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
</code></pre>
<p>+4、4 和 -4 的指示的时间范围如下：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/658fc5e7-79c0-4247-9445-d69bf194c539.png" alt="img" loading="lazy"></figure>
<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>
<pre><code class="language-html">-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
</code></pre>
<p><strong>③ 与文件权限和名称有关的选项</strong></p>
<pre><code class="language-html">-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
</code></pre>
<h3 id="压缩与打包">压缩与打包</h3>
<h4 id="压缩文件名">压缩文件名</h4>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody>
</table>
<h4 id="3-个压缩指令">3 个压缩指令</h4>
<p><strong>1. gzip</strong></p>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<pre><code class="language-html">$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
</code></pre>
<p><strong>2. bzip2</strong></p>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<pre><code class="language-html">$ bzip2 [-cdkzv#] filename
-k ：保留源文件
</code></pre>
<p><strong>3. xz</strong></p>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<pre><code class="language-html">$ xz [-dtlkc#] filename
</code></pre>
<h4 id="打包指令">打包指令</h4>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
<pre><code class="language-html">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td style="text-align:center">查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td style="text-align:center">解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody>
</table>
<h3 id="bash">Bash</h3>
<h4 id="概念">概念</h4>
<p>Bash 是 Shell 的一种</p>
<p>Shell 指的是一类程序，通过 Shell 程序，可以把我们的命令传递给内核，从而调用计算机硬件执行相关的操作，之后再把执行结果翻译成自然语言，呈现在我们面前。</p>
<p>Bash 是当前大多数 Linux 发行版的默认Shell</p>
<h4 id="特性">特性</h4>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h4 id="变量操作">变量操作</h4>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<pre><code class="language-bash">$ x=abc
$ echo $x
$ echo ${x}
</code></pre>
<p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=&quot;lang is $LANG&quot;，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG'，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<pre><code class="language-html">$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
</code></pre>
<p>使用 [ ] 来对数组进行索引操作：</p>
<pre><code class="language-bash">$ array[1]=a
$ array[2]=b
$ echo ${array[1]}
</code></pre>
<h4 id="指令搜索顺序">指令搜索顺序</h4>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h4 id="数据流重定向">数据流重定向</h4>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准输入 (stdin)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td style="text-align:center">标准输出 (stdout)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td style="text-align:center">标准错误输出 (stderr)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody>
</table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而 有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<pre><code class="language-bash">$ find /home -name .bashrc &gt; list 2&gt;&amp;1
</code></pre>
<h3 id="管道指令">管道指令</h3>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<pre><code class="language-bash">$ ls -al /etc | less
</code></pre>
<p><strong>提取指令 cut</strong></p>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<pre><code class="language-html">$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
</code></pre>
<p>示例 1：last 显示登入者的信息，取出用户名。</p>
<pre><code class="language-html">$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d ' ' -f 1
</code></pre>
<p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<pre><code class="language-html">$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dmtsai&quot;
declare -x HOSTNAME=&quot;study.centos.vbird&quot;
.....(其他省略).....

$ export | cut -c 12-
</code></pre>
<p><strong>排序指令 sort</strong></p>
<p>sort 用于排序。</p>
<pre><code class="language-html">$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
</code></pre>
<p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<pre><code class="language-html">$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
</code></pre>
<p><strong>去重指令 uniq</strong></p>
<p>uniq 可以将重复的数据只取一个。</p>
<pre><code class="language-html">$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
</code></pre>
<p>示例：取得每个人的登录总次数</p>
<pre><code class="language-html">$ last | cut -d ' ' -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
</code></pre>
<p><strong>双向输出重定向指令 tee</strong></p>
<p>输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<pre><code class="language-html">$ tee [-a] file
</code></pre>
<p><strong>5 个字符转换指令</strong></p>
<p><code>tr</code> 用来删除一行中的字符，或者对字符进行替换。</p>
<pre><code class="language-html">$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
</code></pre>
<p>示例，将 last 输出的信息所有小写转换为大写。</p>
<pre><code class="language-html">$ last | tr '[a-z]' '[A-Z]'
</code></pre>
<p><code>col</code> 将 tab 字符转为空格字符。</p>
<pre><code class="language-html">$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
</code></pre>
<p><code>expand</code> 将 tab 转换一定数量的空格，默认是 8 个。</p>
<pre><code class="language-html">$ expand [-t] file
-t ：tab 转为空格的数量
</code></pre>
<p><code>join</code> 将有相同数据的那一行合并在一起。</p>
<pre><code class="language-html">$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
</code></pre>
<p><code>paste</code> 直接将两行粘贴在一起。</p>
<pre><code class="language-html">$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
</code></pre>
<p><strong>分区指令 split</strong></p>
<p>split 将一个文件划分成多个文件。</p>
<pre><code class="language-html">$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
</code></pre>
<h3 id="查找指令-grep">查找指令 grep</h3>
<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<pre><code class="language-html">$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre>
<p>示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<pre><code class="language-html">$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &quot;glad&quot;.
18:google is the best tools for search keyword
</code></pre>
<p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p>
<pre><code class="language-html">$ grep -n 'a\{2,5\}' regular_express.txt
</code></pre>
<h3 id="2-个格式化输出指令">2 个格式化输出指令</h3>
<p><strong>printf</strong></p>
<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<pre><code class="language-html">$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</code></pre>
<p><strong>awk</strong></p>
<p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p>
<pre><code class="language-html">$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
$ last -n 5 | awk '{print $1 &quot;\t&quot; $3}'
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri
</code></pre>
<p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<pre><code class="language-html">$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename
</code></pre>
<p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<pre><code class="language-text">$ cat /etc/passwd | awk 'BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t &quot; $3}'
root 0
bin 1
daemon 2
</code></pre>
<p>awk 变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody>
</table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<pre><code class="language-html">$ last -n 5 | awk '{print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
</code></pre>
<h3 id="进程管理-2">进程管理</h3>
<h4 id="4-个查看进程指令">4 个查看进程指令</h4>
<p><strong>1. ps</strong></p>
<p>查看某个时间点的进程信息。</p>
<p>示例：查看自己的进程</p>
<pre><code class="language-sh">## ps -l
</code></pre>
<p>示例：查看系统所有进程</p>
<pre><code class="language-sh">## ps aux
</code></pre>
<p>示例：查看特定的进程</p>
<pre><code class="language-sh">## ps aux | grep threadx
</code></pre>
<p><strong>2. pstree</strong></p>
<p>查看进程树。</p>
<p>示例：查看所有进程树</p>
<pre><code class="language-sh">## pstree -A
</code></pre>
<p><strong>3. top</strong></p>
<p>实时显示进程信息。</p>
<p>示例：两秒钟刷新一次</p>
<pre><code class="language-sh">## top -d 2
</code></pre>
<p><strong>4. netstat</strong></p>
<p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<pre><code class="language-sh">## netstat -anp | grep port
</code></pre>
<h4 id="进程状态-2">进程状态</h4>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R</td>
<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
</tbody>
</table>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2bab4127-3e7d-48cc-914e-436be859fb05.png" alt="img" style="zoom:70%;" />
<h4 id="子进程的-sigchld-信号">子进程的 SIGCHLD 信号</h4>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<p><strong>wait()</strong></p>
<pre><code class="language-c">pid_t wait(int *status)
</code></pre>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<p><strong>waitpid()</strong></p>
<pre><code class="language-c">pid_t waitpid(pid_t pid, int *status, int options)
</code></pre>
<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h4 id="僵尸进程">僵尸进程</h4>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h2 id="关系型数据库">关系型数据库</h2>
<p>SQL 相关语法可以参考 <a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E8%AF%AD%E6%B3%95.html">cyc 大佬的博客</a></p>
<p>SQL 相关练习可以参考 <a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%20%E7%BB%83%E4%B9%A0.html#description-15">cyc 大佬的博客</a></p>
<h3 id="sql-语法">SQL 语法</h3>
<h4 id="内连接-自然连接-外连接">内连接、自然连接、外连接</h4>
<ul>
<li>内连接（INNER JOIN）：只显示符合 on 条件的行
<ul>
<li>自连接：自身与自身的内连接</li>
</ul>
</li>
<li>自然连接（NATURAL JOIN）：自动对同名列进行比对，不能使用 on 语句</li>
<li>外连接（OUTER JOIN）：对于不符合 on 条件的行，对应列用 NULL 展示。分为左外连接、右外连接、全外连接</li>
</ul>
<h4 id="字符集与编码">字符集与编码</h4>
<ul>
<li>
<p>字符集（CHARACTER SET）：用于定义编号指代的字符，如，unicode、ascII、gb2312</p>
</li>
<li>
<p>编码：全称为编码格式，指的是具体字符集在传输和存储过程中的格式，如，utf-8、utf-16 是 unicode 的编码格式。</p>
<ul>
<li>
<blockquote>
<p>UTF-16是一种编码格式。啥是编码格式？就是怎么存储，也就是存储的方式。 存储啥？存二进制数字。为啥要存二进制数字？ 因为Unicode字符集里面把二进制数字和字符一一对应了，存二进制数字就相当于存了二进制数字对应的字符了。为啥不直接存字符？因为计算机只能处理二进制数字。</p>
<p>https://www.cnblogs.com/baxianhua/p/10608480.html</p>
</blockquote>
</li>
<li>
<blockquote>
<p>unicode则是为了让全球能用上统一的字符集而发明的，有6万多个字符，每个字符占2个字节，比如英文a，ascII是97、unicode则是0097（示意的说法）。中文只收录最常用的6000多个汉字。unicode虽然是大一统的标准，但是在表示英文时浪费空间，并且许多古老的程序只支持ascII，unicode从标准设计上来说是不兼容ascII。正因如此，在实际使用中unicode会以utf-8，utf-16等编码方式存储是传输。utf-8保持和ascII一致，英文使用1个字节，其他字符使用2-6个字节，比如中文多数是3个字节。</p>
<p>https://www.cnblogs.com/liuliqiang/p/8258716.html</p>
</blockquote>
</li>
<li>
<p>utf-8：3+1</p>
</li>
<li>
<p>utf-16：2+2</p>
</li>
<li>
<p>utf-32：4+4</p>
</li>
<li>
<p>为什么那么多网站钟情 UTF-8？ - 灵剑的回答 - 知乎 https://www.zhihu.com/question/19817672/answer/141807828</p>
</li>
</ul>
</li>
<li>
<p>校对字符（COLLATE）：即排序规则，用于指定字符间如何进行比较，主要用于排序和分组。例如，utf8_unicode_ci，ci 表示 Case Insensitive，即大小写无关</p>
</li>
</ul>
<h3 id="事务">事务</h3>
<h4 id="基本概念">基本概念</h4>
<p><strong>什么是事务</strong></p>
<p>事务是属于数据库中的一个概念，本质上指的是一系列的操作，但是这些操作会满足一些性质，ACID。</p>
<p>事务可以通过 Commit 提交，也可以使用 Rollback 进行回滚。</p>
<p><strong>ACID</strong></p>
<ul>
<li>原子性 Atomicity：所有操作，要么全部提交，要么全部回滚。
<ul>
<li>回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性</strong> Consistency：强调数据库在逻辑上的一致性状态，依赖于原子性。比如，转账操作，要求多账户余额总和保持一致；扣款操作，要求账户余额变化与扣款金额一致。</li>
<li>隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性 Durability：当事务提交后，该事务中的一系列操作需要能被持久化到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
<ul>
<li>系统发生崩溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
</li>
</ul>
<p>其实，在 ACID 中，最重要的就是一致性，通过一致性，可以保证数据库时刻保持一致性的状态。</p>
<blockquote>
<p>何为一致性状态？它指的是数据处于一种有意义的状态，这种状态是语义上的，而不是语法上的。最常见的例子就是转账，从账户 A 转一笔钱到账户 B，如果账户 A 上的钱减少了，但账户 B 上的钱没有增加，那么就认为此时数据处于不一致的状态。</p>
<p>https://www.cnblogs.com/stone94/p/10409669.html</p>
</blockquote>
<ul>
<li>在无并发的情况下，原子性 可以保证一致性</li>
<li>在有并发的情况下，原子性+隔离性 可以保证一致性</li>
<li>在系统发生崩溃时，持久性 可以保证一致性</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207210437023.png" alt="img" style="zoom:50%;" />
<p><strong>保留点</strong></p>
<p>事务处理中设置的临时占位符，如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<p><strong>autocommit</strong></p>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<h4 id="并发中存在的一致性问题">并发中存在的一致性问题</h4>
<p>在并发环境下，如果事务的隔离性没有得到保证，则会出现很多一致性问题</p>
<p><strong>修改丢失</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221744244.png" alt="img" style="zoom:50%;" />
<p>修改丢失，指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><strong>读脏数据</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221920368.png" alt="img" style="zoom:50%;" />
<p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><strong>不可重复读</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222102010.png" alt="img" style="zoom:50%;" />
<p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><strong>幻读</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207222134306.png" alt="img" style="zoom:50%;" />
<p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p>
<ul>
<li>并发控制可以通过<strong>封锁</strong>来实现，但是封锁操作需要用户自己控制，相当复杂。</li>
<li>数据库管理系统提供了事务的<strong>隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ul>
<h4 id="锁">锁</h4>
<h5 id="锁粒度"><strong>锁粒度</strong></h5>
<p>MySQL 中提供了两种锁粒度：行级锁 以及 表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统<strong>开销</strong>就越大。</p>
<p>在选择锁粒度时，需要在 锁开销 和 并发程度 之间做一个权衡。</p>
<h5 id="锁类型"><strong>锁类型</strong></h5>
<p><strong>读写锁</strong></p>
<ul>
<li>互斥锁（E<strong>x</strong>clusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（<strong>S</strong>hared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207213523777.png" alt="img" style="zoom:50%;" />
<p><strong>意向锁</strong></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度锁。</p>
<p>在存在 行级锁 和 表级锁 的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上添加了 IX/IS，IX/IS 都是<strong>表锁</strong>，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207214442687.png" alt="img" style="zoom:50%;" />
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h5 id="封锁协议">封锁协议</h5>
<p><strong>三级封锁协议</strong></p>
<p><em>一级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220440451.png" alt="img" style="zoom:35%;" />
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<p><em>二级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207220831843.png" alt="img" style="zoom:35%;" />
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><em>三级</em></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207221313819.png" alt="img" style="zoom:35%;" />
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<p><strong>两段锁协议</strong></p>
<p>加锁和解锁分为两个阶段进行。先进行加锁阶段，然后进行解锁阶段。事务进行过程中的所有加锁行为都需要在加锁阶段内完成，解锁同理。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>充分条件：例如，以下操作满足两段锁协议，因此它是可串行化调度的</p>
<pre><code class="language-html">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre>
<p>非必要条件：例如，以下操作不满足两段锁协议，但它还是可串行化调度的。</p>
<pre><code class="language-html">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre>
<h5 id="innodb-的隐式-显式加锁">InnoDB 的隐式、显式加锁</h5>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候<strong>自动</strong>加锁，并且所有的锁都是在同一时刻被释放，这被称为<strong>隐式</strong>加锁。</p>
<p>InnoDB 也可以使用特定的语句进行<strong>显式</strong>加锁，即<strong>手动</strong>加锁：</p>
<pre><code class="language-sql">格式：
SELECT ... LOCK In SHARE MODE; -- 加 X 锁
SELECT ... FOR UPDATE; -- 加 S 锁
例子：
SELECT * FROM table1 WHERE name='张三' LOCK In SHARE MODE;
SELECT * F table1 WHERE name='张三' FOR UPDATE;
</code></pre>
<h4 id="隔离级别">隔离级别</h4>
<ul>
<li>READ UNCOMMITTED (未提交读，也叫脏读）：
<ul>
<li>事务未提交时，依旧可以读取到其所做的修改</li>
<li>该隔离级别在性能上并不会比其他的好太多，但却缺乏其他隔离级别所拥有的好处，因此在实际应用中，一般不使用。</li>
</ul>
</li>
<li>READ COMMITTED (提交读，也叫不可重复读）
<ul>
<li>大部分数据库系统默认的隔离级别，但 MySQL 不是</li>
<li>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li>又被称为“不可重复读”，因为同样的查询，在事务提交前和提交后，读取到的数据可能不同。</li>
</ul>
</li>
<li>REPEATABLE READ (可重复读）
<ul>
<li>MySQL 默认的隔离级别</li>
<li>保证了在一个事务中的多次查询结果一致</li>
<li>该隔离级别可通过 MVCC 实现，但是会存在幻读，即，在事务执行过程中，另一事务修改了数据，从而产生“幻行”，两次查询读取到的数据总行数不一样。</li>
<li>InnoDB 和 XtraDB 存储引擎通过 MVCC + Next-Key Locks 解决了幻读的问题。</li>
</ul>
</li>
<li>SERIALIZABLE (可串行化）
<ul>
<li>最高级别的隔离级别</li>
<li>强制事务串行执行，不存在并发，这样多个事务互不干扰，不会出现并发一致性问题</li>
<li>具体实现：为读取的每一行数据加锁</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191207223400787.png" alt="img" style="zoom:50%;" />
<h4 id="mvcc-多版本并发控制">MVCC 多版本并发控制</h4>
<p><strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<p>MVCC 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p><strong>基本思想</strong></p>
<p>在锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了 读写锁 来避免不必要的加锁操作，例如，读和读没有互斥关系。但，读和写操作仍然是互斥的。</p>
<p>而 MVCC 利用了多版本的思想，<strong>写</strong>操作更新<strong>最新版本</strong>的快照，而<strong>读</strong>操作去读<strong>旧版本</strong>的快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中，事务的每次修改操作（DELETE、INSERT、UPDATE）都会为<strong>数据行</strong>新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<p>多版本并发控制，每个 数据行快照版本 对应一个事务 id，当事务执行修改操作时，会生成对应的版本，多个 数据行快照版本 之间构成链表，从最新的版本开始寻找，直到找到满足要求的版本。</p>
<p><strong>版本号</strong></p>
<ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<p><strong>Undo 日志</strong></p>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<pre><code class="language-sql">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);
UPDATE t SET x=&quot;b&quot; WHERE id=1;
UPDATE t SET x=&quot;c&quot; WHERE id=1;
</code></pre>
<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191208164808217.png" alt="img" style="zoom:50%;" />
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<p><strong>ReadView</strong></p>
<p>有个多版本后，MVCC 该如何使用它呢？</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220106103143882.png" alt="image-20220106103143882" style="zoom:50%;" />
<p>MVCC 维护了一个 ReadView 结构，主要包含：</p>
<ul>
<li>
<p>m_ids：当前系统未提交的事务列表 {TRX_ID_1, TRX_ID_2, ...}</p>
</li>
<li>
<p>min_trx_id：m_ids 中的最小值</p>
</li>
<li>
<p>max_trx_id：当前系统的版本号</p>
<ul>
<li>
<blockquote>
<p>注意，max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，但是，max_trx_id 的值是 4。</p>
<p>https://www.cnblogs.com/jmliao/p/13204946.html</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>creator_trx_id：当前事务的 ID</p>
</li>
</ul>
<p>在进行 SELECT 操作时，根据<strong>数据行</strong>快照的 TRX_ID 与 min_trx_id 和 max_trx_id 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; min_trx_id，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt;= max_trx_id，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt; TRX_ID_MAX，需要根据隔离级别再进行判断：
<ul>
<li>提交读：如果 TRX_ID 在 m_ids 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<p>对于提交读，ReadView 会在每次执行查询语句时生成一次，对于可重复读，只在第一次查询时生成，之后每次查询，复用第一次生成的 ReadView。</p>
<p><strong>快照读与当前读</strong></p>
<p>MVCC 只会在执行 SELECT 语句时发挥作用，在执行修改操作（INSERT、UPDATE、DELETE）时，依旧会对最新数据进行加锁，这是为了避免发生“修改丢失”。</p>
<p>对于 SELECT 操作，会去多版本快照中读取数据，称为 快照读，快照读不会进行加锁操作</p>
<p>对于其他修改操作，会对需要修改的数据进行加锁，确保修改的是最新的数据，这被称为 当前读。以下操作都是当前读：</p>
<pre><code class="language-sql">INSERT;
UPDATE;
DELETE;
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
</code></pre>
<p><strong>幻读问题</strong></p>
<ul>
<li>MVCC 可以解决 快照读 的幻读问题，因为通过版本控制，只会读到旧版本中的数据，不会发生幻读问题</li>
<li>但是无法解决 当前读 的幻读问题，因为当前读获取的是最新的数据
<ul>
<li>举个例子：</li>
<li>事务1 select *</li>
<li>事务2 insert</li>
<li>事务1 select *，此时没问题，因为是快照读，不会读到事务2的insert</li>
<li>事务1 update，因为 update 是当前读，会读到事务 2 的 insert，所以会把这条数据的版本号改成事务1，此时事务 1 再 select，就会出现幻读</li>
</ul>
</li>
</ul>
<h4 id="next-key-locks">Next-Key Locks</h4>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<p><strong>Record Locks</strong></p>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<p><strong>Gap Locks</strong></p>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<pre><code class="language-sql">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
</code></pre>
<p><strong>Next-Key Locks</strong></p>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定的范围都是前开后闭的区间。</p>
<p>例如，一个索引包含以下值：10, 11, 13, and 20，那么可能被锁住的区间有：</p>
<pre><code class="language-sql">(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
</code></pre>
<p>具体加锁规则为：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/50ff45e7d6f7826867bdc9c4197cf4c6.png" alt="img" style="zoom:50%;" />
<blockquote>
<p>看了这结论，应该可以解答一大部分问题，不过有一句非常非常重点的话需要关注：</p>
<p>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列&lt;=5.7.24，8.0 系列 &lt;=8.0.13</p>
<p>https://blog.csdn.net/qq_36535538/article/details/117623068</p>
</blockquote>
<h3 id="mysql">MySQL</h3>
<h4 id="索引">索引</h4>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h5 id="索引类型">索引类型</h5>
<h6 id="b-tree-索引">B+ Tree 索引</h6>
<p>大多数 MySQL 存储引擎的默认索引类型</p>
<p><strong>原理</strong></p>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是 B Tree 的升级版，在 B Tree 的基础上做了改良：</p>
<ul>
<li>添加了叶子结点顺序访问指针</li>
<li>将数据全部保存在叶子结点上</li>
</ul>
<p>相较于 B Tree，B+ Tree 具有如下优点：</p>
<ul>
<li>保留了 B Tree 的平衡性</li>
<li>可通过顺序访问指针提高区间查询的性能（B Tree中，需要使用中序遍历）</li>
<li>将数据保存在叶子结点上，使得非叶子结点可以存储更多 key，进一步降低树高</li>
<li>每次都会查到叶子结点才结束，因此查询时间较稳定</li>
</ul>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">key_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">key_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，且不为 null，则该指针指向节点的所有 key 大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">key_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">key_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img" style="zoom:50%;" />
<p>当需要进行查找操作时</p>
<p>首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入、删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>
<p><strong>VS 红黑树</strong></p>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p>
<p>（一）B+ 树有更低的<strong>树高</strong></p>
<p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>
<p>（二）磁盘访问原理</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>
<p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与<strong>树高</strong>成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
<p>（三）磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<p><em>（不用红黑树的根本原因还是因为树高！）</em></p>
<p><strong>用法</strong></p>
<ul>
<li>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li>
<li>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</li>
<li>可以指定多个列作为索引列，多个索引列共同组成键。</li>
<li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li>
</ul>
<p><strong>InnoDB 中的 B+ Tree 索引</strong></p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个<strong>聚簇索引</strong>。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img" style="zoom:50%;" />
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img" style="zoom:60%;" />
<h6 id="其他索引">其他索引</h6>
<p><strong>哈希索引</strong></p>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ Tree 索引之上再创建一个哈希索引，这样就让 B+ Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<p><strong>全文索引</strong></p>
<p>MyISAM 存储引擎支持全文索引，<strong>用于查找文本中的关键词</strong>，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<p><strong>空间数据索引</strong></p>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h5 id="如何高效使用索引">如何高效使用索引</h5>
<p><strong>独立的列</strong></p>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<pre><code class="language-sql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
</code></pre>
<p><strong>多列索引</strong></p>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<pre><code class="language-sql">SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
</code></pre>
<p><strong>索引列的顺序</strong></p>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<pre><code class="language-sql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
</code></pre>
<pre><code class="language-html">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre>
<p><strong>前缀索引</strong></p>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<p><strong>覆盖索引</strong></p>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h5 id="索引的优点与使用条件">索引的优点与使用条件</h5>
<p>优点：</p>
<ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<p>使用条件：</p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<h4 id="存储引擎">存储引擎</h4>
<p><strong>InnoDB</strong></p>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p><strong>MyISAM</strong></p>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<p><strong>比较</strong></p>
<ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h4 id="数据类型-2">数据类型</h4>
<p><strong>整型</strong></p>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<p><strong>浮点数</strong></p>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<p><strong>字符串</strong></p>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<p><strong>时间和日期</strong></p>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<ul>
<li>DATETIME</li>
</ul>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<ul>
<li>TIMESTAMP</li>
</ul>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<ul>
<li>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</li>
</ul>
<h3 id="以下-3-点均为性能优化">以下 3 点均为性能优化：</h3>
<h3 id="查询性能优化">查询性能优化</h3>
<h4 id="使用-explain-进行分析">使用 Explain 进行分析</h4>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>各字段含义：</p>
<ul>
<li>id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样</li>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>type：针对单表的查询方式
<ul>
<li>all、index、range、ref、eq_ref、const，从左到右效率依次提升</li>
<li>all：全表扫描</li>
<li>index：根据索引的顺序全表扫描</li>
<li>range：索引范围查询，between、&gt;、&lt;、in</li>
<li>ref：查询条件使用索引，但不是唯一索引</li>
<li>eq_ref：查询条件使用唯一索引</li>
<li>const：查询条件使用主键，优化器会把查询优化为一个常量</li>
<li>by https://blog.csdn.net/dennis211/article/details/78170079</li>
</ul>
</li>
<li>possible_keys：可能用到的索引</li>
<li>key : 实际用到的索引</li>
<li>rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）</li>
<li>Extra：
<ul>
<li>Impossible where：查询条件为false</li>
<li>Using where：顺序扫描，where 条件查询</li>
<li>Using index：覆盖索引</li>
<li>Using index condition：索引下推
<ul>
<li>根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表</li>
<li>在表上建立联合索引（name, age）</li>
<li><code>select * from table1 where name like &quot;张%&quot; and age = 23;</code></li>
<li>组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表</li>
<li>by https://zhuanlan.zhihu.com/p/121084592</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优化数据访问">优化数据访问</h4>
<p><strong>减少请求的数据量</strong></p>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<p><strong>减少服务器端扫描的行数</strong></p>
<ul>
<li>最有效的方式是使用覆盖索引进行查询</li>
</ul>
<h4 id="重构查询方式">重构查询方式</h4>
<p><strong>1. 切分大查询</strong></p>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<p>大查询：</p>
<pre><code class="language-sql">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);
</code></pre>
<p>优化后：</p>
<pre><code class="language-sql">rows_affected = 0
do {
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
} while rows_affected &gt; 0
</code></pre>
<p><strong>2. 分解大连接查询</strong></p>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>
<p>让缓存更高效：</p>
<ul>
<li>对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
</ul>
</li>
<li>
<p>减少锁竞争；</p>
</li>
<li>
<p>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</p>
</li>
<li>
<p>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</p>
</li>
</ul>
<pre><code class="language-sql">SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';

SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
</code></pre>
<h3 id="切分分库分表">切分（分库分表）</h3>
<h4 id="水平切分-sharding">水平切分 Sharding</h4>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img" style="zoom:90%;" />
<p>策略：</p>
<ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>ID 唯一性：
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 雪花算法)
<ul>
<li>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</li>
<li>1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0</li>
<li>41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69</li>
<li>10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId</li>
<li>12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号</li>
<li>加起来刚好64位，为一个Long型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="垂直切分">垂直切分</h4>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img" style="zoom:90%;" />
<p>存在的问题：</p>
<ul>
<li>插入删除要同时进行</li>
</ul>
<p>共同存在的问题：</p>
<ul>
<li>事务问题：使用分布式事务来解决，比如 XA 接口。</li>
<li>连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li>
</ul>
<h3 id="分布式">分布式</h3>
<h4 id="主从复制">主从复制</h4>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<h4 id="读写分离">读写分离</h4>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<h3 id="关系型数据库-设计理论">关系型数据库 设计理论</h3>
<p>函数依赖：</p>
<ul>
<li>什么是函数依赖</li>
<li>什么是键码、完全函数依赖、传递函数依赖</li>
</ul>
<p>异常：</p>
<ul>
<li>冗余数据</li>
<li>修改异常</li>
<li>删除异常</li>
<li>插入异常</li>
</ul>
<p>范式</p>
<ul>
<li>第一范式 1NF</li>
<li>第二范式 2NF</li>
<li>第三范式 3NF</li>
</ul>
<h3 id="er-图">ER 图</h3>
<p>http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%85%AB%E3%80%81er-%E5%9B%BE</p>
<h2 id="非关系型数据库-redis">非关系型数据库 Redis</h2>
<h3 id="概述-7">概述</h3>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h3 id="数据类型-3">数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">可以存储的值</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">字符串、整数或者浮点数</td>
<td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作</br>对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td style="text-align:center">LIST</td>
<td style="text-align:center">列表</td>
<td style="text-align:center">从两端压入或者弹出元素 </br> 对单个或者多个元素进行修剪，</br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">无序集合</td>
<td style="text-align:center">添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">包含键值对的无序散列表</td>
<td style="text-align:center">添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td style="text-align:center">ZSET</td>
<td style="text-align:center">有序集合</td>
<td style="text-align:center">添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<h4 id="使用方法">使用方法</h4>
<p>STRING</p>
<pre><code>&gt; set hello world
OK
&gt; get hello
&quot;world&quot;
&gt; del hello
(integer) 1
&gt; get hello
(nil)
</code></pre>
<p>LIST</p>
<pre><code>&gt; rpush list-key item
(integer) 1
&gt; rpush list-key item2
(integer) 2
&gt; rpush list-key item
(integer) 3

&gt; lrange list-key 0 -1
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item&quot;

&gt; lindex list-key 1
&quot;item2&quot;

&gt; lpop list-key
&quot;item&quot;

&gt; lrange list-key 0 -1
1) &quot;item2&quot;
2) &quot;item&quot;
</code></pre>
<p>SET</p>
<pre><code>&gt; sadd set-key item
(integer) 1
&gt; sadd set-key item2
(integer) 1
&gt; sadd set-key item3
(integer) 1
&gt; sadd set-key item
(integer) 0

&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item3&quot;

&gt; sismember set-key item4
(integer) 0
&gt; sismember set-key item
(integer) 1

&gt; srem set-key item2
(integer) 1
&gt; srem set-key item2
(integer) 0

&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item3&quot;
</code></pre>
<p>HASH</p>
<pre><code>&gt; hset hash-key sub-key1 value1
(integer) 1
&gt; hset hash-key sub-key2 value2
(integer) 1
&gt; hset hash-key sub-key1 value1
(integer) 0

&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;
3) &quot;sub-key2&quot;
4) &quot;value2&quot;

&gt; hdel hash-key sub-key2
(integer) 1
&gt; hdel hash-key sub-key2
(integer) 0

&gt; hget hash-key sub-key1
&quot;value1&quot;

&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;
</code></pre>
<p>ZSET</p>
<pre><code>&gt; zadd zset-key 728 member1
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &quot;member1&quot;
2) &quot;728&quot;
3) &quot;member0&quot;
4) &quot;982&quot;

&gt; zrangebyscore zset-key 0 800 withscores
1) &quot;member1&quot;
2) &quot;728&quot;

&gt; zrem zset-key member1
(integer) 1
&gt; zrem zset-key member1
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &quot;member0&quot;
2) &quot;982&quot;
</code></pre>
<h4 id="存储结构">存储结构</h4>
<p>在 redis 中有 对象 和 存储结构 的概念，redis 对象利用不同的存储结构进行存储。例如，String 对象可以用 int 结构进行存储，也可以用 SDS 结构进行存储。</p>
<p>对不同类型的对象，内部存储结构不同：</p>
<ul>
<li>
<p>String对象：</p>
<ul>
<li>
<p>int 存储结构</p>
</li>
<li>
<p>SDS 存储结构</p>
<ul>
<li>
<p>embstr：小于等于 44 字节</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png" alt="image-20210528141323986" loading="lazy"></figure>
</li>
<li>
<p>raw：大于 44 字节</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png" alt="image-20210528141338577" loading="lazy"></figure>
</li>
<li>
<p>embstr与raw的区别是，embstr只会申请一次内存空间</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hash 对象</p>
<ul>
<li>
<p>压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png" alt="image-20210525101358367" loading="lazy"></figure>
</li>
<li>
<p>哈希表：空间占用大，查找快</p>
</li>
</ul>
</li>
<li>
<p>List 对象</p>
<ul>
<li>
<p>压缩列表：数据数量较少或所占空间较少时，使用压缩列表</p>
</li>
<li>
<p>链表：空间占用更多，但添加、删除元素时，效率高</p>
</li>
<li>
<p>快速列表：Redis 3.2 之后，用 快速列表 代替 压缩列表和链表</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png" alt="image-20210528150649602" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>Set 对象</p>
<ul>
<li>整数集合</li>
<li>字典
<ul>
<li>字典中包含两个哈希表，哈希表使用 拉链法 解决哈希冲突</li>
<li>之所以包含两个哈希表，是为了方便进行 rehash 操作。在扩容时，将其中一个 哈希表 上的键值对 rehash 到另一个 哈希表 上，完成之后释放空间并交换两个 哈希表 的角色。</li>
<li>rehash 操作：
<ul>
<li>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</li>
<li>渐进式 rehash 通过记录 字典 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 哈希表0 rehash 到 哈希表1，这一次会把 哈希表0 上 table[rehashidx] 的键值对 rehash 到 哈希表1 上，哈希表0 的 table[rehashidx] 指向 null，并令 rehashidx++。</li>
<li>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</li>
<li>采用渐进式 rehash 会导致字典中的数据分散在两个 哈希表 上，因此对字典的查找操作也需要到对应的 哈希表 上去执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ZSet 对象：</p>
<ul>
<li>
<p>压缩列表</p>
</li>
<li>
<p>跳表：查找快，但更占空间且更新性能低</p>
<ul>
<li>相较于 红黑树 的优势：</li>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</li>
<li>更容易实现</li>
<li>支持无锁操作</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png" alt="image-20210524163213876" loading="lazy"></figure>
</li>
<li>
<p>当元素个数超过 <code>zset-max-ziplist-entries</code>，切换成跳表。</p>
</li>
</ul>
</li>
</ul>
<h4 id="使用场景-7点">使用场景 7点</h4>
<p><strong>计数器、全局序列号</strong></p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能，<code>INCR</code></p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p><strong>缓存</strong></p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p><strong>消息队列</strong></p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p><strong>数据存储</strong></p>
<p><strong>1.1 查找表</strong></p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p><strong>1.2 会话缓存</strong></p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p><strong>分布式锁实现</strong></p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p><strong>其它</strong></p>
<ul>
<li>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
</li>
<li>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
</li>
</ul>
<hr>
<p>String</p>
<ul>
<li>单值缓存</li>
<li>对象缓存：JSON字符串</li>
<li>分布式锁</li>
<li>计数器</li>
<li>分布式系统全局序列号
<ul>
<li>分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。</li>
</ul>
</li>
</ul>
<p>Hash</p>
<ul>
<li>对象缓存
<ul>
<li>与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性</li>
</ul>
</li>
</ul>
<p>List</p>
<ul>
<li>实现栈、队列、拥塞队列</li>
<li>消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。</li>
</ul>
<p>Set</p>
<ul>
<li>抽奖功能：因为set有srandmember、spop方法</li>
<li>点赞功能：频繁添加、删除、比较元素，用set效率比list好</li>
<li>关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作</li>
</ul>
<p>ZSet</p>
<ul>
<li>排行榜</li>
</ul>
<h3 id="性能高的原因">性能高的原因</h3>
<ul>
<li>对象在不同情况下使用不同的存储结构</li>
<li>基于内存</li>
<li>多路复用</li>
</ul>
<h3 id="vs-memcached">VS Memcached</h3>
<p>http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html#%E4%BA%94%E3%80%81redis-%E4%B8%8E-memcached</p>
<h3 id="键的过期时间">键的过期时间</h3>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h3 id="数据淘汰策略">数据淘汰策略</h3>
<p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">volatile-lru</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-ttl</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-random</td>
<td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-lru</td>
<td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-random</td>
<td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td style="text-align:center">noeviction</td>
<td style="text-align:center">禁止驱逐数据</td>
</tr>
</tbody>
</table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h3 id="持久化">持久化</h3>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<p><strong>RDB 持久化</strong></p>
<p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<p><strong>AOF 持久化</strong></p>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">同步频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">always</td>
<td style="text-align:center">每个写命令都同步</td>
</tr>
<tr>
<td style="text-align:center">everysec</td>
<td style="text-align:center">每秒同步一次</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">让操作系统来决定何时同步</td>
</tr>
</tbody>
</table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h3 id="事务-2">事务</h3>
<p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<h3 id="事件">事件</h3>
<p>Redis 服务器是一个事件驱动程序。</p>
<h4 id="文件事件">文件事件</h4>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" alt="img" style="zoom:70%;" />
<h4 id="时间事件">时间事件</h4>
<p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h4 id="事件的调度与执行">事件的调度与执行</h4>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<pre><code class="language-python">def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
</code></pre>
<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<pre><code class="language-python">def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
</code></pre>
<p>从事件处理的角度来看，服务器运行流程如下：</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" alt="img" style="zoom:50%;" />
<h3 id="主从复制-2">主从复制</h3>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<p><strong>连接过程</strong></p>
<ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<p><strong>主从链</strong></p>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" alt="img" style="zoom:80%;" />
<h3 id="sentinel-哨兵">Sentinel 哨兵</h3>
<p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h3 id="分片">分片</h3>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h3 id="论坛系统实践">论坛系统实践</h3>
<p>该论坛系统功能如下：</p>
<ul>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ul>
<p><strong>文章信息</strong></p>
<p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/7c54de21-e2ff-402e-bc42-4037de1c1592.png" alt="img" style="zoom:40%;" />
<p><strong>点赞功能</strong></p>
<p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/485fdf34-ccf8-4185-97c6-17374ee719a0.png" alt="img" style="zoom:40%;" />
<p><strong>对文章进行排序</strong></p>
<p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合或一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间或点赞数，而是根据时间或点赞数间接计算出来的）</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" alt="img" style="zoom:80%;" />
<h2 id="关系型数据库-与-非关系型数据库">关系型数据库 与 非关系型数据库</h2>
<p>本质区别：</p>
<ul>
<li>关系型数据库存储数据之间的关系，比如，可以根据学生学号查询他的姓名。非关系型数据库，只存储数据本身，数据之间是完全独立的。</li>
</ul>
<p>表现形式：</p>
<ul>
<li>关系型：数据表</li>
<li>非关系型：键值对、文档</li>
</ul>
<p>各自优势：</p>
<ul>
<li>关系型：
<ul>
<li>可以利用数据之间的关系进行复杂的查询</li>
<li>不存在冗余（利用范式优化存储）</li>
</ul>
</li>
<li>非关系型：
<ul>
<li>方便扩展</li>
<li>无需经过sql层的解析，读写性能很高</li>
</ul>
</li>
</ul>
<h2 id="设计模式">设计模式</h2>
<h3 id="单例模式">单例模式</h3>
<p><strong>四种常规实现：</strong></p>
<ul>
<li>懒汉式-线程不安全</li>
<li>饿汉式-线程安全</li>
<li>懒汉式-线程安全</li>
<li>双重校验锁-线程安全</li>
</ul>
<p><strong>双重校验锁中，为什么需要用 volatile？</strong></p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p><strong>两种非常规实现：</strong></p>
<p><strong>静态内部类实现</strong></p>
<p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<pre><code class="language-java">public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
</code></pre>
<p>JVM 如何保证 INSTANCE 只实例化一次？</p>
<p>首先，对于类，无论静态类还是非静态类，只有被使用时，类才会被加载</p>
<p>其次，对于成员变量：</p>
<blockquote>
<p>使用了static修饰的成员变量，会在类初始化的过程中被收集进类构造器，即&lt; clinit&gt;方法中，在多线程场景下，JVM会保证只有一个线程能执行该类的&lt; clinit&gt;方法，其他线程将会被阻塞等待，等到唯一的一次&lt; cliint&gt;方法执行完成，其他线程将不会再执行&lt; clinit&gt;方法，转而执行自己的代码。也就是说，static修饰的成员变量，在多线程的情况下能保证只实例化一次。</p>
<p>ps:<br>
&lt; init&gt;:是instance实例构造器，对非静态变量进行初始化。<br>
&lt; clinit&gt;:是class类构造器，对静态变量、静态代码块进行初始化。<br>
————————————————<br>
原文链接：https://blog.csdn.net/weixin_43871678/article/details/107634599</p>
</blockquote>
<p><strong>枚举实现</strong></p>
<pre><code class="language-java">public enum Singleton {

    INSTANCE;

    private String objName;


    public String getObjName() {
        return objName;
    }


    public void setObjName(String objName) {
        this.objName = objName;
    }


    public static void main(String[] args) {

        // 单例测试
        Singleton firstSingleton = Singleton.INSTANCE;
        firstSingleton.setObjName(&quot;firstName&quot;);
        System.out.println(firstSingleton.getObjName());
        Singleton secondSingleton = Singleton.INSTANCE;
        secondSingleton.setObjName(&quot;secondName&quot;);
        System.out.println(firstSingleton.getObjName());
        System.out.println(secondSingleton.getObjName());

        // 反射获取实例测试
        try {
            Singleton[] enumConstants = Singleton.class.getEnumConstants();
            for (Singleton enumConstant : enumConstants) {
                System.out.println(enumConstant.getObjName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code>firstName
secondName
secondName
secondName
</code></pre>
<p>优势：</p>
<ul>
<li>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</li>
<li>该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</li>
</ul>
<h3 id="工厂相关的-3-个模式">工厂相关的 3 个模式</h3>
<ul>
<li>简单工厂模式：由工厂类的 create() 方法负责实例化对象
<ul>
<li>小米工厂负责生产手机</li>
</ul>
</li>
<li>工厂方法模式：工厂类包含抽象方法，工厂子类继承工厂类并实现抽象方法
<ul>
<li>小米子工厂 A 负责生产手机 A，子工厂 B 负责生产手机 B</li>
</ul>
</li>
<li>抽象工厂：在工厂方法模式的基础上，增加抽象方法的个数，从而实现对象家族的创建
<ul>
<li>小米子工厂 A 负责生产手机 A 和 投影仪 A，子工厂 B 负责生产手机 B 和投影仪 B</li>
</ul>
</li>
</ul>
<h3 id="生成器建造者">生成器（建造者）</h3>
<p>具体包含两个类：Director、Builder</p>
<p>由 Director 负责控制流程，由 Builder 负责每一步具体的实现</p>
<p>Director 依靠 Builder，并最终构造出对象</p>
<h3 id="观察者">观察者</h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象</p>
<ul>
<li>添加、移除观察者</li>
<li>通知观察者：notify()</li>
</ul>
<p>而其所有依赖者（Observer）称为观察者</p>
<ul>
<li>收到通知后的操作：update()</li>
</ul>
<h3 id="其他-2">其他</h3>
<p><strong>原型模式</strong></p>
<p>允许一个对象再创建另外一个可定制的对象，调用者无需知道任何创建的细节</p>
<p><strong>责任链</strong></p>
<p>对于请求，当前类无法处理，则抛给上一层</p>
<p>通过组合构成责任链</p>
<pre><code class="language-java">public abstract class Handler {

    protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }

    protected abstract void handleRequest(Request request);
}

public class ConcreteHandler1 extends Handler {

    public ConcreteHandler1(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
</code></pre>
<p><strong>命令</strong></p>
<ul>
<li>Command：命令（开灯操作、关灯操作）</li>
<li>Receiver：命令接收者，也就是命令真正的执行者（灯）</li>
<li>Invoker：通过它来调用命令（遥控器）</li>
<li>Client：可以设置命令与命令的接收者（人）</li>
</ul>
<p><strong>解释器</strong></p>
<p>没懂，暂时不管了，面经遇到再说</p>
<p><strong>迭代器</strong></p>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示</p>
<p><strong>中介者</strong></p>
<p>A 与 B 要通信，A 告诉中介者，由中介者通知 B</p>
<p>优势：对象之间的通信可集中管理，让 A 与 B 解耦</p>
<p><strong>备忘录</strong></p>
<p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态</p>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/50678f34-694f-45a4-91c6-34d985c83fee.png" alt="img" style="zoom:80%;" />
<p><strong>状态</strong></p>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类</p>
<p>实现：将状态抽象成类，并将相应的行为放在该类中</p>
<p><strong>策略</strong></p>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<p>与 状态模式 的比较：</p>
<ul>
<li>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</li>
<li>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</li>
</ul>
<p><strong>模板方法</strong></p>
<p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<p><strong>访问者</strong></p>
<p>不懂，暂时跳过</p>
<p><strong>空对象</strong></p>
<p>使用 什么都不做 的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<p><strong>适配器</strong></p>
<p>把一个类接口转换成另一个用户需要的接口</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png" alt="img" style="zoom:70%;" />
<pre><code class="language-java">public interface Duck {
    void quack();
}
public interface Turkey {
    void gobble();
}

public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&quot;gobble!&quot;);
    }
}
public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}

public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
</code></pre>
<p><strong>桥接模式</strong></p>
<p>将抽象与实现分离开来，使它们可以独立变化</p>
<ul>
<li>Abstraction：定义抽象类的接口</li>
<li>Implementor：定义实现类接口</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png" alt="img" style="zoom:70%;" />
<p>具体应用：https://blog.csdn.net/MY9526/article/details/108738263</p>
<p><strong>组合</strong></p>
<p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png" alt="img" style="zoom:70%;" />
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<p><strong>装饰者</strong></p>
<p>为对象动态添加功能</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="img" style="zoom:67%;" />
<p><strong>外观</strong></p>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能</p>
<p><strong>享元</strong></p>
<p>尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p>
<p>主要用于减少创建对象的数量，以减少内存占用和提高性能</p>
<p><strong>代理</strong></p>
<p>控制对其它对象的访问</p>
<p>代理有以下四类：</p>
<ul>
<li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<h3 id="设计原则">设计原则</h3>
<h4 id="solid">S.O.L.I.D</h4>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRP</td>
<td style="text-align:center">The Single Responsibility Principle</td>
<td style="text-align:center">单一责任原则</td>
</tr>
<tr>
<td style="text-align:center">OCP</td>
<td style="text-align:center">The Open Closed Principle</td>
<td style="text-align:center">开放封闭原则</td>
</tr>
<tr>
<td style="text-align:center">LSP</td>
<td style="text-align:center">The Liskov Substitution Principle</td>
<td style="text-align:center">里氏替换原则</td>
</tr>
<tr>
<td style="text-align:center">ISP</td>
<td style="text-align:center">The Interface Segregation Principle</td>
<td style="text-align:center">接口分离原则</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">The Dependency Inversion Principle</td>
<td style="text-align:center">依赖倒置原则</td>
</tr>
</tbody>
</table>
<p><strong>1. 单一责任原则</strong></p>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<p><strong>2. 开放封闭原则</strong></p>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是<strong>装饰者模式</strong>，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<p><strong>3. 里氏替换原则</strong></p>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<p><strong>4. 接口分离原则</strong></p>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<p><strong>5. 依赖倒置原则</strong></p>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>
抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h4 id="其他原则">其他原则</h4>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOD</td>
<td style="text-align:center">The Law of Demeter</td>
<td style="text-align:center">迪米特法则</td>
</tr>
<tr>
<td style="text-align:center">CRP</td>
<td style="text-align:center">The Composite Reuse Principle</td>
<td style="text-align:center">合成复用原则</td>
</tr>
<tr>
<td style="text-align:center">CCP</td>
<td style="text-align:center">The Common Closure Principle</td>
<td style="text-align:center">共同封闭原则</td>
</tr>
<tr>
<td style="text-align:center">SAP</td>
<td style="text-align:center">The Stable Abstractions Principle</td>
<td style="text-align:center">稳定抽象原则</td>
</tr>
<tr>
<td style="text-align:center">SDP</td>
<td style="text-align:center">The Stable Dependencies Principle</td>
<td style="text-align:center">稳定依赖原则</td>
</tr>
</tbody>
</table>
<p><strong>1. 迪米特法则</strong></p>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<p>外观模式</p>
<p><strong>2. 合成复用原则</strong></p>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<p><strong>3. 共同封闭原则</strong></p>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<p><strong>4. 稳定抽象原则</strong></p>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<p><strong>5. 稳定依赖原则</strong></p>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="红黑树">红黑树</h3>
<p>近似平衡二叉树</p>
<p>性质：</p>
<ul>
<li>每个节点要么红色要么黑色</li>
<li>根节点是黑色</li>
<li>红节点的子节点是黑色</li>
<li>空叶子结点是黑色</li>
</ul>
<p>优势（vs AVL）：</p>
<ul>
<li>虽然查询效率略低于 AVL，但插入效率要远胜于 AVL</li>
</ul>
<h2 id="系统设计">系统设计</h2>
<h3 id="系统设计基础">系统设计基础</h3>
<p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.html">http://www.cyc2018.xyz/其它/系统设计/系统设计基础.html</a></p>
<p>性能指标：</p>
<ul>
<li>响应时间</li>
<li>吞吐量</li>
<li>并发用户数</li>
</ul>
<p>性能优化：</p>
<ul>
<li>集群</li>
<li>缓存</li>
<li>异步</li>
</ul>
<p>四大特性：</p>
<ul>
<li>伸缩性</li>
<li>扩展性</li>
<li>可用性
<ul>
<li>服务降级：系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</li>
</ul>
</li>
<li>安全性</li>
</ul>
<h3 id="分布式-2">分布式</h3>
<h4 id="分布式锁">分布式锁</h4>
<p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>阻塞锁通常使用互斥量来实现：</p>
<ul>
<li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li>
<li>互斥量为 1 表示未锁定状态。</li>
</ul>
<p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p>
<p><strong>1. 数据库的唯一索引</strong></p>
<p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<p><strong>2. Redis 的 SETNX 指令（单个实例实现分布式锁）</strong></p>
<p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<p><strong>Redis 的 RedLock 算法（多个实例实现分布式锁）</strong></p>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁（因为在获取锁的过程中，已经对部分 redis 实例进行加锁了）。</li>
</ul>
<p><strong>3. Zookeeper 的有序节点</strong></p>
<p>1. Zookeeper 抽象模型</p>
<p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/aefa8042-15fa-4e8b-9f50-20b282a2c624.png" alt="img" style="zoom:50%;" />
<p>2. 节点类型</p>
<ul>
<li>永久节点：不会因为会话结束或者超时而消失；</li>
<li>临时节点：如果会话结束或者超时就会消失；</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li>
</ul>
<p>3. 监听器</p>
<p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p>
<p>4. 分布式锁实现</p>
<ul>
<li>创建一个锁目录 /lock；</li>
<li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li>
<li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则，监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码，完成后，删除对应的子节点。</li>
</ul>
<p>5. 会话超时</p>
<p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p>
<p>6. 羊群效应</p>
<p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p>
<h4 id="分布式事务">分布式事务</h4>
<p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p>
<p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p>
<p>分布式锁和分布式事务区别：</p>
<ul>
<li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
<p><strong>两阶段提交 2PC</strong></p>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<p>运行过程：</p>
<ul>
<li>
<p>准备阶段：协调者询问参与者事务<strong>是否执行成功</strong>，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/44d33643-1004-43a3-b99a-4d688a08d0a1.png" alt="img" style="zoom:50%;" />
</li>
<li>
<p>提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png" alt="img" style="zoom:50%;" />
</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</li>
<li>单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</li>
<li>数据不一致：在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li>
</ul>
<p><strong>三阶段提交 3PC</strong></p>
<p>待看：https://zhuanlan.zhihu.com/p/163864897</p>
<p>三阶段提交：</p>
<ul>
<li>第一阶段：各节点检查资源，判断业务是否可执行（但在此阶段不<strong>执行</strong>事务）</li>
<li>第二阶段（缓冲阶段，precommit）：执行业务，但不提交</li>
<li>第三阶段：和两阶段提交的第二阶段相同</li>
</ul>
<p>三阶段提交的优点：</p>
<ul>
<li>
<p>引入超时机制，减少阻塞：</p>
<ul>
<li>
<p>如果超时，默认abort，但如果是第三阶段，超时则自动提交，两阶段提交无法这么做，因为不存在缓冲阶段</p>
</li>
<li>
<blockquote>
<p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）<br>
————————————————<br>
原文链接：https://blog.csdn.net/u010191243/article/details/52081891</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>事务管理器集群：幂等操作</p>
</li>
</ul>
<p><strong>补偿事务 TCC</strong></p>
<p>参考：</p>
<ul>
<li>https://zhuanlan.zhihu.com/p/112540330</li>
<li>https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653195220&amp;idx=2&amp;sn=60552e190233a5b98c4c24fff4ac7238&amp;chksm=8c99f90ebbee70187e9feb6f2f3660df3d06071427bd1a4b3f3467c428d8c1de84c768183e5c&amp;mpshare=1&amp;scene=1&amp;srcid=1001twHtyhaOm0sZl089iHAP#rd</li>
</ul>
<p>过程：</p>
<ul>
<li>Try 阶段：预留资源</li>
<li>Confirm 阶段：执行业务</li>
<li>Cancel 阶段：若部分节点 Confirm 失败，则执行 Cancel 进行 <strong>补偿</strong></li>
</ul>
<p><strong>本地消息表</strong></p>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png" alt="img" style="zoom:50%;" />
<h4 id="cap">CAP</h4>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg" alt="img" style="zoom:40%;" />
<p><strong>一致性</strong></p>
<p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
<ul>
<li>强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。</li>
<li>最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。</li>
<li>弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</li>
</ul>
<p><strong>可用性</strong></p>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<p><strong>分区容忍性</strong></p>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<p><strong>权衡</strong></p>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h4 id="base">BASE</h4>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>基本可用</strong></p>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<p><strong>软状态</strong></p>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h4 id="paxos-协议">Paxos 协议</h4>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。往往只有一个。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/b988877c-0f0a-4593-916d-de2081320628.jpg" alt="img" style="zoom:70%;" />
<p><strong>执行过程</strong></p>
<p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p>
<p>1. Prepare 阶段</p>
<p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png" alt="img" style="zoom:60%;" />
<p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p>
<p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg" alt="img" style="zoom:60%;" />
<p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p>
<p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg" alt="img" style="zoom:60%;" />
<p>2. Accept 阶段</p>
<p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p>
<p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p>
<p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png" alt="img" style="zoom:60%;" />
<p>3. Learn 阶段</p>
<p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg" alt="img" style="zoom:60%;" />
<p><strong>约束条件</strong></p>
<p>1. 正确性</p>
<p>指只有一个提议值会生效。</p>
<p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p>
<p>2. 可终止性</p>
<p>指最后总会有一个提议生效。</p>
<p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p>
<h4 id="raft-协议-竞选-leader">Raft 协议-竞选 Leader</h4>
<p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p>
<p><strong>单个 Candidate 的竞选</strong></p>
<p>有三种节点：Follower、Candidate 和 Leader。</p>
<p>Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li>最初阶段，只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li>
<li>此时 Node A 发送投票请求给其它所有节点。</li>
<li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li>
<li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li>
</ul>
<p><strong>多个 Candidate 的竞选</strong></p>
<ul>
<li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如，Node B 和 Node D 都获得两票，需要重新开始投票。</li>
<li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li>
</ul>
<p><strong>数据同步</strong></p>
<ul>
<li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li>
<li>Leader 会把修改复制到所有 Follower。</li>
<li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li>
<li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li>
</ul>
<h3 id="集群">集群</h3>
<h4 id="负载均衡">负载均衡</h4>
<p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p>
<p>负载均衡器可以用来实现高可用以及伸缩性：</p>
<ul>
<li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li>
<li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li>
</ul>
<p>负载均衡器运行过程包含两个部分：</p>
<ol>
<li>根据负载均衡算法得到转发的节点；</li>
<li>进行转发。</li>
</ol>
<h5 id="负载均衡算法">负载均衡算法</h5>
<p><strong>轮询</strong></p>
<p>轮询算法把每个请求轮流发送到每个服务器上。</p>
<p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载。</p>
<p><strong>加权轮询</strong></p>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p>
<p>例如，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<p><strong>最少连接</strong></p>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p>
<p>例如，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p>
<p>例如，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<p><strong>加权最少连接</strong></p>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<p><strong>随机算法</strong></p>
<p>把请求随机发送到服务器上。</p>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<p><strong>源地址哈希法</strong></p>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p>
<h5 id="转发实现">转发实现</h5>
<p><strong>HTTP 重定向</strong></p>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p>
<p>缺点：</p>
<ul>
<li>需要两次请求，因此访问延迟比较高；</li>
<li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li>
</ul>
<p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg" alt="img" style="zoom:50%;" />
<p><strong>DNS 域名解析</strong></p>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p>
<p>优点：</p>
<ul>
<li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li>
</ul>
<p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg" alt="img" style="zoom:50%;" />
<p><strong>反向代理服务器</strong></p>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p>
<p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p>
<p>优点：</p>
<ul>
<li>与其它功能集成在一起，部署简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li>
</ul>
<p><strong>修改网络层数据包</strong></p>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p>
<p>优点：</p>
<ul>
<li>在内核进程中进行处理，性能比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li>
</ul>
<p><strong>修改链路层数据包</strong></p>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
<p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p>
<h4 id="集群下的-session-管理">集群下的 Session 管理</h4>
<p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p>
<p><strong>Sticky Session</strong></p>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p>
<p>缺点：</p>
<ul>
<li>当服务器宕机时，将丢失该服务器上的所有 Session。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/1623f524-b011-40c8-b83f-eab38d538f76.png" alt="img" style="zoom:50%;" />
<p><strong>Session Replication</strong></p>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p>
<p>缺点：</p>
<ul>
<li>占用过多内存；</li>
<li>同步过程占用网络带宽以及服务器处理器时间。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/40c6570d-c1d7-4c38-843e-ba991b2328c2.png" alt="img" style="zoom:50%;" />
<p><strong>Session Server</strong></p>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p>
<p>优点：</p>
<ul>
<li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要去实现存取 Session 的代码。</li>
</ul>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/fdc45a09-f838-4348-8959-d2c793727788.png" alt="img" style="zoom:50%;" />
<h3 id="缓存">缓存</h3>
<h4 id="缓存特性">缓存特性</h4>
<ul>
<li>命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。</li>
<li>最大空间：缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</li>
<li>淘汰策略：
<ul>
<li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li>
<li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li>
<li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li>
</ul>
</li>
</ul>
<h4 id="缓存应用">缓存应用</h4>
<p><strong>浏览器</strong></p>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p>
<p><strong>ISP</strong></p>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p>
<p><strong>反向代理</strong></p>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p>
<p><strong>本地缓存</strong></p>
<p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p>
<p><strong>分布式缓存</strong></p>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p>
<p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p>
<p><strong>数据库缓存</strong></p>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
<p><strong>Java</strong> 内部的缓存</p>
<p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p>
<p><strong>CPU</strong> 多级缓存</p>
<p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p>
<p><strong>CDN</strong></p>
<p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p>
<p>CDN 主要有以下优点：</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
<h4 id="缓存问题">缓存问题</h4>
<p><strong>缓存穿透</strong></p>
<p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p>
<p>解决方案：</p>
<ul>
<li>对这些不存在的数据缓存一个空数据；</li>
<li>对这类请求进行过滤。</li>
<li>布隆过滤器</li>
</ul>
<p><strong>缓存击穿</strong></p>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>区分击穿与穿透</strong></p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220118101525086.png" alt="image-20220118101525086" style="zoom:50%;" />
<blockquote>
<p>https://www.jianshu.com/p/b144c11e742e</p>
</blockquote>
<p><strong>缓存雪崩</strong></p>
<p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p>
<p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
<p>解决方案：</p>
<ul>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
</ul>
<p><strong>缓存一致性</strong></p>
<p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p>
<p>解决方案：</p>
<ul>
<li>在数据更新的同时立即去更新缓存；</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li>
</ul>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
<p><strong>缓存 “无底洞” 现象</strong></p>
<p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p>
<p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p>
<p>解决方案：</p>
<ul>
<li>优化批量数据操作命令；</li>
<li>减少网络通信次数；</li>
<li>降低接入成本，使用长连接 / 连接池，NIO 等。</li>
</ul>
<h4 id="缓存存储">缓存存储</h4>
<p><strong>传统哈希存储</strong></p>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<p><strong>顺序存储</strong></p>
<p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。</p>
<p>顺序分布相比于哈希分布的主要优点如下：</p>
<ul>
<li>能保持数据原有的顺序；</li>
<li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li>
</ul>
<p><strong>一致性哈希存储</strong></p>
<p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p>
<p>基本原理</p>
<p>将哈希空间 [0, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg" alt="img" style="zoom:60%;" />
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/66402828-fb2b-418f-83f6-82153491bcfe.jpg" alt="img" style="zoom:60%;" />
<p>虚拟节点</p>
<p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p>
<p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>
<h4 id="lru-淘汰算法详解">LRU 淘汰算法详解</h4>
<p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p>
<ul>
<li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li>
<li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li>
</ul>
<h3 id="消息队列">消息队列</h3>
<h4 id="消息模型">消息模型</h4>
<p><strong>点对点</strong></p>
<p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191212011250613.png" alt="img" style="zoom:50%;" />
<p><strong>发布/订阅</strong></p>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20191212011410374.png" alt="img" style="zoom:50%;" />
<p>发布与订阅模式和观察者模式有以下不同：</p>
<ul>
<li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li>
<li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li>
</ul>
<h4 id="使用场景">使用场景</h4>
<p><strong>异步处理</strong></p>
<p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p>
<p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p>
<p><strong>流量削峰</strong></p>
<p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p>
<p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<p><strong>应用解耦</strong></p>
<p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<h4 id="可靠性">可靠性</h4>
<p><strong>发送端的可靠性</strong></p>
<p>发送端完成操作后一定能将消息成功发送到消息队列中。</p>
<p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p>
<p><strong>接收端的可靠性</strong></p>
<p>接收端能够从消息队列成功消费一次消息。</p>
<p>两种实现方法：</p>
<ul>
<li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li>
<li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li>
</ul>
<h3 id="攻击技术">攻击技术</h3>
<p><a href="http://wwww.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.html">http://wwww.cyc2018.xyz/其它/系统设计/攻击技术.html</a></p>
<h2 id="编码实践">编码实践</h2>
<h3 id="面向对象思想">面向对象思想</h3>
<p><strong>封装</strong></p>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<pre><code class="language-java">public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;
    }

    public void work() {
        if (18 &lt;= age &amp;&amp; age &lt;= 50) {
            System.out.println(name + &quot; is working very hard!&quot;);
        } else {
            System.out.println(name + &quot; can't work any more!&quot;);
        }
    }
}
</code></pre>
<p><strong>继承</strong></p>
<p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循 <strong>里氏替换原则</strong>，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p>
<pre><code class="language-java">Animal animal = new Cat();
</code></pre>
<p><strong>多态</strong></p>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<pre><code class="language-java">public class Instrument {

    public void play() {
        System.out.println(&quot;Instument is playing...&quot;);
    }
}

public class Wind extends Instrument {

    public void play() {
        System.out.println(&quot;Wind is playing...&quot;);
    }
}

public class Percussion extends Instrument {

    public void play() {
        System.out.println(&quot;Percussion is playing...&quot;);
    }
}

public class Music {

    public static void main(String[] args) {
        List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}
</code></pre>
<pre><code>Wind is playing...
Percussion is playing...
</code></pre>
<h3 id="正则表达式">正则表达式</h3>
<p>链接：<a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">http://www.cyc2018.xyz/其它/编码实践/正则表达式.html</a></p>
<p>以下为本人摘取的部分内容。</p>
<h4 id="大小写转换">大小写转换</h4>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\l</td>
<td style="text-align:center">把下个字符转换为小写</td>
</tr>
<tr>
<td style="text-align:center">\u</td>
<td style="text-align:center">把下个字符转换为大写</td>
</tr>
<tr>
<td style="text-align:center">\L</td>
<td style="text-align:center">把\L 和\E 之间的字符全部转换为小写</td>
</tr>
<tr>
<td style="text-align:center">\U</td>
<td style="text-align:center">把\U 和\E 之间的字符全部转换为大写</td>
</tr>
<tr>
<td style="text-align:center">\E</td>
<td style="text-align:center">结束\L 或者\U</td>
</tr>
</tbody>
</table>
<p><strong>应用</strong></p>
<p>把文本的第二个和第三个字符转换为大写。</p>
<p><strong>文本</strong></p>
<p>abcd</p>
<p><strong>查找</strong></p>
<pre><code class="language-text">(\w)(\w{2})(\w)
</code></pre>
<p><strong>替换</strong></p>
<pre><code class="language-text">$1\U$2\E$3
</code></pre>
<p><strong>结果</strong></p>
<p>aBCd</p>
<h4 id="嵌入条件">嵌入条件</h4>
<h5 id="回溯引用条件">回溯引用条件</h5>
<p>条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>
<p><strong>正则表达式</strong></p>
<p>子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p>
<pre><code class="language-text">(\()?abc(?(1)\))
</code></pre>
<p><strong>结果</strong></p>
<ol>
<li><strong>(abc)</strong></li>
<li><strong>abc</strong></li>
<li>(abc</li>
</ol>
<h5 id="前后查找条件">前后查找条件</h5>
<p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p>
<p><strong>正则表达式</strong></p>
<p>?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p>
<pre><code class="language-text">\d{5}(?(?=-)-\d{4})
</code></pre>
<p><strong>结果</strong></p>
<ol>
<li><strong>11111</strong></li>
<li>22222-</li>
<li><strong>33333-4444</strong></li>
</ol>
<h3 id="docker">Docker</h3>
<h4 id="解决的问题">解决的问题</h4>
<p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<h4 id="与虚拟机比较">与虚拟机比较</h4>
<p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/be608a77-7b7f-4f8e-87cc-f2237270bf69.png" alt="img" style="zoom:40%;" />
<p><strong>启动速度</strong></p>
<p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<p><strong>占用资源</strong></p>
<p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p>
<p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h4 id="优势">优势</h4>
<p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<p><strong>更容易迁移</strong></p>
<p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<p><strong>更容易维护</strong></p>
<p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p>
<p><strong>更容易扩展</strong></p>
<p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h4 id="使用场景-2">使用场景</h4>
<p><strong>持续集成</strong></p>
<p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p>
<p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
<p><strong>提供可伸缩的云服务</strong></p>
<p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
<p><strong>搭建微服务架构</strong></p>
<p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
<h4 id="镜像与容器">镜像与容器</h4>
<p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<h3 id="git">Git</h3>
<p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html">http://www.cyc2018.xyz/其它/编码实践/Git.html</a></p>
<h3 id="构建工具">构建工具</h3>
<p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">http://www.cyc2018.xyz/其它/编码实践/构建工具.html</a></p>
<h3 id="代码可读性">代码可读性</h3>
<p><a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.html">http://www.cyc2018.xyz/其它/编码实践/代码可读性.html</a></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://javaguide.cn/">JavaGuide</a></li>
<li><a href="http://www.cyc2018.xyz/">CyC2018</a></li>
</ul>
<hr>
<h2 id="过往内容">过往内容</h2>
<h2 id="数据库">数据库</h2>
<h3 id="redis">Redis</h3>
<h4 id="3种集群模式主从-哨兵-集群">3种集群模式：主从、哨兵、集群</h4>
<ul>
<li>主从模式：
<ul>
<li>1个主节点，N个从节点</li>
<li>主节点负责写操作，从节点负责读操作</li>
<li>数据同步</li>
<li>一旦主节点挂了，集群就丧失写功能</li>
</ul>
</li>
<li>哨兵模式
<ul>
<li>主从模式的升级版，添加哨兵</li>
<li>哨兵本质上是一个进程，sentinel进程，负责监控节点状态，如果主节点挂了，会从从节点总竞选得到新的主节点</li>
</ul>
</li>
<li>集群模式
<ul>
<li>主从模式+分区</li>
<li>每个主从集群负责一部分哈希槽</li>
</ul>
</li>
</ul>
<h2 id="并发">并发</h2>
<h3 id="synchronized-和-reentrantlock-的实现及区别">synchronized 和 Reentrantlock 的实现及区别</h3>
<ul>
<li>sychronized 是一个关键字，ReentrantLock 是一个类</li>
<li>sychronized 会自动的加锁与释放锁，ReentrantLock 需要程序员手动加锁与释放锁，因此更灵活，可以根据业务场景进行相应操作</li>
<li>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</li>
<li>sychronized底层有一个锁升级的过程
<ul>
<li>偏向锁：偏向第一次持有锁的线程，该线程无需进行同步操作</li>
<li>轻量级锁：自旋，CAS</li>
<li>重量级锁：线程阻塞时，需要将用户态转到内核态</li>
</ul>
</li>
<li>实现
<ul>
<li>synchronized：锁的是对象，锁信息保存在对象头中，可以是实例对象也可以是类对象<br>
6. 对象：使用汇编指令monitorenter和monitorexit<br>
6. 方法：使用ACC_SYNCHRONIZED标识符，本质上也是monitor的操作</li>
</ul>
<ol start="6">
<li>ReentrantLock：通过代码中的state标识来标识锁的状态</li>
</ol>
</li>
</ul>
<h3 id="cas的缺点">CAS的缺点</h3>
<ul>
<li>ABA问题、CPU空转问题</li>
</ul>
<h3 id="线程池实现机制-配置参数-使用注意点">线程池实现机制、配置参数、使用注意点</h3>
<p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：</p>
<ul>
<li>如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建<br>
新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入<br>
缓冲队列。</li>
<li>如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等<br>
于maximumPoolSize，那么通过handler所指定的策略来处理此任务。</li>
<li>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</li>
</ul>
<p>配置参数：</p>
<ul>
<li>corePoolSize：目的是更有效地利用CPU资源
<ul>
<li>CPU密集型：CPU核数+1，之所以+1，是为了更优的利用率</li>
<li>IO密集型：CPU 核心数 * (1 + IO 耗时/ CPU 耗时)</li>
</ul>
</li>
<li>MaximumPoolSize、workQueueSize、handler拒绝策略、keepAliveTime</li>
</ul>
<p>注意点：</p>
<ul>
<li>线程池预热方法：prestartAllCoreThreads()</li>
</ul>
<h3 id="如何防止超卖现象">如何防止超卖现象</h3>
<ul>
<li>redis缓存和mysql同步更新</li>
<li>减库存排队，使用窗口进行合并</li>
</ul>
<h2 id="jvm">JVM</h2>
<h3 id="gc">GC</h3>
<h4 id="cms-g1的优缺点">CMS、G1的优缺点</h4>
<p>CMS是老年代的垃圾回收器，用的是标记清除算法，所以会产生内存碎片，但是因为它的回收原理是并发回收，因此STW时间较短。</p>
<p>G1是面向整个堆的垃圾回收器，同时将分区的思想与分代相结合，每次回收时，都会去挑选需要回收的分区，使用的算法是标记整理算法，是jdk9默认的收集器，同时G1可以控制STW的时间，如果到达指定的STW时间，对于剩下的分区，就不进行回收，从而可以控制STW的时间。</p>
<h3 id="如何处理线上的oom">如何处理线上的OOM</h3>
<p>-Xms表示初始堆内存大小，memory startup</p>
<p>-XmX表示最大堆内存大小，memory maximum</p>
<p>-Xmn表示新生代内存大小，包括初始值和最大值，memory nursery/new</p>
<p>示例：-Xms16m -Xmx32m</p>
<p>通过参数配置，让java进程在OOM时自动产生dump文件，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp</p>
<p>通过命令行导出dump文件，jmap -dump:live, file=jmap.hprof [PID]</p>
<p>通过jvisualvm分析dump文件，分析哪些对象比较占内存</p>
<p>两种可能</p>
<ul>
<li>对象确实太大了</li>
<li>内存泄漏：各种连接，如果不手动关闭，则会被GC认为是不可回收的对象，导致内存泄漏</li>
</ul>
<h2 id="网络编程">网络编程</h2>
<h3 id="netty">Netty</h3>
<h4 id="了解reactor模型吗">了解Reactor模型吗？</h4>
<p>问题拆解：与Netty是什么关系，有几种类型，各自的优势是什么</p>
<p>Netty 是一个广泛使用的 Java 网络编程框架</p>
<p>Reactor是1995年由道格拉斯提出的一种高性能网络编程模式，一共有3种形式，单线程Reactor、多线程Reactor和主从多线程Reactor。</p>
<ul>
<li>
<p>单线程Reactor：由一个线程处理连接请求、读写操作</p>
</li>
<li>
<p>多线程Reactor：由一个线程处理连接请求，由线程池处理读写操作。但一个线程依旧可以处理多个读写操作。</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/Bule-Zst/picture/raw/master/6463324-1f7a2d77cfa17720.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>主从Reactor：由一个线程池处理连接请求，并将连接好的请求发送给读写线程池进行处理。</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/Bule-Zst/picture/raw/master/6463324-a94066924053c037.png" alt="img" loading="lazy"></figure>
</li>
<li>
<p>优势：不同形式适应不同的场景</p>
</li>
</ul>
<h4 id="bytebuf实现原理">ByteBuf实现原理</h4>
<p>在java nio中提供了ByteBuffer作为字节容器，包括4个属性</p>
<ul>
<li>mark：调用mark()方法时，将position的值赋值给mark；调用reset()方法时，将mark的值赋值给position</li>
<li>position：下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新</li>
<li>limit：缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量</li>
<li>capacity：缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变</li>
<li>读写模式切换：flip()方法</li>
</ul>
<p>netty提供了ByteBuf作为字节容器，包括3个属性</p>
<ul>
<li>readIndex、writerIndex、capacity：字面意思</li>
<li>discardReadBytes()：清空已读部分，利用System.arraycopy()方法</li>
</ul>
<h2 id="rpc">RPC</h2>
<h3 id="dubbo">Dubbo</h3>
<h4 id="spi机制了解吗">SPI机制了解吗</h4>
<p>Java SPI：全称 Service Provider Interface，为接口指定实现类，放在 META-INF/services/ 目录里</p>
<p>Java SPI的缺点：无法按需加载实现类，只能逐个进行加载，可能存在某个实现类，很耗资源，但又用不上</p>
<p>Dubbo SPI的优点：</p>
<ul>
<li>可以根据名称，按需加载。原理：在配置文件中由用户提供 名称-类全限定名 的键值对</li>
</ul>
<h4 id="负载均衡算法-2">负载均衡算法</h4>
<ul>
<li>权重随机算法：获取随机数，然后依次减去每个invorker的权重，直到小于0；如果权重相同，则直接随机</li>
<li>权重轮询算法：每次增加当前权重，选出大于当前权重的invorkers，然后从中按顺序选择</li>
<li>最少活跃调用数算法：每次选出最小活跃的invorker，活跃数为invorker正在处理的请求数，如果不止一个，则对于这些invorkers，使用权重随机算法。</li>
<li>一致性Hash算法：环形Hash空间，虚拟节点，对象迁移，寻找最近节点</li>
</ul>
<h2 id="设计思想">设计思想</h2>
<h3 id="api的设计原则">API的设计原则</h3>
<ul>
<li>单一原则</li>
<li>升级兼容性</li>
<li>幂等设计</li>
</ul>
<h3 id="领域建模">领域建模</h3>
<p>DDD 领域驱动设计</p>
<p>建模：对业务的抽象</p>
<p>领域建模：将建模过程划分成4层：UI 层、应用层、领域层、基建层</p>
<ul>
<li>UI层：负责展示</li>
<li>基建层：负责存储</li>
<li>领域层：负责存储过程中的业务逻辑，只关心是否合法，不管是否合理，例如下订单的操作，设计创建订单和减库存，应该在领域层，而不是应用层</li>
<li>应用层：负责核心业务逻辑，例如，黑名单的业务，应该在应用层，而不应该在领域层</li>
</ul>
<p>参考：https://www.zhihu.com/question/25089273</p>
<h2 id="实战">实战</h2>
<h3 id="做的项目遇到什么问题如何解决">做的项目，遇到什么问题，如何解决</h3>
<h2 id="参考资料-2">参考资料</h2>
<ul>
<li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">分布式事务，这一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/paddix/p/5367116.html">Java并发编程：Synchronized及其实现原理</a></li>
<li><a href="https://blog.csdn.net/kusedexingfu/article/details/103744202">JVM的GC 参数为什么要这么命名：xms、xss、xmn和xmn?</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1578846">未关闭的文件流会引起内存泄露么？</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/3696849.html">Netty中的三种Reactor（反应堆）</a></li>
<li><a href="https://www.jianshu.com/p/3930150bf7f0">Netty系列-一分钟了解ByteBuffer和ByteBuf结构</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/108256452">阿里面试真题：Dubbo的SPI机制 敖丙</a></li>
<li><a href="https://www.jianshu.com/p/60c10eabdfaf">Dubbo负载均衡算法实现</a></li>
<li><a href="https://www.cnblogs.com/twoheads/p/10135896.html">一致性哈希算法(consistent hashing)</a></li>
<li><a href="https://www.bilibili.com/video/BV1Lq4y1S7Rc?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1632973331&amp;unique_k=BEotpJ">朋友投稿！与面试官死磕中间件与库存设计！顺利斩获大厂Offer！</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[春招保卫战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-12-10-春招保卫战/">
        </link>
        <updated>2021-12-10T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录与春招相关的一些内容，包括：</p>
<ul>
<li>明年3月份春招（暑期实习）的备战计划</li>
<li>春招过程中需要注意的地方</li>
</ul>
<hr>
<h2 id="备战阶段">备战阶段</h2>
<h3 id="前言">前言</h3>
<p>Java技术栈+计算机基础+算法+项目+加分项（竞赛/开源项目/博客）</p>
<p>大公司更看重基础知识（八股文），小公司更看中现有能力</p>
<p>边面试边准备，不要等完全准备好再去面试</p>
<h3 id="笔试算法">笔试（算法）</h3>
<ul>
<li><a href="https://www.lintcode.com/cat/">lintcode CAT模式 天梯上分</a></li>
<li><a href="https://codetop.cc/home">CodeTop 汇总互联网大厂面试的高频考题 帮助面试者更有针对性地准备面试</a>
<ul>
<li>可直接定位特定公司、部门的面试题</li>
<li>学长学姐都比较推荐</li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/study/live/489/1/1">左神算法笔面试真题精讲</a></li>
<li><a href="https://www.nowcoder.com/ta/exam-bytedance">牛客网 名企编程真题</a>（企业真题可以多刷刷头条 网易 拼多多）</li>
<li><a href="https://www.nowcoder.com/ta/coding-interviews">牛客网 剑指offer</a></li>
<li><a href="https://www.nowcoder.com/ta/leetcode">牛客网 经典必刷编程题库</a></li>
<li><a href="https://www.nowcoder.com/ta/job-code-high">牛客网 名企高频面试题</a></li>
<li><a href="https://leetcode-cn.com/problem-list/2cktkvj/">LeetCode 热题 HOT 100 官方</a></li>
<li><a href="https://leetcode-cn.com/problem-list/2ckc81c/">LeetCode 精选 TOP 面试题 官方</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/158977583">leetcode 精选 by sergio</a></li>
<li><a href="https://www.yuque.com/office/yuque/0/2020/pdf/619289/1605766958275-87ed48a3-0a68-4433-9d3c-b4ea9c829ccb.pdf?from=https%3A%2F%2Fwww.yuque.com%2Fshenjingwa-o51xg%2Fyh6opc%2Fsqqfew%2Fedit">leetcode 精选</a></li>
<li><a href="https://www.zhihu.com/question/24964987/answer/182447205">lintcode 精选</a></li>
<li><a href="https://www.changgy.com/leetcode-101">LeetCode 101：和你一起你轻松刷题（C++）</a></li>
<li><a href="https://javaguide.cn/cs-basics/algorithms/%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/">JavaGuide</a></li>
<li><a href="http://www.cyc2018.xyz/#%E7%AE%97%E6%B3%95">Cyc2018</a></li>
</ul>
<h3 id="面试题java技术栈计算机基础">面试题（Java技术栈+计算机基础）</h3>
<p><strong>刷面经！</strong></p>
<p>备战阶段，就不要去看书或者视频了，书和视频都是用来系统学习知识的，备战阶段要的就是突击！应试！直接刷 <strong>面试题</strong> 就好~</p>
<h4 id="面经">面经</h4>
<p>面试题：</p>
<ul>
<li><a href="">自己的春招面经 待补充</a></li>
<li><s><a href="https://www.nowcoder.com/discuss/455889?channel=-2&amp;source_id=discuss_terminal_discuss_sim">牛客网 字节提前批 客户端 三轮面经</a></s></li>
<li><a href="https://www.nowcoder.com/discuss/630359?type=2&amp;order=0&amp;pos=13&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=b147450b14934df290b4f5d60279fc4e.211.16436068164962340&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1643606814017">** 牛客网 阿里云 开放平台 java后端 2021暑期实习 一二面hr面</a></li>
<li><a href="https://www.nowcoder.com/discuss/experience?tagId=639">牛客网 Java工程师精选面经合集</a></li>
<li><a href="https://www.nowcoder.com/subject/index/e75efed65dc34f88ad80304f282320f0">牛客网 话题 #实习经验分享#</a></li>
<li><a href="https://www.nowcoder.com/subject/index/dd10269469cc48fa97fc5b0e183d2878">牛客网 话题 #阿里巴巴暑期实习#</a></li>
<li><s><a href="https://zhuanlan.zhihu.com/p/438229187">字节</a> （后面的广告，直接忽略即可）（没看，不是牛客网上的，对质量存疑）</s></li>
<li><a href="https://www.nowcoder.com/discuss/293661?from=zhnkw">合集</a></li>
<li><a href="https://mp.weixin.qq.com/s/i29juUTnfOKZQIeY08l4RA">其他</a></li>
<li><a href="https://www.nowcoder.com/discuss/762719?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">合集 南大 22届 硕 Java后端</a></li>
<li><a href="https://www.nowcoder.com/discuss/629687?source_id=profile_create_nctrack&amp;channel=-1">微软+蚂蚁 南大 22届 硕 Java后端 实习面经</a></li>
<li><a href="https://www.nowcoder.com/discuss/802981?type=all&amp;order=recall&amp;pos=&amp;page=2&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">合集</a></li>
<li>cxy师兄-面经.docx</li>
<li><a href="https://pan.baidu.com/s/1yCCeNMb0FNCJKDIE6EASYA#list/path=%2F">大厂面经合集：美团、腾讯、字节、虾皮 各方向都有</a> 提取码【lrp3】 解压码【jk7z】</li>
<li><a href="https://www.nowcoder.com/discuss/172152">合集 C++ 基础架构方向</a></li>
</ul>
<p>心路历程：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/56655579">cyc2018大佬的面经</a></li>
<li><a href="https://www.nowcoder.com/discuss/762719?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">南大 22届 硕 Java后端</a></li>
</ul>
<h4 id="八股文">八股文</h4>
<p>第一遍刷，抓大放小</p>
<p>要形成自己的八股文文档，方便后期复习</p>
<ul>
<li>
<p><a href="http://bule-zst.gitee.io/2021-09-30-JavaHan/">JavaHan</a></p>
</li>
<li>
<p><a href="https://javaguide.cn/">JavaGuide</a></p>
</li>
<li>
<p><a href="https://cyc2018.github.io/CS-Notes/#/">JavaCyc</a></p>
<ul>
<li>
<p>整理了<a href="http://www.cyc2018.xyz/">cyc2018</a>各部分内容pdf版的页数，方便做计划</p>
  <img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211221102750329.png" style="zoom:60%;" />
</li>
</ul>
</li>
<li>
<p><a href="http://passjava.cn/#/88.Interview/01.Redis/Redis1">PassJava-面试必备</a></p>
</li>
<li>
<p><a href="https://github.com/cosen1024/Java-Interview">「Java面试小抄」一份通向理想互联网公司的面试指南，包括 Java基础、集合、Java并发、JVM、MySQL、Redis、Spring、MyBatis、Kafka、操作系统、计算机网络、系统设计、分布式、Java 项目实战等 by 库森</a></p>
</li>
<li>
<p><a href="https://www.zhihu.com/column/c_1339954942191271936">大厂面试 by 程序员库森</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/820419?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=AAA94FB88430FBA90598250546CE372D-1639365563652">对线面试官系列之Java集合--面试官看了都说好</a></p>
</li>
<li></li>
<li>
<p>下面内容主要整理了需要掌握的知识点，但是没有答案，可以先看上面的内容，下面的查缺补漏时用</p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/61438?from=zhnkw">JAVA后端秋招/春招准备方向</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/359264954">2021春招Java后端开发面试总结【25个技术专题】超详细！</a></p>
</li>
</ul>
<h3 id="项目">项目</h3>
<ul>
<li>
<blockquote>
<p>从需求开始，把整个项目的流程讲明白、讲透彻</p>
<p>介绍项目时，可以埋彩蛋，引导面试官提问</p>
<p>正反说：</p>
<p>​		数据库查询比较快，因为用了索引</p>
<p>​		系统比较慢，通过分析发现是数据库查询比较慢，然后用索引进行了优化</p>
<p>微软宣讲会 Kaifeng</p>
</blockquote>
</li>
<li>
<blockquote>
<p>问项目，问得很细，每一步是怎么实现的，过程，如果不是自己亲手一步一步做绝对会露馅</p>
<p>做项目时遇到了什么困难</p>
<p>https://www.nowcoder.com/discuss/455889?channel=-2&amp;source_id=discuss_terminal_discuss_sim</p>
</blockquote>
</li>
<li>
<blockquote>
<p>对实习项目的描述还不够好，没有把实习内容的闪光点描述出来，也没有讲清楚为什么做这个项目，自己通过什么方法去做，以及最后的结果</p>
<p>cyc2018面经 https://zhuanlan.zhihu.com/p/56655579</p>
</blockquote>
</li>
<li>
<p>如何描述自己的项目：</p>
<ul>
<li>
<p>https://www.cnblogs.com/JavaArchitect/p/7586949.html</p>
<ul>
<li>
<table>
<thead>
<tr>
<th>要素</th>
<th>样式</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景，技术，数据库和其他和技术有关的信息。</td>
<td>我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到 JS 等技术，后台用到Java的SSH，几个人做了X个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。</td>
</tr>
<tr>
<td>要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。</td>
<td>我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月</td>
</tr>
<tr>
<td>描述你在项目里的角色</td>
<td>我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。</td>
</tr>
<tr>
<td>可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个。</td>
<td>用到了Java里面的集合，JDBC等技术，用到了Spring MVC等框架，用技术连接数据库。</td>
</tr>
<tr>
<td>（这部分的风险自己承担）如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。</td>
<td>这个系统是部署在 Linux 上的，每天要处理的数据量是XX，要求是在4小时，1G内存是的情况下处理完5千万条数据。平均访客是每分钟XXX。</td>
</tr>
</tbody>
</table>
</li>
<li>
<table>
<thead>
<tr>
<th>要避免的情况</th>
<th>正确的做法</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>回答很简单。问什么答什么，往往就用一句话回答</td>
<td>把你知道的都说出来，重点突出你知道的思想，框架</td>
<td>问：你SSH用过吗？答：用过。问：在什么项目里用到？答：一个保险项目问：你做了哪方面的事情？答：开发。面试官直接不问了</td>
</tr>
<tr>
<td>说得太流利</td>
<td>适当停顿，边思考边说</td>
<td>让面试官感觉你在背准备的东西，这样后面问题就很难</td>
</tr>
<tr>
<td>项目介绍时什么都说</td>
<td>就说些刚才让准备的一些，而且要有逻辑地说</td>
<td>会让面试官感觉你思路太乱</td>
</tr>
<tr>
<td>过多介绍技术细节</td>
<td>相关技术点到为止，就说你熟悉的技术，等面试官来问</td>
<td>你说到的所有技术要点，都可能会被深问。面试官一般会有自己的面试节奏，如果你在介绍时就太多说技术细节，很有可能被打断，从而没法说出你准备好的亮点。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>这里只列出了部分，具体内容可以看链接，感觉写的挺好的</p>
</li>
</ul>
</li>
<li>
<p>https://zhuanlan.zhihu.com/p/121136858</p>
</li>
<li>
<p>如何介绍自己的项目：STAR法则（背景+目标+行动+结果）：</p>
<ul>
<li>
<p>基本信息：</p>
<ul>
<li>背景+目标：要做什么</li>
<li>项目整体功能</li>
</ul>
</li>
<li>
<p>重点：</p>
<ul>
<li>
<p>行动：干了什么</p>
<ul>
<li>
<p>简短</p>
<ul>
<li>负责的模块</li>
<li>担任的角色与职责</li>
<li>所用的技术点
<ul>
<li>用了什么技术，同类型的技术有哪些，有什么区别，为什么选择这个</li>
<li>介绍时，只需要提用了什么技术，但是后面 3 个问题需要提前准备，防止面试官问</li>
</ul>
</li>
</ul>
</li>
<li>
<p>详细</p>
<ul>
<li>难点是什么（不知道如何实现 或者 实现后出现了bug）</li>
<li>亮点是什么</li>
<li>技术点：</li>
</ul>
</li>
</ul>
</li>
<li>
<p>结果：</p>
<ul>
<li>项目性能、项目成果</li>
<li>对项目的<strong>思考</strong>（优化点和不足）以及<strong>收获</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="智力题">智力题</h3>
<ul>
<li>智力题（或者叫，逻辑思维题、脑筋急转弯），需要提前准备一下</li>
</ul>
<h3 id="简历">简历</h3>
<ul>
<li>专业技能，注明熟练度：熟悉、熟练掌握、精通</li>
<li>不要罗列技术，而是突出，自己通过 XX 技术实现了什么</li>
<li>简历命名：姓名+学校+岗位</li>
<li><a href="https://www.zhihu.com/zvideo/1289637611880026112?utm_source=qq&amp;utm_medium=social&amp;utm_oi=747689983887814656">建议收藏！小白简历这样改，一秒成为优秀简历！秋招必备，让你offer拿到手软！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2OTY4Nzk1Mw==&amp;mid=2247485451&amp;idx=1&amp;sn=6a722f682d1df07404cc79b5aaf41a87&amp;chksm=fcfba2f5cb8c2be30908bc0bf2146c8203d4f055780d6b64d9b2e5570d96b5b0bfae9d872432&amp;scene=21#wechat_redirect">通过 BAT 面试的程序员简历长什么样? 附简历模板</a></li>
<li><a href="https://cyc2018.github.io/page.html">cyc2018 大佬的网页简历</a></li>
</ul>
<h2 id="春招开始">春招开始</h2>
<h3 id="投递">投递</h3>
<h4 id="心得">心得</h4>
<ul>
<li>
<p>海投！一定要海投！</p>
<ul>
<li>疯狂面试，可以积累经验</li>
<li><strong>但有一点需要注意</strong>，就是如果最终拿到实习资格，然后拒掉，会不会影响后期秋招？这个到时候要再确认一下。</li>
<li>对于一些自己不想去的公司或者部门，也可以试着投递，增加经验（如果是部门，提前了解清楚投递会不会影响到自己想去的部门）</li>
</ul>
</li>
<li>
<p>早投递机会更大</p>
</li>
<li>
<p>知乎了解一下boss直聘，到时候找实习，可以把简历放到boss直聘上</p>
</li>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>首先就是策略，一开始最好不要立刻投大厂，因为一上来就面大厂的话容易崩，刚开始面的人少所以难度也会相对高一些，有的还凑合的会被大厂当备胎，很难受的。其次就是能内推就不要走官网，能免笔试免笔试，不是说笔试难度大还是咋地，这玩意其实是玄学，因为你说你一个人做呢没问题，大神嘛无所谓但是你保不齐别人是一个实验室或者一个班级的人在做，如果遇到点坑的题目，你交代了，别人合作做出来了那你被挂能怪谁呢。还有就是如果大家也是合作做题的话，oj的查重或者作弊系统的判别现在越来越严，如果保不齐你被抓到了，可能就被企业拉黑，然后你还不知道，后面怎么投都没面试机会这是最惨的。还有就是大家都是一起做的，然后分数也差不多，但是别人接到了面试而你没有，我就遇到了这样的情况，就很玄学我都怀疑是随机选的人面试。反正就是笔试有风险，大家还是抱紧学长学姐的大腿，能走内推就内推。但是内推之前还是需要能够了解一下这个部门，大概是做什么的，hc的数量以及技术氛围，这点其实很重要，因为一旦进了流程，你反悔就来不及了，如果过了之后还想换部门那只能重新面试，再走一遍别说多恶心了。其实哪个部门最好或者哪个部门最有前景啥的这些问题，真的很难了解的非常清楚，我就纠结过很久很久，这种事情找不到最优解的，不过还好对我而言现在只是实习。</p>
</blockquote>
</li>
<li>
<p>先拿到保底offer，这样心态会好很多</p>
</li>
</ul>
<h4 id="部门信息整理">部门信息整理</h4>
<p><a href="https://duibiao.info/">职级对标 互联网相关信息查询（作息、薪资、评价）</a></p>
<p>事业群 &gt; 部门 &gt; 中心 &gt; 小组</p>
<ul>
<li>
<p>微众：</p>
<ul>
<li>贷款科技部：<strong>很核心</strong></li>
</ul>
</li>
<li>
<p>阿里系：</p>
<ul>
<li>阿里集团（简称集团）
<ul>
<li>阿里云：很香</li>
<li>天猫精灵团队：</li>
<li>钉钉：</li>
<li>一面、二面、总监面、交叉部门主管面、HR面；每一面都有一票否决权（包括HR面）</li>
<li>转正是否成功，很大程度上取决于HR</li>
</ul>
</li>
<li>蚂蚁
<ul>
<li>CTO线-数据与平台技术事业群-蚂蚁智能引擎与数据中台技术事业部-大数据部
<ul>
<li>一面、二面、笔试、三面、四面、HR面</li>
</ul>
</li>
</ul>
</li>
<li>听同学群里讨论，集团没有蚂蚁好，至少薪资福利这块，没有蚂蚁好</li>
<li>重视项目</li>
</ul>
</li>
<li>
<p>百度：</p>
<ul>
<li>工程效率部门：做内部工具的，对个人成长并不好</li>
<li>企业智能平台：主要是内部系统，虽然会接触到机器学习和大数据，不太好</li>
</ul>
</li>
<li>
<p>字节：</p>
<ul>
<li>基础架构</li>
<li>今日头条：薪资很诱人
<ul>
<li>头条加面有两种情况，一是三轮评级都是 4 可以评 SSP，二是面试官评价差别很大，再面一轮决定是否录用</li>
</ul>
</li>
<li>Data：核心部门</li>
<li>一面、二面、三面，就可以offer了</li>
<li>重视算法</li>
</ul>
</li>
<li>
<p>荣耀：</p>
<ul>
<li>产品线部门：</li>
</ul>
</li>
<li>
<p>Vivo：</p>
</li>
<li>
<p>华为：</p>
<ul>
<li>Cloud Bu：不错</li>
<li>车BU智能座舱产品部</li>
<li>南研所消费者 BG</li>
<li>cyc2018 拿到了十四级最高的薪资</li>
<li>不怎么问技术，重视学历</li>
</ul>
</li>
<li>
<p>华泰证券</p>
<ul>
<li>信息技术部：base南京</li>
</ul>
</li>
<li>
<p>网易</p>
<ul>
<li>杭研院</li>
<li>网易互联网</li>
<li>网易雷火</li>
</ul>
</li>
<li>
<p>TP-Link</p>
</li>
<li>
<p>腾讯</p>
<ul>
<li>微信事业群：gc学长说 挺好的</li>
<li>上海CSIG：很差</li>
<li>重视算法</li>
</ul>
</li>
<li>
<p>深兰科技</p>
</li>
<li>
<p>创新奇智</p>
</li>
<li>
<p>便利蜂</p>
</li>
<li>
<p>携程旅行</p>
</li>
<li>
<p>旷视</p>
</li>
<li>
<p>小米</p>
</li>
<li>
<p>bilibili</p>
</li>
<li>
<p>商汤</p>
</li>
<li>
<p>度小满</p>
</li>
<li>
<p>美团</p>
<ul>
<li>金服：</li>
<li>到店：</li>
<li>重视项目</li>
</ul>
</li>
<li>
<p>拼多多</p>
</li>
<li>
<p>贝壳</p>
</li>
<li>
<p>快手</p>
</li>
<li>
<p>360</p>
</li>
<li>
<p>外企</p>
<ul>
<li>
<p>微软</p>
<ul>
<li>STCA-M365
<ul>
<li>笔试、一面、Leader面</li>
</ul>
</li>
<li>3轮技术面+1轮AA面，AA面最终决定是否通过</li>
</ul>
</li>
<li>
<p>亚马逊</p>
</li>
<li>
<p>谷歌</p>
</li>
<li>
<p>虾皮</p>
</li>
<li>
<p>重视算法</p>
</li>
</ul>
</li>
</ul>
<h4 id="待投">待投</h4>
<ul>
<li><s><a href="https://mp.weixin.qq.com/s?__biz=MzU1MTU2NjcxMQ==&amp;mid=2247504396&amp;idx=1&amp;sn=200877c58bd016dbd5d66aefbee154a3&amp;chksm=fb8dfe14ccfa770246c8c5ffd15eb455fea3c1e307ecb0f16ef8365c61463f6bde033c40850d&amp;mpshare=1&amp;scene=23&amp;srcid=1216AelYAleMD4XYJuv0n2FJ&amp;sharer_sharetime=1639639282713&amp;sharer_shareid=02cdcbb08350c969c2db9d032c863a6d#rd">微软 提前批 22.1.1</a> 放弃 觉得自己没有准备好</s></li>
<li><s>宝洁 22.1.14  <a href="https://mp.weixin.qq.com/s/STCpEoSpSLIntZglntZJfw">官网</a> <a href="https://mp.weixin.qq.com/s/1hKslZkERA8okJuSfhX6rw">实习僧链接</a> 放弃 还没准备好</s></li>
<li>字节 日常实习</li>
<li>微软 正式批 22.1.17
<ul>
<li><a href="https://mp.weixin.qq.com/s/0kwiVC9tAH5GeaIE60dOqw">微软校招 | 2022暑期实习招聘正式启动！</a></li>
<li><a href="https://docs.qq.com/doc/DV0NGWmVhVGFPR1dz">微软2022暑期实习招聘 - 求职干货大宝书</a></li>
</ul>
</li>
<li>宽德投资
<ul>
<li><a href="https://mp.weixin.qq.com/s/6BoymRfQs2j0HkXMQK40gQ">春招提前批，速拿OFFER | 宽德投资2022校招 - 信息技术部专场</a></li>
<li>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220114111046898.png" alt="image-20220114111046898" style="zoom:30%;" />
</li>
</ul>
</li>
</ul>
<h4 id="方向">方向</h4>
<ul>
<li>核心业务 &gt; 核心业务基础架构 &gt; 边缘业务基础架构 &gt; 边缘业务</li>
<li>尽量不要去内部系统开发</li>
</ul>
<h3 id="面试中">面试中</h3>
<ul>
<li>
<p>面试中写算法题，要多和面试官交流</p>
<ul>
<li>写之前，问清楚数据量、数据约束</li>
<li>写的过程中，边写边阐述思路</li>
</ul>
</li>
<li>
<p>说话不要太急、平和、不咄咄逼人（仅针对我自己）</p>
</li>
<li>
<p>面试中考察算法题，能给出解决方案当然最好，但同样重要的是<strong>展示</strong>，因为是在面试，哪怕想出解决方案了，如果不能很好的展示，也是没用的。要学会清晰展示自己的思考过程、思路，还可以多和面试官进行交流。</p>
<ul>
<li>思路和沟通能力，比解出答案更重要</li>
</ul>
</li>
<li>
<p>反问的时候可以问：</p>
<ul>
<li>是哪个部分、部门主要是做什么的</li>
<li>面试流程：一共有几面</li>
<li>面试表现</li>
<li>对于提升自己，面试官有什么建议</li>
</ul>
</li>
<li>
<p>职业规划</p>
</li>
<li>
<p>准备一段最能体现我编程能力的代码 https://www.nowcoder.com/discuss/425657?channel=-1&amp;source_id=subject_nctrack</p>
</li>
<li>
<p>面试前提前准备一下</p>
<ul>
<li>“为什么投我们公司或者我们小组或者后台研发”
<ul>
<li>平台比较大，对自身发展有帮助</li>
<li>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20220204111621730.png" alt="image-20220204111621730" style="zoom:30%;" />
</li>
</ul>
</li>
<li>评价一下自己前几面的表现</li>
</ul>
</li>
<li>
<p>演技</p>
<ul>
<li>最近读了哪些书：假装读过，然后往八股文引</li>
<li>脑筋急转弯：不要直接给最优解，体现思考过程</li>
</ul>
</li>
<li>
<p>软实力</p>
<ul>
<li>保持自信</li>
<li>学会用积极的情绪感染面试官，提供情绪价值
<ul>
<li>活泼一点、积极向上、大大方方、自然不拘谨</li>
</ul>
</li>
</ul>
</li>
<li>
<p>回答面试官问题时，可以用生动形象的例子，这样可能效果更好，也能体现自己的思考</p>
</li>
<li>
<p>引导面试官</p>
<ul>
<li>面试时灵活点，不要太憨，学会引导面试官</li>
<li>聊项目时，可以引导到八股文</li>
</ul>
</li>
<li>
<p>面试前，看一看对应公司的面经，提前做准备</p>
</li>
<li>
<p>面试时问一下对方是哪个部门的，方便后续面试时做相应的准备</p>
</li>
<li>
<p><a href="https://b23.tv/ajxmk5">如何回答面试官最后一个问题——钻石版-哔哩哔哩</a></p>
</li>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>其次就是面试总结了。面试过程当中我建议大家开启手机录音。这样方便事后复盘，我是每次都会再听一遍自己的录音，不论是写面经还是琢磨自己的回答有录音真的方便很多。因为面试期间的紧张感会让你很难用最好的描述回答清楚问题，那么事后总结就会让你在下次遇到同样的问题的时候回答的更好。如果说大家有小伙伴在一起战斗的话那么经常互相分享经验真的会决定你能不能拿到offer，大家的经验会让你迅速成长，说实话面试实习这2月也是我成长的最快的一个阶段。<br>
最后就是信息。在面试结束的时候，一般面试官都会问：你有什么问题问我。这个时候我个人最经常问的就是这个部门正在做什么，如果我进来我会接触到什么。面试官才是最了解这个部门的人，只有从他的口里得到的信息才是最真实也是最有用的，通过他的回答你会了解到这个部门做的产品或者是使用的技术，对于自己的学习方向也有很大的指向作用。其次，我会问的问题就是：您认为我在哪些方面可以提高自己。这个问题其实从侧面可以让你获取你此次面试的结果。因为这个问题不像问我面试能不能过这样直白的面试禁忌。一般面试官会指明他认为你的缺点，如果他在说的时候带有建议的语气以及对你其他方面的肯定那基本是十拿九稳了，再不济有大佬对你的一个建议指导对你自己查漏补缺也是非常有帮助的。说下我自己的经历吧，我在面阿里云3面的时候，那位p9大佬在我问完这个问题之后不仅肯定了我的一些表现还给我推荐了2本书建议我去阅读，这真的是非常良好的面试体验。</p>
</blockquote>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/56655579">cyc2018大佬的面经</a> 读后总结：</p>
<ul>
<li>
<p>对于面试官的问题，要能回答到点上；对于自己擅长的知识点，要学会展开讲。</p>
</li>
<li>
<p>面试过程中，要表现得比较自信（不要自大，也不要自卑）</p>
</li>
<li>
<p>这次面试我表现地非常自信，自己知道的知识都很有信心地表达出来，被问到不会的内容也不会那么慌张，和面试官探讨一些细节，然后说说自己的想法，还有自己看过相关的内容</p>
</li>
<li>
<p>整个春招过程中，会被拒很多次，但要时刻保持信心</p>
</li>
<li>
<p>要学会把问题往自己擅长的领域引</p>
</li>
<li>
<p>当被问到没有掌握的知识，可以通过讨论的方式，给出大概的思路，因为很多技术都是相通的</p>
</li>
<li>
<blockquote>
<p>位运算的问题，面试官让我之后完善了再发给他，过后我写了详细文档讲解了思路，以及使用 JUnit 进行了详细的单元测试，把文档和代码都发给了他</p>
</blockquote>
</li>
<li>
<blockquote>
<p>非技术问题回答的支支吾吾，然后面试官开始质疑我说的内容，给我压力，我没有当场反驳，就说了“哦，好像是这样的”。因为面试官全程都绷着脸，所以我也比较紧张，很多问题没回答好。</p>
<p>这次面试失败的主要原因是自己在应对这种压力时处理地不是很好，主要体现在失去信心以及紧张。</p>
<p>解决方法也简单，做好充分准备来保持信心，受到质疑的时候积极反驳，紧张的时候及时调整心态，可以试试深呼吸或者喝水。</p>
</blockquote>
</li>
<li>
<p>面试中还会涉及到非技术性问题，要有心理准备</p>
</li>
<li>
<blockquote>
<p>面完之后我立马查了一下那个错排问题，证实了我的答案是正确的，于是写了一个详细的文档，联系 HR 让她发给面试官</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>面试回答不要太简单，适当展开，把知道的都说出来</p>
</li>
<li>
<blockquote>
<ol>
<li>
<p><strong>保持谦逊的态度。</strong>：不要不懂装懂，不会的问题可以自己分析并提出自己的见解，对面试官提出的问题，<strong>可以当成和面试官的一次讨论</strong>，不要紧张。<strong>不会的问题，可以在最后的提问环节，再和面试官深入探讨一波</strong></p>
</li>
<li>
<p><strong>展示对知识的热情</strong>。对面试官提出的问题，你一定要绘声绘色的去回答，讲出自己的理解，而不是非常死板的死记硬背。知识是背下来的还是真正理解的，一般老辣的面试官深入问一下就心里有数了，当然这个是建立你对知识充分了解的基础上。</p>
</li>
<li>
<p>**能说什么就说什么。**面试的时候，永远不是看你知不知道，而是看你知道多少，所以说面试官提出问题，<strong>你在思考的时候，一定要简单提一下你的思考过程</strong>，主要是表现自己掌握的知识量，这样即使你没有回答到点上，你也会比什么都不说得到更好的评价。</p>
</li>
<li>
<p>**尝试和面试官产生共鸣。**也许很多时候，面试官提出的问题，他自己都没有想到答案，所以这个时候你要尝试站在和他同一水平上，进行平等交流讨论，一般来说面试官都会对你产生回应，从而使得这场面试更加和谐，增加你成功的几率。</p>
</li>
<li>
<p>面试完一家，总结好经验，就let it go吧，即使挂了也不要影响信心和心情，面试很多情况看缘分</p>
</li>
<li>
<p>求职过程中别和身边的人对比 ，别自我怀疑，专注于过程，别在意结果，反思总结，心态别崩</p>
</li>
<li>
<p>坚持 <strong>+</strong> 努力 ，不到最后一刻别放弃</p>
<p>by https://zhuanlan.zhihu.com/p/357871900</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>把所有面试中的不顺利都当作是压力面</p>
</li>
<li>
<p>面试难的部门，不一定就是好部门</p>
</li>
<li>
<p>一般是部门HR会先打电话联系我，然后再安排面试官进行面试</p>
</li>
<li>
<p>维护好自己的面评</p>
<ul>
<li>放弃春招面试，可能导致秋招不给面试机会</li>
<li>任何一场面试，都不要放松，都要重视</li>
<li>不要相信“提前批 不影响 正式批”，任何一场面试都会有面评记录，后续面试面试官会看的！</li>
</ul>
</li>
<li>
<p>面试时，遇到不会的知识点，不用担心，面试更看重的是思维+表达+沟通+学习能力，而不是已经掌握了多少</p>
</li>
</ul>
<h3 id="内推">内推</h3>
<ul>
<li>
<p>lzy 上海 量化</p>
</li>
<li>
<p>误入凡尘里 B站</p>
</li>
<li>
<p>xxb 阿里云</p>
</li>
<li>
<p>gc 微信</p>
</li>
<li>
<p>字节</p>
<ul>
<li>
<blockquote>
<p>作者：特立独行MVP<br>
链接：<br>
https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all<br>
来源：牛客网</p>
<p>有想加入字节跳动 <strong>基础架构</strong> 的同学可以找我内推呀 大量实习和提前批HC！（请搜索基础架构才是~）<br>
直推部门老大直接面试无笔试：可以把简历发送至<a href="mailto:zhuhaochuan.snow@bytedance.com">zhuhaochuan.snow@bytedance.com</a> （注明实习还是校招，岗位）<br>
投递链接：https://job.toutiao.com/s/JNAvu8A<br>
内推码:QDZH4QP</p>
</blockquote>
</li>
<li>
<p>liuqiyang@bytedance.com</p>
</li>
</ul>
</li>
<li>
<p>北京图森未来</p>
<ul>
<li>
<blockquote>
<p>基础架构</p>
<p>目前我也是图森在南京大学的校园大使，大家有想去实习和工作的可以私信我内推呀</p>
<p>https://www.nowcoder.com/discuss/188367?type=all&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_all</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="春招后">春招后</h2>
<ul>
<li>就算春招失利，也不要灰心，秋招还有机会，参考cyc2018大佬的经历</li>
</ul>
<h2 id="暑期实习-and-秋招">暑期实习 and 秋招</h2>
<ul>
<li>秋招也要早做准备！</li>
<li>实习时，可以利用晚上和周末时间来自我提升，因为还需要为秋招做准备</li>
<li>不要相信实习单位所谓的“一定可以转正成功”</li>
<li>秋招的面试表现直接影响薪资，且竞争激烈程度大于春招，要更加重视</li>
<li>秋招很重要，不要为了实习转正牺牲秋招，<strong>给自己更多的选择</strong></li>
<li>可能会问实习经历，也要准备一下，做了什么？难点是什么？如何解决？</li>
</ul>
<h2 id="秋招后">秋招后</h2>
<ul>
<li>秋招结束也不要放弃机会，有一些补录以及春招的机会，说不定比秋招的offer更好</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java锁机制详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/</id>
        <link href="http://Bule-Zst.gitee.io/2021-12-07-Java锁机制详解/">
        </link>
        <updated>2021-12-07T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习Java锁机制过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1YB4y1P7xC?p=1">多线程高并发底层锁机制与优化最佳实践</a></li>
</ul>
<hr>
<h2 id="synchronized">Synchronized</h2>
<p>在普通方法上加synchronized，锁的是对象</p>
<p>在静态方法上加synchronized，锁的是class</p>
<h3 id="实现">实现</h3>
<h4 id="jdk16之前">jdk1.6之前</h4>
<p>对 对象内部的monitor对象 进行加锁，如果加锁失败，进入等待队列，当锁释放时，从等待队列中依次唤醒线程</p>
<ul>
<li>非公平锁：先尝试获取锁，如果失败，则进入等待队列</li>
<li>公平锁：直接进入等待队列</li>
</ul>
<p>缺点：</p>
<ul>
<li>重量级锁</li>
<li>线程挂起和唤醒时，需要从用户态切换到内核态
<ul>
<li>之所以需要切换到内核态，是因为，挂起和唤醒操作，是依赖于内核程序完成的，只有进入内核态，才能调用内核中的方法</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_42013590/article/details/107327439">什么是CPU的用户态和内核态</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[脑裂问题]]></title>
        <id>http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/</id>
        <link href="http://Bule-Zst.gitee.io/2021-11-06-脑裂问题/">
        </link>
        <updated>2021-11-06T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习脑裂问题过程中的笔记。</p>
<hr>
<h2 id="什么是脑裂问题">什么是脑裂问题</h2>
<p>简单说，就是在一个集群中，出现两个master节点</p>
<p>原本，一个集群中，只有一个master节点，可以看做是大脑，现在出现了两个，或者多个，就可以想象成大脑分裂了，所以叫脑裂问题</p>
<h2 id="成因以及造成的后果">成因以及造成的后果</h2>
<p>主要是由网络通信故障导致的</p>
<p>一般来说，集群中的master节点都是选举产生的，想象一下，假设两个机房之间出现了通信故障，那么分处于两个机房中的节点就会各自选举出master节点，当网络恢复时，就不知道该听哪个master节点的了。</p>
<h2 id="如何避免">如何避免</h2>
<p>知道了成因，那么，想解决脑裂问题，就需要避免假死亡现象的产生，因为如果master节点正常死亡，监控节点重新选举master节点，是不会产生脑裂问题的。</p>
<p>有以下三种常见方法：</p>
<ul>
<li>
<p>冗余通信：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信</p>
</li>
<li>
<p>过半机制（Quorum）：zookeeper采用的防止脑裂问题的方法，通过这个机制，可以确保就算发生了网络故障，也只会有一个master节点被选出</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20211106134247658.png" alt="image-20211106134247658" loading="lazy"></figure>
</li>
<li>
<p>共享存储隔离（Fencing）：能看到共享资源的节点就表示在集群中，能够获得共享资源的锁的节点就是master，看不到共享资源的节点就不在集群中</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://blog.csdn.net/u013374645/article/details/93140148">面试题：Zookeeper是如何解决脑裂问题</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/394160966">分布式系统的“脑裂”到底是个什么玩意？</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/u014156013/article/details/81226424">脑裂问题以及如何避免</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[限流算法学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-27-限流算法学习笔记/">
        </link>
        <updated>2021-09-27T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习限流算法过程中的笔记。</p>
<hr>
<h2 id="计数器">计数器</h2>
<p>设置一个计数器counter，其有效时间为1分钟（即每分钟计数器会被重置为0）</p>
<p>存在临界问题</p>
<h2 id="漏桶-leaky-bucket">漏桶 Leaky Bucket</h2>
<p>漏桶算法思路很简单，水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率)，当水流入速度过大会直接溢出(访问频率超过接口响应速率)，然后就拒绝请求，而当入小于出的情况下，漏桶不起任何作用。</p>
<p>流入：以任意速率往桶中放入水滴。<br>
流出：以固定速率从桶中流出水滴。</p>
<p>存在效率较低的问题</p>
<h2 id="令牌桶-token-bucket">令牌桶 Token Bucket</h2>
<p>系统会按恒定 1/QPS 时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水)，如果桶已经满了，令牌就溢出了。如果桶未满，令牌可以积累。新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。</p>
<p>流入：以固定速率从桶中流入水滴<br>
流出：按照任意速率从桶中流出水滴</p>
<h2 id="滑动窗口-rolling-window">滑动窗口 Rolling Window</h2>
<p>滑动窗口代表一段时间，将滑动窗口段划分成多个小格，通过统计滑动窗口中的总请求数，判断是否触发限流。每过一段时间，都将窗口往前移动。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/v2-b2fca280cb01069bc3b30c8b55f9d973_1440w.jpg" alt="img" loading="lazy"></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/duanxz/p/4123068.html">常见限流算法介绍（漏桶算法、令牌桶算法）及实现--待整理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/122431276">精度不够，滑动时间来凑「限流算法第二把法器：滑动时间窗口算法」- 第301篇</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java垃圾回收（GC）]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-23-Java垃圾回收（GC）/">
        </link>
        <updated>2021-09-23T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习JVM垃圾回收过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1T34y1X7xx?p=2&amp;spm_id_from=pageDriver">一节课掌握ZGC垃圾回收器</a></li>
</ul>
<hr>
<h2 id="基础知识">基础知识</h2>
<p>手动回收的问题：</p>
<ul>
<li>内存泄漏</li>
<li>重复回收（多线程）</li>
</ul>
<p>引用计数的问题：</p>
<ul>
<li>
<p>循环引用</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923134958252.png" alt="image-20210923134958252" loading="lazy"></figure>
</li>
</ul>
<h2 id="gc工作原理">GC工作原理</h2>
<h3 id="minor-gc新生代gc">Minor GC（新生代GC）</h3>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210727152911187.png" alt="image-20210727152911187" style="zoom:80%;" />
<ul>
<li>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li>
<li>根可达算法：将“GC Roots”对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象。</li>
<li>每次回收，都会将非垃圾对象放到s0(s1)中，然后杀死Eden和s1(s0)中的对象，并将非垃圾对象的分代年龄加一，当对象的分代年龄变成15时，会被移动到老年代中。</li>
<li>如果非垃圾对象过多，s0(s1)中放不下，则会被放到老年代中。</li>
</ul>
<h3 id="minor-gc-vs-full-gc">Minor GC VS Full GC</h3>
<ul>
<li>Minor GC会跳过处于老年代中的对象，但这样可能会使得部分被老年代中对象所引用的对象被标记成垃圾对象，因此，在Dirty cards中会存储所有老年代对象引用的对象。</li>
<li>Minor GC与Full GC相比，非垃圾对象较少，因此拷贝时间较短</li>
<li>算法不同：
<ul>
<li>Mnior GC用空间换时间，需要两个内存空间，直接Copy</li>
<li>Full GC用时间换空间，需要Mark+Compact</li>
</ul>
</li>
</ul>
<h2 id="zgc垃圾回收器">ZGC垃圾回收器</h2>
<p>将堆划分成3部分：</p>
<ul>
<li>小页面（2M）：对象小于256KB</li>
<li>中页面（32M）：对象在256KM~4MB</li>
<li>大页面（&gt;32M）：对象大于4M</li>
</ul>
<p>指针着色：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923143727759.png" alt="image-20210923143727759" loading="lazy"></figure>
<p>流程：</p>
<ul>
<li>初始标记：只标记与GC Roots直接关联的对象，将指针标记成绿色，会STW，但耗时很短，不会对堆空间进行修改。</li>
<li>并发标记：核心算法，三色标记（黑、白、灰：存活对象、垃圾对象、未扫描完对象）</li>
<li>再标记：处理漏标对象。利用AOP，记录在并发标记阶段所被访问的对象。</li>
<li>并发转移准备：筛选需要转移的分区</li>
<li>初始转移：转移与GC Roots直接关联的对象</li>
<li>并发转移：转发表</li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>
<p>为什么初始标记阶段，不标记所有对象？</p>
<p>因为耗时少！</p>
</li>
<li>
<p>为什么不直接进行并发标记？即，初始标记的意义是什么？</p>
<p>初始标记的意义：找根对象</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210924093232733.png" alt="image-20210924093232733" loading="lazy"></figure>
</li>
</ul>
<h3 id="z的含义">Z的含义</h3>
<blockquote>
<p>可能大伙还惦记这标题吧？<strong>ZGC 的 Z 是什么意思？</strong></p>
<p>其实没啥意思，就是个名字而已。</p>
<p>https://blog.csdn.net/yessimida/article/details/109763732</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/d01944130bba017f5ec46f909b629435.png" alt="img" loading="lazy"></figure>
<h2 id="其他垃圾回收器">其他垃圾回收器</h2>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210923142511010.png" alt="image-20210923142511010" loading="lazy"></figure>
<ul>
<li>
<p>新生代垃圾回收器</p>
<ul>
<li>Serial：标记-复制算法</li>
<li>ParNew：标记-复制算法+多线程+STW尽量短</li>
<li>Parallel Scavenge：标记-复制算法+多线程+吞吐量可控</li>
</ul>
</li>
<li>
<p>老年代垃圾回收器</p>
<ul>
<li>Serial Old：标记-整理算法</li>
<li>Parallel Old：标记-整理算法+多线程</li>
<li>CMS：标记-清除算法+STW尽量短
<ul>
<li>初始标记、并发标记、重新标记、并发清除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>G1</p>
<ul>
<li>
<p>jdk9 默认的收集器</p>
</li>
<li>
<p>标记-整理算法</p>
</li>
<li>
<p>分区+分代</p>
<blockquote>
<p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；</p>
<p>https://www.jianshu.com/p/aef0f4765098</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>ZGC</p>
<ul>
<li>STW极短</li>
<li>分区思想</li>
<li>染色指针</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/kevin7234/p/10644654.html">jvm minor gc 为什么比 full gc 快很多</a></li>
<li><a href="https://www.zhihu.com/question/35172533">为什么minor gc比full gc/major gc快？</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zookeeper学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-16-Zookeeper学习笔记/">
        </link>
        <updated>2021-09-16T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习Zookeeper过程中的笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1av411w7hp?from=search&amp;seid=1946340734056821588&amp;spm_id_from=333.337.0.0">分布式架构Zookeeper入门实战到底层原理剖析</a></li>
</ul>
<hr>
<h2 id="一致性">一致性</h2>
<ul>
<li>强一致性：当更新操作完成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。
<ul>
<li>分布式锁</li>
</ul>
</li>
<li>最终一致性：在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。</li>
<li>弱一致性：当数据更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</li>
</ul>
<p>zookeeper只保证最终一致性</p>
<h2 id="zookeeper-最终一致性-实现原理">zookeeper 最终一致性 实现原理</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210916135047212.png" alt="image-20210916135047212" loading="lazy"></figure>
<ul>
<li>Zab协议
<ul>
<li>领导者选举机制
<ul>
<li>比较两个节点谁的数据更<strong>新</strong> (zxid)，如果zxid相等，则比较myid，myid越大越好。zxid为请求id，对应每一个请求，且越靠后的请求，zxid越大。myid对应node节点，每个节点都有一个互不相等的myid，由配置文件指定。</li>
</ul>
</li>
<li>过半机制</li>
<li>两阶段提交机制
<ul>
<li>预提交</li>
<li>ACK（过半机制）</li>
<li>提交</li>
</ul>
</li>
<li>同步机制</li>
</ul>
</li>
<li>Zab协议的问题：
<ul>
<li>节点越多，写请求处理越慢，因为需要等待半数节点返回ACK</li>
<li>解决方案：
<ul>
<li>新增观察者，不参与两阶段提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/546b9dd86c91">弱一致性、强一致性、最终一致性、顺序一致性</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秒杀系统-实战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-14-秒杀系统-实战/">
        </link>
        <updated>2021-09-14T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录如何实现一个秒杀系统，学习资料如下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1CE411s7xN?p=2&amp;spm_id_from=pageDriver">1小时带你用Redis轻松实现秒杀系统（附秒杀系统优化实战）</a></li>
</ul>
<hr>
<h2 id="什么是秒杀系统">什么是秒杀系统</h2>
<p>其实主要的业务流程就是下订单、减库存，只是，该业务流程是在高并发、大流量的场景下进行的。</p>
<h2 id="并发量">并发量</h2>
<p>一般秒杀系统的并发量是万级别的，几万、几十万、几百万。</p>
<p>单机MySQL的并发量一般为几百，最多一千。</p>
<p>单机Tomcat的并发量一般也为几百。</p>
<p>单机Redis的并发量一般为几万。</p>
<h2 id="优化前">优化前</h2>
<p><a href="https://gitee.com/Bule-Zst/picture/raw/master/Seckill-%E4%BC%98%E5%8C%96%E5%89%8D.jpg">项目下载</a>（为了省事，我把文件后缀改成jpg了，这样直接用图床帮我存到云端）</p>
<p>就是一个简单的购物系统，先下单之后再减库存，这个系统在业务逻辑上是没有bug的，最主要的问题就是性能差。</p>
<p>需要注意的是，在系统里用到了事务，从而保证下单和减库存是原子操作，这里补充说一下Springboot事务失效的两个常见原因：</p>
<ul>
<li>内部调用：事务基于AOP，会对事务对象包装一个代理对象，因此不能直接调用事务对象的方法，应该使用Springboot的依赖注入，使用注入对象的方法。</li>
<li>数据库存储引擎不支持：MyISAM是不支持事务的，所以可以检查一下数据库表的存储引擎，如果是MyISAM，需要改成InnoDB。</li>
</ul>
<p>吞吐量为130/s</p>
<h2 id="优化">优化</h2>
<h3 id="redis缓存">Redis缓存</h3>
<p>使用redis做缓存</p>
<p>在秒杀之前，把商品库存信息放到redis中</p>
<p>在秒杀时，先对redis中的库存执行decrement方法，之后判断返回结果是否小于0，如果返回结果大于等于0，则进行秒杀业务，否则说明库存为零。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {}
</code></pre>
<p>吞吐量为1400/s</p>
<h4 id="存在的问题">存在的问题</h4>
<p>缓存不一致问题：一旦秒杀业务过程中发生错误导致事务回滚，那么redis中的库存信息就和数据库中的不一致了。</p>
<p>解决方案：如果事务中出现报错，就在catch语句中让库存加一。</p>
<pre><code class="language-java">Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
}
</code></pre>
<h3 id="jvm缓存">JVM缓存</h3>
<p>使用ConcurrentHashMap在JVM级别做缓存，当发现redis中库存为零后，使用ConcurrentHashMap标记当前商品为False。</p>
<p>当收到秒杀请求时，首先判断ConcurrentHashMap中当前商品是否被标记，如果被标记了，说明库存为零，直接return。</p>
<p>使用JVM级别的缓存能更好地提高系统性能，因为redis缓存是需要和redis服务做交互的，伴随网络请求，因此性能没有JVM级别快。</p>
<p>吞吐量为：1815/s</p>
<pre><code class="language-java">if( concurrentHashMap.get(id) != null ) {
    return &quot;fail&quot;;
}

Long stock = stringRedisTemplate.opsForValue().decrement( id+&quot;&quot; );
if( stock &lt; 0 ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    concurrentHashMap.put( id, true );
    return &quot;fail&quot;;
}
try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
</code></pre>
<h4 id="存在的问题-2">存在的问题</h4>
<p>JVM级缓存与redis缓存不一致，主要有两种场景</p>
<ul>
<li>
<p>当秒杀业务中存在异常时，会对redis和concurrentHashMap进行恢复，对redis中的缓存进行increment操作，对ConcurrentHashMap进行remove操作，但此时，redis中的库存很可能是负数的情况，因为在高并发情况下，大量请求被接受，所以redis会执行大量的decrement操作，虽然后续会执行increment操作进行恢复，但是有概率在新的请求被处理时，increment操作还未执行，当新的请求进来后，会发现redis中库存为负数，从而在concurrentHashMap进行标记。所以最终，redis中的库存数可能不为0，而concurrentHashMap中对应的商品却被标记了。</p>
<img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210914163636067.png" alt="image-20210914163636067" style="zoom:63%;" />
</li>
<li>
<p>在分布式场景下，不同JVM中的concurrentHashMap很难保证同步，可能在某个JVM中对hashMap进行了恢复，但是别的JVM中，hashMap并没有进行恢复。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>如果是分布式导致的不一致问题，可以使用zookeeper解决。当zookeeper中节点的数据发生改变后，zookeeper会主动通知监听该节点的进程，从而实现分布式下JVM级的缓存同步。之所以使用zookeeper，是因为zookeeper是CP的模型，能较好保证各节点之间的一致性。</li>
<li>如果是单机不一致问题，则借助lua脚本，让redis的减一操作和恢复操作原子化，因为之前出问题的原因就是decr和incr二者之间不具有原子性。</li>
</ul>
<h4 id="修复-lua">修复-lua</h4>
<pre><code class="language-java">if( concurrentHashMap.get(id) != null ) {
    return &quot;fail&quot;;
}

String RELEASE_LOCK_LUA_SCRIPT = &quot;if redis.call('decr', KEYS[1]) == -1 then redis.call('incr', KEYS[1]) return '-1' else return redis.call('get', KEYS[1]) end&quot;;
DefaultRedisScript&lt;String&gt; redisScript = new DefaultRedisScript&lt;&gt;(RELEASE_LOCK_LUA_SCRIPT,String.class);
String result = stringRedisTemplate.execute(redisScript, Collections.singletonList(id+&quot;&quot;) );
if( result.equals(&quot;-1&quot;) ) {
    concurrentHashMap.put( id, true );
    return &quot;fail&quot;;
}

try {
    productService.seckill( id );
} catch ( Exception e ) {
    stringRedisTemplate.opsForValue().increment( id+&quot;&quot; );
    if( concurrentHashMap.get(id) != null ) {
        concurrentHashMap.remove( id );
    }
}
return &quot;ok&quot;;
</code></pre>
<p>吞吐量：1700/s</p>
<h3 id="其他优化手段">其他优化手段</h3>
<ul>
<li>
<p>限流降级</p>
</li>
<li>
<p>Redis集群：提高redis并发量</p>
</li>
<li>
<p>微服务架构</p>
</li>
<li>
<p>异步下单</p>
</li>
<li>
<p>前端优化：静态页面、CDN</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL慢查询优化-实战]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-13-MySQL慢查询优化-实战/">
        </link>
        <updated>2021-09-13T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录优化MySQL慢查询的完整过程以及心得体会。</p>
<hr>
<h2 id="数据准备">数据准备</h2>
<p>随机生成了50w条数据，具体步骤可以参考这篇博客：<a href="https://blog.csdn.net/qq_36994788/article/details/73216961">mysql插入千万条随机数据</a></p>
<h2 id="前置知识">前置知识</h2>
<p>Explain语句结果中各个字段分表表示什么：</p>
<p>各字段含义：</p>
<ul>
<li>id：查询语句中每出现一个 select 关键字，MySQL都会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样</li>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>type：针对单表的查询方式
<ul>
<li>all、index、range、ref、eq_ref、const，从左到右效率依次提升</li>
<li>all：全表扫描</li>
<li>index：根据索引的顺序全表扫描</li>
<li>range：索引范围查询，between、&gt;、&lt;、in</li>
<li>ref：查询条件使用索引，但不是唯一索引</li>
<li>eq_ref：查询条件使用唯一索引</li>
<li>const：查询条件使用主键，优化器会把查询优化为一个常量</li>
<li>by https://blog.csdn.net/dennis211/article/details/78170079</li>
</ul>
</li>
<li>possible_keys：可能用到的索引</li>
<li>key : 实际用到的索引</li>
<li>rows：扫描的行数（注意，这里指的是，在查询过程中，一共扫描了多少行，而不是查询结果中有多少行）</li>
<li>Extra：
<ul>
<li>Impossible where：查询条件为false</li>
<li>Using where：顺序扫描，where 条件查询</li>
<li>Using index：覆盖索引</li>
<li>Using index condition：索引下推
<ul>
<li>根据索引进行查询，查询到主键后，在回表前，再根据索引进行一次判断，对于不符合查询条件的，不进行回表</li>
<li>在表上建立联合索引（name, age）</li>
<li><code>select * from table1 where name like &quot;张%&quot; and age = 23;</code></li>
<li>组合索引遇到 非等值判断 时匹配停止，所以 age 字段无法用于查询，但是在索引下推中，age字段可以用于判断，对于 age 不等于 20 的，不进行回表</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102404385.png" alt="image-20210913102404385" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913125829371.png" alt="image-20210913125829371" loading="lazy"></figure>
<h2 id="优化前统计">优化前统计</h2>
<ul>
<li>
<p>select * from emp where deptno = 101;</p>
<p>时间: 0.55s</p>
</li>
</ul>
<h2 id="开始优化">开始优化</h2>
<h3 id="是否走了索引">是否走了索引</h3>
<p>Explain结果：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913102307124.png" alt="image-20210913102307124" loading="lazy"></figure>
<p>结果分析：</p>
<p>Extra中为Using where，表示未使用索引，根据where条件顺序扫描</p>
<p>解决方案：对deptno列建立索引</p>
<p>建立索引后，Explain结果：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105003822.png" alt="image-20210913105003822" loading="lazy"></figure>
<p>时间: 3.636s</p>
<p>结果分析：时间反而变长了，猜测，可能是发生了回表操作。</p>
<p>验证：</p>
<p>尝试只select deptno，从而使用覆盖索引。</p>
<p>select deptno from emp where deptno = 101;</p>
<p>时间: 0.095s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110312538.png" alt="image-20210913110312538" loading="lazy"></figure>
<p>注意到Extra出现Using index，表示使用了覆盖索引。</p>
<p>尝试select ename，在这种情况下，会发生回表操作</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 3.189s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913110337524.png" alt="image-20210913110337524" loading="lazy"></figure>
<p>未使用覆盖索引</p>
<p>建立联合索引，(deptno, ename)</p>
<p>select ename from emp where deptno = 101;</p>
<p>时间: 0.033s</p>
<p>Explain结果：</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210913105937845.png" alt="image-20210913105937845" loading="lazy"></figure>
<p>使用了覆盖索引</p>
<p>验证结束</p>
<h3 id="是否是最优索引">是否是最优索引</h3>
<p>where条件只对deptno进行了约束，因此是最优索引</p>
<h3 id="是否查询了过多字段">是否查询了过多字段</h3>
<p>select *，查询字段过多，应根据实际业务需要，减少查询字段，例如只查询ename和deptno，这样就可以使用联合索引进行优化。</p>
<h3 id="是否应该进行分库分表">是否应该进行分库分表</h3>
<p>暂时不考虑分库分表</p>
<h3 id="是否数据库服务所在机器性能过低">是否数据库服务所在机器性能过低</h3>
<p>暂时不考虑机器性能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ConcurrentHashMap详解]]></title>
        <id>http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/</id>
        <link href="http://Bule-Zst.gitee.io/2021-09-01-ConcurrentHashMap详解/">
        </link>
        <updated>2021-09-01T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要用于记录学习ConcurrentHashMap过程中的学习笔记，学习资料如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/4dTDHcwa7M9">ConcurrentHashMap底层原理与源码分析深入详解</a></li>
</ul>
<hr>
<h2 id="hashmap">HashMap</h2>
<p>非线程安全</p>
<p>实现原理：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901135831288.png" alt="image-20210901135831288" loading="lazy"></figure>
<h2 id="hashtable">Hashtable</h2>
<p>线程安全：对put方法加synchronized锁</p>
<p>缺点：性能差</p>
<h2 id="concurrenthashmap-jdk17">ConcurrentHashMap jdk1.7</h2>
<p>class Segment extends Reentralock</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210901141125962.png" alt="image-20210901141125962" loading="lazy"></figure>
<h3 id="构造方法">构造方法</h3>
<p>segments数组长度为2的幂，为什么？因为计算下标时需要 <code>h &amp; (length-1)</code>，因此，必须是2的幂。</p>
<p>同时，Segment对象内部的数组，长度也是2的幂，大小为 <code>initialCapacity / concurrencyLevel</code></p>
<p>流程：</p>
<ul>
<li>首先，根据initialCapacity、loadFactor和concurrencyLevel，计算segments数组的大小、segment对象内部table的大小和threshold</li>
<li>然后，初始化Segment对象，并放到segments[0]</li>
</ul>
<pre><code class="language-java">public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &lt; c)
        cap &lt;&lt;= 1;
    // create segments and segments[0]
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
</code></pre>
<h3 id="put">put</h3>
<p>流程：</p>
<ul>
<li>首先，根据key获取Segment对象，如果不存在，则初始化，使用CAS赋值给segments数组</li>
<li>尝试对Segment对象进行加锁
<ul>
<li>如果加锁失败，则边尝试加锁，边遍历table[key]</li>
<li>如果遍历过程中，找到了对应的entry对象，则<strong>停止遍历</strong>。如果遍历完，依旧没有找到entry对象，则新建entry对象，然后<strong>停止遍历</strong>。</li>
<li>停止遍历后
<ul>
<li>继续尝试加锁，如果尝试次数超过 <code>MAX_SCAN_RETRIES</code>，则调用lock方法，阻塞加锁</li>
<li>如果在尝试加锁过程中，发现table[key]被修改（first != table[key]），则重新开始遍历</li>
</ul>
</li>
<li>只有当新建entry对象时，才会在加锁后获取到entry对象，其余情况下，获取到的都为null</li>
</ul>
</li>
<li>加锁成功后，开始遍历table[key]
<ul>
<li>如果找到对应entry对象，则修改其value值</li>
<li>如果没有找到entry对象，则判断之前是否已经新建过entry对象，如果没有，则新建。将新建的entry对象加入到table[key]的头结点之前，然后判断是否需要进行扩容操作。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&lt;K,V&gt;[] tab = table;
        int index = (tab.length - 1) &amp; hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}

private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {
    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = null;
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        HashEntry&lt;K,V&gt; f; // to recheck first below
        if (retries &lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries &gt; MAX_SCAN_RETRIES) {
            lock();
            break;
        }
        else if ((retries &amp; 1) == 0 &amp;&amp;
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
</code></pre>
<h3 id="扩容">扩容</h3>
<ul>
<li>首先，segment数组的长度是不会变的，与并发级别（concurrencyLevel）相同，扩容只在segment对象内部进行</li>
<li>在put方法中，若segment中元素个数超过threshold，则进行rehash。
<ul>
<li>将table大小扩展一倍，并对所有元素放到新table中，同时根据比例因子更新threshold</li>
<li>这里有一个需要说明的地方，在转移中，会去寻找最后一节不需要改动的链表，然后将其整个移动到新table中。怎么理解呢？因为在移动过程中，需要重复创建Entry，比较耗费资源，所以能尽量不创建就不创建。因此，转移过程中，会先找到 lastRun 节点，该节点后面的节点对应的hash值和该节点都一样，所以可以一起移动到新table中。然后再对lastRun节点之前的节点一个一个进行转移。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//扩容，Segment中，只对Segment中的HashEntry[]扩容
@SuppressWarnings(&quot;unchecked&quot;)
private void rehash(HashEntry&lt;K,V&gt; node) {
	HashEntry&lt;K,V&gt;[] oldTable = table;//保存老的HashEntry[]
	int oldCapacity = oldTable.length;
	int newCapacity = oldCapacity &lt;&lt; 1;//扩容为原来的2倍
	threshold = (int)(newCapacity * loadFactor);//计算新的阈值
	HashEntry&lt;K,V&gt;[] newTable =
		(HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];//创建新的HashEntry[]
	int sizeMask = newCapacity - 1;
	for (int i = 0; i &lt; oldCapacity ; i++) {//循环移动老的数组中的元素
		HashEntry&lt;K,V&gt; e = oldTable[i];
		if (e != null) {
			HashEntry&lt;K,V&gt; next = e.next;
			int idx = e.hash &amp; sizeMask;//计算在HashEntry[]中存放的位置
			if (next == null)   //当前节点的下一个节点为null，说明当前链表就一个节点
				newTable[idx] = e;//直接赋值
			else { //存在链表
				HashEntry&lt;K,V&gt; lastRun = e;
				int lastIdx = idx;
				//循环找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
				for (HashEntry&lt;K,V&gt; last = next;
					 last != null;
					 last = last.next) {
					int k = last.hash &amp; sizeMask;
					if (k != lastIdx) {
						lastIdx = k;
						lastRun = last;
					}
				}
				newTable[lastIdx] = lastRun;//复制链表
				//处理lastRun之前的节点，这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
				for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
					V v = p.value;
					int h = p.hash;
					int k = h &amp; sizeMask;
					HashEntry&lt;K,V&gt; n = newTable[k];
					newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
				}
			}
		}
	}
	 // 将新加的 node 放到新数组中刚刚的两个链表之一的头部
	int nodeIndex = node.hash &amp; sizeMask;
	node.setNext(newTable[nodeIndex]);
	newTable[nodeIndex] = node;
	table = newTable;
}
</code></pre>
<h2 id="concurrenthashmap-jdk18">ConcurrentHashMap jdk1.8</h2>
<h3 id="sizectl">sizeCtl</h3>
<ul>
<li>-1：正在初始化</li>
<li>0：未进行初始化</li>
<li>&gt;0：
<ul>
<li>若还未进行初始化，则为初始化时 <code>tabel</code> 的容量</li>
<li>else，为触发下一次扩容的阈值</li>
</ul>
</li>
</ul>
<h3 id="初始化">初始化</h3>
<ul>
<li>如果sizeCtl小于0，则说明正在进行初始化，通过 <code>Thread.yield()</code> 让出CPU时间</li>
<li>else
<ul>
<li>将 <code>sizeCtl</code> 的值赋值为 <code>sc</code>，作为备份，然后将sizeCtl赋值为-1
<ul>
<li>如果sc大于0，初始化长度为sc的table</li>
<li>else，初始化长度为 <code>DEFAULT_CAPACITY</code> 的table</li>
</ul>
</li>
<li>将 <code>n-(n&gt;&gt;&gt;2)</code> 的值赋值给sizeCtl，<code>n-(n&gt;&gt;&gt;2)</code> 表示 <code>0.75*n</code> ，所以sizeCtl为触发下一次扩容的阈值</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre>
<h3 id="put-2">put</h3>
<ul>
<li>
<p>for循环</p>
<ul>
<li>
<p>如果table为空，则初始化table，然后重新循环</p>
</li>
<li>
<p>如果table[i]为空，则初始化node节点，然后放到table[i]中</p>
<ul>
<li>如果“放”操作成功，则结束循环</li>
<li>因为存在并发，“放”的操作可能失败，如果失败，则重新循环。</li>
</ul>
</li>
<li>
<p>如果table[i]的状态是MOVED，说明当前正在扩容，则帮忙一起扩容，扩容结束后，重新循环。</p>
</li>
<li>
<p>以上3个条件都不满足，则对table[i]加锁</p>
<ul>
<li>
<p>如果table[i]为链表，则遍历链表，并维护binCount变量，寻找key是否存在</p>
<ul>
<li>如果存在，则更新value，结束遍历</li>
<li>如果不存在，利用尾插法，插入新的node节点，结束遍历</li>
</ul>
</li>
<li>
<p>如果table[i]为红黑树，则向红黑树中插入node节点，将binCount设为2</p>
</li>
<li>
<p>插入完成后，如果binCount大于等于TREEIFY_THRESHOLD（默认为8），则将table[i]由链表转换成红黑树。</p>
</li>
<li>
<p>退出循环</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果key在原先链表、红黑树中不存在（即，需要插入新节点），则调用 <code>addCount(1L, binCount)</code> 将count加1。</p>
</li>
</ul>
<pre><code class="language-java">final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh &gt;= 0) {
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
</code></pre>
<h4 id="链表转红黑树">链表转红黑树</h4>
<ul>
<li>根据链表，生成新的TreeNode类型的双向链表，hd为头结点</li>
<li>利用 <code>TreeBin(TreeNode&lt;K,V&gt; b)</code> 构造函数，由双向链表转成红黑树</li>
</ul>
<pre><code class="language-java">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {
    Node&lt;K,V&gt; b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            tryPresize(n &lt;&lt; 1);
        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&lt;K,V&gt; hd = null, tl = null;
                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {
                        TreeNode&lt;K,V&gt; p =
                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));
                }
            }
        }
    }
}
</code></pre>
<h6 id="treebin与treenode">TreeBin与TreeNode</h6>
<p>在jdk1.8的HashMap中，没有使用TreeBin，为什么ConcurrentHashMap中使用了TreeBin？</p>
<ul>
<li>避免红黑树头结点发生变化：
<ul>
<li>在节点插入到红黑树的过程中，头结点可能会因为左移而改变，但是在ConcurrentHashMap中，是需要对头结点进行加锁操作的，一旦头结点发生改变，那么别的线程，就不会受到锁的限制，从而造成错误。</li>
</ul>
</li>
</ul>
<h4 id="addcount">addCount</h4>
<p>功能梳理：</p>
<ul>
<li>让ConcurrentHashMap的size加x</li>
<li>在满足一定条件的情况下，对ConcurrentHashMap进行扩容</li>
</ul>
<p>流程梳理：</p>
<ul>
<li>
<p>加x部分：</p>
<ul>
<li>
<p>对ConcurrentHashMap的size进行加x操作有两种选择：</p>
<ul>
<li>对counterCells加x（可以先看size方法，加深对counterCells的理解）</li>
<li>对baseCount加x</li>
</ul>
</li>
<li>
<p>首先判断counterCells是否为空，如果不为空，则进入if内部，对counterCells加x</p>
</li>
<li>
<p>如果counterCells为空，则尝试对baseCount进行加x操作</p>
<ul>
<li>如果成功，则结束，进入后续扩容部分</li>
<li>如果失败，则同样进入if内部，对counterCells加x</li>
</ul>
</li>
<li>
<p>对counterCells加x的操作流程：</p>
<ul>
<li>如果counterCells为空，则①</li>
<li>如果counterCells不为空，但是length小于等于0，则①
<ul>
<li>这里补充一点，代码里的写法是 <code>(m = as.length - 1) &lt; 0</code> ，为什么要这么做呢，因为后续需要使用m进行与操作获取数组下标位置，与的时候是需要用 <code>length-1</code> 的，所以直接在上面的判断中进行赋值。</li>
</ul>
</li>
<li>如果counterCells不为空，且length也大于0，则判断对应下标位置的元素 <code>as[ThreadLocalRandom.getProbe() &amp; m]</code> 是否为空，如果为空，则①</li>
<li>如果对应下标位置的元素也不为空，则尝试直接对该元素进行加x操作，如果失败，则①</li>
<li>①：调用 <code>fullAddCount(x, uncontended)</code> 对counterCells加x，addCount方法结束</li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩容部分：</p>
<ul>
<li>不进行扩容的情况
<ul>
<li>check小于0</li>
<li>对counterCells进行加x操作，并且check小于等于1</li>
<li>调用fullAddCount对counterCells进行加x操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
        if (check &lt;= 1)
            return;
        s = sumCount();
    }
    if (check &gt;= 0) {
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
</code></pre>
<h5 id="fulladdcount">fullAddCount</h5>
<ul>
<li>使用线程的探针值对h进行赋值</li>
<li>for循环
<ul>
<li>如果counterCells不为空，且长度等于0
<ul>
<li>如果counterCells数组对应下标位置元素为空
<ul>
<li>将collide赋值为false</li>
<li>如果counterCells未被其他线程占用，则尝试使用x为对应位置进行初始化，如果初始化成功，则退出循环</li>
</ul>
</li>
<li>如果wasUncontended为false，则将wasUncontended改为true。
<ul>
<li>wasUncontended：表示上一次没有冲突</li>
<li>如果为false，则说明有冲突，所以直接跳到最后一条语句，更新h的值</li>
</ul>
</li>
<li>尝试使用CAS对数组对应下标位置的元素加x
<ul>
<li>如果成功，则退出循环</li>
</ul>
</li>
<li></li>
<li></li>
<li>更新h的值</li>
</ul>
</li>
<li>else，如果cellsBusy为0（说明counterCells没有被其他线程占用）
<ul>
<li>则对counterCells进行初始化，初始化为长度为2的数组，并将x的值添加到数组中</li>
<li>如果成功，则退出循环</li>
</ul>
</li>
<li>else，尝试对baseCount进行加x操作
<ul>
<li>如果成功，则退出循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final void fullAddCount(long x, boolean wasUncontended) {
    int h;
    if ((h = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit();      // force initialization
        h = ThreadLocalRandom.getProbe();
        wasUncontended = true;
    }
    
    boolean collide = false;                // True if last slot nonempty
    for (;;) {
        CounterCell[] as; CounterCell a; int n; long v;
        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) {
            if ((a = as[(n - 1) &amp; h]) == null) {
                if (cellsBusy == 0) {            // Try to attach new Cell
                    CounterCell r = new CounterCell(x); // Optimistic create
                    if (cellsBusy == 0 &amp;&amp;
                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                        boolean created = false;
                        try {               // Recheck under lock
                            CounterCell[] rs; int m, j;
                            if ((rs = counterCells) != null &amp;&amp;
                                (m = rs.length) &gt; 0 &amp;&amp;
                                rs[j = (m - 1) &amp; h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                break;
            else if (counterCells != as || n &gt;= NCPU)
                collide = false;            // At max size or stale
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 &amp;&amp;
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                try {
                    if (counterCells == as) {// Expand table unless stale
                        CounterCell[] rs = new CounterCell[n &lt;&lt; 1];
                        for (int i = 0; i &lt; n; ++i)
                            rs[i] = as[i];
                        counterCells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            h = ThreadLocalRandom.advanceProbe(h);
        }
        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;
                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
            boolean init = false;
            try {                           // Initialize table
                if (counterCells == as) {
                    CounterCell[] rs = new CounterCell[2];
                    rs[h &amp; 1] = new CounterCell(x);
                    counterCells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
            break;                          // Fall back on using base
    }
}
</code></pre>
<h3 id="size">size</h3>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_36625757/article/details/90074355">JDK1.7&amp;1.8中ConcurrentHashMap解析</a></li>
<li><a href="https://www.bilibili.com/video/BV1H64y1X7yM?p=6">我敢说这是B站最详细的hashmap及ConcurrentHashMap底层原理解析，16个小时带你吃透所有知识</a></li>
</ul>
]]></content>
    </entry>
</feed>