<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://Bule-Zst.gitee.io</id>
    <title>Bule-Zst</title>
    <updated>2021-05-28T08:36:20.633Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://Bule-Zst.gitee.io"/>
    <link rel="self" href="http://Bule-Zst.gitee.io/atom.xml"/>
    <logo>http://Bule-Zst.gitee.io/images/avatar.png</logo>
    <icon>http://Bule-Zst.gitee.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Bule-Zst</rights>
    <entry>
        <title type="html"><![CDATA[NIO与epoll模型学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-27-NIO与epoll模型学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-27-NIO与epoll模型学习笔记/">
        </link>
        <updated>2021-05-27T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习NIO及Netty线程模型过程中的笔记，学习资料为视频，链接如下：</p>
<ul>
<li><a href="https://ke.qq.com/course/3293405?taid=11073426419761373">深入Hotspot源码与Linux内核理解NIO与Netty线程模型</a></li>
</ul>
<hr>
<h2 id="io">IO</h2>
<h3 id="bio">BIO</h3>
<h4 id="基本写法">基本写法</h4>
<pre><code class="language-java">ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    BufferedReader reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
    System.out.println( reader.readLine() );
}
</code></pre>
<p>缺点：并发量为1</p>
<h4 id="优化1使用多线程进行优化">优化1：使用多线程进行优化</h4>
<pre><code class="language-java">ServerSocket serverSocket = new ServerSocket( 9000 );
while( true ) {
    Socket socket = serverSocket.accept();
    new Thread() {
        @Override
        public void run() {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader( new InputStreamReader( socket.getInputStream()));
                System.out.println( reader.readLine() );
            } catch (IOException e) {
                e.printStackTrace();
            }
            
        }
    }.start();
}
</code></pre>
<p>缺点：存在C10K问题，当并发量过大时，因为开的线程太多，会被内存挤爆。</p>
<h4 id="优化2使用线程池进行优化">优化2：使用线程池进行优化</h4>
<p>缺点：并发数会受到线程池中线程数的约束</p>
<h4 id="共同问题">共同问题</h4>
<p>可能会存在建立连接后不发数据的情况，导致该线程阻塞，降低系统性能</p>
<h3 id="nio">NIO</h3>
<h4 id="基本写法-2">基本写法</h4>
<pre><code class="language-java">ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
List&lt;SocketChannel&gt; socketChannelList = new ArrayList&lt;&gt;();
while( true ) {
    SocketChannel socketChannel = serverChannel.accept();
    if( socketChannel != null ) {
        socketChannel.configureBlocking( false );
        socketChannelList.add( socketChannel );
    }
    Iterator&lt;SocketChannel&gt; iterator = socketChannelList.iterator();
    while( iterator.hasNext() ) {
        SocketChannel socketChannel1 = iterator.next();
        ByteBuffer byteBuffer = ByteBuffer.allocate(128);
        int len = socketChannel1.read( byteBuffer );
        if( len &gt; 0 ) {
            System.out.println( new String(byteBuffer.array()));
        } else if( len == -1 ) {
            iterator.remove();
        }
    }
}
</code></pre>
<p>缺点：</p>
<ul>
<li>对所有连接进行轮询，判断是否发送数据，但可能大部分连接都没有发送数据（空轮询）</li>
<li>C10K问题</li>
</ul>
<h4 id="优化使用selector进行优化">优化：使用selector进行优化</h4>
<pre><code class="language-java">ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind( new InetSocketAddress(9000) );
serverChannel.configureBlocking( false );
Selector selector = Selector.open();
serverChannel.register( selector, SelectionKey.OP_ACCEPT );
while( true ) {
    selector.select();
    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
    while( iterator.hasNext() ) {
        SelectionKey selectionKey = iterator.next();
        if( selectionKey.isAcceptable() ) {
            ServerSocketChannel serverChannel1 = (ServerSocketChannel) selectionKey.channel();
            SocketChannel socketChannel = serverChannel1.accept();
            socketChannel.register( selector, SelectionKey.OP_READ );
        } else if( selectionKey.isReadable() ) {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(128);
            int len = socketChannel.read( byteBuffer );
            if( len &gt; 0 ) {
                System.out.println( new String(byteBuffer.array()));
            } else if( len == -1 ) {
                iterator.remove();
            }
        }
        iterator.remove();
    }
}
</code></pre>
<h4 id="selector原理">Selector原理</h4>
<p>在linux环境下，selector基于epoll实现（在windows环境下，不基于epoll）。</p>
<p>使用epoll_create创建epoll对象，使用epoll_ctl进行注册，使用epoll_wait进行阻塞监听。</p>
<p>Java调用操作系统的内核函数来创建Socket，获取到Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符，将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知。</p>
<p>epoll基于“回调”实现监听。</p>
<p>在Selector中，连接建立、数据读取都依赖于系统函数，例如，连接建立依赖于accept函数。因此，Selector可以使用epoll监听系统函数的调用，从而实现对连接建立、数据读取的监听。</p>
<p>本质上，epoll监听的事文件描述符的状态（可读、可写）</p>
<h4 id="对selector的理解">对Selector的理解</h4>
<p>在Selector的实现中，看似是存在阻塞的（<code>selector.select()</code>），但Selector依旧属于同步非阻塞IO的范畴，这是因为，这里所谓的阻塞，指的是当有多个连接希望建立时，因为正在处理某个连接的建立，导致其他连接无法被处理（连接被阻塞了），因此，这里所谓的阻塞，面向的对象是连接，当然，也可以是数据的读取，而不是程序的阻塞。</p>
<p>对于<code>selector.select()</code>方法，当没有连接希望建立时，会阻塞，一旦有连接希望建立，则会立刻结束阻塞，且当有多个连接希望建立时，多个连接之间也不会有相互影响（即，因为线程A的建立，导致线程B建立请求的阻塞）。</p>
<p>在<code>selector.select()</code>方法的内部，其实调用的是<code>epoll_wait</code>方法，这个方法是异步非阻塞的。</p>
<h3 id="nio与aio的区别">NIO与AIO的区别</h3>
<p>NIO为同步非阻塞IO，会在程序中进行轮询，当发现有事件发生后，会对事件进行处理。</p>
<p>AIO为异步非阻塞IO，预先写好处理逻辑，当有事件发生后，处理函数会被调用，用于处理事件（观察者模式）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RESTHeart学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-14-RESTHeart学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-14-RESTHeart学习笔记/">
        </link>
        <updated>2021-05-14T00:35:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习Zabbix过程中的笔记</p>
<p>学习资料来源：</p>
<ul>
<li><a href="https://restheart.org/docs/try/">Try RESTHeart Online</a></li>
<li><a href="https://www.cnblogs.com/rongfengliang/p/9584470.html">restheart 基本使用</a></li>
</ul>
<hr>
<p>PS：在RESTHeart中，如果要更新的item不存在，则会自动进行创建。</p>
<h2 id="创建">创建</h2>
<h3 id="创建文档">创建文档</h3>
<p>POST</p>
<p><code>host_url/db_id/collection_id -d &quot;{'from':'you','message':'create document'}&quot;</code></p>
<h2 id="获取">获取</h2>
<h3 id="获取集合中所有文档">获取集合中所有文档</h3>
<p>GET</p>
<p><code>host_url/db_id/collection_id</code></p>
<h3 id="获取特定文档">获取特定文档</h3>
<p>GET</p>
<p><code>host_url/db_id/collection_id/document_id</code></p>
<h3 id="指定过滤条件获取集合中的部分文档">指定过滤条件，获取集合中的部分文档</h3>
<p>GET</p>
<p><code>host_url/db_id/collection_id?filter={'from':'you'}&amp;pagesize=2</code></p>
<h2 id="更新">更新</h2>
<h3 id="更新数据库">更新数据库</h3>
<p>PUT</p>
<p><code>host_url/db_id</code></p>
<h3 id="更新集合">更新集合</h3>
<p>PUT</p>
<p><code>host_url/db_id/collection_id</code></p>
<h3 id="更新整个文档">更新整个文档</h3>
<p>PUT</p>
<p><code>host_url/db_id/collection_id/document_id -d &quot;{'from':'you','message':'create document'}&quot;</code></p>
<h3 id="更新文档中的部分内容">更新文档中的部分内容</h3>
<p>PATCH</p>
<p><code>host_url/db_id/collection_id/document_id -d &quot;{'from':'you','message':'create document'}&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zabbix学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-14-Zabbix学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-14-Zabbix学习笔记/">
        </link>
        <updated>2021-05-14T00:35:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习Zabbix过程中的笔记</p>
<p>学习资料来源：</p>
<ul>
<li><a href="https://www.zsythink.net/archives/790">zabbix从放弃到入门</a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Celery学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-13-Celery学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-13-Celery学习笔记/">
        </link>
        <updated>2021-05-13T02:06:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习Celery过程中的笔记</p>
<p>学习资料来源：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/22304455">使用Celery-小明</a></li>
</ul>
<hr>
<h2 id="架构">架构</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210513101505012.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-12-MongoDB学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-12-MongoDB学习笔记/">
        </link>
        <updated>2021-05-12T01:26:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习MongoDB过程中的笔记</p>
<p>学习资料来源：</p>
<ul>
<li><a href="https://www.cnblogs.com/xiaohuiduan/p/11403891.html">Mongodb最基础入门教程</a></li>
<li><a href="https://developer.aliyun.com/article/64352">什么场景应该用 MongoDB ？</a></li>
<li><a href="https://www.zhihu.com/question/32071167">MongoDB 应用场景?</a></li>
</ul>
<hr>
<h2 id="mongodb使用场景">MongoDB使用场景</h2>
<ul>
<li>使用方便
<ul>
<li>增加字段不用改表结构</li>
</ul>
</li>
<li>可进行地理位置查询</li>
<li>方便扩展</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-08-redis学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-08-redis学习笔记/">
        </link>
        <updated>2021-05-08T07:13:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习redis过程中的笔记，学习资料为视频及pdf，链接如下：</p>
<ul>
<li><a href="https://www.aliyundrive.com/s/2Fg2Arj1Doe">双十一秒杀系统后端Redis高并发架构实战</a></li>
<li><a href="https://www.aliyundrive.com/s/N7WiV8Wgjm9">亿级流量新浪微博与微信Redis架构实战</a></li>
<li><a href="https://www.aliyundrive.com/s/e1jtR4D15kz">Redis常见面试题汇总.pdf</a></li>
<li><a href="https://www.aliyundrive.com/s/CprZdykwNd2">Redis持久化、主从与哨兵架构详解.pdf</a></li>
<li><a href="https://www.aliyundrive.com/s/1HdqGt4krK1">Redis命令参考手册完整版.pdf</a></li>
</ul>
<hr>
<h2 id="分布式">分布式</h2>
<h3 id="分布式并发场景中可能存在的问题">分布式并发场景中可能存在的问题</h3>
<p>使用synchronized对代码块加锁，但因为是分布式，多个应用同时访问redis，依旧无法解决并发冲突问题</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210508160113749.png" alt="" loading="lazy"></figure>
<h3 id="redis实现分布式锁">Redis实现分布式锁</h3>
<p>使用SETNX实现分布式锁</p>
<ul>
<li>
<p>存在的问题：因为某些原因，锁在用完后没有成功释放，如，功能代码块抛异常、系统宕机</p>
</li>
<li>
<p>解决方案：</p>
<ul>
<li>增加过期时间：</li>
<li>存在的问题：
<ul>
<li>实际业务执行时间可能会大于过期时间：进程A执行过慢，导致锁自动被释放，之后进程B进行加锁，开始处理业务，然后进程A执行完，释放B的锁，又导致进程C进行加锁，无限循环，最终导致锁永久失效。</li>
</ul>
</li>
<li>解决方案：自己的锁只有自己可以释放（或者过期自动释放）
<ul>
<li>存在的问题：
<ul>
<li>还是<strong>过期时间</strong>的锅：当进程A需要释放锁的时候，从redis获取锁的value，发现是自己加的锁，但随后，锁因为过期时间，自动失效，进程B随即进行加锁，然后进程A释放锁，就导致会把进程B的锁释放掉。</li>
</ul>
</li>
<li>解决方案：
<ul>
<li>锁续命：另开一个线程，持续进行加锁操作，例如过期时间是30s，则每10s加一次锁，保证业务执行过程中，锁不会自动失效。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分布式锁的性能问题">分布式锁的性能问题</h3>
<p>使用分布式锁，本质上是让所有web请求串行化执行，执行效率较低。</p>
<p>解决方案：分段加锁</p>
<ul>
<li>举例：秒杀场景下，为了防止超卖，需要使用分布式锁，例如商品数量为200个，那么可以划分成10分，分别进行加锁，这样可以提高约10倍的效率。</li>
</ul>
<h2 id="缓存-数据库双写不一致问题">缓存、数据库双写不一致问题</h2>
<p>场景1：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213252468.png" alt="" loading="lazy"></figure>
<p>场景2：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210508213547682.png" alt="" loading="lazy"></figure>
<p><strong>不一致</strong>：数据库里数据为6，缓存为10</p>
<h3 id="解决方案">解决方案</h3>
<p>比较不推荐的做法：</p>
<ul>
<li>延迟双删</li>
<li>内存队列</li>
</ul>
<p>推荐做法：</p>
<ul>
<li>读多写少
<ul>
<li>分布式锁：通过读写锁进行优化</li>
</ul>
</li>
<li>读多写多，对一致性要求不高
<ul>
<li>给缓存设置过期时间，保证双写不一致的最大时长。</li>
</ul>
</li>
<li>读多写多，对一致性要求高
<ul>
<li>不要用缓存：因为缓存更新后，可能过了几秒，就又要进行更新。这种情况下，不如不用缓存。</li>
<li>使用canal中间件</li>
</ul>
</li>
</ul>
<h2 id="redis">Redis</h2>
<p>全称：Remote Dictionary Server</p>
<h3 id="为什么性能高">为什么性能高</h3>
<p>对性能的影响：</p>
<ul>
<li>消极
<ul>
<li>单线程</li>
</ul>
</li>
<li>积极
<ul>
<li>内存操作</li>
<li>基于epoll的多路复用模型</li>
<li>高效的数据存储结构</li>
</ul>
</li>
</ul>
<h4 id="数据存储结构">数据存储结构</h4>
<p>redis使用哈希表存储key-value对</p>
<p>在redis中有对象和数据结构的概念，redis对象利用不同的数据结构进行存储，例如，String对象可以用int数据结构进行存储，也可以用SDS数据结构进行存储。</p>
<p>对不同类型的对象，内部存储逻辑不同：</p>
<ul>
<li>
<p>String对象：</p>
<ul>
<li>
<p>int数据结构</p>
</li>
<li>
<p>SDS数据结构</p>
<ul>
<li>
<p>embstr：小于等于44字节</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141323986.png" alt="image-20210528141323986" loading="lazy"></figure>
</li>
<li>
<p>raw：大于44字节</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528141338577.png" alt="image-20210528141338577" loading="lazy"></figure>
</li>
<li>
<p>embstr与raw的区别是，embstr只会申请一次内存空间</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hash对象</p>
<ul>
<li>
<p>压缩列表：空间占用小，查找慢。当数据个数较小或者数据所占内存空间较少（键和值的大小都小于 64 字节）时，使用压缩列表。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210525101358367.png" alt="image-20210525101358367" loading="lazy"></figure>
</li>
<li>
<p>哈希表：空间占用大，查找快</p>
</li>
</ul>
</li>
<li>
<p>List对象</p>
<ul>
<li>
<p>压缩列表：数据数量较少或所占空间较少时，使用压缩列表</p>
</li>
<li>
<p>链表：空间占用更多，但添加、删除元素时，效率高</p>
</li>
<li>
<p>快速列表：Redis3.2之后，用快速列表代替压缩列表和链表</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210528150649602.png" alt="image-20210528150649602" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>Set对象</p>
<ul>
<li>整数集合</li>
<li>哈希表</li>
</ul>
</li>
<li>
<p>ZSet对象：</p>
<ul>
<li>
<p>压缩列表</p>
</li>
<li>
<p>跳表：查找快，但更占空间且更新性能低</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210524163213876.png" alt="image-20210524163213876" loading="lazy"></figure>
</li>
<li>
<p>当元素个数超过<code>zset-max-ziplist-entries</code>，切换成跳表。</p>
</li>
</ul>
</li>
</ul>
<h4 id="epoll多路复用模型">epoll多路复用模型</h4>
<h5 id="redis为什么要用epoll">redis为什么要用epoll</h5>
<ul>
<li>redis是单线程的：redis是内存操作，虽然内存的速度比CPU慢，但依旧很快，CPU的利用率较高，无需使用多线程提高CPU的利用率。</li>
<li>对于单线程的应用，当用户进行网络请求后，该线程会被阻塞，等待用户输入。线程被阻塞，也就意味着整个进程、整个redis被阻塞。若等待用户输入时间较长，则在高并发场景下，会极大影响redis性能。</li>
<li>因此，redis需要将等待用户输入这一操作委托给系统去完成，即，redis基于系统提供的epoll实现了多路复用模型。</li>
</ul>
<h5 id="epoll的实现原理">epoll的实现原理</h5>
<h5 id="redis如何使用epoll">redis如何使用epoll</h5>
<p>epoll_create</p>
<p>epoll_ctl</p>
<p>epoll_wait</p>
<h3 id="不同数据类型的适用场景">不同数据类型的适用场景</h3>
<h4 id="string">String</h4>
<ul>
<li>单值缓存</li>
<li>对象缓存：JSON字符串</li>
<li>分布式锁</li>
<li>计数器</li>
<li>分布式系统全局序列号
<ul>
<li>分库分表，用redis维护Id。优化思路：一次性让Id增加100，减少对redis的访问次数。</li>
</ul>
</li>
</ul>
<h4 id="hash">Hash</h4>
<ul>
<li>对象缓存
<ul>
<li>与string方式存储相比，其优势在于：对于局部频繁更新，效率更高，比如，只修改对象的某个属性</li>
</ul>
</li>
</ul>
<h4 id="list">List</h4>
<ul>
<li>实现栈、队列、拥塞队列</li>
<li>消息流：当大V发消息后，将消息id添加到每个关注用户的消息List中，使用LPUSH，用户获取消息使用LRANGE。</li>
</ul>
<h4 id="set">Set</h4>
<ul>
<li>抽奖功能：因为set有srandmember、spop方法</li>
<li>点赞功能：频繁添加、删除、比较元素，用set效率比list好</li>
<li>关注模型（共同关注、我关注的人关注了谁、可能认识的人）：集合操作</li>
</ul>
<h4 id="zset">ZSet</h4>
<ul>
<li>排行榜</li>
</ul>
<h3 id="备份策略">备份策略</h3>
<ul>
<li>每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份</li>
<li>每天都保留一份当日的数据备份到一个目录中去，保留最近1个月的备份</li>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</li>
</ul>
<h3 id="主从架构">主从架构</h3>
<p>防止单点redis宕机，对业务造成影响</p>
<p>使用主从架构，子节点同步父节点信息，当父节点宕机后，用子节点代替父节点继续提供服务</p>
<p>主从节点切换导致锁丢失：使用zookeeper代替redis</p>
<p>redis vs zookeeper：redis性能更好；zookeeper一致性更好。</p>
<h3 id="哨兵机制">哨兵机制</h3>
<p>1、故障节点主观下线</p>
<p>2、故障节点客观下线</p>
<p>3、Sentinel集群选举Leader</p>
<p>4、Sentinel Leader决定新主节点</p>
<p>详细资料：<a href="https://blog.csdn.net/weixin_28871885/article/details/113315639">redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析</a></p>
<h3 id="lua脚本">Lua脚本</h3>
<p>Lua脚本可以植入redis内部进行运行</p>
<p>Lua脚本的优势：</p>
<ul>
<li>减少网络开销：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。这点跟管道类似。</li>
<li>原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。</li>
<li>替代redis的事务功能：redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了常规的事务功能，支持报错回滚操作，官方推荐如果要使用redis的事务功能可以用redis lua替代。</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/hunternet/p/11306690.html">Redis数据结构——压缩列表</a></li>
<li><a href="https://blog.csdn.net/qq_45401061/article/details/107382276">面试官：Redis 为什么这么快？除了基于内存操作还有其他原因吗？</a></li>
<li><a href="https://blog.csdn.net/u011663149/article/details/85307615">Redis为什么是单线程、及高并发快的大原因详解</a></li>
<li><a href="https://blog.csdn.net/yyoc97/article/details/85804654">从redis为什么单线程还那么快到epoll的设计原理</a></li>
<li><a href="https://blog.csdn.net/weixin_28871885/article/details/113315639">redis 从节点如何选举从节点升级为主节点_redis sentinel集群选举机制剖析</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker学习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-05-07-docker学习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-05-07-docker学习笔记/">
        </link>
        <updated>2021-05-07T01:19:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章主要记录了学习docker过程中的笔记，学习资料为视频，链接如下：</p>
<p><a href="https://ke.qq.com/course/3385294?taid=11066554472179662">Docker部署微服务实战</a></p>
<hr>
<h2 id="安装">安装</h2>
<pre><code># 设置yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# 安装docker
yum -y install docker-ce # ce为社区版
# 启动docker
service docker start
# 验证
docker version
</code></pre>
<h2 id="使用">使用</h2>
<h3 id="镜像相关">镜像相关</h3>
<pre><code># 搜索镜像
docker search java
# 下载镜像
docker pull java:8
docker pull nginx:1.14
# 列出本地镜像
docker images
# 删除镜像
docker rmi java:8
</code></pre>
<h3 id="容器相关">容器相关</h3>
<pre><code># 新建并启动容器
docker run -d -p 91:80 -net=bridge(default)/host nginx
# 列出容器
docker ps
# 启动/停止容器
docker start/stop container_id
# 查看容器信息
docker inspect container_id
# 进入容器
docker container exec -it container_id /bin/bash
</code></pre>
<h2 id="好处">好处</h2>
<ul>
<li>将主流的中间件打包成docker，可实现快速部署。因为docker的使用，如启动和关闭，命令都是相同的，所以可以使用脚本实现自动化的部署。而如果不使用docker，不同的中间件都有一套对应的运维命令，运维工作的效率将会降低很多。</li>
</ul>
<h2 id="构建镜像">构建镜像</h2>
<pre><code># 指定基础镜像
FROM nginx
# 执行命令
RUN echo &quot;hello, world!&quot; &gt; hello.html
# 复制文件到容器
ADD a.jar /app.jar
# 声明需要暴露的端口
EXPOSE 8761
# 配置容器启动后执行的命令
ENTRYPOINT[&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]

docker build -t nginx:hello .
</code></pre>
<h2 id="virtual-machines-vs-docker">Virtual Machines VS Docker</h2>
<p>OS：虚拟机有实实在在的操作系统；Docker通过引擎虚拟操作系统</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210507193822675.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NOJ优化-PHP-Laravel]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-25-NOJ优化-PHP-Laravel/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-25-NOJ优化-PHP-Laravel/">
        </link>
        <updated>2021-04-25T09:12:53.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章，主要介绍一下NOJ的部署。</p>
<p>主要参考这篇文章：https://njuptaaa.github.io/docs/#/noj/guide/deploy</p>
<hr>
<h2 id="部署">部署</h2>
<h3 id="安装环境">安装环境</h3>
<p>需要安装的环境有：Apache、PHP、Composer、MySQL、Redis</p>
<p>Apache和MySQL在我本地已经有了，直接跳过。</p>
<p>对于PHP和Composer，直接在官网下载，需要注意的是，对于Composer，直接下载可执行的安装包就行；对于PHP，需要下载的是zip，而不是source code，如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175552450.png" alt="image-20210425175552450" loading="lazy"></figure>
<p>PHP压缩包下载完，解压到任意文件夹中，然后运行Composer的安装程序，在安装过程中，需要指定php的路径，选择解压后文件夹中的php.exe：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/Bule-Zst/picture/raw/master/image-20210425175722912.png" alt="image-20210425175722912" loading="lazy"></figure>
<h3 id="git-clone">git-clone</h3>
<p>在这一步，需要注意的是，需要把noj项目克隆到apache或者nginx的文件夹下，并将其中的public文件夹设置成根目录。</p>
<h3 id="composer-install">composer install</h3>
<h4 id="your-lock-file-does-not-contain-a-compatible-set-of-packages-please-run-composer-update">Your lock file does not contain a compatible set of packages. Please run composer update.</h4>
<p>环境配置好后，就可以开始安装项目了，使用<code>composer install</code>进行安装，但我本地报错：</p>
<pre><code>E:\NOJ&gt;composer install
Installing dependencies from lock file (including require-dev)
Verifying lock file contents can be installed on current platform.
Your lock file does not contain a compatible set of packages. Please run composer update.

  Problem 1
    - grubersjoe/bing-daily-photo is locked to version v2.0.0 and an update of this package was not requested.
    - grubersjoe/bing-daily-photo v2.0.0 requires ext-intl * -&gt; it is missing from your system. Install or enable PHP's intl extension.
  Problem 2
    - intervention/image is locked to version 2.5.1 and an update of this package was not requested.
    - intervention/image 2.5.1 requires ext-fileinfo * -&gt; it is missing from your system. Install or enable PHP's fileinfo extension.
  Problem 3
    - league/flysystem is locked to version 1.1.3 and an update of this package was not requested.
    - league/flysystem 1.1.3 requires ext-fileinfo * -&gt; it is missing from your system. Install or enable PHP's fileinfo extension.
  Problem 4
    - league/mime-type-detection is locked to version 1.5.1 and an update of this package was not requested.
    - league/mime-type-detection 1.5.1 requires ext-fileinfo * -&gt; it is missing from your system. Install or enable PHP's fileinfo extension.
  Problem 5
    - phpoffice/phpspreadsheet is locked to version 1.15.0 and an update of this package was not requested.
    - phpoffice/phpspreadsheet 1.15.0 requires ext-fileinfo * -&gt; it is missing from your system. Install or enable PHP's fileinfo extension.
  Problem 6
    - league/flysystem 1.1.3 requires ext-fileinfo * -&gt; it is missing from your system. Install or enable PHP's fileinfo extension.
    - spatie/laravel-backup 6.13.1 requires league/flysystem ^1.0.49 -&gt; satisfiable by league/flysystem[1.1.3].
    - spatie/laravel-backup is locked to version 6.13.1 and an update of this package was not requested.

To enable extensions, verify that they are enabled in your .ini files:
    - E:\environment\php\php-7.3.27-nts-Win32-VC15-x64\php.ini
You can also run `php --ini` inside terminal to see which files are used by PHP in CLI mode.
</code></pre>
<p>使用<code>composer install --ignore-platform-reqs</code>就不会报错了。</p>
<h4 id="the-process-class-relies-on-proc_open-which-is-not-available-on-your-php-installation">The Process class relies on proc_open, which is not available on your PHP installation.</h4>
<p><a href="https://blog.csdn.net/lw545034502/article/details/96450335">（亲测可用）The Process class relies on proc_open, which is not available on your PHP installation.解决方案！</a></p>
<h3 id="php-routes的使用">php routes的使用</h3>
<p><a href="https://www.cnblogs.com/yaoliuyang/p/12298780.html">thinkphp中路由的基本使用</a></p>
<h3 id="nginx配置">nginx配置</h3>
<p><a href="https://zhuanlan.zhihu.com/p/96149578">PHP]深度解析Nginx下的PHP框架路由实现</a></p>
<h2 id="项目信息">项目信息</h2>
<ul>
<li>submit：提交到后台</li>
<li>pedding：队列中准备提交</li>
<li>waiting：已提交，等待结果</li>
<li>submitting -&gt; pedding -&gt; waiting -&gt; accept</li>
</ul>
<h2 id="优化">优化</h2>
<p>01:08开始</p>
<p>前面，主要是介绍项目</p>
<h3 id="优化1实时更新榜单">优化1：实时更新榜单</h3>
<p>06:00</p>
<p>目前是一分钟更新一次，从数据库读取到redis中</p>
<p>优化思路：1、使用增量更新，当有新的AC事件发生时，更新内存中的redis缓存；2、客户端，对于提交记录，循环查询结果，查询操作为异步，循环间隔为5s，使用内存锁避免查询冲突</p>
<p>目前的问题：对于每个提交记录，被更新了10几次。</p>
<h3 id="优化2容器化">优化2：容器化</h3>
<p>将各个功能点封装成docker容器</p>
<h3 id="优化3管理功能界面">优化3：管理功能界面</h3>
<p>74:28</p>
<h2 id="phpstore">PhpStore</h2>
<ul>
<li><a href="https://blog.csdn.net/ljh101/article/details/112549860">composer require --dev barryvdh/laravel-ide-helper报错解决</a></li>
<li>[<a href="https://my.oschina.net/anziguoer/blog/647367">Phpstorm 安装 laravel扩展，laravel代码提示插件</a>](https://my.oschina.net/anziguoer/blog/647367)</li>
</ul>
<p>后台参考这里的代码https://github.com/ZsgsDesign/HASAAOSE/tree/main/app/Admin</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[南京大学-软件过程改进-复习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-16-南京大学-软件过程改进-复习笔记/">
        </link>
        <updated>2021-04-16T01:53:00.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要是对 <a href="https://wym0120.github.io/2021/04/12/cmmi/">[课堂笔记] 软件过程改进 </a>这篇文章的一些个人补充</p>
<hr>
<p>[TOC]</p>
<h2 id="过程的定义">过程的定义</h2>
<ul>
<li>IEEE: Sequence of steps performed for a given purpose.
<ul>
<li>为给定目的执行的步骤顺序。</li>
</ul>
</li>
<li>PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a SP ecified end result.
<ul>
<li>人员、材料、能源、设备和程序 在工作活动中的逻辑组织，旨在产生SP（特定实践）确认的最终结果。</li>
</ul>
</li>
<li>CMMI GLOSSARY: A set of interrelated activities, which transform inputs into outputs, to achieve a given purpose (These activities can be mapped to one or more practices in CMMI process areas to allow a model to be useful for process improvement and process appraisal.)
<ul>
<li>一组相互关联的活动，这些活动将输入转化为输出，以实现给定的目的（这些活动可以映射到CMMI过程域中的一个或多个实践，以使模型可用于流程改进和流程评估。）</li>
</ul>
</li>
</ul>
<h2 id="过程和过程域的关系">过程和过程域的关系</h2>
<p>过程域中包含若干过程。</p>
<h2 id="连续式表示法与阶段式表示法">连续式表示法与阶段式表示法</h2>
<ul>
<li>连续式表示法：选择一个特定的过程域进行改进。</li>
<li>阶段式表示法：选择某一成熟度级别下的多个过程域进行改进。</li>
</ul>
<h2 id="等价阶段式定级">等价阶段式定级</h2>
<ul>
<li>CL：capability level 能力等级</li>
<li>ML：maturity level 成熟度级别</li>
</ul>
<h2 id="过程模型">过程模型</h2>
<p>过程模型是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。</p>
<p>CMMI 开发模型就是一种过程模型。</p>
<h2 id="cmmi来源于哪三个模型-研究机构">CMMI来源于哪三个模型 ，研究机构</h2>
<ul>
<li>软件工程 sw-cmm</li>
<li>系统工程 EIA/IS</li>
<li>集成化产品和过程开发 IPD-CMM</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/image-20210416144801516.png" alt="image-20210416144801516" loading="lazy"></figure>
<h2 id="已管理和已定义的区别">已管理和已定义的区别</h2>
<p>已管理：标准、过程描述与规程在过程的每个特定实例中（如在某一特定项目中）都可能有很大的不同。</p>
<p>已定义：项目的标准、过程描述与规程是从组织的标准过程集中裁剪得来，以适应特定的项目或组织级单位，因而就更为一致，除非是裁剪指南所允许的差别。</p>
<h2 id="过程域">过程域</h2>
<h3 id="工程类">工程类</h3>
<h4 id="确认与验证的区别">确认与验证的区别</h4>
<p>确认：确认产品实际的用途是否符合其预期的用途；做了正确的事。</p>
<p>验证：验证工作产品（or 产品）的功能是否符合需求；正确地做了事。</p>
<h3 id="支持类">支持类</h3>
<h4 id="度量与分析-and-过程与产品质量保证">度量与分析 and 过程与产品质量保证</h4>
<p>PPQA专注于质量，而MA则是对一切过程提供度量与分析。当对质量进行度量与分析时，个人认为MA与PPQA是等价的，因此，MA的范围更广，而PPQA则专注于质量方面。</p>
<h2 id="ppt中问题整理">PPT中问题整理</h2>
<ul>
<li>
<p>requirements traceability：需求可追溯性</p>
</li>
<li>
<p>A to B and vice versa：A符合B，反之亦然</p>
</li>
<li>
<p>Budget and funding：预算和资金</p>
</li>
<li>
<p>Staff：职员</p>
</li>
<li>
<p>Facilities：设施</p>
</li>
<li>
<p>peer review meetings：同行评审会议</p>
</li>
<li>
<p>delinquent：拖欠的</p>
</li>
<li>
<p>People are not meeting schedules.：人们没有遵守时间表。</p>
</li>
<li>
<p>likelihood：可能性</p>
</li>
<li>
<p>motion sensors：运动传感器</p>
</li>
<li>
<p>contract：合同</p>
</li>
<li>
<p>COTS were used for the keypad; sensors were secured from suppliers; and the controller consists of re-used PASS in-house software.：键盘上使用了COTS； 传感器由供应商提供保护； 控制器由重复使用的PASS内部软件组成。</p>
</li>
<li>
<p>incorporating experiences：整合经验</p>
</li>
<li>
<p>appraisal metrics：评估指标</p>
</li>
<li>
<p>align with：对齐</p>
</li>
<li>
<p>All PASS projects follow the standard process exactly as is.：所有PASS项目都完全按照标准流程进行。</p>
</li>
<li>
<p>trace：追溯</p>
</li>
<li>
<p>tailoring：裁剪</p>
</li>
<li>
<p>Spiral lifecycle：螺旋生命周期</p>
</li>
</ul>
<h2 id="简答题列表">简答题列表</h2>
<h3 id="过程域相关">过程域相关</h3>
<p>Lv4组织级过程性能(OPP)</p>
<ul>
<li>x.y.z代表着什么</li>
</ul>
<p>Lv2项目监督与控制(PMC)</p>
<ul>
<li>项目监控点选择的原则？原因</li>
<li>SG2中的相关实践约定，需要采取纠偏措施的问题来源</li>
<li>纠偏行动的先决条件</li>
</ul>
<p>Lv2项目计划(PP)</p>
<ul>
<li>PP过程域在项目中的作用域</li>
<li>计划制定的原则？</li>
<li>一般的估算方法有哪几个？区别</li>
<li>什么是承诺管理？承诺的分类</li>
<li>PP中“建立”和“维护”两个活动的解释？</li>
<li>估算目标: 不是尽可能客观描述代码行/工作量（永远不可能实现估算），而是得到一个数字<strong>数字对不对不重要，重要的是大家认可</strong></li>
</ul>
<p>Lv2需求管理(REQM)</p>
<ul>
<li>(需求跟踪的方法) 需求跟踪矩阵的使用</li>
<li>(获得需求承诺) 应该获得那些人的承诺</li>
<li>识别需求不一致性的最有效方法</li>
<li>敏捷对于需求的态度是拥抱变更，但这是不正确的，大部分开发人员还是希望能够close开发</li>
<li>Scrum对于需求的态度是不响应一个SP rint中的需求变更(目标不变)，只是记录到backlog，可能会在下一个迭代响应变更</li>
<li>理解双向可跟踪</li>
</ul>
<p>Lv4量化项目管理(QPM)</p>
<ul>
<li>OPP 和 QPM 的关联</li>
<li>QPM SP1.2 和之前过程定义的区别 （和 IPM 的区别）</li>
<li>QPM 和 OPM 的关系</li>
</ul>
<p>Lv3产品集成(PI)</p>
<ul>
<li>假设你是产品集成的负责人，拒绝那些不合格的产品组件。定义哪些验收标准</li>
</ul>
<p>Lv3验证 (VER)</p>
<ul>
<li>VAL 和 VER的关键区别</li>
</ul>
<p>Lv2度量与分析(MA)</p>
<ul>
<li>度量分析的作用体现在哪些方面？(从项目和组织两个角度分析)</li>
<li>度量的目的要支持质量的目标</li>
<li>如何满足度量的可追踪性(哪些工作产品可以满足)</li>
</ul>
<p>Lv2配置管理(CM)</p>
<ul>
<li>一个软件开发过程中会产生很多工作产品artifacts/work product，但是并不是所有产品都是值得管理的，要去掉一些不那么重要的产品，确保重要的（为了让交付有完整性的）工作产品被管理。其实就是为了减少工作量。</li>
<li>CCB: Change Control Board</li>
<li>配置管理员的主要职责</li>
<li>配置项标示的规则，什么情况下改写Vx.y.z中的x和y？什么说情况下改写z？规则是怎样的</li>
<li>配置管理系统的等级？三个概念库如何体现配置库的等级？配置库需要注意什么</li>
<li>基线的定义和特点</li>
</ul>
<p>Lv2过程与产品质量保证(PPQA)</p>
<ul>
<li>软件项目质量的分类</li>
<li>QA行使的角色</li>
<li>解释 PPQA QA SQA NC QC</li>
<li>QA 和 QC差别？</li>
<li>执行PPQA的工具方法</li>
<li>简述评审一般过程、审计一般过程</li>
<li>QA人员以及PPQA过程的质量保证如何实现</li>
<li>如何评价&quot;测试驱动开发TDD可以显著提升质量&quot;这一说法</li>
</ul>
<p>Lv3决策分析与解决(DAR)</p>
<ul>
<li>如何评价 &quot;CMMI 是官僚、重文档的&quot;这一说法</li>
</ul>
<p>Lv5原因分析与解决(CAR)</p>
<ul>
<li>CAR 在本质上做的是什么</li>
<li>CAR 一定是选坏的吗</li>
<li>CAR 实际上是依赖于 OPM 进行执行的</li>
<li>CAR 的理念是不犯错比犯了错再改正更好</li>
<li>CAR 在4级和5级的不同</li>
<li>CAR 为什么需要和 OPM 配合</li>
</ul>
<h3 id="ppt">ppt</h3>
<ul>
<li>Which of the following examples of requirements traceability are adequate?</li>
<li>PASS is planning their resources. What project resources should be included?</li>
<li>Project Management and Control</li>
<li>Risk Management</li>
<li>Supplier Agreement Management</li>
<li>Which CM SPs could have prevented the problem?</li>
<li>Which are process evaluations? Which are product evaluations?</li>
<li>Which of the following are adequate for verification procedures and criteria?</li>
<li>Which are verification and which are validation?</li>
<li>Which of the following show incorporating experiences?</li>
<li>Which PASS scenarios align with IPM?</li>
<li>Organizational Process Definition</li>
<li>Organizational Training</li>
<li>VER SG2 SG3: SG3包含SG2</li>
<li>持续集成 vs 大爆炸集成</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[南京大学-高级数据库开发技术-复习笔记]]></title>
        <id>http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/</id>
        <link href="http://Bule-Zst.gitee.io/2021-04-15-南京大学-高级数据库开发技术-复习笔记/">
        </link>
        <updated>2021-04-15T07:35:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="b树-b树索引">B树、B+树索引</h2>
<h3 id="阶的含义">阶的含义</h3>
<ul>
<li>上限：每个节点最多有 M 个子树</li>
<li>下限：
<ul>
<li>根节点至少2个子树
<ul>
<li>非根节点至少有⌈M /2⌉个子树</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="画结构">画结构</h3>
<p>B+树</p>
<figure data-type="image" tabindex="1"><img src="http://Bule-Zst.gitee.io/post-images/image-20210415160910412.png" alt="image-20210415160910412" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://Bule-Zst.gitee.io/post-images/image-20210418174758526.png" alt="image-20210418174758526" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://Bule-Zst.gitee.io/post-images/image-20210418175351820.png" alt="image-20210418175351820" loading="lazy"></figure>
<h3 id="b树使用场景">B+树使用场景</h3>
<p>能做的：</p>
<ul>
<li>全键值：Where x=123</li>
<li>键值范围：Where 45&lt;x&lt;123</li>
<li>键前缀查找：where x LIKE ‘J%’</li>
</ul>
<p>什么时候能用，什么时候不能用：</p>
<ul>
<li>对于一般索引，都能用，除非查询优化器发现用了索引后，会导致性能降低，则不会使用索引，例如因为索引占用空间太大，导致IO操作耗时较高。</li>
<li>对于复合索引，如果违反最左匹配原则，则不能用。例如，对(x,y)建立索引，但对y进行查询，则不能用。</li>
<li>对于一个有索引的列作出函数查询，Select * from t where f(indexed_col) = value</li>
<li>隐形函数查询，比如查询SQL中存在隐式类型转换，比如no为VARCHAR类型，但是查询时把该字段当做INT类型查询：SELECT * FROM T WHERE no = 2124</li>
<li>没有正确的统计信息，造成查询优化器无法做出正确的选择</li>
<li>含前导模糊查询的Like语法不能使用索引（”%XXX”）</li>
<li>B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引</li>
</ul>
<p>什么时候应该用：</p>
<ul>
<li>仅当要通过索引访问表中很少一部分行</li>
<li>虽然查询行数比较多，但索引包含多个字段，而要访问的字段全部包含在索引中时，查找只需通过索引而不用访问全表时</li>
</ul>
<p>什么时候不应该用（没找到答案，自己的理解）：</p>
<ul>
<li>当需要查询的数据占表总数据的比重很大时，不应该使用索引，因为查询优化器会发现，使用索引的效率不如全表遍历。</li>
<li>写密集型事务：频繁修改索引，增加开销</li>
</ul>
<h2 id="分区">分区</h2>
<h3 id="分区是干嘛用的">分区是干嘛用的</h3>
<p>分区就是将一个大表根据条件分割成若干个小表，是一种数据分组方式，能够提高并发性和并行性。对于多用户并发访问情况，查询效率可能较高。</p>
<p>表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件）上</p>
<h3 id="根据分区键partition-key的类型分类分区有哪几种类型">根据分区键（Partition Key）的类型分类，分区有哪几种类型？</h3>
<ul>
<li>哈希分区：对分区键进行哈希运算，根据运算结果进行分区。 <s>把不同的列随机平均的分布到不同的物理环境，达到备份和恢复（写 undo 和 redo文件）效率高，降低错误回滚压力（为了管理）。</s></li>
<li>范围分区：根据连续数据的范围对数据进行分区~~。把字段的值分布到一个物理范围~~，这个范围是你在创建分区时指定的分区键决定的。这种分区方式是最为常用的。</li>
<li>列表分区：把不同的列存到不同的分区中。</li>
</ul>
<h3 id="如何选择分区键-选择原则是什么">如何选择分区键、选择原则是什么</h3>
<ul>
<li>哈希分区：根据分区键，可以快速找到记录，但对范围检索没有任何帮助。更接近于非数据驱动的循环分区，用于负载均衡，提高并发的能力。</li>
<li>范围分区：比较常用，非常适合处理历史数据。</li>
<li>列表分区：查询时，通常只查询某几个字段，或者，某几个字段通常一起被查询。但，每个分区都必须有主键，因此会造成冗余。</li>
<li></li>
<li>按什么字段进行分区要整体考虑，因为：更新分区键会引起移动数据，应该避免这么做。当数据分区键均匀分布时，分区表查询收益最大。</li>
</ul>
<h2 id="设计原则">设计原则</h2>
<h3 id="处理模式操作模式批处理与实时系统">处理模式（操作模式）：批处理与实时系统</h3>
<p>9.2 为性能设计（下）.mp4，17:09</p>
<h4 id="基本逻辑">基本逻辑</h4>
<ul>
<li>
<p>异步处理模式：可以允许用户发出操作之后去做其他工作，数据库进行集中的批处理，当处理完毕后通知用户，但是实时性不好</p>
</li>
<li>
<p>同步处理时模式：用户必须等待数据库操作并返回结果，期间不能做其它操作。适合数据库进行实时交易。</p>
</li>
</ul>
<h4 id="好坏">好坏</h4>
<ul>
<li>当操作过于复杂，需要横跨很多系统、物理环境，实时系统中不可控的因素就会变多，此时就需要采用异步处理模式。</li>
<li>异步处理模式：健壮性、稳定性更强。</li>
<li>同步处理模式：满足实时性的要求，在某些特定业务下，这是必须的，比如银行转账业务。</li>
</ul>
<h4 id="选择">选择</h4>
<ul>
<li>由系统需求和所需处理的数据的物理结构决定的，大部分情况下，同步和异步是共存的，不能先入为主得认为业务必须同步。</li>
<li>从性能的角度，如果对实时性没有要求，则可以考虑尝试使用批处理模式</li>
<li>在批处理模式下，更容易暴露性能问题，因为批处理需要压榨硬件资源，而实时系统只有在高并发或大数据量的情况下才可能暴露性能问题，而当实时系统暴露出性能问题后，可能会极大影响正常业务的开展。</li>
</ul>
<h3 id="存储模式集中式与分布式">存储模式：集中式与分布式</h3>
<p>9.2 为性能设计（下）.mp4，11:31</p>
<h4 id="基本逻辑-2">基本逻辑</h4>
<ul>
<li>
<p>分布式数据存储：将数据分散存储在多台独立的设备上，一般情况下，多台设备在地理位置上相对分散。</p>
</li>
<li>
<p>集中式数据存储：将数据集中存储在一台或多台设备上，一般情况下，存储设备在地理位置上相对集中。</p>
</li>
</ul>
<h4 id="好坏-2">好坏</h4>
<ul>
<li>分布式数据系统：
<ul>
<li>缺点
<ul>
<li>复杂度高、健壮性低、管理成本高</li>
<li>保密性不易控制</li>
<li>多个副本的一致性难以保证</li>
<li>不同数据源数据的结合极为困难
<ul>
<li>数据传输开销大</li>
<li>脱离数据源的环境，数据源无法从数据规划中获益（物理结构、索引）</li>
</ul>
</li>
</ul>
</li>
<li>优点
<ul>
<li>单一节点的负担低</li>
<li>具有更灵活的体系结构</li>
</ul>
</li>
</ul>
</li>
<li>集中式
<ul>
<li>缺点：单点故障，会带来很大损失，因此常常需要热备份或灾难备份</li>
</ul>
</li>
</ul>
<h4 id="选择-2">选择</h4>
<ul>
<li>平衡、折中
<ul>
<li>全球性的数据，若集中存储，则跨大陆的访问速度将大幅降低（离数据越近，访问越快）；但从另一个角度看，因为集中式避免了分布式中的数据传输，并可以利用数据规划，因此查询速度快。</li>
<li>集中式存储的访问吞吐量有上限</li>
</ul>
</li>
</ul>
<h2 id="sql-查询优化器是如何工作的">SQL-查询优化器是如何工作的</h2>
<p>4.1 SQL优化.mp4，13:38</p>
<p>优化是在数据处理的真正被执行的时候发生</p>
<p>不同结果的关系表达式在实际环境下执行的效率千差万别</p>
<p>查询优化器如何权衡哪种优化更好</p>
<ul>
<li>基于成本的优化器 CBO：综合考虑所有的情况。现在最常用的优化器类型。</li>
<li>基于规则的优化器 RBO：根据预定义的规则进行优化，例如加减的权重是1，乘除的权重是2。</li>
</ul>
<p>SQL的执行顺序：</p>
<ul>
<li>SQL、语法语义检查、解析（软解析+硬解析）、执行计划、执行引擎、存储引擎、数据库</li>
<li>解析是整个SQL优化最消耗资源的环节，其中硬解析是最重要的一部分。</li>
<li>执行计划：Plan，二进制的执行代码</li>
<li>解析+生成执行计划是查询优化器最重要的工作</li>
<li>生成执行计划后，抛入执行引擎，从数据库中读取数据，然后返回。</li>
<li>语法分析：判断一条SQL语句的语法是否符合SQL的规范，代价小</li>
<li>语义分析：判断该SQL语句所访问的对象是否准确，且用户是否有相应的权限，代价小</li>
<li>硬解析：对提交的sql完全重新从头进行解析(当在共享池中找不到已解析好的结果时将会进行此操作)</li>
<li>软解析：如果在共享池中找到了与之完全相同的sql解析好的结果后，会跳过硬解析的后两步，代价小</li>
</ul>
<p>优化器只能对关系领域进行优化</p>
<p>优化器的有效范围：</p>
<ul>
<li>优化器需要借助数据库中找到的信息</li>
<li>能进行数学意义上的等价变换</li>
<li>优化器考虑整体响应时间</li>
<li>优化器改善的是独立的查询</li>
</ul>
<h2 id="数据库设计-层次结构">数据库设计-层次结构</h2>
<p>6.1 处理层次结构.mp4，12:17</p>
<ul>
<li>
<p>邻接模型：id、pid</p>
<ul>
<li>兄弟节点是无序的</li>
</ul>
</li>
<li>
<p>物化路径模型：1、1.1、1.1.2</p>
<ul>
<li>兄弟节点是有序的</li>
<li>方便扩展：3层结构扩展层4层</li>
<li>查询语句编写简单，找出适当的记录并缩排显示比较容易</li>
</ul>
</li>
<li>
<p>嵌套集合模型：left_num、right_num，所有子节点都在left_num和right_num之间</p>
<p>上述3种树状表结构设计都满足三范式</p>
</li>
</ul>
<p>两种查询方式：</p>
<ul>
<li>自顶向下（Vandamme查询）
<ul>
<li>邻接模型
<ul>
<li>
<p>connect by current = <em>prior</em> previous，非关系型查询方式</p>
<figure data-type="image" tabindex="4"><img src="http://Bule-Zst.gitee.io/post-images/image-20210420103050088.png" alt="image-20210420103050088" loading="lazy"></figure>
</li>
<li>
<p>利用with as，首先定义起始点，之后对两个select语句进行union all，通过递归查询不断根据父记录生成子记录。</p>
<figure data-type="image" tabindex="5"><img src="http://Bule-Zst.gitee.io/post-images/image-20210420103019003.png" alt="image-20210420103019003" loading="lazy"></figure>
</li>
<li>
<p>mysql不支持connect by，也不支持with as，因此只能事先知道树的深度，然后手动union</p>
</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>
<p>计算深度：path字符串长度 减去 去掉点之后的path字符串长度</p>
</li>
<li>
<p>指定需要查询的path前缀，之后使用模糊查询获取结果，然后对path进行排序，即可</p>
<figure data-type="image" tabindex="6"><img src="http://Bule-Zst.gitee.io/post-images/image-20210420103422776.png" alt="image-20210420103422776" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>自底向上（Hignland查询）
<ul>
<li>邻接模型
<ul>
<li>connect by previous = <em>prior</em> current</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>指定需要查询的叶子结点，之后使用模糊查询获取父节点</li>
<li>会存在重复记录，因此需要使用distinct</li>
<li>排序问题：对distinct的结果进行select，并按path进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>性能对比</p>
<ul>
<li>自顶向下
<ul>
<li>邻接模型
<ul>
<li>性能最好，每秒返回的查询记录数最多，只需要处理数值关系，但性能会收到迭代操作的影响</li>
</ul>
</li>
<li>物化路径模型
<ul>
<li>中等，因为涉及到字符串操作</li>
<li>计算深度、缩排函数 比较费时</li>
</ul>
</li>
</ul>
</li>
<li>自底向上
<ul>
<li>和自顶向下类似，邻接最好，物化路径中等</li>
<li>当不能用connect by和with as时，可以使用物化路径模型作为替代</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>